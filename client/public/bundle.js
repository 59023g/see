(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = {
  SUPABASE_TABLE_NAME: "see",
  SUPABASE_URL: "https://pcgsfodxjxahcrqgyods.supabase.co",
  SUPABASE_ANON: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBjZ3Nmb2R4anhhaGNycWd5b2RzIiwicm9sZSI6ImFub24iLCJpYXQiOjE2NzA4MDIzOTAsImV4cCI6MTk4NjM3ODM5MH0.gMQ6cTJ0K_fCuu1wadoZFDxQhyILObDwdfkVp4Z_nms"
};
exports["default"] = _default;

},{}],2:[function(require,module,exports){
"use strict";

var _supabaseJs = require("@supabase/supabase-js");
var _config = _interopRequireDefault(require("./config"));
var _utils = require("./utils");
var _choo = _interopRequireDefault(require("choo"));
var _home = _interopRequireDefault(require("./views/home"));
var _ux = _interopRequireDefault(require("./store/ux"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// index.js

Promise.resolve().then(function () {
  return _interopRequireWildcard(require("./static/app.css"));
});
var database = (0, _supabaseJs.createClient)(_config["default"].SUPABASE_URL, _config["default"].SUPABASE_ANON);
var app = (0, _choo["default"])();
app.route("/", _home["default"]);
app.use(_ux["default"]);
app.use(function (state, emitter) {
  emitter.on("DOMContentLoaded", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _yield$database$from$, data, error, groups;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return database.from(_config["default"].SUPABASE_TABLE_NAME).select('*').order('id', {
            ascending: false
          });
        case 2:
          _yield$database$from$ = _context.sent;
          data = _yield$database$from$.data;
          error = _yield$database$from$.error;
          if (!error) {
            _context.next = 7;
            break;
          }
          throw error;
        case 7:
          groups = data.reduce(function (groups, item) {
            // timezone change here
            var tzDate = new Date(item.created_at).toLocaleString('en-US', {
              timeZone: 'America/New_York'
            });
            item.data.timestamp = tzDate;
            var date = tzDate.split(',')[0];
            if (!groups[date]) {
              groups[date] = [];
            }
            groups[date].push(item);
            return groups;
          }, {}); // console.log(groups)
          groups = getAnalytics(groups);
          // groups = groupBySession(groups)

          state.data = groups;
          emitter.emit("render");
        case 11:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })));
});
app.mount("body");
function getAnalytics(groups) {
  // loop through groups
  var entries = Object.entries(groups);
  var newObj = {};
  for (var i = 0; i < entries.length; i++) {
    var visits = 0;
    var fb = 0;
    var twit = 0;
    var clickThroughs = 0;
    for (var d = 0; d < entries[i][1].length; d++) {
      var element = entries[i][1][d];
      if (element.data.action_type === "visit") {
        visits++;
      }
      if ((0, _utils.getClickThroughs)(element.data)) {
        clickThroughs++;
      }
      if ((0, _utils.getTwitRefs)(element.data.referrer)) {
        twit++;
      }
      // pre-sessionId manual facebook get
      var fbclid = (0, _utils.parseSource)(element.data.source);
      if (fbclid) {
        element.data.sessionId = fbclid;
        fb++;
      }
    }
    entries[i].push({
      visits: visits,
      fb: fb,
      twit: twit,
      clickThroughs: clickThroughs
    });
    newObj[entries[i][0]] = {
      data: entries[i][1],
      meta: entries[i][2]
    };
  }
  return newObj;
}
function groupBySession(groups) {
  // console.log(groups)
  for (var key in groups) {
    console.log(groups[key].data);
    var _g = groups[key].data.reduce(function (group, item) {
      console.log(item);
      if (!item.data.sessionId) {
        item.data.sessionId = "xyz";
      }
      console.log(item.data.sessionId, item.data.sessionId);
      if (!group[item.data.sessionId]) {
        group[item.data.sessionId] = [];
      }
      console.log(group);
      console.log(item.data.sessionId, group[item.data.sessionId]);
      group[item.data.sessionId].push(item);
      return group;
    }, {});

    // if (Object.hasOwnProperty.call(object, key)) {
    //   const element = object[key];

    // }
    return _g;
  }
  console.log(g);
  return groups;
}

},{"./config":1,"./static/app.css":91,"./store/ux":92,"./utils":93,"./views/home":95,"@supabase/supabase-js":47,"choo":58}],3:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionsClient = void 0;
var helper_1 = require("./helper");
var types_1 = require("./types");
var FunctionsClient = /*#__PURE__*/function () {
  function FunctionsClient(url) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      customFetch = _ref.customFetch;
    _classCallCheck(this, FunctionsClient);
    this.url = url;
    this.headers = headers;
    this.fetch = (0, helper_1.resolveFetch)(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  _createClass(FunctionsClient, [{
    key: "setAuth",
    value: function setAuth(token) {
      this.headers.Authorization = "Bearer ".concat(token);
    }
    /**
     * Invokes a function
     * @param functionName - the name of the function to invoke
     */
  }, {
    key: "invoke",
    value: function invoke(functionName) {
      var invokeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _a;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var headers, functionArgs, _headers, body, response, isRelayError, responseType, data;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              headers = invokeOptions.headers, functionArgs = invokeOptions.body;
              _headers = {};
              if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type') || !headers)) {
                if (typeof Blob !== 'undefined' && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
                  // will work for File as File inherits Blob
                  // also works for ArrayBuffer as it is the same underlying structure as a Blob
                  _headers['Content-Type'] = 'application/octet-stream';
                  body = functionArgs;
                } else if (typeof functionArgs === 'string') {
                  // plain string
                  _headers['Content-Type'] = 'text/plain';
                  body = functionArgs;
                } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {
                  // don't set content-type headers
                  // Request will automatically add the right boundary value
                  body = functionArgs;
                } else {
                  // default, assume this is JSON
                  _headers['Content-Type'] = 'application/json';
                  body = JSON.stringify(functionArgs);
                }
              }
              _context.next = 6;
              return this.fetch("".concat(this.url, "/").concat(functionName), {
                method: 'POST',
                // headers priority is (high to low):
                // 1. invoke-level headers
                // 2. client-level headers
                // 3. default Content-Type header
                headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
                body: body
              })["catch"](function (fetchError) {
                throw new types_1.FunctionsFetchError(fetchError);
              });
            case 6:
              response = _context.sent;
              isRelayError = response.headers.get('x-relay-error');
              if (!(isRelayError && isRelayError === 'true')) {
                _context.next = 10;
                break;
              }
              throw new types_1.FunctionsRelayError(response);
            case 10:
              if (response.ok) {
                _context.next = 12;
                break;
              }
              throw new types_1.FunctionsHttpError(response);
            case 12:
              responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();
              if (!(responseType === 'application/json')) {
                _context.next = 19;
                break;
              }
              _context.next = 16;
              return response.json();
            case 16:
              data = _context.sent;
              _context.next = 34;
              break;
            case 19:
              if (!(responseType === 'application/octet-stream')) {
                _context.next = 25;
                break;
              }
              _context.next = 22;
              return response.blob();
            case 22:
              data = _context.sent;
              _context.next = 34;
              break;
            case 25:
              if (!(responseType === 'multipart/form-data')) {
                _context.next = 31;
                break;
              }
              _context.next = 28;
              return response.formData();
            case 28:
              data = _context.sent;
              _context.next = 34;
              break;
            case 31:
              _context.next = 33;
              return response.text();
            case 33:
              data = _context.sent;
            case 34:
              return _context.abrupt("return", {
                data: data,
                error: null
              });
            case 37:
              _context.prev = 37;
              _context.t0 = _context["catch"](0);
              return _context.abrupt("return", {
                data: null,
                error: _context.t0
              });
            case 40:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 37]]);
      }));
    }
  }]);
  return FunctionsClient;
}();
exports.FunctionsClient = FunctionsClient;

},{"./helper":4,"./types":6}],4:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveFetch = void 0;
var resolveFetch = function resolveFetch(customFetch) {
  var _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = function _fetch() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _yield$Promise$resolv;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return Promise.resolve().then(function () {
                return __importStar(require('cross-fetch'));
              });
            case 2:
              _context.next = 4;
              return (_yield$Promise$resolv = _context.sent).fetch.apply(_yield$Promise$resolv, args);
            case 4:
              return _context.abrupt("return", _context.sent);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
    };
  } else {
    _fetch = fetch;
  }
  return function () {
    return _fetch.apply(void 0, arguments);
  };
};
exports.resolveFetch = resolveFetch;

},{"cross-fetch":59}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionsRelayError = exports.FunctionsHttpError = exports.FunctionsFetchError = exports.FunctionsError = exports.FunctionsClient = void 0;
var FunctionsClient_1 = require("./FunctionsClient");
Object.defineProperty(exports, "FunctionsClient", {
  enumerable: true,
  get: function get() {
    return FunctionsClient_1.FunctionsClient;
  }
});
var types_1 = require("./types");
Object.defineProperty(exports, "FunctionsError", {
  enumerable: true,
  get: function get() {
    return types_1.FunctionsError;
  }
});
Object.defineProperty(exports, "FunctionsFetchError", {
  enumerable: true,
  get: function get() {
    return types_1.FunctionsFetchError;
  }
});
Object.defineProperty(exports, "FunctionsHttpError", {
  enumerable: true,
  get: function get() {
    return types_1.FunctionsHttpError;
  }
});
Object.defineProperty(exports, "FunctionsRelayError", {
  enumerable: true,
  get: function get() {
    return types_1.FunctionsRelayError;
  }
});

},{"./FunctionsClient":3,"./types":6}],6:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function set(target, property, value, receiver) { if (typeof Reflect !== "undefined" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }
function _set(target, property, value, receiver, isStrict) { var s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new TypeError('failed to set property'); } return value; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionsHttpError = exports.FunctionsRelayError = exports.FunctionsFetchError = exports.FunctionsError = void 0;
var FunctionsError = /*#__PURE__*/function (_Error) {
  _inherits(FunctionsError, _Error);
  var _super = _createSuper(FunctionsError);
  function FunctionsError(message) {
    var _thisSuper, _this;
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'FunctionsError';
    var context = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck(this, FunctionsError);
    _this = _super.call(this, message);
    _set((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(FunctionsError.prototype)), "name", name, _thisSuper, true);
    _this.context = context;
    return _this;
  }
  return _createClass(FunctionsError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.FunctionsError = FunctionsError;
var FunctionsFetchError = /*#__PURE__*/function (_FunctionsError) {
  _inherits(FunctionsFetchError, _FunctionsError);
  var _super2 = _createSuper(FunctionsFetchError);
  function FunctionsFetchError(context) {
    _classCallCheck(this, FunctionsFetchError);
    return _super2.call(this, 'Failed to send a request to the Edge Function', 'FunctionsFetchError', context);
  }
  return _createClass(FunctionsFetchError);
}(FunctionsError);
exports.FunctionsFetchError = FunctionsFetchError;
var FunctionsRelayError = /*#__PURE__*/function (_FunctionsError2) {
  _inherits(FunctionsRelayError, _FunctionsError2);
  var _super3 = _createSuper(FunctionsRelayError);
  function FunctionsRelayError(context) {
    _classCallCheck(this, FunctionsRelayError);
    return _super3.call(this, 'Relay Error invoking the Edge Function', 'FunctionsRelayError', context);
  }
  return _createClass(FunctionsRelayError);
}(FunctionsError);
exports.FunctionsRelayError = FunctionsRelayError;
var FunctionsHttpError = /*#__PURE__*/function (_FunctionsError3) {
  _inherits(FunctionsHttpError, _FunctionsError3);
  var _super4 = _createSuper(FunctionsHttpError);
  function FunctionsHttpError(context) {
    _classCallCheck(this, FunctionsHttpError);
    return _super4.call(this, 'Edge Function returned a non-2xx status code', 'FunctionsHttpError', context);
  }
  return _createClass(FunctionsHttpError);
}(FunctionsError);
exports.FunctionsHttpError = FunctionsHttpError;

},{}],7:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var fetch_1 = require("./lib/fetch");
var helpers_1 = require("./lib/helpers");
var errors_1 = require("./lib/errors");
var GoTrueAdminApi = /*#__PURE__*/function () {
  function GoTrueAdminApi(_ref) {
    var _ref$url = _ref.url,
      url = _ref$url === void 0 ? '' : _ref$url,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      fetch = _ref.fetch;
    _classCallCheck(this, GoTrueAdminApi);
    this.url = url;
    this.headers = headers;
    this.fetch = (0, helpers_1.resolveFetch)(fetch);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   */
  _createClass(GoTrueAdminApi, [{
    key: "signOut",
    value: function signOut(jwt) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/logout"), {
                headers: this.headers,
                jwt: jwt,
                noResolveJson: true
              });
            case 3:
              return _context.abrupt("return", {
                data: null,
                error: null
              });
            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](0);
              if (!(0, errors_1.isAuthError)(_context.t0)) {
                _context.next = 10;
                break;
              }
              return _context.abrupt("return", {
                data: null,
                error: _context.t0
              });
            case 10:
              throw _context.t0;
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 6]]);
      }));
    }
    /**
     * Sends an invite link to an email address.
     * @param email The email address of the user.
     * @param options.redirectTo A URL or mobile deeplink to send the user to after they are confirmed.
     * @param options.data Optional user metadata
     */
  }, {
    key: "inviteUserByEmail",
    value: function inviteUserByEmail(email) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/invite"), {
                body: {
                  email: email,
                  data: options.data
                },
                headers: this.headers,
                redirectTo: options.redirectTo,
                xform: fetch_1._userResponse
              });
            case 3:
              return _context2.abrupt("return", _context2.sent);
            case 6:
              _context2.prev = 6;
              _context2.t0 = _context2["catch"](0);
              if (!(0, errors_1.isAuthError)(_context2.t0)) {
                _context2.next = 10;
                break;
              }
              return _context2.abrupt("return", {
                data: {
                  user: null
                },
                error: _context2.t0
              });
            case 10:
              throw _context2.t0;
            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 6]]);
      }));
    }
    /**
     * Generates email links and OTPs to be sent via a custom email provider.
     * @param email The user's email.
     * @param options.password User password. For signup only.
     * @param options.data Optional user metadata. For signup only.
     * @param options.redirectTo The redirect url which should be appended to the generated link
     */
  }, {
    key: "generateLink",
    value: function generateLink(params) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var options, rest, body;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              options = params.options, rest = __rest(params, ["options"]);
              body = Object.assign(Object.assign({}, rest), options);
              if ('newEmail' in rest) {
                // replace newEmail with new_email in request body
                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
                delete body['newEmail'];
              }
              _context3.next = 6;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/admin/generate_link"), {
                body: body,
                headers: this.headers,
                xform: fetch_1._generateLinkResponse,
                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
              });
            case 6:
              return _context3.abrupt("return", _context3.sent);
            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](0);
              if (!(0, errors_1.isAuthError)(_context3.t0)) {
                _context3.next = 13;
                break;
              }
              return _context3.abrupt("return", {
                data: {
                  properties: null,
                  user: null
                },
                error: _context3.t0
              });
            case 13:
              throw _context3.t0;
            case 14:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 9]]);
      }));
    }
    // User Admin API
    /**
     * Creates a new user.
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
  }, {
    key: "createUser",
    value: function createUser(attributes) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/admin/users"), {
                body: attributes,
                headers: this.headers,
                xform: fetch_1._userResponse
              });
            case 3:
              return _context4.abrupt("return", _context4.sent);
            case 6:
              _context4.prev = 6;
              _context4.t0 = _context4["catch"](0);
              if (!(0, errors_1.isAuthError)(_context4.t0)) {
                _context4.next = 10;
                break;
              }
              return _context4.abrupt("return", {
                data: {
                  user: null
                },
                error: _context4.t0
              });
            case 10:
              throw _context4.t0;
            case 11:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 6]]);
      }));
    }
    /**
     * Get a list of users.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
     */
  }, {
    key: "listUsers",
    value: function listUsers(params) {
      var _a, _b, _c, _d, _e, _f, _g;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var pagination, response, users, total, links;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              pagination = {
                nextPage: null,
                lastPage: 0,
                total: 0
              };
              _context5.next = 4;
              return (0, fetch_1._request)(this.fetch, 'GET', "".concat(this.url, "/admin/users"), {
                headers: this.headers,
                noResolveJson: true,
                query: {
                  page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',
                  per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''
                },
                xform: fetch_1._noResolveJsonResponse
              });
            case 4:
              response = _context5.sent;
              if (!response.error) {
                _context5.next = 7;
                break;
              }
              throw response.error;
            case 7:
              _context5.next = 9;
              return response.json();
            case 9:
              users = _context5.sent;
              total = (_e = response.headers.get('x-total-count')) !== null && _e !== void 0 ? _e : 0;
              links = (_g = (_f = response.headers.get('link')) === null || _f === void 0 ? void 0 : _f.split(',')) !== null && _g !== void 0 ? _g : [];
              if (links.length > 0) {
                links.forEach(function (link) {
                  var page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1));
                  var rel = JSON.parse(link.split(';')[1].split('=')[1]);
                  pagination["".concat(rel, "Page")] = page;
                });
                pagination.total = parseInt(total);
              }
              return _context5.abrupt("return", {
                data: Object.assign(Object.assign({}, users), pagination),
                error: null
              });
            case 16:
              _context5.prev = 16;
              _context5.t0 = _context5["catch"](0);
              if (!(0, errors_1.isAuthError)(_context5.t0)) {
                _context5.next = 20;
                break;
              }
              return _context5.abrupt("return", {
                data: {
                  users: []
                },
                error: _context5.t0
              });
            case 20:
              throw _context5.t0;
            case 21:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 16]]);
      }));
    }
    /**
     * Get user by id.
     *
     * @param uid The user's unique identifier
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
  }, {
    key: "getUserById",
    value: function getUserById(uid) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              _context6.next = 3;
              return (0, fetch_1._request)(this.fetch, 'GET', "".concat(this.url, "/admin/users/").concat(uid), {
                headers: this.headers,
                xform: fetch_1._userResponse
              });
            case 3:
              return _context6.abrupt("return", _context6.sent);
            case 6:
              _context6.prev = 6;
              _context6.t0 = _context6["catch"](0);
              if (!(0, errors_1.isAuthError)(_context6.t0)) {
                _context6.next = 10;
                break;
              }
              return _context6.abrupt("return", {
                data: {
                  user: null
                },
                error: _context6.t0
              });
            case 10:
              throw _context6.t0;
            case 11:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 6]]);
      }));
    }
    /**
     * Updates the user data.
     *
     * @param attributes The data you want to update.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
  }, {
    key: "updateUserById",
    value: function updateUserById(uid, attributes) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return (0, fetch_1._request)(this.fetch, 'PUT', "".concat(this.url, "/admin/users/").concat(uid), {
                body: attributes,
                headers: this.headers,
                xform: fetch_1._userResponse
              });
            case 3:
              return _context7.abrupt("return", _context7.sent);
            case 6:
              _context7.prev = 6;
              _context7.t0 = _context7["catch"](0);
              if (!(0, errors_1.isAuthError)(_context7.t0)) {
                _context7.next = 10;
                break;
              }
              return _context7.abrupt("return", {
                data: {
                  user: null
                },
                error: _context7.t0
              });
            case 10:
              throw _context7.t0;
            case 11:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[0, 6]]);
      }));
    }
    /**
     * Delete a user. Requires a `service_role` key.
     *
     * @param id The user id you want to remove.
     *
     * This function should only be called on a server. Never expose your `service_role` key in the browser.
     */
  }, {
    key: "deleteUser",
    value: function deleteUser(id) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              _context8.next = 3;
              return (0, fetch_1._request)(this.fetch, 'DELETE', "".concat(this.url, "/admin/users/").concat(id), {
                headers: this.headers,
                xform: fetch_1._userResponse
              });
            case 3:
              return _context8.abrupt("return", _context8.sent);
            case 6:
              _context8.prev = 6;
              _context8.t0 = _context8["catch"](0);
              if (!(0, errors_1.isAuthError)(_context8.t0)) {
                _context8.next = 10;
                break;
              }
              return _context8.abrupt("return", {
                data: {
                  user: null
                },
                error: _context8.t0
              });
            case 10:
              throw _context8.t0;
            case 11:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[0, 6]]);
      }));
    }
  }, {
    key: "_listFactors",
    value: function _listFactors(params) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var _yield, data, error;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              _context9.next = 3;
              return (0, fetch_1._request)(this.fetch, 'GET', "".concat(this.url, "/admin/users/").concat(params.userId, "/factors"), {
                headers: this.headers,
                xform: function xform(factors) {
                  return {
                    data: {
                      factors: factors
                    },
                    error: null
                  };
                }
              });
            case 3:
              _yield = _context9.sent;
              data = _yield.data;
              error = _yield.error;
              return _context9.abrupt("return", {
                data: data,
                error: error
              });
            case 9:
              _context9.prev = 9;
              _context9.t0 = _context9["catch"](0);
              if (!(0, errors_1.isAuthError)(_context9.t0)) {
                _context9.next = 13;
                break;
              }
              return _context9.abrupt("return", {
                data: null,
                error: _context9.t0
              });
            case 13:
              throw _context9.t0;
            case 14:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[0, 9]]);
      }));
    }
  }, {
    key: "_deleteFactor",
    value: function _deleteFactor(params) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var data;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.prev = 0;
              _context10.next = 3;
              return (0, fetch_1._request)(this.fetch, 'DELETE', "".concat(this.url, "/admin/users/").concat(params.userId, "/factors/").concat(params.id), {
                headers: this.headers
              });
            case 3:
              data = _context10.sent;
              return _context10.abrupt("return", {
                data: data,
                error: null
              });
            case 7:
              _context10.prev = 7;
              _context10.t0 = _context10["catch"](0);
              if (!(0, errors_1.isAuthError)(_context10.t0)) {
                _context10.next = 11;
                break;
              }
              return _context10.abrupt("return", {
                data: null,
                error: _context10.t0
              });
            case 11:
              throw _context10.t0;
            case 12:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this, [[0, 7]]);
      }));
    }
  }]);
  return GoTrueAdminApi;
}();
exports["default"] = GoTrueAdminApi;

},{"./lib/errors":11,"./lib/fetch":12,"./lib/helpers":13}],8:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var GoTrueAdminApi_1 = __importDefault(require("./GoTrueAdminApi"));
var constants_1 = require("./lib/constants");
var errors_1 = require("./lib/errors");
var fetch_1 = require("./lib/fetch");
var helpers_1 = require("./lib/helpers");
var local_storage_1 = __importDefault(require("./lib/local-storage"));
var polyfills_1 = require("./lib/polyfills");
(0, polyfills_1.polyfillGlobalThis)(); // Make "globalThis" available
var DEFAULT_OPTIONS = {
  url: constants_1.GOTRUE_URL,
  storageKey: constants_1.STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: constants_1.DEFAULT_HEADERS
};
var GoTrueClient = /*#__PURE__*/function () {
  /**
   * Create a new client for use in the browser.
   */
  function GoTrueClient(options) {
    _classCallCheck(this, GoTrueClient);
    this.stateChangeEmitters = new Map();
    this.networkRetries = 0;
    this.refreshingDeferred = null;
    /**
     * Keeps track of the async client initialization.
     * When null or not yet resolved the auth state is `unknown`
     * Once resolved the the auth state is known and it's save to call any further client methods.
     * Keep extra care to never reject or throw uncaught errors
     */
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.inMemorySession = null;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.persistSession = settings.persistSession;
    this.storage = settings.storage || local_storage_1["default"];
    this.admin = new GoTrueAdminApi_1["default"]({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = (0, helpers_1.resolveFetch)(settings.fetch);
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.initialize();
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
    };
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  _createClass(GoTrueClient, [{
    key: "initialize",
    value: function initialize() {
      if (!this.initializePromise) {
        this.initializePromise = this._initialize();
      }
      return this.initializePromise;
    }
    /**
     * IMPORTANT:
     * 1. Never throw in this method, as it is called from the constructor
     * 2. Never return a session from this method as it would be cached over
     *    the whole lifetime of the client
     */
  }, {
    key: "_initialize",
    value: function _initialize() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _yield$this$_getSessi, data, error, session, redirectType;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.initializePromise) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", this.initializePromise);
            case 2:
              _context.prev = 2;
              if (!(this.detectSessionInUrl && this._isImplicitGrantFlow())) {
                _context.next = 19;
                break;
              }
              _context.next = 6;
              return this._getSessionFromUrl();
            case 6:
              _yield$this$_getSessi = _context.sent;
              data = _yield$this$_getSessi.data;
              error = _yield$this$_getSessi.error;
              if (!error) {
                _context.next = 13;
                break;
              }
              _context.next = 12;
              return this._removeSession();
            case 12:
              return _context.abrupt("return", {
                error: error
              });
            case 13:
              session = data.session, redirectType = data.redirectType;
              _context.next = 16;
              return this._saveSession(session);
            case 16:
              this._notifyAllSubscribers('SIGNED_IN', session);
              if (redirectType === 'recovery') {
                this._notifyAllSubscribers('PASSWORD_RECOVERY', session);
              }
              return _context.abrupt("return", {
                error: null
              });
            case 19:
              _context.next = 21;
              return this._recoverAndRefresh();
            case 21:
              return _context.abrupt("return", {
                error: null
              });
            case 24:
              _context.prev = 24;
              _context.t0 = _context["catch"](2);
              if (!(0, errors_1.isAuthError)(_context.t0)) {
                _context.next = 28;
                break;
              }
              return _context.abrupt("return", {
                error: _context.t0
              });
            case 28:
              return _context.abrupt("return", {
                error: new errors_1.AuthUnknownError('Unexpected error during initialization', _context.t0)
              });
            case 29:
              _context.prev = 29;
              this._handleVisibilityChange();
              return _context.finish(29);
            case 32:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[2, 24, 29, 32]]);
      }));
    }
    /**
     * Creates a new user.
     * @returns A logged-in session if the server has "autoconfirm" ON
     * @returns A user if the server has "autoconfirm" OFF
     */
  }, {
    key: "signUp",
    value: function signUp(credentials) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var res, email, password, options, phone, _password, _options, _res, data, error, session, user;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return this._removeSession();
            case 3:
              if (!('email' in credentials)) {
                _context2.next = 10;
                break;
              }
              email = credentials.email, password = credentials.password, options = credentials.options;
              _context2.next = 7;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/signup"), {
                headers: this.headers,
                redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
                body: {
                  email: email,
                  password: password,
                  data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
                  gotrue_meta_security: {
                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                  }
                },
                xform: fetch_1._sessionResponse
              });
            case 7:
              res = _context2.sent;
              _context2.next = 18;
              break;
            case 10:
              if (!('phone' in credentials)) {
                _context2.next = 17;
                break;
              }
              phone = credentials.phone, _password = credentials.password, _options = credentials.options;
              _context2.next = 14;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/signup"), {
                headers: this.headers,
                body: {
                  phone: phone,
                  password: _password,
                  data: (_b = _options === null || _options === void 0 ? void 0 : _options.data) !== null && _b !== void 0 ? _b : {},
                  gotrue_meta_security: {
                    captcha_token: _options === null || _options === void 0 ? void 0 : _options.captchaToken
                  }
                },
                xform: fetch_1._sessionResponse
              });
            case 14:
              res = _context2.sent;
              _context2.next = 18;
              break;
            case 17:
              throw new errors_1.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');
            case 18:
              _res = res, data = _res.data, error = _res.error;
              if (!(error || !data)) {
                _context2.next = 21;
                break;
              }
              return _context2.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: error
              });
            case 21:
              session = data.session;
              user = data.user;
              if (!data.session) {
                _context2.next = 27;
                break;
              }
              _context2.next = 26;
              return this._saveSession(data.session);
            case 26:
              this._notifyAllSubscribers('SIGNED_IN', session);
            case 27:
              return _context2.abrupt("return", {
                data: {
                  user: user,
                  session: session
                },
                error: null
              });
            case 30:
              _context2.prev = 30;
              _context2.t0 = _context2["catch"](0);
              if (!(0, errors_1.isAuthError)(_context2.t0)) {
                _context2.next = 34;
                break;
              }
              return _context2.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: _context2.t0
              });
            case 34:
              throw _context2.t0;
            case 35:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 30]]);
      }));
    }
    /**
     * Log in an existing user with an email and password or phone and password.
     */
  }, {
    key: "signInWithPassword",
    value: function signInWithPassword(credentials) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var res, email, password, options, phone, _password2, _options2, _res2, data, error;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this._removeSession();
            case 3:
              if (!('email' in credentials)) {
                _context3.next = 10;
                break;
              }
              email = credentials.email, password = credentials.password, options = credentials.options;
              _context3.next = 7;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/token?grant_type=password"), {
                headers: this.headers,
                body: {
                  email: email,
                  password: password,
                  data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
                  gotrue_meta_security: {
                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                  }
                },
                xform: fetch_1._sessionResponse
              });
            case 7:
              res = _context3.sent;
              _context3.next = 18;
              break;
            case 10:
              if (!('phone' in credentials)) {
                _context3.next = 17;
                break;
              }
              phone = credentials.phone, _password2 = credentials.password, _options2 = credentials.options;
              _context3.next = 14;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/token?grant_type=password"), {
                headers: this.headers,
                body: {
                  phone: phone,
                  password: _password2,
                  data: (_b = _options2 === null || _options2 === void 0 ? void 0 : _options2.data) !== null && _b !== void 0 ? _b : {},
                  gotrue_meta_security: {
                    captcha_token: _options2 === null || _options2 === void 0 ? void 0 : _options2.captchaToken
                  }
                },
                xform: fetch_1._sessionResponse
              });
            case 14:
              res = _context3.sent;
              _context3.next = 18;
              break;
            case 17:
              throw new errors_1.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');
            case 18:
              _res2 = res, data = _res2.data, error = _res2.error;
              if (!(error || !data)) {
                _context3.next = 21;
                break;
              }
              return _context3.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: error
              });
            case 21:
              if (!data.session) {
                _context3.next = 25;
                break;
              }
              _context3.next = 24;
              return this._saveSession(data.session);
            case 24:
              this._notifyAllSubscribers('SIGNED_IN', data.session);
            case 25:
              return _context3.abrupt("return", {
                data: data,
                error: error
              });
            case 28:
              _context3.prev = 28;
              _context3.t0 = _context3["catch"](0);
              if (!(0, errors_1.isAuthError)(_context3.t0)) {
                _context3.next = 32;
                break;
              }
              return _context3.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: _context3.t0
              });
            case 32:
              throw _context3.t0;
            case 33:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 28]]);
      }));
    }
    /**
     * Log in an existing user via a third-party provider.
     */
  }, {
    key: "signInWithOAuth",
    value: function signInWithOAuth(credentials) {
      var _a, _b, _c;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this._removeSession();
            case 2:
              return _context4.abrupt("return", this._handleProviderSignIn(credentials.provider, {
                redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
                scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
                queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams
              }));
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
    }
    /**
     * Log in a user using magiclink or a one-time password (OTP).
     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
     */
  }, {
    key: "signInWithOtp",
    value: function signInWithOtp(credentials) {
      var _a, _b, _c, _d;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var email, options, _yield, error, phone, _options3, _yield2, _error;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return this._removeSession();
            case 3:
              if (!('email' in credentials)) {
                _context5.next = 10;
                break;
              }
              email = credentials.email, options = credentials.options;
              _context5.next = 7;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/otp"), {
                headers: this.headers,
                body: {
                  email: email,
                  data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
                  create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
                  gotrue_meta_security: {
                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
                  }
                },
                redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
              });
            case 7:
              _yield = _context5.sent;
              error = _yield.error;
              return _context5.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: error
              });
            case 10:
              if (!('phone' in credentials)) {
                _context5.next = 17;
                break;
              }
              phone = credentials.phone, _options3 = credentials.options;
              _context5.next = 14;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/otp"), {
                headers: this.headers,
                body: {
                  phone: phone,
                  data: (_c = _options3 === null || _options3 === void 0 ? void 0 : _options3.data) !== null && _c !== void 0 ? _c : {},
                  create_user: (_d = _options3 === null || _options3 === void 0 ? void 0 : _options3.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
                  gotrue_meta_security: {
                    captcha_token: _options3 === null || _options3 === void 0 ? void 0 : _options3.captchaToken
                  }
                }
              });
            case 14:
              _yield2 = _context5.sent;
              _error = _yield2.error;
              return _context5.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: _error
              });
            case 17:
              throw new errors_1.AuthInvalidCredentialsError('You must provide either an email or phone number.');
            case 20:
              _context5.prev = 20;
              _context5.t0 = _context5["catch"](0);
              if (!(0, errors_1.isAuthError)(_context5.t0)) {
                _context5.next = 24;
                break;
              }
              return _context5.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: _context5.t0
              });
            case 24:
              throw _context5.t0;
            case 25:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 20]]);
      }));
    }
    /**
     * Log in a user given a User supplied OTP received via mobile.
     */
  }, {
    key: "verifyOtp",
    value: function verifyOtp(params) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var _yield3, data, error, session, user;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              _context6.next = 3;
              return this._removeSession();
            case 3:
              _context6.next = 5;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/verify"), {
                headers: this.headers,
                body: Object.assign(Object.assign({}, params), {
                  gotrue_meta_security: {
                    captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken
                  }
                }),
                redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,
                xform: fetch_1._sessionResponse
              });
            case 5:
              _yield3 = _context6.sent;
              data = _yield3.data;
              error = _yield3.error;
              if (!error) {
                _context6.next = 10;
                break;
              }
              throw error;
            case 10:
              if (data) {
                _context6.next = 12;
                break;
              }
              throw 'An error occurred on token verification.';
            case 12:
              session = data.session;
              user = data.user;
              if (!(session === null || session === void 0 ? void 0 : session.access_token)) {
                _context6.next = 18;
                break;
              }
              _context6.next = 17;
              return this._saveSession(session);
            case 17:
              this._notifyAllSubscribers('SIGNED_IN', session);
            case 18:
              return _context6.abrupt("return", {
                data: {
                  user: user,
                  session: session
                },
                error: null
              });
            case 21:
              _context6.prev = 21;
              _context6.t0 = _context6["catch"](0);
              if (!(0, errors_1.isAuthError)(_context6.t0)) {
                _context6.next = 25;
                break;
              }
              return _context6.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: _context6.t0
              });
            case 25:
              throw _context6.t0;
            case 26:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 21]]);
      }));
    }
    /**
     * Attempts a single-sign on using an enterprise Identity Provider. A
     * successful SSO attempt will redirect the current page to the identity
     * provider authorization page. The redirect URL is implementation and SSO
     * protocol specific.
     *
     * You can use it by providing a SSO domain. Typically you can extract this
     * domain by asking users for their email address. If this domain is
     * registered on the Auth instance the redirect will use that organization's
     * currently active SSO Identity Provider for the login.
     *
     * If you have built an organization-specific login page, you can use the
     * organization's SSO Identity Provider UUID directly instead.
     *
     * This API is experimental and availability is conditional on correct
     * settings on the Auth service.
     *
     * @experimental
     */
  }, {
    key: "signInWithSSO",
    value: function signInWithSSO(params) {
      var _a, _b, _c;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return this._removeSession();
            case 3:
              _context7.next = 5;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/sso"), {
                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {
                  provider_id: params.providerId
                } : null), 'domain' in params ? {
                  domain: params.domain
                } : null), {
                  redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined
                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {
                  gotrue_meta_security: {
                    captcha_token: params.options.captchaToken
                  }
                } : null), {
                  skip_http_redirect: true
                }),
                headers: this.headers,
                xform: fetch_1._ssoResponse
              });
            case 5:
              return _context7.abrupt("return", _context7.sent);
            case 8:
              _context7.prev = 8;
              _context7.t0 = _context7["catch"](0);
              if (!(0, errors_1.isAuthError)(_context7.t0)) {
                _context7.next = 12;
                break;
              }
              return _context7.abrupt("return", {
                data: null,
                error: _context7.t0
              });
            case 12:
              throw _context7.t0;
            case 13:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[0, 8]]);
      }));
    }
    /**
     * Returns the session, refreshing it if necessary.
     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
     */
  }, {
    key: "getSession",
    value: function getSession() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var currentSession, maybeSession, hasExpired, _yield$this$_callRefr, session, error;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.initializePromise;
            case 2:
              currentSession = null;
              if (!this.persistSession) {
                _context8.next = 16;
                break;
              }
              _context8.next = 6;
              return (0, helpers_1.getItemAsync)(this.storage, this.storageKey);
            case 6:
              maybeSession = _context8.sent;
              if (!(maybeSession !== null)) {
                _context8.next = 14;
                break;
              }
              if (!this._isValidSession(maybeSession)) {
                _context8.next = 12;
                break;
              }
              currentSession = maybeSession;
              _context8.next = 14;
              break;
            case 12:
              _context8.next = 14;
              return this._removeSession();
            case 14:
              _context8.next = 17;
              break;
            case 16:
              currentSession = this.inMemorySession;
            case 17:
              if (currentSession) {
                _context8.next = 19;
                break;
              }
              return _context8.abrupt("return", {
                data: {
                  session: null
                },
                error: null
              });
            case 19:
              hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;
              if (hasExpired) {
                _context8.next = 22;
                break;
              }
              return _context8.abrupt("return", {
                data: {
                  session: currentSession
                },
                error: null
              });
            case 22:
              _context8.next = 24;
              return this._callRefreshToken(currentSession.refresh_token);
            case 24:
              _yield$this$_callRefr = _context8.sent;
              session = _yield$this$_callRefr.session;
              error = _yield$this$_callRefr.error;
              if (!error) {
                _context8.next = 29;
                break;
              }
              return _context8.abrupt("return", {
                data: {
                  session: null
                },
                error: error
              });
            case 29:
              return _context8.abrupt("return", {
                data: {
                  session: session
                },
                error: null
              });
            case 30:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
    }
    /**
     * Gets the current user details if there is an existing session.
     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.
     */
  }, {
    key: "getUser",
    value: function getUser(jwt) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var _yield$this$getSessio, data, error;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              if (jwt) {
                _context9.next = 10;
                break;
              }
              _context9.next = 4;
              return this.getSession();
            case 4:
              _yield$this$getSessio = _context9.sent;
              data = _yield$this$getSessio.data;
              error = _yield$this$getSessio.error;
              if (!error) {
                _context9.next = 9;
                break;
              }
              throw error;
            case 9:
              // Default to Authorization header if there is no existing session
              jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;
            case 10:
              _context9.next = 12;
              return (0, fetch_1._request)(this.fetch, 'GET', "".concat(this.url, "/user"), {
                headers: this.headers,
                jwt: jwt,
                xform: fetch_1._userResponse
              });
            case 12:
              return _context9.abrupt("return", _context9.sent);
            case 15:
              _context9.prev = 15;
              _context9.t0 = _context9["catch"](0);
              if (!(0, errors_1.isAuthError)(_context9.t0)) {
                _context9.next = 19;
                break;
              }
              return _context9.abrupt("return", {
                data: {
                  user: null
                },
                error: _context9.t0
              });
            case 19:
              throw _context9.t0;
            case 20:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[0, 15]]);
      }));
    }
    /**
     * Updates user data, if there is a logged in user.
     */
  }, {
    key: "updateUser",
    value: function updateUser(attributes) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var _yield$this$getSessio2, sessionData, sessionError, session, _yield4, data, userError;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.prev = 0;
              _context10.next = 3;
              return this.getSession();
            case 3:
              _yield$this$getSessio2 = _context10.sent;
              sessionData = _yield$this$getSessio2.data;
              sessionError = _yield$this$getSessio2.error;
              if (!sessionError) {
                _context10.next = 8;
                break;
              }
              throw sessionError;
            case 8:
              if (sessionData.session) {
                _context10.next = 10;
                break;
              }
              throw new errors_1.AuthSessionMissingError();
            case 10:
              session = sessionData.session;
              _context10.next = 13;
              return (0, fetch_1._request)(this.fetch, 'PUT', "".concat(this.url, "/user"), {
                headers: this.headers,
                body: attributes,
                jwt: session.access_token,
                xform: fetch_1._userResponse
              });
            case 13:
              _yield4 = _context10.sent;
              data = _yield4.data;
              userError = _yield4.error;
              if (!userError) {
                _context10.next = 18;
                break;
              }
              throw userError;
            case 18:
              session.user = data.user;
              _context10.next = 21;
              return this._saveSession(session);
            case 21:
              this._notifyAllSubscribers('USER_UPDATED', session);
              return _context10.abrupt("return", {
                data: {
                  user: session.user
                },
                error: null
              });
            case 25:
              _context10.prev = 25;
              _context10.t0 = _context10["catch"](0);
              if (!(0, errors_1.isAuthError)(_context10.t0)) {
                _context10.next = 29;
                break;
              }
              return _context10.abrupt("return", {
                data: {
                  user: null
                },
                error: _context10.t0
              });
            case 29:
              throw _context10.t0;
            case 30:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this, [[0, 25]]);
      }));
    }
    /**
     * Decodes a JWT (without performing any validation).
     */
  }, {
    key: "_decodeJWT",
    value: function _decodeJWT(jwt) {
      return (0, helpers_1.decodeJWTPayload)(jwt);
    }
    /**
     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
     * If the refresh token or access token in the current session is invalid, an error will be thrown.
     * @param currentSession The current session that minimally contains an access token and refresh token.
     */
  }, {
    key: "setSession",
    value: function setSession(currentSession) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var timeNow, expiresAt, hasExpired, session, payload, _yield$this$_callRefr2, refreshedSession, error, _yield$this$getUser, data, _error2;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _context11.prev = 0;
              if (!(!currentSession.access_token || !currentSession.refresh_token)) {
                _context11.next = 3;
                break;
              }
              throw new errors_1.AuthSessionMissingError();
            case 3:
              timeNow = Date.now() / 1000;
              expiresAt = timeNow;
              hasExpired = true;
              session = null;
              payload = (0, helpers_1.decodeJWTPayload)(currentSession.access_token);
              if (payload.exp) {
                expiresAt = payload.exp;
                hasExpired = expiresAt <= timeNow;
              }
              if (!hasExpired) {
                _context11.next = 22;
                break;
              }
              _context11.next = 12;
              return this._callRefreshToken(currentSession.refresh_token);
            case 12:
              _yield$this$_callRefr2 = _context11.sent;
              refreshedSession = _yield$this$_callRefr2.session;
              error = _yield$this$_callRefr2.error;
              if (!error) {
                _context11.next = 17;
                break;
              }
              return _context11.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: error
              });
            case 17:
              if (refreshedSession) {
                _context11.next = 19;
                break;
              }
              return _context11.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: null
              });
            case 19:
              session = refreshedSession;
              _context11.next = 32;
              break;
            case 22:
              _context11.next = 24;
              return this.getUser(currentSession.access_token);
            case 24:
              _yield$this$getUser = _context11.sent;
              data = _yield$this$getUser.data;
              _error2 = _yield$this$getUser.error;
              if (!_error2) {
                _context11.next = 29;
                break;
              }
              throw _error2;
            case 29:
              session = {
                access_token: currentSession.access_token,
                refresh_token: currentSession.refresh_token,
                user: data.user,
                token_type: 'bearer',
                expires_in: expiresAt - timeNow,
                expires_at: expiresAt
              };
              _context11.next = 32;
              return this._saveSession(session);
            case 32:
              return _context11.abrupt("return", {
                data: {
                  user: session.user,
                  session: session
                },
                error: null
              });
            case 35:
              _context11.prev = 35;
              _context11.t0 = _context11["catch"](0);
              if (!(0, errors_1.isAuthError)(_context11.t0)) {
                _context11.next = 39;
                break;
              }
              return _context11.abrupt("return", {
                data: {
                  session: null,
                  user: null
                },
                error: _context11.t0
              });
            case 39:
              throw _context11.t0;
            case 40:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this, [[0, 35]]);
      }));
    }
    /**
     * Returns a new session, regardless of expiry status.
     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
     * If the current session's refresh token is invalid, an error will be thrown.
     * @param currentSession The current session. If passed in, it must contain a refresh token.
     */
  }, {
    key: "refreshSession",
    value: function refreshSession(currentSession) {
      var _a;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        var _yield$this$getSessio3, data, _error3, _yield$this$_callRefr3, session, error;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.prev = 0;
              if (currentSession) {
                _context12.next = 10;
                break;
              }
              _context12.next = 4;
              return this.getSession();
            case 4:
              _yield$this$getSessio3 = _context12.sent;
              data = _yield$this$getSessio3.data;
              _error3 = _yield$this$getSessio3.error;
              if (!_error3) {
                _context12.next = 9;
                break;
              }
              throw _error3;
            case 9:
              currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;
            case 10:
              if (currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token) {
                _context12.next = 12;
                break;
              }
              throw new errors_1.AuthSessionMissingError();
            case 12:
              _context12.next = 14;
              return this._callRefreshToken(currentSession.refresh_token);
            case 14:
              _yield$this$_callRefr3 = _context12.sent;
              session = _yield$this$_callRefr3.session;
              error = _yield$this$_callRefr3.error;
              if (!error) {
                _context12.next = 19;
                break;
              }
              return _context12.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: error
              });
            case 19:
              if (session) {
                _context12.next = 21;
                break;
              }
              return _context12.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: null
              });
            case 21:
              return _context12.abrupt("return", {
                data: {
                  user: session.user,
                  session: session
                },
                error: null
              });
            case 24:
              _context12.prev = 24;
              _context12.t0 = _context12["catch"](0);
              if (!(0, errors_1.isAuthError)(_context12.t0)) {
                _context12.next = 28;
                break;
              }
              return _context12.abrupt("return", {
                data: {
                  user: null,
                  session: null
                },
                error: _context12.t0
              });
            case 28:
              throw _context12.t0;
            case 29:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this, [[0, 24]]);
      }));
    }
    /**
     * Gets the session data from a URL string
     */
  }, {
    key: "_getSessionFromUrl",
    value: function _getSessionFromUrl() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
        var error_description, error_code, _error4, provider_token, provider_refresh_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$getUser2, data, error, user, session, redirectType;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _context13.prev = 0;
              if ((0, helpers_1.isBrowser)()) {
                _context13.next = 3;
                break;
              }
              throw new errors_1.AuthImplicitGrantRedirectError('No browser detected.');
            case 3:
              if (this._isImplicitGrantFlow()) {
                _context13.next = 5;
                break;
              }
              throw new errors_1.AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');
            case 5:
              error_description = (0, helpers_1.getParameterByName)('error_description');
              if (!error_description) {
                _context13.next = 14;
                break;
              }
              error_code = (0, helpers_1.getParameterByName)('error_code');
              if (error_code) {
                _context13.next = 10;
                break;
              }
              throw new errors_1.AuthImplicitGrantRedirectError('No error_code detected.');
            case 10:
              _error4 = (0, helpers_1.getParameterByName)('error');
              if (_error4) {
                _context13.next = 13;
                break;
              }
              throw new errors_1.AuthImplicitGrantRedirectError('No error detected.');
            case 13:
              throw new errors_1.AuthImplicitGrantRedirectError(error_description, {
                error: _error4,
                code: error_code
              });
            case 14:
              provider_token = (0, helpers_1.getParameterByName)('provider_token');
              provider_refresh_token = (0, helpers_1.getParameterByName)('provider_refresh_token');
              access_token = (0, helpers_1.getParameterByName)('access_token');
              if (access_token) {
                _context13.next = 19;
                break;
              }
              throw new errors_1.AuthImplicitGrantRedirectError('No access_token detected.');
            case 19:
              expires_in = (0, helpers_1.getParameterByName)('expires_in');
              if (expires_in) {
                _context13.next = 22;
                break;
              }
              throw new errors_1.AuthImplicitGrantRedirectError('No expires_in detected.');
            case 22:
              refresh_token = (0, helpers_1.getParameterByName)('refresh_token');
              if (refresh_token) {
                _context13.next = 25;
                break;
              }
              throw new errors_1.AuthImplicitGrantRedirectError('No refresh_token detected.');
            case 25:
              token_type = (0, helpers_1.getParameterByName)('token_type');
              if (token_type) {
                _context13.next = 28;
                break;
              }
              throw new errors_1.AuthImplicitGrantRedirectError('No token_type detected.');
            case 28:
              timeNow = Math.round(Date.now() / 1000);
              expires_at = timeNow + parseInt(expires_in);
              _context13.next = 32;
              return this.getUser(access_token);
            case 32:
              _yield$this$getUser2 = _context13.sent;
              data = _yield$this$getUser2.data;
              error = _yield$this$getUser2.error;
              if (!error) {
                _context13.next = 37;
                break;
              }
              throw error;
            case 37:
              user = data.user;
              session = {
                provider_token: provider_token,
                provider_refresh_token: provider_refresh_token,
                access_token: access_token,
                expires_in: parseInt(expires_in),
                expires_at: expires_at,
                refresh_token: refresh_token,
                token_type: token_type,
                user: user
              };
              redirectType = (0, helpers_1.getParameterByName)('type'); // Remove tokens from URL
              window.location.hash = '';
              return _context13.abrupt("return", {
                data: {
                  session: session,
                  redirectType: redirectType
                },
                error: null
              });
            case 44:
              _context13.prev = 44;
              _context13.t0 = _context13["catch"](0);
              if (!(0, errors_1.isAuthError)(_context13.t0)) {
                _context13.next = 48;
                break;
              }
              return _context13.abrupt("return", {
                data: {
                  session: null,
                  redirectType: null
                },
                error: _context13.t0
              });
            case 48:
              throw _context13.t0;
            case 49:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this, [[0, 44]]);
      }));
    }
    /**
     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
     */
  }, {
    key: "_isImplicitGrantFlow",
    value: function _isImplicitGrantFlow() {
      return (0, helpers_1.isBrowser)() && (Boolean((0, helpers_1.getParameterByName)('access_token')) || Boolean((0, helpers_1.getParameterByName)('error_description')));
    }
    /**
     * Inside a browser context, `signOut()` will remove the logged in user from the browser session
     * and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
     *
     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
     */
  }, {
    key: "signOut",
    value: function signOut() {
      var _a;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var _yield$this$getSessio4, data, sessionError, accessToken, _yield$this$admin$sig, error;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this.getSession();
            case 2:
              _yield$this$getSessio4 = _context14.sent;
              data = _yield$this$getSessio4.data;
              sessionError = _yield$this$getSessio4.error;
              if (!sessionError) {
                _context14.next = 7;
                break;
              }
              return _context14.abrupt("return", {
                error: sessionError
              });
            case 7:
              accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;
              if (!accessToken) {
                _context14.next = 16;
                break;
              }
              _context14.next = 11;
              return this.admin.signOut(accessToken);
            case 11:
              _yield$this$admin$sig = _context14.sent;
              error = _yield$this$admin$sig.error;
              if (!error) {
                _context14.next = 16;
                break;
              }
              if ((0, errors_1.isAuthApiError)(error) && (error.status === 404 || error.status === 401)) {
                _context14.next = 16;
                break;
              }
              return _context14.abrupt("return", {
                error: error
              });
            case 16:
              _context14.next = 18;
              return this._removeSession();
            case 18:
              this._notifyAllSubscribers('SIGNED_OUT', null);
              return _context14.abrupt("return", {
                error: null
              });
            case 20:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
    }
    /**
     * Receive a notification every time an auth event happens.
     * @param callback A callback function to be invoked when an auth event happens.
     */
  }, {
    key: "onAuthStateChange",
    value: function onAuthStateChange(callback) {
      var _this = this;
      var id = (0, helpers_1.uuid)();
      var subscription = {
        id: id,
        callback: callback,
        unsubscribe: function unsubscribe() {
          _this.stateChangeEmitters["delete"](id);
        }
      };
      this.stateChangeEmitters.set(id, subscription);
      return {
        data: {
          subscription: subscription
        }
      };
    }
    /**
     * Sends a password reset request to an email address.
     * @param email The email address of the user.
     * @param options.redirectTo The URL to send the user to after they click the password reset link.
     * @param options.captchaToken Verification token received when the user completes the captcha on the site.
     */
  }, {
    key: "resetPasswordForEmail",
    value: function resetPasswordForEmail(email) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              _context15.prev = 0;
              _context15.next = 3;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/recover"), {
                body: {
                  email: email,
                  gotrue_meta_security: {
                    captcha_token: options.captchaToken
                  }
                },
                headers: this.headers,
                redirectTo: options.redirectTo
              });
            case 3:
              return _context15.abrupt("return", _context15.sent);
            case 6:
              _context15.prev = 6;
              _context15.t0 = _context15["catch"](0);
              if (!(0, errors_1.isAuthError)(_context15.t0)) {
                _context15.next = 10;
                break;
              }
              return _context15.abrupt("return", {
                data: null,
                error: _context15.t0
              });
            case 10:
              throw _context15.t0;
            case 11:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this, [[0, 6]]);
      }));
    }
    /**
     * Generates a new JWT.
     * @param refreshToken A valid refresh token that was returned on login.
     */
  }, {
    key: "_refreshAccessToken",
    value: function _refreshAccessToken(refreshToken) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.prev = 0;
              _context16.next = 3;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/token?grant_type=refresh_token"), {
                body: {
                  refresh_token: refreshToken
                },
                headers: this.headers,
                xform: fetch_1._sessionResponse
              });
            case 3:
              return _context16.abrupt("return", _context16.sent);
            case 6:
              _context16.prev = 6;
              _context16.t0 = _context16["catch"](0);
              if (!(0, errors_1.isAuthError)(_context16.t0)) {
                _context16.next = 10;
                break;
              }
              return _context16.abrupt("return", {
                data: {
                  session: null,
                  user: null
                },
                error: _context16.t0
              });
            case 10:
              throw _context16.t0;
            case 11:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this, [[0, 6]]);
      }));
    }
  }, {
    key: "_isValidSession",
    value: function _isValidSession(maybeSession) {
      var isValidSession = _typeof(maybeSession) === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;
      return isValidSession;
    }
  }, {
    key: "_handleProviderSignIn",
    value: function _handleProviderSignIn(provider) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var url = this._getUrlForProvider(provider, {
        redirectTo: options.redirectTo,
        scopes: options.scopes,
        queryParams: options.queryParams
      });
      // try to open on the browser
      if ((0, helpers_1.isBrowser)()) {
        window.location.href = url;
      }
      return {
        data: {
          provider: provider,
          url: url
        },
        error: null
      };
    }
    /**
     * Recovers the session from LocalStorage and refreshes
     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
     */
  }, {
    key: "_recoverAndRefresh",
    value: function _recoverAndRefresh() {
      var _a;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var _this2 = this;
        var currentSession, timeNow, _yield$this$_callRefr4, error;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.prev = 0;
              _context17.next = 3;
              return (0, helpers_1.getItemAsync)(this.storage, this.storageKey);
            case 3:
              currentSession = _context17.sent;
              if (this._isValidSession(currentSession)) {
                _context17.next = 9;
                break;
              }
              if (!(currentSession !== null)) {
                _context17.next = 8;
                break;
              }
              _context17.next = 8;
              return this._removeSession();
            case 8:
              return _context17.abrupt("return");
            case 9:
              timeNow = Math.round(Date.now() / 1000);
              if (!(((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + constants_1.EXPIRY_MARGIN)) {
                _context17.next = 32;
                break;
              }
              if (!(this.autoRefreshToken && currentSession.refresh_token)) {
                _context17.next = 28;
                break;
              }
              this.networkRetries++;
              _context17.next = 15;
              return this._callRefreshToken(currentSession.refresh_token);
            case 15:
              _yield$this$_callRefr4 = _context17.sent;
              error = _yield$this$_callRefr4.error;
              if (!error) {
                _context17.next = 25;
                break;
              }
              console.log(error.message);
              if (!(error instanceof errors_1.AuthRetryableFetchError && this.networkRetries < constants_1.NETWORK_FAILURE.MAX_RETRIES)) {
                _context17.next = 23;
                break;
              }
              if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);
              this.refreshTokenTimer = setTimeout(function () {
                return _this2._recoverAndRefresh();
              }, Math.pow(constants_1.NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff
              );
              return _context17.abrupt("return");
            case 23:
              _context17.next = 25;
              return this._removeSession();
            case 25:
              this.networkRetries = 0;
              _context17.next = 30;
              break;
            case 28:
              _context17.next = 30;
              return this._removeSession();
            case 30:
              _context17.next = 36;
              break;
            case 32:
              if (!this.persistSession) {
                _context17.next = 35;
                break;
              }
              _context17.next = 35;
              return this._saveSession(currentSession);
            case 35:
              this._notifyAllSubscribers('SIGNED_IN', currentSession);
            case 36:
              _context17.next = 42;
              break;
            case 38:
              _context17.prev = 38;
              _context17.t0 = _context17["catch"](0);
              console.error(_context17.t0);
              return _context17.abrupt("return");
            case 42:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this, [[0, 38]]);
      }));
    }
  }, {
    key: "_callRefreshToken",
    value: function _callRefreshToken(refreshToken) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
        var _yield$this$_refreshA, data, error, result, _result;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              if (!this.refreshingDeferred) {
                _context18.next = 2;
                break;
              }
              return _context18.abrupt("return", this.refreshingDeferred.promise);
            case 2:
              _context18.prev = 2;
              this.refreshingDeferred = new helpers_1.Deferred();
              if (refreshToken) {
                _context18.next = 6;
                break;
              }
              throw new errors_1.AuthSessionMissingError();
            case 6:
              _context18.next = 8;
              return this._refreshAccessToken(refreshToken);
            case 8:
              _yield$this$_refreshA = _context18.sent;
              data = _yield$this$_refreshA.data;
              error = _yield$this$_refreshA.error;
              if (!error) {
                _context18.next = 13;
                break;
              }
              throw error;
            case 13:
              if (data.session) {
                _context18.next = 15;
                break;
              }
              throw new errors_1.AuthSessionMissingError();
            case 15:
              _context18.next = 17;
              return this._saveSession(data.session);
            case 17:
              this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);
              result = {
                session: data.session,
                error: null
              };
              this.refreshingDeferred.resolve(result);
              return _context18.abrupt("return", result);
            case 23:
              _context18.prev = 23;
              _context18.t0 = _context18["catch"](2);
              if (!(0, errors_1.isAuthError)(_context18.t0)) {
                _context18.next = 29;
                break;
              }
              _result = {
                session: null,
                error: _context18.t0
              };
              (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(_result);
              return _context18.abrupt("return", _result);
            case 29:
              (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(_context18.t0);
              throw _context18.t0;
            case 31:
              _context18.prev = 31;
              this.refreshingDeferred = null;
              return _context18.finish(31);
            case 34:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this, [[2, 23, 31, 34]]);
      }));
    }
  }, {
    key: "_notifyAllSubscribers",
    value: function _notifyAllSubscribers(event, session) {
      this.stateChangeEmitters.forEach(function (x) {
        return x.callback(event, session);
      });
    }
    /**
     * set currentSession and currentUser
     * process to _startAutoRefreshToken if possible
     */
  }, {
    key: "_saveSession",
    value: function _saveSession(session) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
        var expiresAt, timeNow, expiresIn, refreshDurationBeforeExpires;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              if (!this.persistSession) {
                this.inMemorySession = session;
              }
              expiresAt = session.expires_at;
              if (expiresAt) {
                timeNow = Math.round(Date.now() / 1000);
                expiresIn = expiresAt - timeNow;
                refreshDurationBeforeExpires = expiresIn > constants_1.EXPIRY_MARGIN ? constants_1.EXPIRY_MARGIN : 0.5;
                this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);
              }
              if (!(this.persistSession && session.expires_at)) {
                _context19.next = 6;
                break;
              }
              _context19.next = 6;
              return this._persistSession(session);
            case 6:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
    }
  }, {
    key: "_persistSession",
    value: function _persistSession(currentSession) {
      return (0, helpers_1.setItemAsync)(this.storage, this.storageKey, currentSession);
    }
  }, {
    key: "_removeSession",
    value: function _removeSession() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              if (!this.persistSession) {
                _context20.next = 5;
                break;
              }
              _context20.next = 3;
              return (0, helpers_1.removeItemAsync)(this.storage, this.storageKey);
            case 3:
              _context20.next = 6;
              break;
            case 5:
              this.inMemorySession = null;
            case 6:
              if (this.refreshTokenTimer) {
                clearTimeout(this.refreshTokenTimer);
              }
            case 7:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
    }
    /**
     * Clear and re-create refresh token timer
     * @param value time intervals in milliseconds.
     * @param session The current session.
     */
  }, {
    key: "_startAutoRefreshToken",
    value: function _startAutoRefreshToken(value) {
      var _this3 = this;
      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);
      if (value <= 0 || !this.autoRefreshToken) return;
      this.refreshTokenTimer = setTimeout(function () {
        return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
          var _yield$this$getSessio5, session, sessionError, _yield$this$_callRefr5, error;
          return _regeneratorRuntime().wrap(function _callee21$(_context21) {
            while (1) switch (_context21.prev = _context21.next) {
              case 0:
                this.networkRetries++;
                _context21.next = 3;
                return this.getSession();
              case 3:
                _yield$this$getSessio5 = _context21.sent;
                session = _yield$this$getSessio5.data.session;
                sessionError = _yield$this$getSessio5.error;
                if (!(!sessionError && session)) {
                  _context21.next = 13;
                  break;
                }
                _context21.next = 9;
                return this._callRefreshToken(session.refresh_token);
              case 9:
                _yield$this$_callRefr5 = _context21.sent;
                error = _yield$this$_callRefr5.error;
                if (!error) this.networkRetries = 0;
                if (error instanceof errors_1.AuthRetryableFetchError && this.networkRetries < constants_1.NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(constants_1.NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff
              case 13:
              case "end":
                return _context21.stop();
            }
          }, _callee21, this);
        }));
      }, value);
      if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();
    }
  }, {
    key: "_handleVisibilityChange",
    value: function _handleVisibilityChange() {
      var _this4 = this;
      if (!(0, helpers_1.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
        return false;
      }
      try {
        window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', function () {
          return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
            return _regeneratorRuntime().wrap(function _callee22$(_context22) {
              while (1) switch (_context22.prev = _context22.next) {
                case 0:
                  if (!(document.visibilityState === 'visible')) {
                    _context22.next = 5;
                    break;
                  }
                  _context22.next = 3;
                  return this.initializePromise;
                case 3:
                  _context22.next = 5;
                  return this._recoverAndRefresh();
                case 5:
                case "end":
                  return _context22.stop();
              }
            }, _callee22, this);
          }));
        });
      } catch (error) {
        console.error('_handleVisibilityChange', error);
      }
    }
    /**
     * Generates the relevant login URL for a third-party provider.
     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
     * @param options.scopes A space-separated list of scopes granted to the OAuth application.
     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
     */
  }, {
    key: "_getUrlForProvider",
    value: function _getUrlForProvider(provider, options) {
      var urlParams = ["provider=".concat(encodeURIComponent(provider))];
      if (options === null || options === void 0 ? void 0 : options.redirectTo) {
        urlParams.push("redirect_to=".concat(encodeURIComponent(options.redirectTo)));
      }
      if (options === null || options === void 0 ? void 0 : options.scopes) {
        urlParams.push("scopes=".concat(encodeURIComponent(options.scopes)));
      }
      if (options === null || options === void 0 ? void 0 : options.queryParams) {
        var query = new URLSearchParams(options.queryParams);
        urlParams.push(query.toString());
      }
      return "".concat(this.url, "/authorize?").concat(urlParams.join('&'));
    }
  }, {
    key: "_unenroll",
    value: function _unenroll(params) {
      var _a;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
        var _yield$this$getSessio6, sessionData, sessionError;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _context23.prev = 0;
              _context23.next = 3;
              return this.getSession();
            case 3:
              _yield$this$getSessio6 = _context23.sent;
              sessionData = _yield$this$getSessio6.data;
              sessionError = _yield$this$getSessio6.error;
              if (!sessionError) {
                _context23.next = 8;
                break;
              }
              return _context23.abrupt("return", {
                data: null,
                error: sessionError
              });
            case 8:
              _context23.next = 10;
              return (0, fetch_1._request)(this.fetch, 'DELETE', "".concat(this.url, "/factors/").concat(params.factorId), {
                headers: this.headers,
                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
              });
            case 10:
              return _context23.abrupt("return", _context23.sent);
            case 13:
              _context23.prev = 13;
              _context23.t0 = _context23["catch"](0);
              if (!(0, errors_1.isAuthError)(_context23.t0)) {
                _context23.next = 17;
                break;
              }
              return _context23.abrupt("return", {
                data: null,
                error: _context23.t0
              });
            case 17:
              throw _context23.t0;
            case 18:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this, [[0, 13]]);
      }));
    }
    /**
     * Enrolls a factor
     * @param friendlyName Human readable name assigned to a device
     * @param factorType device which we're validating against. Can only be TOTP for now.
     * @param issuer domain which the user is enrolling with
     */
  }, {
    key: "_enroll",
    value: function _enroll(params) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
        var _yield$this$getSessio7, sessionData, sessionError, _yield5, data, error;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _context24.prev = 0;
              _context24.next = 3;
              return this.getSession();
            case 3:
              _yield$this$getSessio7 = _context24.sent;
              sessionData = _yield$this$getSessio7.data;
              sessionError = _yield$this$getSessio7.error;
              if (!sessionError) {
                _context24.next = 8;
                break;
              }
              return _context24.abrupt("return", {
                data: null,
                error: sessionError
              });
            case 8:
              _context24.next = 10;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/factors"), {
                body: {
                  friendly_name: params.friendlyName,
                  factor_type: params.factorType,
                  issuer: params.issuer
                },
                headers: this.headers,
                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
              });
            case 10:
              _yield5 = _context24.sent;
              data = _yield5.data;
              error = _yield5.error;
              if (!error) {
                _context24.next = 15;
                break;
              }
              return _context24.abrupt("return", {
                data: null,
                error: error
              });
            case 15:
              if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {
                data.totp.qr_code = "data:image/svg+xml;utf-8,".concat(data.totp.qr_code);
              }
              return _context24.abrupt("return", {
                data: data,
                error: null
              });
            case 19:
              _context24.prev = 19;
              _context24.t0 = _context24["catch"](0);
              if (!(0, errors_1.isAuthError)(_context24.t0)) {
                _context24.next = 23;
                break;
              }
              return _context24.abrupt("return", {
                data: null,
                error: _context24.t0
              });
            case 23:
              throw _context24.t0;
            case 24:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this, [[0, 19]]);
      }));
    }
    /**
     * Validates a device as part of the enrollment step.
     * @param factorId System assigned identifier for authenticator device as returned by enroll
     * @param code Code Generated by an authenticator device
     */
  }, {
    key: "_verify",
    value: function _verify(params) {
      var _a;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
        var _yield$this$getSessio8, sessionData, sessionError, _yield6, data, error;
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              _context25.prev = 0;
              _context25.next = 3;
              return this.getSession();
            case 3:
              _yield$this$getSessio8 = _context25.sent;
              sessionData = _yield$this$getSessio8.data;
              sessionError = _yield$this$getSessio8.error;
              if (!sessionError) {
                _context25.next = 8;
                break;
              }
              return _context25.abrupt("return", {
                data: null,
                error: sessionError
              });
            case 8:
              _context25.next = 10;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/factors/").concat(params.factorId, "/verify"), {
                body: {
                  code: params.code,
                  challenge_id: params.challengeId
                },
                headers: this.headers,
                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
              });
            case 10:
              _yield6 = _context25.sent;
              data = _yield6.data;
              error = _yield6.error;
              if (!error) {
                _context25.next = 15;
                break;
              }
              return _context25.abrupt("return", {
                data: null,
                error: error
              });
            case 15:
              _context25.next = 17;
              return this._saveSession(Object.assign({
                expires_at: Math.round(Date.now() / 1000) + data.expires_in
              }, data));
            case 17:
              this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);
              return _context25.abrupt("return", {
                data: data,
                error: error
              });
            case 21:
              _context25.prev = 21;
              _context25.t0 = _context25["catch"](0);
              if (!(0, errors_1.isAuthError)(_context25.t0)) {
                _context25.next = 25;
                break;
              }
              return _context25.abrupt("return", {
                data: null,
                error: _context25.t0
              });
            case 25:
              throw _context25.t0;
            case 26:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this, [[0, 21]]);
      }));
    }
    /**
     * Creates a challenge which a user can verify against
     * @param factorId System assigned identifier for authenticator device as returned by enroll
     */
  }, {
    key: "_challenge",
    value: function _challenge(params) {
      var _a;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
        var _yield$this$getSessio9, sessionData, sessionError;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              _context26.prev = 0;
              _context26.next = 3;
              return this.getSession();
            case 3:
              _yield$this$getSessio9 = _context26.sent;
              sessionData = _yield$this$getSessio9.data;
              sessionError = _yield$this$getSessio9.error;
              if (!sessionError) {
                _context26.next = 8;
                break;
              }
              return _context26.abrupt("return", {
                data: null,
                error: sessionError
              });
            case 8:
              _context26.next = 10;
              return (0, fetch_1._request)(this.fetch, 'POST', "".concat(this.url, "/factors/").concat(params.factorId, "/challenge"), {
                headers: this.headers,
                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
              });
            case 10:
              return _context26.abrupt("return", _context26.sent);
            case 13:
              _context26.prev = 13;
              _context26.t0 = _context26["catch"](0);
              if (!(0, errors_1.isAuthError)(_context26.t0)) {
                _context26.next = 17;
                break;
              }
              return _context26.abrupt("return", {
                data: null,
                error: _context26.t0
              });
            case 17:
              throw _context26.t0;
            case 18:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this, [[0, 13]]);
      }));
    }
    /**
     * Creates a challenge and immediately verifies it
     * @param factorId System assigned identifier for authenticator device as returned by enroll
     * @param code Code Generated by an authenticator device
     */
  }, {
    key: "_challengeAndVerify",
    value: function _challengeAndVerify(params) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
        var _yield$this$_challeng, challengeData, challengeError;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this._challenge({
                factorId: params.factorId
              });
            case 2:
              _yield$this$_challeng = _context27.sent;
              challengeData = _yield$this$_challeng.data;
              challengeError = _yield$this$_challeng.error;
              if (!challengeError) {
                _context27.next = 7;
                break;
              }
              return _context27.abrupt("return", {
                data: null,
                error: challengeError
              });
            case 7:
              _context27.next = 9;
              return this._verify({
                factorId: params.factorId,
                challengeId: challengeData.id,
                code: params.code
              });
            case 9:
              return _context27.abrupt("return", _context27.sent);
            case 10:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
    }
    /**
     * Displays all devices for a given user
     */
  }, {
    key: "_listFactors",
    value: function _listFactors() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
        var _yield$this$getUser3, user, userError, factors, totp;
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              _context28.next = 2;
              return this.getUser();
            case 2:
              _yield$this$getUser3 = _context28.sent;
              user = _yield$this$getUser3.data.user;
              userError = _yield$this$getUser3.error;
              if (!userError) {
                _context28.next = 7;
                break;
              }
              return _context28.abrupt("return", {
                data: null,
                error: userError
              });
            case 7:
              factors = (user === null || user === void 0 ? void 0 : user.factors) || [];
              totp = factors.filter(function (factor) {
                return factor.factor_type === 'totp' && factor.status === 'verified';
              });
              return _context28.abrupt("return", {
                data: {
                  all: factors,
                  totp: totp
                },
                error: null
              });
            case 10:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
    }
    /**
     * Gets the current and next authenticator assurance level (AAL)
     * and the current authentication methods for the session (AMR)
     */
  }, {
    key: "_getAuthenticatorAssuranceLevel",
    value: function _getAuthenticatorAssuranceLevel() {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
        var _yield$this$getSessio10, session, sessionError, payload, currentLevel, nextLevel, verifiedFactors, currentAuthenticationMethods;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return this.getSession();
            case 2:
              _yield$this$getSessio10 = _context29.sent;
              session = _yield$this$getSessio10.data.session;
              sessionError = _yield$this$getSessio10.error;
              if (!sessionError) {
                _context29.next = 7;
                break;
              }
              return _context29.abrupt("return", {
                data: null,
                error: sessionError
              });
            case 7:
              if (session) {
                _context29.next = 9;
                break;
              }
              return _context29.abrupt("return", {
                data: {
                  currentLevel: null,
                  nextLevel: null,
                  currentAuthenticationMethods: []
                },
                error: null
              });
            case 9:
              payload = this._decodeJWT(session.access_token);
              currentLevel = null;
              if (payload.aal) {
                currentLevel = payload.aal;
              }
              nextLevel = currentLevel;
              verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(function (factor) {
                return factor.status === 'verified';
              })) !== null && _b !== void 0 ? _b : [];
              if (verifiedFactors.length > 0) {
                nextLevel = 'aal2';
              }
              currentAuthenticationMethods = payload.amr || [];
              return _context29.abrupt("return", {
                data: {
                  currentLevel: currentLevel,
                  nextLevel: nextLevel,
                  currentAuthenticationMethods: currentAuthenticationMethods
                },
                error: null
              });
            case 17:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));
    }
  }]);
  return GoTrueClient;
}();
exports["default"] = GoTrueClient;

},{"./GoTrueAdminApi":7,"./lib/constants":10,"./lib/errors":11,"./lib/fetch":12,"./lib/helpers":13,"./lib/local-storage":14,"./lib/polyfills":15}],9:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GoTrueClient = exports.GoTrueAdminApi = void 0;
var GoTrueAdminApi_1 = __importDefault(require("./GoTrueAdminApi"));
exports.GoTrueAdminApi = GoTrueAdminApi_1["default"];
var GoTrueClient_1 = __importDefault(require("./GoTrueClient"));
exports.GoTrueClient = GoTrueClient_1["default"];
__exportStar(require("./lib/types"), exports);
__exportStar(require("./lib/errors"), exports);

},{"./GoTrueAdminApi":7,"./GoTrueClient":8,"./lib/errors":11,"./lib/types":16}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NETWORK_FAILURE = exports.EXPIRY_MARGIN = exports.DEFAULT_HEADERS = exports.AUDIENCE = exports.STORAGE_KEY = exports.GOTRUE_URL = void 0;
var version_1 = require("./version");
exports.GOTRUE_URL = 'http://localhost:9999';
exports.STORAGE_KEY = 'supabase.auth.token';
exports.AUDIENCE = '';
exports.DEFAULT_HEADERS = {
  'X-Client-Info': "gotrue-js/".concat(version_1.version)
};
exports.EXPIRY_MARGIN = 10; // in seconds
exports.NETWORK_FAILURE = {
  MAX_RETRIES: 10,
  RETRY_INTERVAL: 2 // in deciseconds
};

},{"./version":17}],11:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AuthRetryableFetchError = exports.AuthImplicitGrantRedirectError = exports.AuthInvalidCredentialsError = exports.AuthSessionMissingError = exports.CustomAuthError = exports.AuthUnknownError = exports.isAuthApiError = exports.AuthApiError = exports.isAuthError = exports.AuthError = void 0;
var AuthError = /*#__PURE__*/function (_Error) {
  _inherits(AuthError, _Error);
  var _super = _createSuper(AuthError);
  function AuthError(message) {
    var _this;
    _classCallCheck(this, AuthError);
    _this = _super.call(this, message);
    _this.__isAuthError = true;
    _this.name = 'AuthError';
    return _this;
  }
  return _createClass(AuthError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.AuthError = AuthError;
function isAuthError(error) {
  return _typeof(error) === 'object' && error !== null && '__isAuthError' in error;
}
exports.isAuthError = isAuthError;
var AuthApiError = /*#__PURE__*/function (_AuthError) {
  _inherits(AuthApiError, _AuthError);
  var _super2 = _createSuper(AuthApiError);
  function AuthApiError(message, status) {
    var _this2;
    _classCallCheck(this, AuthApiError);
    _this2 = _super2.call(this, message);
    _this2.name = 'AuthApiError';
    _this2.status = status;
    return _this2;
  }
  _createClass(AuthApiError, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status
      };
    }
  }]);
  return AuthApiError;
}(AuthError);
exports.AuthApiError = AuthApiError;
function isAuthApiError(error) {
  return isAuthError(error) && error.name === 'AuthApiError';
}
exports.isAuthApiError = isAuthApiError;
var AuthUnknownError = /*#__PURE__*/function (_AuthError2) {
  _inherits(AuthUnknownError, _AuthError2);
  var _super3 = _createSuper(AuthUnknownError);
  function AuthUnknownError(message, originalError) {
    var _this3;
    _classCallCheck(this, AuthUnknownError);
    _this3 = _super3.call(this, message);
    _this3.name = 'AuthUnknownError';
    _this3.originalError = originalError;
    return _this3;
  }
  return _createClass(AuthUnknownError);
}(AuthError);
exports.AuthUnknownError = AuthUnknownError;
var CustomAuthError = /*#__PURE__*/function (_AuthError3) {
  _inherits(CustomAuthError, _AuthError3);
  var _super4 = _createSuper(CustomAuthError);
  function CustomAuthError(message, name, status) {
    var _this4;
    _classCallCheck(this, CustomAuthError);
    _this4 = _super4.call(this, message);
    _this4.name = name;
    _this4.status = status;
    return _this4;
  }
  _createClass(CustomAuthError, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status
      };
    }
  }]);
  return CustomAuthError;
}(AuthError);
exports.CustomAuthError = CustomAuthError;
var AuthSessionMissingError = /*#__PURE__*/function (_CustomAuthError) {
  _inherits(AuthSessionMissingError, _CustomAuthError);
  var _super5 = _createSuper(AuthSessionMissingError);
  function AuthSessionMissingError() {
    _classCallCheck(this, AuthSessionMissingError);
    return _super5.call(this, 'Auth session missing!', 'AuthSessionMissingError', 400);
  }
  return _createClass(AuthSessionMissingError);
}(CustomAuthError);
exports.AuthSessionMissingError = AuthSessionMissingError;
var AuthInvalidCredentialsError = /*#__PURE__*/function (_CustomAuthError2) {
  _inherits(AuthInvalidCredentialsError, _CustomAuthError2);
  var _super6 = _createSuper(AuthInvalidCredentialsError);
  function AuthInvalidCredentialsError(message) {
    _classCallCheck(this, AuthInvalidCredentialsError);
    return _super6.call(this, message, 'AuthInvalidCredentialsError', 400);
  }
  return _createClass(AuthInvalidCredentialsError);
}(CustomAuthError);
exports.AuthInvalidCredentialsError = AuthInvalidCredentialsError;
var AuthImplicitGrantRedirectError = /*#__PURE__*/function (_CustomAuthError3) {
  _inherits(AuthImplicitGrantRedirectError, _CustomAuthError3);
  var _super7 = _createSuper(AuthImplicitGrantRedirectError);
  function AuthImplicitGrantRedirectError(message) {
    var _this5;
    var details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, AuthImplicitGrantRedirectError);
    _this5 = _super7.call(this, message, 'AuthImplicitGrantRedirectError', 500);
    _this5.details = null;
    _this5.details = details;
    return _this5;
  }
  _createClass(AuthImplicitGrantRedirectError, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        details: this.details
      };
    }
  }]);
  return AuthImplicitGrantRedirectError;
}(CustomAuthError);
exports.AuthImplicitGrantRedirectError = AuthImplicitGrantRedirectError;
var AuthRetryableFetchError = /*#__PURE__*/function (_CustomAuthError4) {
  _inherits(AuthRetryableFetchError, _CustomAuthError4);
  var _super8 = _createSuper(AuthRetryableFetchError);
  function AuthRetryableFetchError(message, status) {
    _classCallCheck(this, AuthRetryableFetchError);
    return _super8.call(this, message, 'AuthRetryableFetchError', status);
  }
  return _createClass(AuthRetryableFetchError);
}(CustomAuthError);
exports.AuthRetryableFetchError = AuthRetryableFetchError;

},{}],12:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._noResolveJsonResponse = exports._generateLinkResponse = exports._ssoResponse = exports._userResponse = exports._sessionResponse = exports._request = void 0;
var helpers_1 = require("./helpers");
var errors_1 = require("./errors");
var _getErrorMessage = function _getErrorMessage(err) {
  return err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
};
var handleError = function handleError(error, reject) {
  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var NETWORK_ERROR_CODES;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          NETWORK_ERROR_CODES = [502, 503, 504];
          if (!(0, helpers_1.looksLikeFetchResponse)(error)) {
            reject(new errors_1.AuthRetryableFetchError(_getErrorMessage(error), 0));
          } else if (NETWORK_ERROR_CODES.includes(error.status)) {
            // status in 500...599 range - server had an error, request might be retryed.
            reject(new errors_1.AuthRetryableFetchError(_getErrorMessage(error), error.status));
          } else {
            // got a response from server that is not in the 500...599 range - should not retry
            error.json().then(function (err) {
              reject(new errors_1.AuthApiError(_getErrorMessage(err), error.status || 500));
            })["catch"](function (e) {
              // not a valid json response
              reject(new errors_1.AuthUnknownError(_getErrorMessage(e), e));
            });
          }
        case 2:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
};
var _getRequestParams = function _getRequestParams(method, options, parameters, body) {
  var params = {
    method: method,
    headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
  };
  if (method === 'GET') {
    return params;
  }
  params.headers = Object.assign({
    'Content-Type': 'application/json;charset=UTF-8'
  }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
function _request(fetcher, method, url, options) {
  var _a;
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var headers, qs, queryString, data;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
          if (options === null || options === void 0 ? void 0 : options.jwt) {
            headers['Authorization'] = "Bearer ".concat(options.jwt);
          }
          qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};
          if (options === null || options === void 0 ? void 0 : options.redirectTo) {
            qs['redirect_to'] = options.redirectTo;
          }
          queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';
          _context2.next = 7;
          return _handleRequest(fetcher, method, url + queryString, {
            headers: headers,
            noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
          }, {}, options === null || options === void 0 ? void 0 : options.body);
        case 7:
          data = _context2.sent;
          return _context2.abrupt("return", (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {
            data: Object.assign({}, data),
            error: null
          });
        case 9:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
}
exports._request = _request;
function _handleRequest(fetcher, method, url, options, parameters, body) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          return _context3.abrupt("return", new Promise(function (resolve, reject) {
            fetcher(url, _getRequestParams(method, options, parameters, body)).then(function (result) {
              if (!result.ok) throw result;
              if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
              return result.json();
            }).then(function (data) {
              return resolve(data);
            })["catch"](function (error) {
              return handleError(error, reject);
            });
          }));
        case 1:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
}
function _sessionResponse(data) {
  var _a;
  var session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);
  }
  var user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return {
    data: {
      session: session,
      user: user
    },
    error: null
  };
}
exports._sessionResponse = _sessionResponse;
function _userResponse(data) {
  var _a;
  var user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return {
    data: {
      user: user
    },
    error: null
  };
}
exports._userResponse = _userResponse;
function _ssoResponse(data) {
  return {
    data: data,
    error: null
  };
}
exports._ssoResponse = _ssoResponse;
function _generateLinkResponse(data) {
  var action_link = data.action_link,
    email_otp = data.email_otp,
    hashed_token = data.hashed_token,
    redirect_to = data.redirect_to,
    verification_type = data.verification_type,
    rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  var properties = {
    action_link: action_link,
    email_otp: email_otp,
    hashed_token: hashed_token,
    redirect_to: redirect_to,
    verification_type: verification_type
  };
  var user = Object.assign({}, rest);
  return {
    data: {
      properties: properties,
      user: user
    },
    error: null
  };
}
exports._generateLinkResponse = _generateLinkResponse;
function _noResolveJsonResponse(data) {
  return data;
}
exports._noResolveJsonResponse = _noResolveJsonResponse;
/**
 * hasSession checks if the response object contains a valid session
 * @param data A response object
 * @returns true if a session is in the response
 */
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}

},{"./errors":11,"./helpers":13}],13:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeJWTPayload = exports.Deferred = exports.decodeBase64URL = exports.removeItemAsync = exports.getItemAsync = exports.setItemAsync = exports.looksLikeFetchResponse = exports.resolveFetch = exports.getParameterByName = exports.isBrowser = exports.uuid = exports.expiresAt = void 0;
function expiresAt(expiresIn) {
  var timeNow = Math.round(Date.now() / 1000);
  return timeNow + expiresIn;
}
exports.expiresAt = expiresAt;
function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
      v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
exports.uuid = uuid;
var isBrowser = function isBrowser() {
  return typeof document !== 'undefined';
};
exports.isBrowser = isBrowser;
function getParameterByName(name, url) {
  var _a;
  if (!url) url = ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.href) || '';
  // eslint-disable-next-line no-useless-escape
  name = name.replace(/[\[\]]/g, '\\$&');
  var regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),
    results = regex.exec(url);
  if (!results) return null;
  if (!results[2]) return '';
  return decodeURIComponent(results[2].replace(/\+/g, ' '));
}
exports.getParameterByName = getParameterByName;
var resolveFetch = function resolveFetch(customFetch) {
  var _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = function _fetch() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _yield$Promise$resolv;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return Promise.resolve().then(function () {
                return __importStar(require('cross-fetch'));
              });
            case 2:
              _context.next = 4;
              return (_yield$Promise$resolv = _context.sent).fetch.apply(_yield$Promise$resolv, args);
            case 4:
              return _context.abrupt("return", _context.sent);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
    };
  } else {
    _fetch = fetch;
  }
  return function () {
    return _fetch.apply(void 0, arguments);
  };
};
exports.resolveFetch = resolveFetch;
var looksLikeFetchResponse = function looksLikeFetchResponse(maybeResponse) {
  return _typeof(maybeResponse) === 'object' && maybeResponse !== null && 'status' in maybeResponse && 'ok' in maybeResponse && 'json' in maybeResponse && typeof maybeResponse.json === 'function';
};
exports.looksLikeFetchResponse = looksLikeFetchResponse;
// Storage helpers
var setItemAsync = function setItemAsync(storage, key, data) {
  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return storage.setItem(key, JSON.stringify(data));
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
};
exports.setItemAsync = setItemAsync;
var getItemAsync = function getItemAsync(storage, key) {
  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var value;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return storage.getItem(key);
        case 2:
          value = _context3.sent;
          if (value) {
            _context3.next = 5;
            break;
          }
          return _context3.abrupt("return", null);
        case 5:
          _context3.prev = 5;
          return _context3.abrupt("return", JSON.parse(value));
        case 9:
          _context3.prev = 9;
          _context3.t0 = _context3["catch"](5);
          return _context3.abrupt("return", value);
        case 12:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[5, 9]]);
  }));
};
exports.getItemAsync = getItemAsync;
var removeItemAsync = function removeItemAsync(storage, key) {
  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return storage.removeItem(key);
        case 2:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
};
exports.removeItemAsync = removeItemAsync;
var decodeBase64URL = function decodeBase64URL(value) {
  try {
    // atob is present in all browsers and nodejs >= 16
    // but if it is not it will throw a ReferenceError in which case we can try to use Buffer
    // replace are here to convert the Base64-URL into Base64 which is what atob supports
    // replace with //g regex acts like replaceAll
    // Decoding base64 to UTF8 see https://stackoverflow.com/a/30106551/17622044
    return decodeURIComponent(atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/')).split('').map(function (c) {
      return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
  } catch (e) {
    if (e instanceof ReferenceError) {
      // running on nodejs < 16
      // Buffer supports Base64-URL transparently
      return Buffer.from(value, 'base64').toString('utf-8');
    } else {
      throw e;
    }
  }
};
exports.decodeBase64URL = decodeBase64URL;
/**
 * A deferred represents some asynchronous work that is not yet finished, which
 * may or may not culminate in a value.
 * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts
 */
var Deferred = /*#__PURE__*/_createClass(function Deferred() {
  var _this = this;
  _classCallCheck(this, Deferred);
  // eslint-disable-next-line @typescript-eslint/no-extra-semi
  ;
  this.promise = new Deferred.promiseConstructor(function (res, rej) {
    // eslint-disable-next-line @typescript-eslint/no-extra-semi
    ;
    _this.resolve = res;
    _this.reject = rej;
  });
});
exports.Deferred = Deferred;
Deferred.promiseConstructor = Promise;
// Taken from: https://stackoverflow.com/questions/38552003/how-to-decode-jwt-token-in-javascript-without-using-a-library
function decodeJWTPayload(token) {
  // Regex checks for base64url format
  var base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;
  var parts = token.split('.');
  if (parts.length !== 3) {
    throw new Error('JWT is not valid: not a JWT structure');
  }
  if (!base64UrlRegex.test(parts[1])) {
    throw new Error('JWT is not valid: payload is not in base64url format');
  }
  var base64Url = parts[1];
  return JSON.parse((0, exports.decodeBase64URL)(base64Url));
}
exports.decodeJWTPayload = decodeJWTPayload;

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":54,"cross-fetch":59}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var helpers_1 = require("./helpers");
var localStorageAdapter = {
  getItem: function getItem(key) {
    if (!(0, helpers_1.isBrowser)()) {
      return null;
    }
    return globalThis.localStorage.getItem(key);
  },
  setItem: function setItem(key, value) {
    if (!(0, helpers_1.isBrowser)()) {
      return;
    }
    globalThis.localStorage.setItem(key, value);
  },
  removeItem: function removeItem(key) {
    if (!(0, helpers_1.isBrowser)()) {
      return;
    }
    globalThis.localStorage.removeItem(key);
  }
};
exports["default"] = localStorageAdapter;

},{"./helpers":13}],15:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyfillGlobalThis = void 0;
/**
 * https://mathiasbynens.be/notes/globalthis
 */
function polyfillGlobalThis() {
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object') return;
  try {
    Object.defineProperty(Object.prototype, '__magic__', {
      get: function get() {
        return this;
      },
      configurable: true
    });
    // @ts-expect-error 'Allow access to magic'
    __magic__.globalThis = __magic__;
    // @ts-expect-error 'Allow access to magic'
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== 'undefined') {
      // @ts-expect-error 'Allow access to globals'
      self.globalThis = self;
    }
  }
}
exports.polyfillGlobalThis = polyfillGlobalThis;

},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
// Generated by genversion.
exports.version = '2.6.1';

},{}],18:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var cross_fetch_1 = __importDefault(require("cross-fetch"));
var PostgrestBuilder = /*#__PURE__*/function () {
  function PostgrestBuilder(builder) {
    _classCallCheck(this, PostgrestBuilder);
    this.shouldThrowOnError = false;
    this.method = builder.method;
    this.url = builder.url;
    this.headers = builder.headers;
    this.schema = builder.schema;
    this.body = builder.body;
    this.shouldThrowOnError = builder.shouldThrowOnError;
    this.signal = builder.signal;
    this.allowEmpty = builder.allowEmpty;
    if (builder.fetch) {
      this.fetch = builder.fetch;
    } else if (typeof fetch === 'undefined') {
      this.fetch = cross_fetch_1["default"];
    } else {
      this.fetch = fetch;
    }
  }
  /**
   * If there's an error with the query, throwOnError will reject the promise by
   * throwing the error instead of returning it as part of a successful response.
   *
   * {@link https://github.com/supabase/supabase-js/issues/92}
   */
  _createClass(PostgrestBuilder, [{
    key: "throwOnError",
    value: function throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
  }, {
    key: "then",
    value: function then(onfulfilled, onrejected) {
      var _this = this;
      // https://postgrest.org/en/stable/api.html#switching-schemas
      if (this.schema === undefined) {
        // skip
      } else if (['GET', 'HEAD'].includes(this.method)) {
        this.headers['Accept-Profile'] = this.schema;
      } else {
        this.headers['Content-Profile'] = this.schema;
      }
      if (this.method !== 'GET' && this.method !== 'HEAD') {
        this.headers['Content-Type'] = 'application/json';
      }
      // NOTE: Invoke w/o `this` to avoid illegal invocation error.
      // https://github.com/supabase/postgrest-js/pull/247
      var _fetch = this.fetch;
      var res = _fetch(this.url.toString(), {
        method: this.method,
        headers: this.headers,
        body: JSON.stringify(this.body),
        signal: this.signal
      }).then(function (res) {
        return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var _a, _b, _c, error, data, count, status, statusText, body, countHeader, contentRange, _body, postgrestResponse;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                error = null;
                data = null;
                count = null;
                status = res.status;
                statusText = res.statusText;
                if (!res.ok) {
                  _context.next = 16;
                  break;
                }
                if (!(this.method !== 'HEAD')) {
                  _context.next = 11;
                  break;
                }
                _context.next = 9;
                return res.text();
              case 9:
                body = _context.sent;
                if (body === '') {
                  // Prefer: return=minimal
                } else if (this.headers['Accept'] === 'text/csv') {
                  data = body;
                } else if (this.headers['Accept'] && this.headers['Accept'].includes('application/vnd.pgrst.plan+text')) {
                  data = body;
                } else {
                  data = JSON.parse(body);
                }
              case 11:
                countHeader = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.match(/count=(exact|planned|estimated)/);
                contentRange = (_b = res.headers.get('content-range')) === null || _b === void 0 ? void 0 : _b.split('/');
                if (countHeader && contentRange && contentRange.length > 1) {
                  count = parseInt(contentRange[1]);
                }
                _context.next = 23;
                break;
              case 16:
                _context.next = 18;
                return res.text();
              case 18:
                _body = _context.sent;
                try {
                  error = JSON.parse(_body);
                  // Workaround for https://github.com/supabase/postgrest-js/issues/295
                  if (Array.isArray(error) && res.status === 404) {
                    data = [];
                    error = null;
                    status = 200;
                    statusText = 'OK';
                  }
                } catch (_d) {
                  // Workaround for https://github.com/supabase/postgrest-js/issues/295
                  if (res.status === 404 && _body === '') {
                    status = 204;
                    statusText = 'No Content';
                  } else {
                    error = {
                      message: _body
                    };
                  }
                }
                if (error && this.allowEmpty && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes('Results contain 0 rows'))) {
                  error = null;
                  status = 200;
                  statusText = 'OK';
                }
                if (!(error && this.shouldThrowOnError)) {
                  _context.next = 23;
                  break;
                }
                throw error;
              case 23:
                postgrestResponse = {
                  error: error,
                  data: data,
                  count: count,
                  status: status,
                  statusText: statusText
                };
                return _context.abrupt("return", postgrestResponse);
              case 25:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
      });
      if (!this.shouldThrowOnError) {
        res = res["catch"](function (fetchError) {
          return {
            error: {
              message: "FetchError: ".concat(fetchError.message),
              details: '',
              hint: '',
              code: fetchError.code || ''
            },
            data: null,
            count: null,
            status: 0,
            statusText: ''
          };
        });
      }
      return res.then(onfulfilled, onrejected);
    }
  }]);
  return PostgrestBuilder;
}();
exports["default"] = PostgrestBuilder;

},{"cross-fetch":59}],19:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var PostgrestQueryBuilder_1 = __importDefault(require("./PostgrestQueryBuilder"));
var PostgrestFilterBuilder_1 = __importDefault(require("./PostgrestFilterBuilder"));
var constants_1 = require("./constants");
/**
 * PostgREST client.
 *
 * @typeParam Database - Types for the schema from the [type
 * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)
 *
 * @typeParam SchemaName - Postgres schema to switch to. Must be a string
 * literal, the same one passed to the constructor. If the schema is not
 * `"public"`, this must be supplied manually.
 */
var PostgrestClient = /*#__PURE__*/function () {
  // TODO: Add back shouldThrowOnError once we figure out the typings
  /**
   * Creates a PostgREST client.
   *
   * @param url - URL of the PostgREST endpoint
   * @param options - Named parameters
   * @param options.headers - Custom headers
   * @param options.schema - Postgres schema to switch to
   * @param options.fetch - Custom fetch
   */
  function PostgrestClient(url) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      schema = _ref.schema,
      fetch = _ref.fetch;
    _classCallCheck(this, PostgrestClient);
    this.url = url;
    this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
    this.schema = schema;
    this.fetch = fetch;
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  _createClass(PostgrestClient, [{
    key: "from",
    value: function from(relation) {
      var url = new URL("".concat(this.url, "/").concat(relation));
      return new PostgrestQueryBuilder_1["default"](url, {
        headers: Object.assign({}, this.headers),
        schema: this.schema,
        fetch: this.fetch
      });
    }
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
  }, {
    key: "rpc",
    value: function rpc(fn) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref2$head = _ref2.head,
        head = _ref2$head === void 0 ? false : _ref2$head,
        count = _ref2.count;
      var method;
      var url = new URL("".concat(this.url, "/rpc/").concat(fn));
      var body;
      if (head) {
        method = 'HEAD';
        Object.entries(args).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
            name = _ref4[0],
            value = _ref4[1];
          url.searchParams.append(name, "".concat(value));
        });
      } else {
        method = 'POST';
        body = args;
      }
      var headers = Object.assign({}, this.headers);
      if (count) {
        headers['Prefer'] = "count=".concat(count);
      }
      return new PostgrestFilterBuilder_1["default"]({
        method: method,
        url: url,
        headers: headers,
        schema: this.schema,
        body: body,
        fetch: this.fetch,
        allowEmpty: false
      });
    }
  }]);
  return PostgrestClient;
}();
exports["default"] = PostgrestClient;

},{"./PostgrestFilterBuilder":20,"./PostgrestQueryBuilder":21,"./constants":23}],20:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var PostgrestTransformBuilder_1 = __importDefault(require("./PostgrestTransformBuilder"));
var PostgrestFilterBuilder = /*#__PURE__*/function (_PostgrestTransformBu) {
  _inherits(PostgrestFilterBuilder, _PostgrestTransformBu);
  var _super = _createSuper(PostgrestFilterBuilder);
  function PostgrestFilterBuilder() {
    _classCallCheck(this, PostgrestFilterBuilder);
    return _super.apply(this, arguments);
  }
  _createClass(PostgrestFilterBuilder, [{
    key: "eq",
    value:
    /**
     * Match only rows where `column` is equal to `value`.
     *
     * To check if the value of `column` is NULL, you should use `.is()` instead.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    function eq(column, value) {
      this.url.searchParams.append(column, "eq.".concat(value));
      return this;
    }
    /**
     * Match only rows where `column` is not equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
  }, {
    key: "neq",
    value: function neq(column, value) {
      this.url.searchParams.append(column, "neq.".concat(value));
      return this;
    }
    /**
     * Match only rows where `column` is greater than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
  }, {
    key: "gt",
    value: function gt(column, value) {
      this.url.searchParams.append(column, "gt.".concat(value));
      return this;
    }
    /**
     * Match only rows where `column` is greater than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
  }, {
    key: "gte",
    value: function gte(column, value) {
      this.url.searchParams.append(column, "gte.".concat(value));
      return this;
    }
    /**
     * Match only rows where `column` is less than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
  }, {
    key: "lt",
    value: function lt(column, value) {
      this.url.searchParams.append(column, "lt.".concat(value));
      return this;
    }
    /**
     * Match only rows where `column` is less than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
  }, {
    key: "lte",
    value: function lte(column, value) {
      this.url.searchParams.append(column, "lte.".concat(value));
      return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-sensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
  }, {
    key: "like",
    value: function like(column, pattern) {
      this.url.searchParams.append(column, "like.".concat(pattern));
      return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-insensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
  }, {
    key: "ilike",
    value: function ilike(column, pattern) {
      this.url.searchParams.append(column, "ilike.".concat(pattern));
      return this;
    }
    /**
     * Match only rows where `column` IS `value`.
     *
     * For non-boolean columns, this is only relevant for checking if the value of
     * `column` is NULL by setting `value` to `null`.
     *
     * For boolean columns, you can also set `value` to `true` or `false` and it
     * will behave the same way as `.eq()`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
  }, {
    key: "is",
    value: function is(column, value) {
      this.url.searchParams.append(column, "is.".concat(value));
      return this;
    }
    /**
     * Match only rows where `column` is included in the `values` array.
     *
     * @param column - The column to filter on
     * @param values - The values array to filter with
     */
  }, {
    key: "in",
    value: function _in(column, values) {
      var cleanedValues = values.map(function (s) {
        // handle postgrest reserved characters
        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters
        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return "\"".concat(s, "\"");else return "".concat(s);
      }).join(',');
      this.url.searchParams.append(column, "in.(".concat(cleanedValues, ")"));
      return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * `column` contains every element appearing in `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
  }, {
    key: "contains",
    value: function contains(column, value) {
      if (typeof value === 'string') {
        // range types can be inclusive '[', ']' or exclusive '(', ')' so just
        // keep it simple and accept a string
        this.url.searchParams.append(column, "cs.".concat(value));
      } else if (Array.isArray(value)) {
        // array
        this.url.searchParams.append(column, "cs.{".concat(value.join(','), "}"));
      } else {
        // json
        this.url.searchParams.append(column, "cs.".concat(JSON.stringify(value)));
      }
      return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * every element appearing in `column` is contained by `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
  }, {
    key: "containedBy",
    value: function containedBy(column, value) {
      if (typeof value === 'string') {
        // range
        this.url.searchParams.append(column, "cd.".concat(value));
      } else if (Array.isArray(value)) {
        // array
        this.url.searchParams.append(column, "cd.{".concat(value.join(','), "}"));
      } else {
        // json
        this.url.searchParams.append(column, "cd.".concat(JSON.stringify(value)));
      }
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is greater than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
  }, {
    key: "rangeGt",
    value: function rangeGt(column, range) {
      this.url.searchParams.append(column, "sr.".concat(range));
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or greater than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
  }, {
    key: "rangeGte",
    value: function rangeGte(column, range) {
      this.url.searchParams.append(column, "nxl.".concat(range));
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is less than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
  }, {
    key: "rangeLt",
    value: function rangeLt(column, range) {
      this.url.searchParams.append(column, "sl.".concat(range));
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or less than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
  }, {
    key: "rangeLte",
    value: function rangeLte(column, range) {
      this.url.searchParams.append(column, "nxr.".concat(range));
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where `column` is
     * mutually exclusive to `range` and there can be no element between the two
     * ranges.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
  }, {
    key: "rangeAdjacent",
    value: function rangeAdjacent(column, range) {
      this.url.searchParams.append(column, "adj.".concat(range));
      return this;
    }
    /**
     * Only relevant for array and range columns. Match only rows where
     * `column` and `value` have an element in common.
     *
     * @param column - The array or range column to filter on
     * @param value - The array or range value to filter with
     */
  }, {
    key: "overlaps",
    value: function overlaps(column, value) {
      if (typeof value === 'string') {
        // range
        this.url.searchParams.append(column, "ov.".concat(value));
      } else {
        // array
        this.url.searchParams.append(column, "ov.{".concat(value.join(','), "}"));
      }
      return this;
    }
    /**
     * Only relevant for text and tsvector columns. Match only rows where
     * `column` matches the query string in `query`.
     *
     * @param column - The text or tsvector column to filter on
     * @param query - The query text to match with
     * @param options - Named parameters
     * @param options.config - The text search configuration to use
     * @param options.type - Change how the `query` text is interpreted
     */
  }, {
    key: "textSearch",
    value: function textSearch(column, query) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        config = _ref.config,
        type = _ref.type;
      var typePart = '';
      if (type === 'plain') {
        typePart = 'pl';
      } else if (type === 'phrase') {
        typePart = 'ph';
      } else if (type === 'websearch') {
        typePart = 'w';
      }
      var configPart = config === undefined ? '' : "(".concat(config, ")");
      this.url.searchParams.append(column, "".concat(typePart, "fts").concat(configPart, ".").concat(query));
      return this;
    }
    /**
     * Match only rows where each column in `query` keys is equal to its
     * associated value. Shorthand for multiple `.eq()`s.
     *
     * @param query - The object to filter with, with column names as keys mapped
     * to their filter values
     */
  }, {
    key: "match",
    value: function match(query) {
      var _this = this;
      Object.entries(query).forEach(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
          column = _ref3[0],
          value = _ref3[1];
        _this.url.searchParams.append(column, "eq.".concat(value));
      });
      return this;
    }
    /**
     * Match only rows which doesn't satisfy the filter.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to be negated to filter with, following
     * PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
  }, {
    key: "not",
    value: function not(column, operator, value) {
      this.url.searchParams.append(column, "not.".concat(operator, ".").concat(value));
      return this;
    }
    /**
     * Match only rows which satisfy at least one of the filters.
     *
     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure it's properly sanitized.
     *
     * It's currently not possible to do an `.or()` filter across multiple tables.
     *
     * @param filters - The filters to use, following PostgREST syntax
     * @param foreignTable - Set this to filter on foreign tables instead of the
     * current table
     */
  }, {
    key: "or",
    value: function or(filters) {
      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        foreignTable = _ref4.foreignTable;
      var key = foreignTable ? "".concat(foreignTable, ".or") : 'or';
      this.url.searchParams.append(key, "(".concat(filters, ")"));
      return this;
    }
    /**
     * Match only rows which satisfy the filter. This is an escape hatch - you
     * should use the specific filter methods wherever possible.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to filter with, following PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
  }, {
    key: "filter",
    value: function filter(column, operator, value) {
      this.url.searchParams.append(column, "".concat(operator, ".").concat(value));
      return this;
    }
  }]);
  return PostgrestFilterBuilder;
}(PostgrestTransformBuilder_1["default"]);
exports["default"] = PostgrestFilterBuilder;

},{"./PostgrestTransformBuilder":22}],21:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var PostgrestFilterBuilder_1 = __importDefault(require("./PostgrestFilterBuilder"));
var PostgrestQueryBuilder = /*#__PURE__*/function () {
  function PostgrestQueryBuilder(url, _ref) {
    var _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      schema = _ref.schema,
      fetch = _ref.fetch;
    _classCallCheck(this, PostgrestQueryBuilder);
    this.url = url;
    this.headers = headers;
    this.schema = schema;
    this.fetch = fetch;
  }
  /**
   * Perform a SELECT query on the table or view.
   *
   * @param columns - The columns to retrieve, separated by commas
   *
   * @param options - Named parameters
   *
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   *
   * @param options.count - Count algorithm to use to count rows in the table or view.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  _createClass(PostgrestQueryBuilder, [{
    key: "select",
    value: function select(columns) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$head = _ref2.head,
        head = _ref2$head === void 0 ? false : _ref2$head,
        count = _ref2.count;
      var method = head ? 'HEAD' : 'GET';
      // Remove whitespaces except when quoted
      var quoted = false;
      var cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(function (c) {
        if (/\s/.test(c) && !quoted) {
          return '';
        }
        if (c === '"') {
          quoted = !quoted;
        }
        return c;
      }).join('');
      this.url.searchParams.set('select', cleanedColumns);
      if (count) {
        this.headers['Prefer'] = "count=".concat(count);
      }
      return new PostgrestFilterBuilder_1["default"]({
        method: method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch,
        allowEmpty: false
      });
    }
    /**
     * Perform an INSERT into the table or view.
     *
     * By default, inserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to insert. Pass an object to insert a single row
     * or an array to insert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count inserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
  }, {
    key: "insert",
    value: function insert(values) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        count = _ref3.count;
      var method = 'POST';
      var prefersHeaders = [];
      var body = values;
      if (count) {
        prefersHeaders.push("count=".concat(count));
      }
      if (this.headers['Prefer']) {
        prefersHeaders.unshift(this.headers['Prefer']);
      }
      this.headers['Prefer'] = prefersHeaders.join(',');
      if (Array.isArray(values)) {
        var columns = values.reduce(function (acc, x) {
          return acc.concat(Object.keys(x));
        }, []);
        if (columns.length > 0) {
          var uniqueColumns = _toConsumableArray(new Set(columns)).map(function (column) {
            return "\"".concat(column, "\"");
          });
          this.url.searchParams.set('columns', uniqueColumns.join(','));
        }
      }
      return new PostgrestFilterBuilder_1["default"]({
        method: method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: body,
        fetch: this.fetch,
        allowEmpty: false
      });
    }
    /**
     * Perform an UPSERT on the table or view. Depending on the column(s) passed
     * to `onConflict`, `.upsert()` allows you to perform the equivalent of
     * `.insert()` if a row with the corresponding `onConflict` columns doesn't
     * exist, or if it does exist, perform an alternative action depending on
     * `ignoreDuplicates`.
     *
     * By default, upserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to upsert with. Pass an object to upsert a
     * single row or an array to upsert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
     * duplicate rows are determined. Two rows are duplicates if all the
     * `onConflict` columns are equal.
     *
     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
     * `false`, duplicate rows are merged with existing rows.
     *
     * @param options.count - Count algorithm to use to count upserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
  }, {
    key: "upsert",
    value: function upsert(values) {
      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        onConflict = _ref4.onConflict,
        _ref4$ignoreDuplicate = _ref4.ignoreDuplicates,
        ignoreDuplicates = _ref4$ignoreDuplicate === void 0 ? false : _ref4$ignoreDuplicate,
        count = _ref4.count;
      var method = 'POST';
      var prefersHeaders = ["resolution=".concat(ignoreDuplicates ? 'ignore' : 'merge', "-duplicates")];
      if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);
      var body = values;
      if (count) {
        prefersHeaders.push("count=".concat(count));
      }
      if (this.headers['Prefer']) {
        prefersHeaders.unshift(this.headers['Prefer']);
      }
      this.headers['Prefer'] = prefersHeaders.join(',');
      return new PostgrestFilterBuilder_1["default"]({
        method: method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: body,
        fetch: this.fetch,
        allowEmpty: false
      });
    }
    /**
     * Perform an UPDATE on the table or view.
     *
     * By default, updated rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param values - The values to update with
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count updated rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
  }, {
    key: "update",
    value: function update(values) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        count = _ref5.count;
      var method = 'PATCH';
      var prefersHeaders = [];
      var body = values;
      if (count) {
        prefersHeaders.push("count=".concat(count));
      }
      if (this.headers['Prefer']) {
        prefersHeaders.unshift(this.headers['Prefer']);
      }
      this.headers['Prefer'] = prefersHeaders.join(',');
      return new PostgrestFilterBuilder_1["default"]({
        method: method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: body,
        fetch: this.fetch,
        allowEmpty: false
      });
    }
    /**
     * Perform a DELETE on the table or view.
     *
     * By default, deleted rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count deleted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
  }, {
    key: "delete",
    value: function _delete() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        count = _ref6.count;
      var method = 'DELETE';
      var prefersHeaders = [];
      if (count) {
        prefersHeaders.push("count=".concat(count));
      }
      if (this.headers['Prefer']) {
        prefersHeaders.unshift(this.headers['Prefer']);
      }
      this.headers['Prefer'] = prefersHeaders.join(',');
      return new PostgrestFilterBuilder_1["default"]({
        method: method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch,
        allowEmpty: false
      });
    }
  }]);
  return PostgrestQueryBuilder;
}();
exports["default"] = PostgrestQueryBuilder;

},{"./PostgrestFilterBuilder":20}],22:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var PostgrestBuilder_1 = __importDefault(require("./PostgrestBuilder"));
var PostgrestTransformBuilder = /*#__PURE__*/function (_PostgrestBuilder_1$d) {
  _inherits(PostgrestTransformBuilder, _PostgrestBuilder_1$d);
  var _super = _createSuper(PostgrestTransformBuilder);
  function PostgrestTransformBuilder() {
    _classCallCheck(this, PostgrestTransformBuilder);
    return _super.apply(this, arguments);
  }
  _createClass(PostgrestTransformBuilder, [{
    key: "select",
    value:
    /**
     * Perform a SELECT on the query result.
     *
     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
     * return modified rows. By calling this method, modified rows are returned in
     * `data`.
     *
     * @param columns - The columns to retrieve, separated by commas
     */
    function select(columns) {
      // Remove whitespaces except when quoted
      var quoted = false;
      var cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(function (c) {
        if (/\s/.test(c) && !quoted) {
          return '';
        }
        if (c === '"') {
          quoted = !quoted;
        }
        return c;
      }).join('');
      this.url.searchParams.set('select', cleanedColumns);
      if (this.headers['Prefer']) {
        this.headers['Prefer'] += ',';
      }
      this.headers['Prefer'] += 'return=representation';
      return this;
    }
    /**
     * Order the query result by `column`.
     *
     * You can call this method multiple times to order by multiple columns.
     *
     * You can order foreign tables, but it doesn't affect the ordering of the
     * current table.
     *
     * @param column - The column to order by
     * @param options - Named parameters
     * @param options.ascending - If `true`, the result will be in ascending order
     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
     * `null`s appear last.
     * @param options.foreignTable - Set this to order a foreign table by foreign
     * columns
     */
  }, {
    key: "order",
    value: function order(column) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$ascending = _ref.ascending,
        ascending = _ref$ascending === void 0 ? true : _ref$ascending,
        nullsFirst = _ref.nullsFirst,
        foreignTable = _ref.foreignTable;
      var key = foreignTable ? "".concat(foreignTable, ".order") : 'order';
      var existingOrder = this.url.searchParams.get(key);
      this.url.searchParams.set(key, "".concat(existingOrder ? "".concat(existingOrder, ",") : '').concat(column, ".").concat(ascending ? 'asc' : 'desc').concat(nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'));
      return this;
    }
    /**
     * Limit the query result by `count`.
     *
     * @param count - The maximum number of rows to return
     * @param options - Named parameters
     * @param options.foreignTable - Set this to limit rows of foreign tables
     * instead of the current table
     */
  }, {
    key: "limit",
    value: function limit(count) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        foreignTable = _ref2.foreignTable;
      var key = typeof foreignTable === 'undefined' ? 'limit' : "".concat(foreignTable, ".limit");
      this.url.searchParams.set(key, "".concat(count));
      return this;
    }
    /**
     * Limit the query result by `from` and `to` inclusively.
     *
     * @param from - The starting index from which to limit the result
     * @param to - The last index to which to limit the result
     * @param options - Named parameters
     * @param options.foreignTable - Set this to limit rows of foreign tables
     * instead of the current table
     */
  }, {
    key: "range",
    value: function range(from, to) {
      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        foreignTable = _ref3.foreignTable;
      var keyOffset = typeof foreignTable === 'undefined' ? 'offset' : "".concat(foreignTable, ".offset");
      var keyLimit = typeof foreignTable === 'undefined' ? 'limit' : "".concat(foreignTable, ".limit");
      this.url.searchParams.set(keyOffset, "".concat(from));
      // Range is inclusive, so add 1
      this.url.searchParams.set(keyLimit, "".concat(to - from + 1));
      return this;
    }
    /**
     * Set the AbortSignal for the fetch request.
     *
     * @param signal - The AbortSignal to use for the fetch request
     */
  }, {
    key: "abortSignal",
    value: function abortSignal(signal) {
      this.signal = signal;
      return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be one row (e.g. using `.limit(1)`), otherwise this
     * returns an error.
     */
  }, {
    key: "single",
    value: function single() {
      this.headers['Accept'] = 'application/vnd.pgrst.object+json';
      return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
     * this returns an error.
     */
  }, {
    key: "maybeSingle",
    value: function maybeSingle() {
      this.headers['Accept'] = 'application/vnd.pgrst.object+json';
      this.allowEmpty = true;
      return this;
    }
    /**
     * Return `data` as a string in CSV format.
     */
  }, {
    key: "csv",
    value: function csv() {
      this.headers['Accept'] = 'text/csv';
      return this;
    }
    /**
     * Return `data` as an object in [GeoJSON](https://geojson.org) format.
     */
  }, {
    key: "geojson",
    value: function geojson() {
      this.headers['Accept'] = 'application/geo+json';
      return this;
    }
    /**
     * Return `data` as the EXPLAIN plan for the query.
     *
     * @param options - Named parameters
     *
     * @param options.analyze - If `true`, the query will be executed and the
     * actual run time will be returned
     *
     * @param options.verbose - If `true`, the query identifier will be returned
     * and `data` will include the output columns of the query
     *
     * @param options.settings - If `true`, include information on configuration
     * parameters that affect query planning
     *
     * @param options.buffers - If `true`, include information on buffer usage
     *
     * @param options.wal - If `true`, include information on WAL record generation
     *
     * @param options.format - The format of the output, can be `"text"` (default)
     * or `"json"`
     */
  }, {
    key: "explain",
    value: function explain() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$analyze = _ref4.analyze,
        analyze = _ref4$analyze === void 0 ? false : _ref4$analyze,
        _ref4$verbose = _ref4.verbose,
        verbose = _ref4$verbose === void 0 ? false : _ref4$verbose,
        _ref4$settings = _ref4.settings,
        settings = _ref4$settings === void 0 ? false : _ref4$settings,
        _ref4$buffers = _ref4.buffers,
        buffers = _ref4$buffers === void 0 ? false : _ref4$buffers,
        _ref4$wal = _ref4.wal,
        wal = _ref4$wal === void 0 ? false : _ref4$wal,
        _ref4$format = _ref4.format,
        format = _ref4$format === void 0 ? 'text' : _ref4$format;
      var options = [analyze ? 'analyze' : null, verbose ? 'verbose' : null, settings ? 'settings' : null, buffers ? 'buffers' : null, wal ? 'wal' : null].filter(Boolean).join('|');
      // An Accept header can carry multiple media types but postgrest-js always sends one
      var forMediatype = this.headers['Accept'];
      this.headers['Accept'] = "application/vnd.pgrst.plan+".concat(format, "; for=\"").concat(forMediatype, "\"; options=").concat(options, ";");
      if (format === 'json') return this;else return this;
    }
    /**
     * Rollback the query.
     *
     * `data` will still be returned, but the query is not committed.
     */
  }, {
    key: "rollback",
    value: function rollback() {
      var _a;
      if (((_a = this.headers['Prefer']) !== null && _a !== void 0 ? _a : '').trim().length > 0) {
        this.headers['Prefer'] += ',tx=rollback';
      } else {
        this.headers['Prefer'] = 'tx=rollback';
      }
      return this;
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     */
  }, {
    key: "returns",
    value: function returns() {
      return this;
    }
  }]);
  return PostgrestTransformBuilder;
}(PostgrestBuilder_1["default"]);
exports["default"] = PostgrestTransformBuilder;

},{"./PostgrestBuilder":18}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_HEADERS = void 0;
var version_1 = require("./version");
exports.DEFAULT_HEADERS = {
  'X-Client-Info': "postgrest-js/".concat(version_1.version)
};

},{"./version":25}],24:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;
var PostgrestClient_1 = require("./PostgrestClient");
Object.defineProperty(exports, "PostgrestClient", {
  enumerable: true,
  get: function get() {
    return __importDefault(PostgrestClient_1)["default"];
  }
});
var PostgrestQueryBuilder_1 = require("./PostgrestQueryBuilder");
Object.defineProperty(exports, "PostgrestQueryBuilder", {
  enumerable: true,
  get: function get() {
    return __importDefault(PostgrestQueryBuilder_1)["default"];
  }
});
var PostgrestFilterBuilder_1 = require("./PostgrestFilterBuilder");
Object.defineProperty(exports, "PostgrestFilterBuilder", {
  enumerable: true,
  get: function get() {
    return __importDefault(PostgrestFilterBuilder_1)["default"];
  }
});
var PostgrestTransformBuilder_1 = require("./PostgrestTransformBuilder");
Object.defineProperty(exports, "PostgrestTransformBuilder", {
  enumerable: true,
  get: function get() {
    return __importDefault(PostgrestTransformBuilder_1)["default"];
  }
});
var PostgrestBuilder_1 = require("./PostgrestBuilder");
Object.defineProperty(exports, "PostgrestBuilder", {
  enumerable: true,
  get: function get() {
    return __importDefault(PostgrestBuilder_1)["default"];
  }
});

},{"./PostgrestBuilder":18,"./PostgrestClient":19,"./PostgrestFilterBuilder":20,"./PostgrestQueryBuilder":21,"./PostgrestTransformBuilder":22}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = '1.1.1';

},{}],26:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_LISTEN_TYPES = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = void 0;
var constants_1 = require("./lib/constants");
var push_1 = __importDefault(require("./lib/push"));
var timer_1 = __importDefault(require("./lib/timer"));
var RealtimePresence_1 = __importDefault(require("./RealtimePresence"));
var Transformers = __importStar(require("./lib/transformers"));
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function (REALTIME_LISTEN_TYPES) {
  REALTIME_LISTEN_TYPES["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES["POSTGRES_CHANGES"] = "postgres_changes";
})(REALTIME_LISTEN_TYPES = exports.REALTIME_LISTEN_TYPES || (exports.REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function (REALTIME_SUBSCRIBE_STATES) {
  REALTIME_SUBSCRIBE_STATES["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES = exports.REALTIME_SUBSCRIBE_STATES || (exports.REALTIME_SUBSCRIBE_STATES = {}));
/** A channel is the basic building block of Realtime
 * and narrows the scope of data flow to subscribed clients.
 * You can think of a channel as a chatroom where participants are able to see who's online
 * and send and receive messages.
 **/
var RealtimeChannel = /*#__PURE__*/function () {
  function RealtimeChannel( /** Topic name can be any string. */
  topic) {
    var _this = this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      config: {}
    };
    var socket = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck(this, RealtimeChannel);
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = constants_1.CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.params.config = Object.assign({
      broadcast: {
        ack: false,
        self: false
      },
      presence: {
        key: ''
      }
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new push_1["default"](this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new timer_1["default"](function () {
      return _this._rejoinUntilConnected();
    }, this.socket.reconnectAfterMs);
    this.joinPush.receive('ok', function () {
      _this.state = constants_1.CHANNEL_STATES.joined;
      _this.rejoinTimer.reset();
      _this.pushBuffer.forEach(function (pushEvent) {
        return pushEvent.send();
      });
      _this.pushBuffer = [];
    });
    this._onClose(function () {
      _this.rejoinTimer.reset();
      _this.socket.log('channel', "close ".concat(_this.topic, " ").concat(_this._joinRef()));
      _this.state = constants_1.CHANNEL_STATES.closed;
      _this.socket._remove(_this);
    });
    this._onError(function (reason) {
      if (_this._isLeaving() || _this._isClosed()) {
        return;
      }
      _this.socket.log('channel', "error ".concat(_this.topic), reason);
      _this.state = constants_1.CHANNEL_STATES.errored;
      _this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive('timeout', function () {
      if (!_this._isJoining()) {
        return;
      }
      _this.socket.log('channel', "timeout ".concat(_this.topic), _this.joinPush.timeout);
      _this.state = constants_1.CHANNEL_STATES.errored;
      _this.rejoinTimer.scheduleTimeout();
    });
    this._on(constants_1.CHANNEL_EVENTS.reply, {}, function (payload, ref) {
      _this._trigger(_this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence_1["default"](this);
  }
  /** Subscribe registers your client with the server */
  _createClass(RealtimeChannel, [{
    key: "subscribe",
    value: function subscribe(callback) {
      var _this2 = this;
      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;
      var _a, _b;
      if (this.joinedOnce) {
        throw "tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance";
      } else {
        var _this$params$config = this.params.config,
          broadcast = _this$params$config.broadcast,
          presence = _this$params$config.presence;
        this._onError(function (e) {
          return callback && callback('CHANNEL_ERROR', e);
        });
        this._onClose(function () {
          return callback && callback('CLOSED');
        });
        var accessTokenPayload = {};
        var config = {
          broadcast: broadcast,
          presence: presence,
          postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(function (r) {
            return r.filter;
          })) !== null && _b !== void 0 ? _b : []
        };
        if (this.socket.accessToken) {
          accessTokenPayload.access_token = this.socket.accessToken;
        }
        this.updateJoinPayload(Object.assign({
          config: config
        }, accessTokenPayload));
        this.joinedOnce = true;
        this._rejoin(timeout);
        this.joinPush.receive('ok', function (_ref2) {
          var serverPostgresFilters = _ref2.postgres_changes;
          var _a;
          _this2.socket.accessToken && _this2.socket.setAuth(_this2.socket.accessToken);
          if (serverPostgresFilters === undefined) {
            callback && callback('SUBSCRIBED');
            return;
          } else {
            var clientPostgresBindings = _this2.bindings.postgres_changes;
            var bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;
            var newPostgresBindings = [];
            for (var i = 0; i < bindingsLen; i++) {
              var clientPostgresBinding = clientPostgresBindings[i];
              var _clientPostgresBindin = clientPostgresBinding.filter,
                event = _clientPostgresBindin.event,
                schema = _clientPostgresBindin.schema,
                table = _clientPostgresBindin.table,
                filter = _clientPostgresBindin.filter;
              var serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];
              if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
                newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {
                  id: serverPostgresFilter.id
                }));
              } else {
                _this2.unsubscribe();
                callback && callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));
                return;
              }
            }
            _this2.bindings.postgres_changes = newPostgresBindings;
            callback && callback('SUBSCRIBED');
            return;
          }
        }).receive('error', function (error) {
          callback && callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));
          return;
        }).receive('timeout', function () {
          callback && callback('TIMED_OUT');
          return;
        });
      }
      return this;
    }
  }, {
    key: "presenceState",
    value: function presenceState() {
      return this.presence.state;
    }
  }, {
    key: "track",
    value: function track(payload) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.send({
                type: 'presence',
                event: 'track',
                payload: payload
              }, opts.timeout || this.timeout);
            case 2:
              return _context.abrupt("return", _context.sent);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "untrack",
    value: function untrack() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.send({
                type: 'presence',
                event: 'untrack'
              }, opts);
            case 2:
              return _context2.abrupt("return", _context2.sent);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "on",
    value: function on(type, filter, callback) {
      return this._on(type, filter, callback);
    }
  }, {
    key: "send",
    value: function send(payload) {
      var _this3 = this;
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve) {
        var _a, _b, _c;
        var push = _this3._push(payload.type, payload, opts.timeout || _this3.timeout);
        if (push.rateLimited) {
          resolve('rate limited');
        }
        if (payload.type === 'broadcast' && !((_c = (_b = (_a = _this3.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
          resolve('ok');
        }
        push.receive('ok', function () {
          return resolve('ok');
        });
        push.receive('timeout', function () {
          return resolve('timed out');
        });
      });
    }
  }, {
    key: "updateJoinPayload",
    value: function updateJoinPayload(payload) {
      this.joinPush.updatePayload(payload);
    }
    /**
     * Leaves the channel.
     *
     * Unsubscribes from server events, and instructs channel to terminate on server.
     * Triggers onClose() hooks.
     *
     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
     * channel.unsubscribe().receive("ok", () => alert("left!") )
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      var _this4 = this;
      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;
      this.state = constants_1.CHANNEL_STATES.leaving;
      var onClose = function onClose() {
        _this4.socket.log('channel', "leave ".concat(_this4.topic));
        _this4._trigger(constants_1.CHANNEL_EVENTS.close, 'leave', _this4._joinRef());
      };
      this.rejoinTimer.reset();
      // Destroy joinPush to avoid connection timeouts during unscription phase
      this.joinPush.destroy();
      return new Promise(function (resolve) {
        var leavePush = new push_1["default"](_this4, constants_1.CHANNEL_EVENTS.leave, {}, timeout);
        leavePush.receive('ok', function () {
          onClose();
          resolve('ok');
        }).receive('timeout', function () {
          onClose();
          resolve('timed out');
        }).receive('error', function () {
          resolve('error');
        });
        leavePush.send();
        if (!_this4._canPush()) {
          leavePush.trigger('ok', {});
        }
      });
    }
    /** @internal */
  }, {
    key: "_push",
    value: function _push(event, payload) {
      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;
      if (!this.joinedOnce) {
        throw "tried to push '".concat(event, "' to '").concat(this.topic, "' before joining. Use channel.subscribe() before pushing events");
      }
      var pushEvent = new push_1["default"](this, event, payload, timeout);
      if (this._canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling before dispatching to the channel callbacks.
     * Must return the payload, modified or unmodified.
     *
     * @internal
     */
  }, {
    key: "_onMessage",
    value: function _onMessage(_event, payload, _ref) {
      return payload;
    }
    /** @internal */
  }, {
    key: "_isMember",
    value: function _isMember(topic) {
      return this.topic === topic;
    }
    /** @internal */
  }, {
    key: "_joinRef",
    value: function _joinRef() {
      return this.joinPush.ref;
    }
    /** @internal */
  }, {
    key: "_trigger",
    value: function _trigger(type, payload, ref) {
      var _this5 = this;
      var _a, _b;
      var typeLower = type.toLocaleLowerCase();
      var _constants_1$CHANNEL_ = constants_1.CHANNEL_EVENTS,
        close = _constants_1$CHANNEL_.close,
        error = _constants_1$CHANNEL_.error,
        leave = _constants_1$CHANNEL_.leave,
        join = _constants_1$CHANNEL_.join;
      var events = [close, error, leave, join];
      if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
        return;
      }
      var handledPayload = this._onMessage(typeLower, payload, ref);
      if (payload && !handledPayload) {
        throw 'channel onMessage callbacks must return the payload, modified or unmodified';
      }
      if (['insert', 'update', 'delete'].includes(typeLower)) {
        (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(function (bind) {
          var _a, _b, _c;
          return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
        }).map(function (bind) {
          return bind.callback(handledPayload, ref);
        });
      } else {
        (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(function (bind) {
          var _a, _b, _c, _d, _e, _f;
          if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {
            if ('id' in bind) {
              var bindId = bind.id;
              var bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;
              return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
            } else {
              var _bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
              return _bindEvent === '*' || _bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
            }
          } else {
            return bind.type.toLocaleLowerCase() === typeLower;
          }
        }).map(function (bind) {
          if (_typeof(handledPayload) === 'object' && 'ids' in handledPayload) {
            var postgresChanges = handledPayload.data;
            var schema = postgresChanges.schema,
              table = postgresChanges.table,
              commit_timestamp = postgresChanges.commit_timestamp,
              _type = postgresChanges.type,
              errors = postgresChanges.errors;
            var enrichedPayload = {
              schema: schema,
              table: table,
              commit_timestamp: commit_timestamp,
              eventType: _type,
              "new": {},
              old: {},
              errors: errors
            };
            handledPayload = Object.assign(Object.assign({}, enrichedPayload), _this5._getPayloadRecords(postgresChanges));
          }
          bind.callback(handledPayload, ref);
        });
      }
    }
    /** @internal */
  }, {
    key: "_isClosed",
    value: function _isClosed() {
      return this.state === constants_1.CHANNEL_STATES.closed;
    }
    /** @internal */
  }, {
    key: "_isJoined",
    value: function _isJoined() {
      return this.state === constants_1.CHANNEL_STATES.joined;
    }
    /** @internal */
  }, {
    key: "_isJoining",
    value: function _isJoining() {
      return this.state === constants_1.CHANNEL_STATES.joining;
    }
    /** @internal */
  }, {
    key: "_isLeaving",
    value: function _isLeaving() {
      return this.state === constants_1.CHANNEL_STATES.leaving;
    }
    /** @internal */
  }, {
    key: "_replyEventName",
    value: function _replyEventName(ref) {
      return "chan_reply_".concat(ref);
    }
    /** @internal */
  }, {
    key: "_on",
    value: function _on(type, filter, callback) {
      var typeLower = type.toLocaleLowerCase();
      var binding = {
        type: typeLower,
        filter: filter,
        callback: callback
      };
      if (this.bindings[typeLower]) {
        this.bindings[typeLower].push(binding);
      } else {
        this.bindings[typeLower] = [binding];
      }
      return this;
    }
    /** @internal */
  }, {
    key: "_off",
    value: function _off(type, filter) {
      var typeLower = type.toLocaleLowerCase();
      this.bindings[typeLower] = this.bindings[typeLower].filter(function (bind) {
        var _a;
        return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
      });
      return this;
    }
    /** @internal */
  }, {
    key: "_rejoinUntilConnected",
    value: /** @internal */
    function _rejoinUntilConnected() {
      this.rejoinTimer.scheduleTimeout();
      if (this.socket.isConnected()) {
        this._rejoin();
      }
    }
    /**
     * Registers a callback that will be executed when the channel closes.
     *
     * @internal
     */
  }, {
    key: "_onClose",
    value: function _onClose(callback) {
      this._on(constants_1.CHANNEL_EVENTS.close, {}, callback);
    }
    /**
     * Registers a callback that will be executed when the channel encounteres an error.
     *
     * @internal
     */
  }, {
    key: "_onError",
    value: function _onError(callback) {
      this._on(constants_1.CHANNEL_EVENTS.error, {}, function (reason) {
        return callback(reason);
      });
    }
    /**
     * Returns `true` if the socket is connected and the channel has been joined.
     *
     * @internal
     */
  }, {
    key: "_canPush",
    value: function _canPush() {
      return this.socket.isConnected() && this._isJoined();
    }
    /** @internal */
  }, {
    key: "_rejoin",
    value: function _rejoin() {
      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;
      if (this._isLeaving()) {
        return;
      }
      this.socket._leaveOpenTopic(this.topic);
      this.state = constants_1.CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    /** @internal */
  }, {
    key: "_getPayloadRecords",
    value: function _getPayloadRecords(payload) {
      var records = {
        "new": {},
        old: {}
      };
      if (payload.type === 'INSERT' || payload.type === 'UPDATE') {
        records["new"] = Transformers.convertChangeData(payload.columns, payload.record);
      }
      if (payload.type === 'UPDATE' || payload.type === 'DELETE') {
        records.old = Transformers.convertChangeData(payload.columns, payload.old_record);
      }
      return records;
    }
  }], [{
    key: "isEqual",
    value: function isEqual(obj1, obj2) {
      if (Object.keys(obj1).length !== Object.keys(obj2).length) {
        return false;
      }
      for (var k in obj1) {
        if (obj1[k] !== obj2[k]) {
          return false;
        }
      }
      return true;
    }
  }]);
  return RealtimeChannel;
}();
exports["default"] = RealtimeChannel;

},{"./RealtimePresence":28,"./lib/constants":30,"./lib/push":31,"./lib/timer":33,"./lib/transformers":34}],27:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var websocket_1 = require("websocket");
var constants_1 = require("./lib/constants");
var timer_1 = __importDefault(require("./lib/timer"));
var serializer_1 = __importDefault(require("./lib/serializer"));
var RealtimeChannel_1 = __importDefault(require("./RealtimeChannel"));
var noop = function noop() {};
var RealtimeClient = /*#__PURE__*/function () {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket.
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers The optional headers to pass when connecting.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   */
  function RealtimeClient(endPoint, options) {
    var _this = this;
    _classCallCheck(this, RealtimeClient);
    var _a;
    this.accessToken = null;
    this.channels = [];
    this.endPoint = '';
    this.headers = constants_1.DEFAULT_HEADERS;
    this.params = {};
    this.timeout = constants_1.DEFAULT_TIMEOUT;
    this.transport = websocket_1.w3cwebsocket;
    this.heartbeatIntervalMs = 30000;
    this.heartbeatTimer = undefined;
    this.pendingHeartbeatRef = null;
    this.ref = 0;
    this.logger = noop;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new serializer_1["default"]();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.eventsPerSecondLimitMs = 100;
    this.inThrottle = false;
    this.endPoint = "".concat(endPoint, "/").concat(constants_1.TRANSPORTS.websocket);
    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;
    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;
    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;
    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;
    var eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;
    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);
    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : function (tries) {
      return [1000, 2000, 5000, 10000][tries - 1] || 10000;
    };
    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : function (payload, callback) {
      return callback(JSON.stringify(payload));
    };
    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
    this.reconnectTimer = new timer_1["default"](function () {
      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.disconnect();
              this.connect();
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
    }, this.reconnectAfterMs);
  }
  /**
   * Connects the socket, unless already connected.
   */
  _createClass(RealtimeClient, [{
    key: "connect",
    value: function connect() {
      var _this2 = this;
      if (this.conn) {
        return;
      }
      this.conn = new this.transport(this._endPointURL(), [], null, this.headers);
      if (this.conn) {
        this.conn.binaryType = 'arraybuffer';
        this.conn.onopen = function () {
          return _this2._onConnOpen();
        };
        this.conn.onerror = function (error) {
          return _this2._onConnError(error);
        };
        this.conn.onmessage = function (event) {
          return _this2._onConnMessage(event);
        };
        this.conn.onclose = function (event) {
          return _this2._onConnClose(event);
        };
      }
    }
    /**
     * Disconnects the socket.
     *
     * @param code A numeric status code to send on disconnect.
     * @param reason A custom reason for the disconnect.
     */
  }, {
    key: "disconnect",
    value: function disconnect(code, reason) {
      if (this.conn) {
        this.conn.onclose = function () {}; // noop
        if (code) {
          this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');
        } else {
          this.conn.close();
        }
        this.conn = null;
        // remove open handles
        this.heartbeatTimer && clearInterval(this.heartbeatTimer);
        this.reconnectTimer.reset();
      }
    }
  }, {
    key: "getChannels",
    value: function getChannels() {
      return this.channels;
    }
  }, {
    key: "removeChannel",
    value: function removeChannel(channel) {
      var _this3 = this;
      return channel.unsubscribe().then(function (status) {
        if (_this3.channels.length === 0) {
          _this3.disconnect();
        }
        return status;
      });
    }
  }, {
    key: "removeAllChannels",
    value: function removeAllChannels() {
      var _this4 = this;
      return Promise.all(this.channels.map(function (channel) {
        return channel.unsubscribe();
      })).then(function (values) {
        _this4.disconnect();
        return values;
      });
    }
    /**
     * Logs the message.
     *
     * For customized logging, `this.logger` can be overriden.
     */
  }, {
    key: "log",
    value: function log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    /**
     * Returns the current state of the socket.
     */
  }, {
    key: "connectionState",
    value: function connectionState() {
      switch (this.conn && this.conn.readyState) {
        case constants_1.SOCKET_STATES.connecting:
          return constants_1.CONNECTION_STATE.Connecting;
        case constants_1.SOCKET_STATES.open:
          return constants_1.CONNECTION_STATE.Open;
        case constants_1.SOCKET_STATES.closing:
          return constants_1.CONNECTION_STATE.Closing;
        default:
          return constants_1.CONNECTION_STATE.Closed;
      }
    }
    /**
     * Retuns `true` is the connection is open.
     */
  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.connectionState() === constants_1.CONNECTION_STATE.Open;
    }
  }, {
    key: "channel",
    value: function channel(topic) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        config: {}
      };
      if (!this.isConnected()) {
        this.connect();
      }
      var chan = new RealtimeChannel_1["default"]("realtime:".concat(topic), params, this);
      this.channels.push(chan);
      return chan;
    }
    /**
     * Push out a message if the socket is connected.
     *
     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
     */
  }, {
    key: "push",
    value: function push(data) {
      var _this5 = this;
      var topic = data.topic,
        event = data.event,
        payload = data.payload,
        ref = data.ref;
      var callback = function callback() {
        _this5.encode(data, function (result) {
          var _a;
          (_a = _this5.conn) === null || _a === void 0 ? void 0 : _a.send(result);
        });
      };
      this.log('push', "".concat(topic, " ").concat(event, " (").concat(ref, ")"), payload);
      if (this.isConnected()) {
        if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {
          var isThrottled = this._throttle(callback)();
          if (isThrottled) {
            return 'rate limited';
          }
        } else {
          callback();
        }
      } else {
        this.sendBuffer.push(callback);
      }
    }
    /**
     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
     *
     * @param token A JWT string.
     */
  }, {
    key: "setAuth",
    value: function setAuth(token) {
      this.accessToken = token;
      this.channels.forEach(function (channel) {
        token && channel.updateJoinPayload({
          access_token: token
        });
        if (channel.joinedOnce && channel._isJoined()) {
          channel._push(constants_1.CHANNEL_EVENTS.access_token, {
            access_token: token
          });
        }
      });
    }
    /**
     * Return the next message ref, accounting for overflows
     *
     * @internal
     */
  }, {
    key: "_makeRef",
    value: function _makeRef() {
      var newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    /**
     * Unsubscribe from channels with the specified topic.
     *
     * @internal
     */
  }, {
    key: "_leaveOpenTopic",
    value: function _leaveOpenTopic(topic) {
      var dupChannel = this.channels.find(function (c) {
        return c.topic === topic && (c._isJoined() || c._isJoining());
      });
      if (dupChannel) {
        this.log('transport', "leaving duplicate topic \"".concat(topic, "\""));
        dupChannel.unsubscribe();
      }
    }
    /**
     * Removes a subscription from the socket.
     *
     * @param channel An open subscription.
     *
     * @internal
     */
  }, {
    key: "_remove",
    value: function _remove(channel) {
      this.channels = this.channels.filter(function (c) {
        return c._joinRef() !== channel._joinRef();
      });
    }
    /**
     * Returns the URL of the websocket.
     *
     * @internal
     */
  }, {
    key: "_endPointURL",
    value: function _endPointURL() {
      return this._appendParams(this.endPoint, Object.assign({}, this.params, {
        vsn: constants_1.VSN
      }));
    }
    /** @internal */
  }, {
    key: "_onConnMessage",
    value: function _onConnMessage(rawMessage) {
      var _this6 = this;
      this.decode(rawMessage.data, function (msg) {
        var topic = msg.topic,
          event = msg.event,
          payload = msg.payload,
          ref = msg.ref;
        if (ref && ref === _this6.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {
          _this6.pendingHeartbeatRef = null;
        }
        _this6.log('receive', "".concat(payload.status || '', " ").concat(topic, " ").concat(event, " ").concat(ref && '(' + ref + ')' || ''), payload);
        _this6.channels.filter(function (channel) {
          return channel._isMember(topic);
        }).forEach(function (channel) {
          return channel._trigger(event, payload, ref);
        });
        _this6.stateChangeCallbacks.message.forEach(function (callback) {
          return callback(msg);
        });
      });
    }
    /** @internal */
  }, {
    key: "_onConnOpen",
    value: function _onConnOpen() {
      var _this7 = this;
      this.log('transport', "connected to ".concat(this._endPointURL()));
      this._flushSendBuffer();
      this.reconnectTimer.reset();
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = setInterval(function () {
        return _this7._sendHeartbeat();
      }, this.heartbeatIntervalMs);
      this.stateChangeCallbacks.open.forEach(function (callback) {
        return callback();
      });
    }
    /** @internal */
  }, {
    key: "_onConnClose",
    value: function _onConnClose(event) {
      this.log('transport', 'close', event);
      this._triggerChanError();
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.scheduleTimeout();
      this.stateChangeCallbacks.close.forEach(function (callback) {
        return callback(event);
      });
    }
    /** @internal */
  }, {
    key: "_onConnError",
    value: function _onConnError(error) {
      this.log('transport', error.message);
      this._triggerChanError();
      this.stateChangeCallbacks.error.forEach(function (callback) {
        return callback(error);
      });
    }
    /** @internal */
  }, {
    key: "_triggerChanError",
    value: function _triggerChanError() {
      this.channels.forEach(function (channel) {
        return channel._trigger(constants_1.CHANNEL_EVENTS.error);
      });
    }
    /** @internal */
  }, {
    key: "_appendParams",
    value: function _appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      var prefix = url.match(/\?/) ? '&' : '?';
      var query = new URLSearchParams(params);
      return "".concat(url).concat(prefix).concat(query);
    }
    /** @internal */
  }, {
    key: "_flushSendBuffer",
    value: function _flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach(function (callback) {
          return callback();
        });
        this.sendBuffer = [];
      }
    }
    /** @internal */
  }, {
    key: "_sendHeartbeat",
    value: function _sendHeartbeat() {
      var _a;
      if (!this.isConnected()) {
        return;
      }
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');
        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(constants_1.WS_CLOSE_NORMAL, 'hearbeat timeout');
        return;
      }
      this.pendingHeartbeatRef = this._makeRef();
      this.push({
        topic: 'phoenix',
        event: 'heartbeat',
        payload: {},
        ref: this.pendingHeartbeatRef
      });
      this.setAuth(this.accessToken);
    }
    /** @internal */
  }, {
    key: "_throttle",
    value: function _throttle(callback) {
      var _this8 = this;
      var eventsPerSecondLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.eventsPerSecondLimitMs;
      return function () {
        if (_this8.inThrottle) return true;
        callback();
        _this8.inThrottle = true;
        setTimeout(function () {
          _this8.inThrottle = false;
        }, eventsPerSecondLimit);
        return false;
      };
    }
  }]);
  return RealtimeClient;
}();
exports["default"] = RealtimeClient;

},{"./RealtimeChannel":26,"./lib/constants":30,"./lib/serializer":32,"./lib/timer":33,"websocket":88}],28:[function(require,module,exports){
"use strict";

/*
  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js
  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md
*/
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REALTIME_PRESENCE_LISTEN_EVENTS = void 0;
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function (REALTIME_PRESENCE_LISTEN_EVENTS) {
  REALTIME_PRESENCE_LISTEN_EVENTS["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS = exports.REALTIME_PRESENCE_LISTEN_EVENTS || (exports.REALTIME_PRESENCE_LISTEN_EVENTS = {}));
var RealtimePresence = /*#__PURE__*/function () {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  function RealtimePresence(channel, opts) {
    var _this = this;
    _classCallCheck(this, RealtimePresence);
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.caller = {
      onJoin: function onJoin() {},
      onLeave: function onLeave() {},
      onSync: function onSync() {}
    };
    var events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: 'presence_state',
      diff: 'presence_diff'
    };
    this.channel._on(events.state, {}, function (newState) {
      var _this$caller = _this.caller,
        onJoin = _this$caller.onJoin,
        onLeave = _this$caller.onLeave,
        onSync = _this$caller.onSync;
      _this.joinRef = _this.channel._joinRef();
      _this.state = RealtimePresence.syncState(_this.state, newState, onJoin, onLeave);
      _this.pendingDiffs.forEach(function (diff) {
        _this.state = RealtimePresence.syncDiff(_this.state, diff, onJoin, onLeave);
      });
      _this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, function (diff) {
      var _this$caller2 = _this.caller,
        onJoin = _this$caller2.onJoin,
        onLeave = _this$caller2.onLeave,
        onSync = _this$caller2.onSync;
      if (_this.inPendingSyncState()) {
        _this.pendingDiffs.push(diff);
      } else {
        _this.state = RealtimePresence.syncDiff(_this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin(function (key, currentPresences, newPresences) {
      _this.channel._trigger('presence', {
        event: 'join',
        key: key,
        currentPresences: currentPresences,
        newPresences: newPresences
      });
    });
    this.onLeave(function (key, currentPresences, leftPresences) {
      _this.channel._trigger('presence', {
        event: 'leave',
        key: key,
        currentPresences: currentPresences,
        leftPresences: leftPresences
      });
    });
    this.onSync(function () {
      _this.channel._trigger('presence', {
        event: 'sync'
      });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  _createClass(RealtimePresence, [{
    key: "onJoin",
    value: /** @internal */
    function onJoin(callback) {
      this.caller.onJoin = callback;
    }
    /** @internal */
  }, {
    key: "onLeave",
    value: function onLeave(callback) {
      this.caller.onLeave = callback;
    }
    /** @internal */
  }, {
    key: "onSync",
    value: function onSync(callback) {
      this.caller.onSync = callback;
    }
    /** @internal */
  }, {
    key: "inPendingSyncState",
    value: function inPendingSyncState() {
      return !this.joinRef || this.joinRef !== this.channel._joinRef();
    }
  }], [{
    key: "syncState",
    value: function syncState(currentState, newState, onJoin, onLeave) {
      var state = this.cloneDeep(currentState);
      var transformedState = this.transformState(newState);
      var joins = {};
      var leaves = {};
      this.map(state, function (key, presences) {
        if (!transformedState[key]) {
          leaves[key] = presences;
        }
      });
      this.map(transformedState, function (key, newPresences) {
        var currentPresences = state[key];
        if (currentPresences) {
          var newPresenceRefs = newPresences.map(function (m) {
            return m.presence_ref;
          });
          var curPresenceRefs = currentPresences.map(function (m) {
            return m.presence_ref;
          });
          var joinedPresences = newPresences.filter(function (m) {
            return curPresenceRefs.indexOf(m.presence_ref) < 0;
          });
          var leftPresences = currentPresences.filter(function (m) {
            return newPresenceRefs.indexOf(m.presence_ref) < 0;
          });
          if (joinedPresences.length > 0) {
            joins[key] = joinedPresences;
          }
          if (leftPresences.length > 0) {
            leaves[key] = leftPresences;
          }
        } else {
          joins[key] = newPresences;
        }
      });
      return this.syncDiff(state, {
        joins: joins,
        leaves: leaves
      }, onJoin, onLeave);
    }
    /**
     * Used to sync a diff of presence join and leave events from the
     * server, as they happen.
     *
     * Like `syncState`, `syncDiff` accepts optional `onJoin` and
     * `onLeave` callbacks to react to a user joining or leaving from a
     * device.
     *
     * @internal
     */
  }, {
    key: "syncDiff",
    value: function syncDiff(state, diff, onJoin, onLeave) {
      var _this2 = this;
      var _joins$leaves = {
          joins: this.transformState(diff.joins),
          leaves: this.transformState(diff.leaves)
        },
        joins = _joins$leaves.joins,
        leaves = _joins$leaves.leaves;
      if (!onJoin) {
        onJoin = function onJoin() {};
      }
      if (!onLeave) {
        onLeave = function onLeave() {};
      }
      this.map(joins, function (key, newPresences) {
        var _a;
        var currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];
        state[key] = _this2.cloneDeep(newPresences);
        if (currentPresences.length > 0) {
          var _state$key;
          var joinedPresenceRefs = state[key].map(function (m) {
            return m.presence_ref;
          });
          var curPresences = currentPresences.filter(function (m) {
            return joinedPresenceRefs.indexOf(m.presence_ref) < 0;
          });
          (_state$key = state[key]).unshift.apply(_state$key, _toConsumableArray(curPresences));
        }
        onJoin(key, currentPresences, newPresences);
      });
      this.map(leaves, function (key, leftPresences) {
        var currentPresences = state[key];
        if (!currentPresences) return;
        var presenceRefsToRemove = leftPresences.map(function (m) {
          return m.presence_ref;
        });
        currentPresences = currentPresences.filter(function (m) {
          return presenceRefsToRemove.indexOf(m.presence_ref) < 0;
        });
        state[key] = currentPresences;
        onLeave(key, currentPresences, leftPresences);
        if (currentPresences.length === 0) delete state[key];
      });
      return state;
    }
    /** @internal */
  }, {
    key: "map",
    value: function map(obj, func) {
      return Object.getOwnPropertyNames(obj).map(function (key) {
        return func(key, obj[key]);
      });
    }
    /**
     * Remove 'metas' key
     * Change 'phx_ref' to 'presence_ref'
     * Remove 'phx_ref' and 'phx_ref_prev'
     *
     * @example
     * // returns {
     *  abc123: [
     *    { presence_ref: '2', user_id: 1 },
     *    { presence_ref: '3', user_id: 2 }
     *  ]
     * }
     * RealtimePresence.transformState({
     *  abc123: {
     *    metas: [
     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
     *      { phx_ref: '3', user_id: 2 }
     *    ]
     *  }
     * })
     *
     * @internal
     */
  }, {
    key: "transformState",
    value: function transformState(state) {
      state = this.cloneDeep(state);
      return Object.getOwnPropertyNames(state).reduce(function (newState, key) {
        var presences = state[key];
        if ('metas' in presences) {
          newState[key] = presences.metas.map(function (presence) {
            presence['presence_ref'] = presence['phx_ref'];
            delete presence['phx_ref'];
            delete presence['phx_ref_prev'];
            return presence;
          });
        } else {
          newState[key] = presences;
        }
        return newState;
      }, {});
    }
    /** @internal */
  }, {
    key: "cloneDeep",
    value: function cloneDeep(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }]);
  return RealtimePresence;
}();
exports["default"] = RealtimePresence;

},{}],29:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_PRESENCE_LISTEN_EVENTS = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = exports.REALTIME_LISTEN_TYPES = exports.RealtimeClient = exports.RealtimeChannel = exports.RealtimePresence = void 0;
var RealtimeClient_1 = __importDefault(require("./RealtimeClient"));
exports.RealtimeClient = RealtimeClient_1["default"];
var RealtimeChannel_1 = __importStar(require("./RealtimeChannel"));
exports.RealtimeChannel = RealtimeChannel_1["default"];
Object.defineProperty(exports, "REALTIME_LISTEN_TYPES", {
  enumerable: true,
  get: function get() {
    return RealtimeChannel_1.REALTIME_LISTEN_TYPES;
  }
});
Object.defineProperty(exports, "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT", {
  enumerable: true,
  get: function get() {
    return RealtimeChannel_1.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
  }
});
Object.defineProperty(exports, "REALTIME_SUBSCRIBE_STATES", {
  enumerable: true,
  get: function get() {
    return RealtimeChannel_1.REALTIME_SUBSCRIBE_STATES;
  }
});
var RealtimePresence_1 = __importStar(require("./RealtimePresence"));
exports.RealtimePresence = RealtimePresence_1["default"];
Object.defineProperty(exports, "REALTIME_PRESENCE_LISTEN_EVENTS", {
  enumerable: true,
  get: function get() {
    return RealtimePresence_1.REALTIME_PRESENCE_LISTEN_EVENTS;
  }
});

},{"./RealtimeChannel":26,"./RealtimeClient":27,"./RealtimePresence":28}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CONNECTION_STATE = exports.TRANSPORTS = exports.CHANNEL_EVENTS = exports.CHANNEL_STATES = exports.SOCKET_STATES = exports.WS_CLOSE_NORMAL = exports.DEFAULT_TIMEOUT = exports.VSN = exports.DEFAULT_HEADERS = void 0;
var version_1 = require("./version");
exports.DEFAULT_HEADERS = {
  'X-Client-Info': "realtime-js/".concat(version_1.version)
};
exports.VSN = '1.0.0';
exports.DEFAULT_TIMEOUT = 10000;
exports.WS_CLOSE_NORMAL = 1000;
var SOCKET_STATES;
(function (SOCKET_STATES) {
  SOCKET_STATES[SOCKET_STATES["connecting"] = 0] = "connecting";
  SOCKET_STATES[SOCKET_STATES["open"] = 1] = "open";
  SOCKET_STATES[SOCKET_STATES["closing"] = 2] = "closing";
  SOCKET_STATES[SOCKET_STATES["closed"] = 3] = "closed";
})(SOCKET_STATES = exports.SOCKET_STATES || (exports.SOCKET_STATES = {}));
var CHANNEL_STATES;
(function (CHANNEL_STATES) {
  CHANNEL_STATES["closed"] = "closed";
  CHANNEL_STATES["errored"] = "errored";
  CHANNEL_STATES["joined"] = "joined";
  CHANNEL_STATES["joining"] = "joining";
  CHANNEL_STATES["leaving"] = "leaving";
})(CHANNEL_STATES = exports.CHANNEL_STATES || (exports.CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function (CHANNEL_EVENTS) {
  CHANNEL_EVENTS["close"] = "phx_close";
  CHANNEL_EVENTS["error"] = "phx_error";
  CHANNEL_EVENTS["join"] = "phx_join";
  CHANNEL_EVENTS["reply"] = "phx_reply";
  CHANNEL_EVENTS["leave"] = "phx_leave";
  CHANNEL_EVENTS["access_token"] = "access_token";
})(CHANNEL_EVENTS = exports.CHANNEL_EVENTS || (exports.CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function (TRANSPORTS) {
  TRANSPORTS["websocket"] = "websocket";
})(TRANSPORTS = exports.TRANSPORTS || (exports.TRANSPORTS = {}));
var CONNECTION_STATE;
(function (CONNECTION_STATE) {
  CONNECTION_STATE["Connecting"] = "connecting";
  CONNECTION_STATE["Open"] = "open";
  CONNECTION_STATE["Closing"] = "closing";
  CONNECTION_STATE["Closed"] = "closed";
})(CONNECTION_STATE = exports.CONNECTION_STATE || (exports.CONNECTION_STATE = {}));

},{"./version":35}],31:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var constants_1 = require("../lib/constants");
var Push = /*#__PURE__*/function () {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  function Push(channel, event) {
    var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.DEFAULT_TIMEOUT;
    _classCallCheck(this, Push);
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = undefined;
    this.ref = '';
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
    this.rateLimited = false;
  }
  _createClass(Push, [{
    key: "resend",
    value: function resend(timeout) {
      this.timeout = timeout;
      this._cancelRefEvent();
      this.ref = '';
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
      this.send();
    }
  }, {
    key: "send",
    value: function send() {
      if (this._hasReceived('timeout')) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      var status = this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload,
        ref: this.ref,
        join_ref: this.channel._joinRef()
      });
      if (status === 'rate limited') {
        this.rateLimited = true;
      }
    }
  }, {
    key: "updatePayload",
    value: function updatePayload(payload) {
      this.payload = Object.assign(Object.assign({}, this.payload), payload);
    }
  }, {
    key: "receive",
    value: function receive(status, callback) {
      var _a;
      if (this._hasReceived(status)) {
        callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);
      }
      this.recHooks.push({
        status: status,
        callback: callback
      });
      return this;
    }
  }, {
    key: "startTimeout",
    value: function startTimeout() {
      var _this = this;
      if (this.timeoutTimer) {
        return;
      }
      this.ref = this.channel.socket._makeRef();
      this.refEvent = this.channel._replyEventName(this.ref);
      var callback = function callback(payload) {
        _this._cancelRefEvent();
        _this._cancelTimeout();
        _this.receivedResp = payload;
        _this._matchReceive(payload);
      };
      this.channel._on(this.refEvent, {}, callback);
      this.timeoutTimer = setTimeout(function () {
        _this.trigger('timeout', {});
      }, this.timeout);
    }
  }, {
    key: "trigger",
    value: function trigger(status, response) {
      if (this.refEvent) this.channel._trigger(this.refEvent, {
        status: status,
        response: response
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._cancelRefEvent();
      this._cancelTimeout();
    }
  }, {
    key: "_cancelRefEvent",
    value: function _cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel._off(this.refEvent, {});
    }
  }, {
    key: "_cancelTimeout",
    value: function _cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = undefined;
    }
  }, {
    key: "_matchReceive",
    value: function _matchReceive(_ref) {
      var status = _ref.status,
        response = _ref.response;
      this.recHooks.filter(function (h) {
        return h.status === status;
      }).forEach(function (h) {
        return h.callback(response);
      });
    }
  }, {
    key: "_hasReceived",
    value: function _hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
  }]);
  return Push;
}();
exports["default"] = Push;

},{"../lib/constants":30}],32:[function(require,module,exports){
"use strict";

// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe
// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Serializer = /*#__PURE__*/function () {
  function Serializer() {
    _classCallCheck(this, Serializer);
    this.HEADER_LENGTH = 1;
  }
  _createClass(Serializer, [{
    key: "decode",
    value: function decode(rawPayload, callback) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback(this._binaryDecode(rawPayload));
      }
      if (typeof rawPayload === 'string') {
        return callback(JSON.parse(rawPayload));
      }
      return callback({});
    }
  }, {
    key: "_binaryDecode",
    value: function _binaryDecode(buffer) {
      var view = new DataView(buffer);
      var decoder = new TextDecoder();
      return this._decodeBroadcast(buffer, view, decoder);
    }
  }, {
    key: "_decodeBroadcast",
    value: function _decodeBroadcast(buffer, view, decoder) {
      var topicSize = view.getUint8(1);
      var eventSize = view.getUint8(2);
      var offset = this.HEADER_LENGTH + 2;
      var topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      var event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      var data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
      return {
        ref: null,
        topic: topic,
        event: event,
        payload: data
      };
    }
  }]);
  return Serializer;
}();
exports["default"] = Serializer;

},{}],33:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.
 *
 * @example
 *    let reconnectTimer = new Timer(() => this.connect(), function(tries){
 *      return [1000, 5000, 10000][tries - 1] || 10000
 *    })
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 *    reconnectTimer.scheduleTimeout() // fires after 5000
 *    reconnectTimer.reset()
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 */
var Timer = /*#__PURE__*/function () {
  function Timer(callback, timerCalc) {
    _classCallCheck(this, Timer);
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = undefined;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  _createClass(Timer, [{
    key: "reset",
    value: function reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    // Cancels any previous scheduleTimeout and schedules callback
  }, {
    key: "scheduleTimeout",
    value: function scheduleTimeout() {
      var _this = this;
      clearTimeout(this.timer);
      this.timer = setTimeout(function () {
        _this.tries = _this.tries + 1;
        _this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  }]);
  return Timer;
}();
exports["default"] = Timer;

},{}],34:[function(require,module,exports){
"use strict";

/**
 * Helpers to convert the change Payload into native JS types.
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toTimestampString = exports.toArray = exports.toJson = exports.toNumber = exports.toBoolean = exports.convertCell = exports.convertColumn = exports.convertChangeData = exports.PostgresTypes = void 0;
// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under
// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE
var PostgresTypes;
(function (PostgresTypes) {
  PostgresTypes["abstime"] = "abstime";
  PostgresTypes["bool"] = "bool";
  PostgresTypes["date"] = "date";
  PostgresTypes["daterange"] = "daterange";
  PostgresTypes["float4"] = "float4";
  PostgresTypes["float8"] = "float8";
  PostgresTypes["int2"] = "int2";
  PostgresTypes["int4"] = "int4";
  PostgresTypes["int4range"] = "int4range";
  PostgresTypes["int8"] = "int8";
  PostgresTypes["int8range"] = "int8range";
  PostgresTypes["json"] = "json";
  PostgresTypes["jsonb"] = "jsonb";
  PostgresTypes["money"] = "money";
  PostgresTypes["numeric"] = "numeric";
  PostgresTypes["oid"] = "oid";
  PostgresTypes["reltime"] = "reltime";
  PostgresTypes["text"] = "text";
  PostgresTypes["time"] = "time";
  PostgresTypes["timestamp"] = "timestamp";
  PostgresTypes["timestamptz"] = "timestamptz";
  PostgresTypes["timetz"] = "timetz";
  PostgresTypes["tsrange"] = "tsrange";
  PostgresTypes["tstzrange"] = "tstzrange";
})(PostgresTypes = exports.PostgresTypes || (exports.PostgresTypes = {}));
/**
 * Takes an array of columns and an object of string values then converts each string value
 * to its mapped type.
 *
 * @param {{name: String, type: String}[]} columns
 * @param {Object} record
 * @param {Object} options The map of various options that can be applied to the mapper
 * @param {Array} options.skipTypes The array of types that should not be converted
 *
 * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})
 * //=>{ first_name: 'Paul', age: 33 }
 */
var convertChangeData = function convertChangeData(columns, record) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _a;
  var skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];
  return Object.keys(record).reduce(function (acc, rec_key) {
    acc[rec_key] = (0, exports.convertColumn)(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
exports.convertChangeData = convertChangeData;
/**
 * Converts the value of an individual column.
 *
 * @param {String} columnName The column that you want to convert
 * @param {{name: String, type: String}[]} columns All of the columns
 * @param {Object} record The map of string values
 * @param {Array} skipTypes An array of types that should not be converted
 * @return {object} Useless information
 *
 * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])
 * //=> 33
 * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])
 * //=> "33"
 */
var convertColumn = function convertColumn(columnName, columns, record, skipTypes) {
  var column = columns.find(function (x) {
    return x.name === columnName;
  });
  var colType = column === null || column === void 0 ? void 0 : column.type;
  var value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return (0, exports.convertCell)(colType, value);
  }
  return noop(value);
};
exports.convertColumn = convertColumn;
/**
 * If the value of the cell is `null`, returns null.
 * Otherwise converts the string value to the correct type.
 * @param {String} type A postgres column type
 * @param {String} stringValue The cell value
 *
 * @example convertCell('bool', 't')
 * //=> true
 * @example convertCell('int8', '10')
 * //=> 10
 * @example convertCell('_int4', '{1,2,3,4}')
 * //=> [1,2,3,4]
 */
var convertCell = function convertCell(type, value) {
  // if data type is an array
  if (type.charAt(0) === '_') {
    var dataType = type.slice(1, type.length);
    return (0, exports.toArray)(value, dataType);
  }
  // If not null, convert to correct type.
  switch (type) {
    case PostgresTypes.bool:
      return (0, exports.toBoolean)(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return (0, exports.toNumber)(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return (0, exports.toJson)(value);
    case PostgresTypes.timestamp:
      return (0, exports.toTimestampString)(value);
    // Format to be consistent with PostgREST
    case PostgresTypes.abstime: // To allow users to cast it based on Timezone
    case PostgresTypes.date: // To allow users to cast it based on Timezone
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime: // To allow users to cast it based on Timezone
    case PostgresTypes.text:
    case PostgresTypes.time: // To allow users to cast it based on Timezone
    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone
    case PostgresTypes.timetz: // To allow users to cast it based on Timezone
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop(value);
    default:
      // Return the value for remaining types
      return noop(value);
  }
};
exports.convertCell = convertCell;
var noop = function noop(value) {
  return value;
};
var toBoolean = function toBoolean(value) {
  switch (value) {
    case 't':
      return true;
    case 'f':
      return false;
    default:
      return value;
  }
};
exports.toBoolean = toBoolean;
var toNumber = function toNumber(value) {
  if (typeof value === 'string') {
    var parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
exports.toNumber = toNumber;
var toJson = function toJson(value) {
  if (typeof value === 'string') {
    try {
      return JSON.parse(value);
    } catch (error) {
      console.log("JSON parse error: ".concat(error));
      return value;
    }
  }
  return value;
};
exports.toJson = toJson;
/**
 * Converts a Postgres Array into a native JS array
 *
 * @example toArray('{}', 'int4')
 * //=> []
 * @example toArray('{"[2021-01-01,2021-12-31)","(2021-01-01,2021-12-32]"}', 'daterange')
 * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']
 * @example toArray([1,2,3,4], 'int4')
 * //=> [1,2,3,4]
 */
var toArray = function toArray(value, type) {
  if (typeof value !== 'string') {
    return value;
  }
  var lastIdx = value.length - 1;
  var closeBrace = value[lastIdx];
  var openBrace = value[0];
  // Confirm value is a Postgres array by checking curly brackets
  if (openBrace === '{' && closeBrace === '}') {
    var arr;
    var valTrim = value.slice(1, lastIdx);
    // TODO: find a better solution to separate Postgres array data
    try {
      arr = JSON.parse('[' + valTrim + ']');
    } catch (_) {
      // WARNING: splitting on comma does not cover all edge cases
      arr = valTrim ? valTrim.split(',') : [];
    }
    return arr.map(function (val) {
      return (0, exports.convertCell)(type, val);
    });
  }
  return value;
};
exports.toArray = toArray;
/**
 * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'
 * See https://github.com/supabase/supabase/issues/18
 *
 * @example toTimestampString('2019-09-10 00:00:00')
 * //=> '2019-09-10T00:00:00'
 */
var toTimestampString = function toTimestampString(value) {
  if (typeof value === 'string') {
    return value.replace(' ', 'T');
  }
  return value;
};
exports.toTimestampString = toTimestampString;

},{}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = '2.1.0';

},{}],36:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageClient = void 0;
var StorageFileApi_1 = __importDefault(require("./packages/StorageFileApi"));
var StorageBucketApi_1 = __importDefault(require("./packages/StorageBucketApi"));
var StorageClient = /*#__PURE__*/function (_StorageBucketApi_1$d) {
  _inherits(StorageClient, _StorageBucketApi_1$d);
  var _super = _createSuper(StorageClient);
  function StorageClient(url) {
    var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var fetch = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck(this, StorageClient);
    return _super.call(this, url, headers, fetch);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  _createClass(StorageClient, [{
    key: "from",
    value: function from(id) {
      return new StorageFileApi_1["default"](this.url, this.headers, id, this.fetch);
    }
  }]);
  return StorageClient;
}(StorageBucketApi_1["default"]);
exports.StorageClient = StorageClient;

},{"./packages/StorageBucketApi":44,"./packages/StorageFileApi":45}],37:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageClient = void 0;
var StorageClient_1 = require("./StorageClient");
Object.defineProperty(exports, "StorageClient", {
  enumerable: true,
  get: function get() {
    return StorageClient_1.StorageClient;
  }
});
__exportStar(require("./lib/types"), exports);
__exportStar(require("./lib/errors"), exports);

},{"./StorageClient":36,"./lib/errors":39,"./lib/types":42}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_HEADERS = void 0;
var version_1 = require("./version");
exports.DEFAULT_HEADERS = {
  'X-Client-Info': "storage-js/".concat(version_1.version)
};

},{"./version":43}],39:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageUnknownError = exports.StorageApiError = exports.isStorageError = exports.StorageError = void 0;
var StorageError = /*#__PURE__*/function (_Error) {
  _inherits(StorageError, _Error);
  var _super = _createSuper(StorageError);
  function StorageError(message) {
    var _this;
    _classCallCheck(this, StorageError);
    _this = _super.call(this, message);
    _this.__isStorageError = true;
    _this.name = 'StorageError';
    return _this;
  }
  return _createClass(StorageError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.StorageError = StorageError;
function isStorageError(error) {
  return _typeof(error) === 'object' && error !== null && '__isStorageError' in error;
}
exports.isStorageError = isStorageError;
var StorageApiError = /*#__PURE__*/function (_StorageError) {
  _inherits(StorageApiError, _StorageError);
  var _super2 = _createSuper(StorageApiError);
  function StorageApiError(message, status) {
    var _this2;
    _classCallCheck(this, StorageApiError);
    _this2 = _super2.call(this, message);
    _this2.name = 'StorageApiError';
    _this2.status = status;
    return _this2;
  }
  _createClass(StorageApiError, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status
      };
    }
  }]);
  return StorageApiError;
}(StorageError);
exports.StorageApiError = StorageApiError;
var StorageUnknownError = /*#__PURE__*/function (_StorageError2) {
  _inherits(StorageUnknownError, _StorageError2);
  var _super3 = _createSuper(StorageUnknownError);
  function StorageUnknownError(message, originalError) {
    var _this3;
    _classCallCheck(this, StorageUnknownError);
    _this3 = _super3.call(this, message);
    _this3.name = 'StorageUnknownError';
    _this3.originalError = originalError;
    return _this3;
  }
  return _createClass(StorageUnknownError);
}(StorageError);
exports.StorageUnknownError = StorageUnknownError;

},{}],40:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remove = exports.put = exports.post = exports.get = void 0;
var errors_1 = require("./errors");
var helpers_1 = require("./helpers");
var _getErrorMessage = function _getErrorMessage(err) {
  return err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
};
var handleError = function handleError(error, reject) {
  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var Res;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, helpers_1.resolveResponse)();
        case 2:
          Res = _context.sent;
          if (error instanceof Res) {
            error.json().then(function (err) {
              reject(new errors_1.StorageApiError(_getErrorMessage(err), error.status || 500));
            });
          } else {
            reject(new errors_1.StorageUnknownError(_getErrorMessage(error), error));
          }
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
};
var _getRequestParams = function _getRequestParams(method, options, parameters, body) {
  var params = {
    method: method,
    headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
  };
  if (method === 'GET') {
    return params;
  }
  params.headers = Object.assign({
    'Content-Type': 'application/json'
  }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest(fetcher, method, url, options, parameters, body) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", new Promise(function (resolve, reject) {
            fetcher(url, _getRequestParams(method, options, parameters, body)).then(function (result) {
              if (!result.ok) throw result;
              if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
              return result.json();
            }).then(function (data) {
              return resolve(data);
            })["catch"](function (error) {
              return handleError(error, reject);
            });
          }));
        case 1:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
}
function get(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          return _context3.abrupt("return", _handleRequest(fetcher, 'GET', url, options, parameters));
        case 1:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
}
exports.get = get;
function post(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          return _context4.abrupt("return", _handleRequest(fetcher, 'POST', url, options, parameters, body));
        case 1:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
}
exports.post = post;
function put(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          return _context5.abrupt("return", _handleRequest(fetcher, 'PUT', url, options, parameters, body));
        case 1:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
}
exports.put = put;
function remove(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          return _context6.abrupt("return", _handleRequest(fetcher, 'DELETE', url, options, parameters, body));
        case 1:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
}
exports.remove = remove;

},{"./errors":39,"./helpers":41}],41:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveResponse = exports.resolveFetch = void 0;
var resolveFetch = function resolveFetch(customFetch) {
  var _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = function _fetch() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _yield$Promise$resolv;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return Promise.resolve().then(function () {
                return __importStar(require('cross-fetch'));
              });
            case 2:
              _context.next = 4;
              return (_yield$Promise$resolv = _context.sent).fetch.apply(_yield$Promise$resolv, args);
            case 4:
              return _context.abrupt("return", _context.sent);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
    };
  } else {
    _fetch = fetch;
  }
  return function () {
    return _fetch.apply(void 0, arguments);
  };
};
exports.resolveFetch = resolveFetch;
var resolveResponse = function resolveResponse() {
  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(typeof Response === 'undefined')) {
            _context2.next = 4;
            break;
          }
          _context2.next = 3;
          return Promise.resolve().then(function () {
            return __importStar(require('cross-fetch'));
          });
        case 3:
          return _context2.abrupt("return", _context2.sent.Response);
        case 4:
          return _context2.abrupt("return", Response);
        case 5:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
};
exports.resolveResponse = resolveResponse;

},{"cross-fetch":59}],42:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
// generated by genversion
exports.version = '2.1.0';

},{}],44:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var constants_1 = require("../lib/constants");
var errors_1 = require("../lib/errors");
var fetch_1 = require("../lib/fetch");
var helpers_1 = require("../lib/helpers");
var StorageBucketApi = /*#__PURE__*/function () {
  function StorageBucketApi(url) {
    var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var fetch = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck(this, StorageBucketApi);
    this.url = url;
    this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
    this.fetch = (0, helpers_1.resolveFetch)(fetch);
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  _createClass(StorageBucketApi, [{
    key: "listBuckets",
    value: function listBuckets() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var data;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return (0, fetch_1.get)(this.fetch, "".concat(this.url, "/bucket"), {
                headers: this.headers
              });
            case 3:
              data = _context.sent;
              return _context.abrupt("return", {
                data: data,
                error: null
              });
            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](0);
              if (!(0, errors_1.isStorageError)(_context.t0)) {
                _context.next = 11;
                break;
              }
              return _context.abrupt("return", {
                data: null,
                error: _context.t0
              });
            case 11:
              throw _context.t0;
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 7]]);
      }));
    }
    /**
     * Retrieves the details of an existing Storage bucket.
     *
     * @param id The unique identifier of the bucket you would like to retrieve.
     */
  }, {
    key: "getBucket",
    value: function getBucket(id) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var data;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return (0, fetch_1.get)(this.fetch, "".concat(this.url, "/bucket/").concat(id), {
                headers: this.headers
              });
            case 3:
              data = _context2.sent;
              return _context2.abrupt("return", {
                data: data,
                error: null
              });
            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2["catch"](0);
              if (!(0, errors_1.isStorageError)(_context2.t0)) {
                _context2.next = 11;
                break;
              }
              return _context2.abrupt("return", {
                data: null,
                error: _context2.t0
              });
            case 11:
              throw _context2.t0;
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 7]]);
      }));
    }
    /**
     * Creates a new Storage bucket
     *
     * @param id A unique identifier for the bucket you are creating.
     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
     * @returns newly created bucket id
     */
  }, {
    key: "createBucket",
    value: function createBucket(id) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        "public": false
      };
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var data;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return (0, fetch_1.post)(this.fetch, "".concat(this.url, "/bucket"), {
                id: id,
                name: id,
                "public": options["public"]
              }, {
                headers: this.headers
              });
            case 3:
              data = _context3.sent;
              return _context3.abrupt("return", {
                data: data,
                error: null
              });
            case 7:
              _context3.prev = 7;
              _context3.t0 = _context3["catch"](0);
              if (!(0, errors_1.isStorageError)(_context3.t0)) {
                _context3.next = 11;
                break;
              }
              return _context3.abrupt("return", {
                data: null,
                error: _context3.t0
              });
            case 11:
              throw _context3.t0;
            case 12:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 7]]);
      }));
    }
    /**
     * Updates a Storage bucket
     *
     * @param id A unique identifier for the bucket you are updating.
     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
     */
  }, {
    key: "updateBucket",
    value: function updateBucket(id, options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var data;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return (0, fetch_1.put)(this.fetch, "".concat(this.url, "/bucket/").concat(id), {
                id: id,
                name: id,
                "public": options["public"]
              }, {
                headers: this.headers
              });
            case 3:
              data = _context4.sent;
              return _context4.abrupt("return", {
                data: data,
                error: null
              });
            case 7:
              _context4.prev = 7;
              _context4.t0 = _context4["catch"](0);
              if (!(0, errors_1.isStorageError)(_context4.t0)) {
                _context4.next = 11;
                break;
              }
              return _context4.abrupt("return", {
                data: null,
                error: _context4.t0
              });
            case 11:
              throw _context4.t0;
            case 12:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 7]]);
      }));
    }
    /**
     * Removes all objects inside a single bucket.
     *
     * @param id The unique identifier of the bucket you would like to empty.
     */
  }, {
    key: "emptyBucket",
    value: function emptyBucket(id) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var data;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return (0, fetch_1.post)(this.fetch, "".concat(this.url, "/bucket/").concat(id, "/empty"), {}, {
                headers: this.headers
              });
            case 3:
              data = _context5.sent;
              return _context5.abrupt("return", {
                data: data,
                error: null
              });
            case 7:
              _context5.prev = 7;
              _context5.t0 = _context5["catch"](0);
              if (!(0, errors_1.isStorageError)(_context5.t0)) {
                _context5.next = 11;
                break;
              }
              return _context5.abrupt("return", {
                data: null,
                error: _context5.t0
              });
            case 11:
              throw _context5.t0;
            case 12:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 7]]);
      }));
    }
    /**
     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
     * You must first `empty()` the bucket.
     *
     * @param id The unique identifier of the bucket you would like to delete.
     */
  }, {
    key: "deleteBucket",
    value: function deleteBucket(id) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var data;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              _context6.next = 3;
              return (0, fetch_1.remove)(this.fetch, "".concat(this.url, "/bucket/").concat(id), {}, {
                headers: this.headers
              });
            case 3:
              data = _context6.sent;
              return _context6.abrupt("return", {
                data: data,
                error: null
              });
            case 7:
              _context6.prev = 7;
              _context6.t0 = _context6["catch"](0);
              if (!(0, errors_1.isStorageError)(_context6.t0)) {
                _context6.next = 11;
                break;
              }
              return _context6.abrupt("return", {
                data: null,
                error: _context6.t0
              });
            case 11:
              throw _context6.t0;
            case 12:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 7]]);
      }));
    }
  }]);
  return StorageBucketApi;
}();
exports["default"] = StorageBucketApi;

},{"../lib/constants":38,"../lib/errors":39,"../lib/fetch":40,"../lib/helpers":41}],45:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var errors_1 = require("../lib/errors");
var fetch_1 = require("../lib/fetch");
var helpers_1 = require("../lib/helpers");
var DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: 'name',
    order: 'asc'
  }
};
var DEFAULT_FILE_OPTIONS = {
  cacheControl: '3600',
  contentType: 'text/plain;charset=UTF-8',
  upsert: false
};
var StorageFileApi = /*#__PURE__*/function () {
  function StorageFileApi(url) {
    var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var bucketId = arguments.length > 2 ? arguments[2] : undefined;
    var fetch = arguments.length > 3 ? arguments[3] : undefined;
    _classCallCheck(this, StorageFileApi);
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = (0, helpers_1.resolveFetch)(fetch);
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  _createClass(StorageFileApi, [{
    key: "uploadOrUpdate",
    value: function uploadOrUpdate(method, path, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var body, options, headers, cleanPath, _path, res, error;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
              headers = Object.assign(Object.assign({}, this.headers), method === 'POST' && {
                'x-upsert': String(options.upsert)
              });
              if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {
                body = new FormData();
                body.append('cacheControl', options.cacheControl);
                body.append('', fileBody);
              } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {
                body = fileBody;
                body.append('cacheControl', options.cacheControl);
              } else {
                body = fileBody;
                headers['cache-control'] = "max-age=".concat(options.cacheControl);
                headers['content-type'] = options.contentType;
              }
              cleanPath = this._removeEmptyFolders(path);
              _path = this._getFinalPath(cleanPath);
              _context.next = 8;
              return this.fetch("".concat(this.url, "/object/").concat(_path), {
                method: method,
                body: body,
                headers: headers
              });
            case 8:
              res = _context.sent;
              if (!res.ok) {
                _context.next = 13;
                break;
              }
              return _context.abrupt("return", {
                data: {
                  path: cleanPath
                },
                error: null
              });
            case 13:
              _context.next = 15;
              return res.json();
            case 15:
              error = _context.sent;
              return _context.abrupt("return", {
                data: null,
                error: error
              });
            case 17:
              _context.next = 24;
              break;
            case 19:
              _context.prev = 19;
              _context.t0 = _context["catch"](0);
              if (!(0, errors_1.isStorageError)(_context.t0)) {
                _context.next = 23;
                break;
              }
              return _context.abrupt("return", {
                data: null,
                error: _context.t0
              });
            case 23:
              throw _context.t0;
            case 24:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 19]]);
      }));
    }
    /**
     * Uploads a file to an existing bucket.
     *
     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
     * @param fileBody The body of the file to be stored in the bucket.
     */
  }, {
    key: "upload",
    value: function upload(path, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.uploadOrUpdate('POST', path, fileBody, fileOptions));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
    }
    /**
     * Replaces an existing file at the specified path with a new one.
     *
     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
     * @param fileBody The body of the file to be stored in the bucket.
     */
  }, {
    key: "update",
    value: function update(path, fileBody, fileOptions) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.uploadOrUpdate('PUT', path, fileBody, fileOptions));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
    }
    /**
     * Moves an existing file to a new path in the same bucket.
     *
     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
     */
  }, {
    key: "move",
    value: function move(fromPath, toPath) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var data;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return (0, fetch_1.post)(this.fetch, "".concat(this.url, "/object/move"), {
                bucketId: this.bucketId,
                sourceKey: fromPath,
                destinationKey: toPath
              }, {
                headers: this.headers
              });
            case 3:
              data = _context4.sent;
              return _context4.abrupt("return", {
                data: data,
                error: null
              });
            case 7:
              _context4.prev = 7;
              _context4.t0 = _context4["catch"](0);
              if (!(0, errors_1.isStorageError)(_context4.t0)) {
                _context4.next = 11;
                break;
              }
              return _context4.abrupt("return", {
                data: null,
                error: _context4.t0
              });
            case 11:
              throw _context4.t0;
            case 12:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 7]]);
      }));
    }
    /**
     * Copies an existing file to a new path in the same bucket.
     *
     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
     */
  }, {
    key: "copy",
    value: function copy(fromPath, toPath) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var data;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return (0, fetch_1.post)(this.fetch, "".concat(this.url, "/object/copy"), {
                bucketId: this.bucketId,
                sourceKey: fromPath,
                destinationKey: toPath
              }, {
                headers: this.headers
              });
            case 3:
              data = _context5.sent;
              return _context5.abrupt("return", {
                data: {
                  path: data.Key
                },
                error: null
              });
            case 7:
              _context5.prev = 7;
              _context5.t0 = _context5["catch"](0);
              if (!(0, errors_1.isStorageError)(_context5.t0)) {
                _context5.next = 11;
                break;
              }
              return _context5.abrupt("return", {
                data: null,
                error: _context5.t0
              });
            case 11:
              throw _context5.t0;
            case 12:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 7]]);
      }));
    }
    /**
     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
     *
     * @param path The file path, including the current file name. For example `folder/image.png`.
     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
     * @param options.transform Transform the asset before serving it to the client.
     */
  }, {
    key: "createSignedUrl",
    value: function createSignedUrl(path, expiresIn, options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var _path, data, downloadQueryParam, signedUrl;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              _path = this._getFinalPath(path);
              _context6.next = 4;
              return (0, fetch_1.post)(this.fetch, "".concat(this.url, "/object/sign/").concat(_path), Object.assign({
                expiresIn: expiresIn
              }, (options === null || options === void 0 ? void 0 : options.transform) ? {
                transform: options.transform
              } : {}), {
                headers: this.headers
              });
            case 4:
              data = _context6.sent;
              downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? "&download=".concat(options.download === true ? '' : options.download) : '';
              signedUrl = encodeURI("".concat(this.url).concat(data.signedURL).concat(downloadQueryParam));
              data = {
                signedUrl: signedUrl
              };
              return _context6.abrupt("return", {
                data: data,
                error: null
              });
            case 11:
              _context6.prev = 11;
              _context6.t0 = _context6["catch"](0);
              if (!(0, errors_1.isStorageError)(_context6.t0)) {
                _context6.next = 15;
                break;
              }
              return _context6.abrupt("return", {
                data: null,
                error: _context6.t0
              });
            case 15:
              throw _context6.t0;
            case 16:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 11]]);
      }));
    }
    /**
     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
     *
     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
     */
  }, {
    key: "createSignedUrls",
    value: function createSignedUrls(paths, expiresIn, options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var _this = this;
        var data, downloadQueryParam;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return (0, fetch_1.post)(this.fetch, "".concat(this.url, "/object/sign/").concat(this.bucketId), {
                expiresIn: expiresIn,
                paths: paths
              }, {
                headers: this.headers
              });
            case 3:
              data = _context7.sent;
              downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? "&download=".concat(options.download === true ? '' : options.download) : '';
              return _context7.abrupt("return", {
                data: data.map(function (datum) {
                  return Object.assign(Object.assign({}, datum), {
                    signedUrl: datum.signedURL ? encodeURI("".concat(_this.url).concat(datum.signedURL).concat(downloadQueryParam)) : null
                  });
                }),
                error: null
              });
            case 8:
              _context7.prev = 8;
              _context7.t0 = _context7["catch"](0);
              if (!(0, errors_1.isStorageError)(_context7.t0)) {
                _context7.next = 12;
                break;
              }
              return _context7.abrupt("return", {
                data: null,
                error: _context7.t0
              });
            case 12:
              throw _context7.t0;
            case 13:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[0, 8]]);
      }));
    }
    /**
     * Downloads a file.
     *
     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
     * @param options.transform Transform the asset before serving it to the client.
     */
  }, {
    key: "download",
    value: function download(path, options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var wantsTransformation, renderPath, transformationQuery, queryString, _path, res, data;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';
              renderPath = wantsTransformation ? 'render/image/authenticated' : 'object';
              transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
              queryString = transformationQuery ? "?".concat(transformationQuery) : '';
              _context8.prev = 4;
              _path = this._getFinalPath(path);
              _context8.next = 8;
              return (0, fetch_1.get)(this.fetch, "".concat(this.url, "/").concat(renderPath, "/").concat(_path).concat(queryString), {
                headers: this.headers,
                noResolveJson: true
              });
            case 8:
              res = _context8.sent;
              _context8.next = 11;
              return res.blob();
            case 11:
              data = _context8.sent;
              return _context8.abrupt("return", {
                data: data,
                error: null
              });
            case 15:
              _context8.prev = 15;
              _context8.t0 = _context8["catch"](4);
              if (!(0, errors_1.isStorageError)(_context8.t0)) {
                _context8.next = 19;
                break;
              }
              return _context8.abrupt("return", {
                data: null,
                error: _context8.t0
              });
            case 19:
              throw _context8.t0;
            case 20:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[4, 15]]);
      }));
    }
    /**
     * Retrieves the URL for an asset in a public bucket.
     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
     *
     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
     * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
     * @param options.transform Transform the asset before serving it to the client.
     */
  }, {
    key: "getPublicUrl",
    value: function getPublicUrl(path, options) {
      var _path = this._getFinalPath(path);
      var _queryString = [];
      var downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? "download=".concat(options.download === true ? '' : options.download) : '';
      if (downloadQueryParam !== '') {
        _queryString.push(downloadQueryParam);
      }
      var wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';
      var renderPath = wantsTransformation ? 'render/image' : 'object';
      var transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      if (transformationQuery !== '') {
        _queryString.push(transformationQuery);
      }
      var queryString = _queryString.join('&');
      if (queryString !== '') {
        queryString = "?".concat(queryString);
      }
      return {
        data: {
          publicUrl: encodeURI("".concat(this.url, "/").concat(renderPath, "/public/").concat(_path).concat(queryString))
        }
      };
    }
    /**
     * Deletes files within the same bucket
     *
     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
     */
  }, {
    key: "remove",
    value: function remove(paths) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var data;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              _context9.next = 3;
              return (0, fetch_1.remove)(this.fetch, "".concat(this.url, "/object/").concat(this.bucketId), {
                prefixes: paths
              }, {
                headers: this.headers
              });
            case 3:
              data = _context9.sent;
              return _context9.abrupt("return", {
                data: data,
                error: null
              });
            case 7:
              _context9.prev = 7;
              _context9.t0 = _context9["catch"](0);
              if (!(0, errors_1.isStorageError)(_context9.t0)) {
                _context9.next = 11;
                break;
              }
              return _context9.abrupt("return", {
                data: null,
                error: _context9.t0
              });
            case 11:
              throw _context9.t0;
            case 12:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[0, 7]]);
      }));
    }
    /**
     * Get file metadata
     * @param id the file id to retrieve metadata
     */
    // async getMetadata(
    //   id: string
    // ): Promise<
    //   | {
    //       data: Metadata
    //       error: null
    //     }
    //   | {
    //       data: null
    //       error: StorageError
    //     }
    // > {
    //   try {
    //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
    //     return { data, error: null }
    //   } catch (error) {
    //     if (isStorageError(error)) {
    //       return { data: null, error }
    //     }
    //     throw error
    //   }
    // }
    /**
     * Update file metadata
     * @param id the file id to update metadata
     * @param meta the new file metadata
     */
    // async updateMetadata(
    //   id: string,
    //   meta: Metadata
    // ): Promise<
    //   | {
    //       data: Metadata
    //       error: null
    //     }
    //   | {
    //       data: null
    //       error: StorageError
    //     }
    // > {
    //   try {
    //     const data = await post(
    //       this.fetch,
    //       `${this.url}/metadata/${id}`,
    //       { ...meta },
    //       { headers: this.headers }
    //     )
    //     return { data, error: null }
    //   } catch (error) {
    //     if (isStorageError(error)) {
    //       return { data: null, error }
    //     }
    //     throw error
    //   }
    // }
    /**
     * Lists all the files within a bucket.
     * @param path The folder path.
     */
  }, {
    key: "list",
    value: function list(path, options, parameters) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var body, data;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.prev = 0;
              body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), {
                prefix: path || ''
              });
              _context10.next = 4;
              return (0, fetch_1.post)(this.fetch, "".concat(this.url, "/object/list/").concat(this.bucketId), body, {
                headers: this.headers
              }, parameters);
            case 4:
              data = _context10.sent;
              return _context10.abrupt("return", {
                data: data,
                error: null
              });
            case 8:
              _context10.prev = 8;
              _context10.t0 = _context10["catch"](0);
              if (!(0, errors_1.isStorageError)(_context10.t0)) {
                _context10.next = 12;
                break;
              }
              return _context10.abrupt("return", {
                data: null,
                error: _context10.t0
              });
            case 12:
              throw _context10.t0;
            case 13:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this, [[0, 8]]);
      }));
    }
  }, {
    key: "_getFinalPath",
    value: function _getFinalPath(path) {
      return "".concat(this.bucketId, "/").concat(path);
    }
  }, {
    key: "_removeEmptyFolders",
    value: function _removeEmptyFolders(path) {
      return path.replace(/^\/|\/$/g, '').replace(/\/+/g, '/');
    }
  }, {
    key: "transformOptsToQueryString",
    value: function transformOptsToQueryString(transform) {
      var params = [];
      if (transform.width) {
        params.push("width=".concat(transform.width));
      }
      if (transform.height) {
        params.push("height=".concat(transform.height));
      }
      if (transform.resize) {
        params.push("resize=".concat(transform.resize));
      }
      return params.join('&');
    }
  }]);
  return StorageFileApi;
}();
exports["default"] = StorageFileApi;

},{"../lib/errors":39,"../lib/fetch":40,"../lib/helpers":41}],46:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var functions_js_1 = require("@supabase/functions-js");
var postgrest_js_1 = require("@supabase/postgrest-js");
var realtime_js_1 = require("@supabase/realtime-js");
var storage_js_1 = require("@supabase/storage-js");
var constants_1 = require("./lib/constants");
var fetch_1 = require("./lib/fetch");
var helpers_1 = require("./lib/helpers");
var SupabaseAuthClient_1 = require("./lib/SupabaseAuthClient");
var DEFAULT_GLOBAL_OPTIONS = {
  headers: constants_1.DEFAULT_HEADERS
};
var DEFAULT_DB_OPTIONS = {
  schema: 'public'
};
var DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true
};
var DEFAULT_REALTIME_OPTIONS = {};
/**
 * Supabase Client.
 *
 * An isomorphic Javascript client for interacting with Postgres.
 */
var SupabaseClient = /*#__PURE__*/function () {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  function SupabaseClient(supabaseUrl, supabaseKey, options) {
    _classCallCheck(this, SupabaseClient);
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    if (!supabaseUrl) throw new Error('supabaseUrl is required.');
    if (!supabaseKey) throw new Error('supabaseKey is required.');
    var _supabaseUrl = (0, helpers_1.stripTrailingSlash)(supabaseUrl);
    this.realtimeUrl = "".concat(_supabaseUrl, "/realtime/v1").replace(/^http/i, 'ws');
    this.authUrl = "".concat(_supabaseUrl, "/auth/v1");
    this.storageUrl = "".concat(_supabaseUrl, "/storage/v1");
    var isPlatform = _supabaseUrl.match(/(supabase\.co)|(supabase\.in)/);
    if (isPlatform) {
      var urlParts = _supabaseUrl.split('.');
      this.functionsUrl = "".concat(urlParts[0], ".functions.").concat(urlParts[1], ".").concat(urlParts[2]);
    } else {
      this.functionsUrl = "".concat(_supabaseUrl, "/functions/v1");
    }
    // default storage key uses the supabase project ref as a namespace
    var defaultStorageKey = "sb-".concat(new URL(this.authUrl).hostname.split('.')[0], "-auth-token");
    var DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), {
        storageKey: defaultStorageKey
      }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    var settings = (0, helpers_1.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_b = (_a = settings.auth) === null || _a === void 0 ? void 0 : _a.storageKey) !== null && _b !== void 0 ? _b : '';
    this.headers = (_d = (_c = settings.global) === null || _c === void 0 ? void 0 : _c.headers) !== null && _d !== void 0 ? _d : {};
    this.auth = this._initSupabaseAuthClient((_e = settings.auth) !== null && _e !== void 0 ? _e : {}, this.headers, (_f = settings.global) === null || _f === void 0 ? void 0 : _f.fetch);
    this.fetch = (0, fetch_1.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), (_g = settings.global) === null || _g === void 0 ? void 0 : _g.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({
      headers: this.headers
    }, settings.realtime));
    this.rest = new postgrest_js_1.PostgrestClient("".concat(_supabaseUrl, "/rest/v1"), {
      headers: this.headers,
      schema: (_h = settings.db) === null || _h === void 0 ? void 0 : _h.schema,
      fetch: this.fetch
    });
    this._listenForAuthEvents();
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  _createClass(SupabaseClient, [{
    key: "functions",
    get: function get() {
      return new functions_js_1.FunctionsClient(this.functionsUrl, {
        headers: this.headers,
        customFetch: this.fetch
      });
    }
    /**
     * Supabase Storage allows you to manage user-generated content, such as photos or videos.
     */
  }, {
    key: "storage",
    get: function get() {
      return new storage_js_1.StorageClient(this.storageUrl, this.headers, this.fetch);
    }
  }, {
    key: "from",
    value: function from(relation) {
      return this.rest.from(relation);
    }
    /**
     * Perform a function call.
     *
     * @param fn  The function name to call.
     * @param args  The parameters to pass to the function call.
     * @param options.head   When set to true, no data will be returned.
     * @param options.count  Count algorithm to use to count rows in a table.
     *
     */
  }, {
    key: "rpc",
    value: function rpc(fn) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 ? arguments[2] : undefined;
      return this.rest.rpc(fn, args, options);
    }
    /**
     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
     *
     * @param {string} name - The name of the Realtime channel.
     * @param {Object} opts - The options to pass to the Realtime channel.
     *
     */
  }, {
    key: "channel",
    value: function channel(name) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        config: {}
      };
      return this.realtime.channel(name, opts);
    }
    /**
     * Returns all Realtime channels.
     */
  }, {
    key: "getChannels",
    value: function getChannels() {
      return this.realtime.getChannels();
    }
    /**
     * Unsubscribes and removes Realtime channel from Realtime client.
     *
     * @param {RealtimeChannel} channel - The name of the Realtime channel.
     *
     */
  }, {
    key: "removeChannel",
    value: function removeChannel(channel) {
      return this.realtime.removeChannel(channel);
    }
    /**
     * Unsubscribes and removes all Realtime channels from Realtime client.
     */
  }, {
    key: "removeAllChannels",
    value: function removeAllChannels() {
      return this.realtime.removeAllChannels();
    }
  }, {
    key: "_getAccessToken",
    value: function _getAccessToken() {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _yield$this$auth$getS, data;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.auth.getSession();
            case 2:
              _yield$this$auth$getS = _context.sent;
              data = _yield$this$auth$getS.data;
              return _context.abrupt("return", (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "_initSupabaseAuthClient",
    value: function _initSupabaseAuthClient(_ref, headers, fetch) {
      var autoRefreshToken = _ref.autoRefreshToken,
        persistSession = _ref.persistSession,
        detectSessionInUrl = _ref.detectSessionInUrl,
        storage = _ref.storage,
        storageKey = _ref.storageKey;
      var authHeaders = {
        Authorization: "Bearer ".concat(this.supabaseKey),
        apikey: "".concat(this.supabaseKey)
      };
      return new SupabaseAuthClient_1.SupabaseAuthClient({
        url: this.authUrl,
        headers: Object.assign(Object.assign({}, authHeaders), headers),
        storageKey: storageKey,
        autoRefreshToken: autoRefreshToken,
        persistSession: persistSession,
        detectSessionInUrl: detectSessionInUrl,
        storage: storage,
        fetch: fetch
      });
    }
  }, {
    key: "_initRealtimeClient",
    value: function _initRealtimeClient(options) {
      return new realtime_js_1.RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {
        params: Object.assign({
          apikey: this.supabaseKey
        }, options === null || options === void 0 ? void 0 : options.params)
      }));
    }
  }, {
    key: "_listenForAuthEvents",
    value: function _listenForAuthEvents() {
      var _this = this;
      var data = this.auth.onAuthStateChange(function (event, session) {
        _this._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, 'CLIENT');
      });
      return data;
    }
  }, {
    key: "_handleTokenChanged",
    value: function _handleTokenChanged(event, token, source) {
      if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {
        // Token has changed
        this.realtime.setAuth(token !== null && token !== void 0 ? token : null);
        this.changedAccessToken = token;
      } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {
        // Token is removed
        this.realtime.setAuth(this.supabaseKey);
        if (source == 'STORAGE') this.auth.signOut();
      }
    }
  }]);
  return SupabaseClient;
}();
exports["default"] = SupabaseClient;

},{"./lib/SupabaseAuthClient":48,"./lib/constants":49,"./lib/fetch":50,"./lib/helpers":51,"@supabase/functions-js":5,"@supabase/postgrest-js":24,"@supabase/realtime-js":29,"@supabase/storage-js":37}],47:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createClient = exports.SupabaseClient = exports.FunctionsError = exports.FunctionsRelayError = exports.FunctionsFetchError = exports.FunctionsHttpError = void 0;
var SupabaseClient_1 = __importDefault(require("./SupabaseClient"));
__exportStar(require("@supabase/gotrue-js"), exports);
var functions_js_1 = require("@supabase/functions-js");
Object.defineProperty(exports, "FunctionsHttpError", {
  enumerable: true,
  get: function get() {
    return functions_js_1.FunctionsHttpError;
  }
});
Object.defineProperty(exports, "FunctionsFetchError", {
  enumerable: true,
  get: function get() {
    return functions_js_1.FunctionsFetchError;
  }
});
Object.defineProperty(exports, "FunctionsRelayError", {
  enumerable: true,
  get: function get() {
    return functions_js_1.FunctionsRelayError;
  }
});
Object.defineProperty(exports, "FunctionsError", {
  enumerable: true,
  get: function get() {
    return functions_js_1.FunctionsError;
  }
});
__exportStar(require("@supabase/realtime-js"), exports);
var SupabaseClient_2 = require("./SupabaseClient");
Object.defineProperty(exports, "SupabaseClient", {
  enumerable: true,
  get: function get() {
    return __importDefault(SupabaseClient_2)["default"];
  }
});
/**
 * Creates a new Supabase Client.
 */
var createClient = function createClient(supabaseUrl, supabaseKey, options) {
  return new SupabaseClient_1["default"](supabaseUrl, supabaseKey, options);
};
exports.createClient = createClient;

},{"./SupabaseClient":46,"@supabase/functions-js":5,"@supabase/gotrue-js":9,"@supabase/realtime-js":29}],48:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SupabaseAuthClient = void 0;
var gotrue_js_1 = require("@supabase/gotrue-js");
var SupabaseAuthClient = /*#__PURE__*/function (_gotrue_js_1$GoTrueCl) {
  _inherits(SupabaseAuthClient, _gotrue_js_1$GoTrueCl);
  var _super = _createSuper(SupabaseAuthClient);
  function SupabaseAuthClient(options) {
    _classCallCheck(this, SupabaseAuthClient);
    return _super.call(this, options);
  }
  return _createClass(SupabaseAuthClient);
}(gotrue_js_1.GoTrueClient);
exports.SupabaseAuthClient = SupabaseAuthClient;

},{"@supabase/gotrue-js":9}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_HEADERS = void 0;
// constants.ts
var version_1 = require("./version");
exports.DEFAULT_HEADERS = {
  'X-Client-Info': "supabase-js/".concat(version_1.version)
};

},{"./version":52}],50:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchWithAuth = exports.resolveHeadersConstructor = exports.resolveFetch = void 0;
var cross_fetch_1 = __importStar(require("cross-fetch"));
var resolveFetch = function resolveFetch(customFetch) {
  var _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = cross_fetch_1["default"];
  } else {
    _fetch = fetch;
  }
  return function () {
    return _fetch.apply(void 0, arguments);
  };
};
exports.resolveFetch = resolveFetch;
var resolveHeadersConstructor = function resolveHeadersConstructor() {
  if (typeof Headers === 'undefined') {
    return cross_fetch_1.Headers;
  }
  return Headers;
};
exports.resolveHeadersConstructor = resolveHeadersConstructor;
var fetchWithAuth = function fetchWithAuth(supabaseKey, getAccessToken, customFetch) {
  var fetch = (0, exports.resolveFetch)(customFetch);
  var HeadersConstructor = (0, exports.resolveHeadersConstructor)();
  return function (input, init) {
    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _a, accessToken, headers;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return getAccessToken();
          case 2:
            _context.t1 = _a = _context.sent;
            _context.t0 = _context.t1 !== null;
            if (!_context.t0) {
              _context.next = 6;
              break;
            }
            _context.t0 = _a !== void 0;
          case 6:
            if (!_context.t0) {
              _context.next = 10;
              break;
            }
            _context.t2 = _a;
            _context.next = 11;
            break;
          case 10:
            _context.t2 = supabaseKey;
          case 11:
            accessToken = _context.t2;
            headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
            if (!headers.has('apikey')) {
              headers.set('apikey', supabaseKey);
            }
            if (!headers.has('Authorization')) {
              headers.set('Authorization', "Bearer ".concat(accessToken));
            }
            return _context.abrupt("return", fetch(input, Object.assign(Object.assign({}, init), {
              headers: headers
            })));
          case 16:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
  };
};
exports.fetchWithAuth = fetchWithAuth;

},{"cross-fetch":59}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applySettingDefaults = exports.isBrowser = exports.stripTrailingSlash = exports.uuid = void 0;
function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
      v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
exports.uuid = uuid;
function stripTrailingSlash(url) {
  return url.replace(/\/$/, '');
}
exports.stripTrailingSlash = stripTrailingSlash;
var isBrowser = function isBrowser() {
  return typeof window !== 'undefined';
};
exports.isBrowser = isBrowser;
function applySettingDefaults(options, defaults) {
  var dbOptions = options.db,
    authOptions = options.auth,
    realtimeOptions = options.realtime,
    globalOptions = options.global;
  var DEFAULT_DB_OPTIONS = defaults.db,
    DEFAULT_AUTH_OPTIONS = defaults.auth,
    DEFAULT_REALTIME_OPTIONS = defaults.realtime,
    DEFAULT_GLOBAL_OPTIONS = defaults.global;
  return {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),
    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions)
  };
}
exports.applySettingDefaults = applySettingDefaults;

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = '2.2.2';

},{}],53:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}

},{}],54:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var base64 = require('base64-js');
var ieee754 = require('ieee754');
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}
Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  buf.__proto__ = Buffer.prototype;
  return buf;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}
Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value);
  }
  if (value == null) {
    throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }
  var b = fromObject(value);
  if (b) return b;
  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }
  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}
function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }
  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype;
  return buf;
}
function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}
function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf);
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
  }
  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
        return asciiWrite(this, string, offset, length);
      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf = this.subarray(start, end);
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype;
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0];
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":53,"buffer":54,"ieee754":64}],55:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var assert = require('assert');
var LRU = require('nanolru');
module.exports = ChooComponentCache;
function ChooComponentCache(state, emit, lru) {
  assert.ok(this instanceof ChooComponentCache, 'ChooComponentCache should be created with `new`');
  assert.equal(_typeof(state), 'object', 'ChooComponentCache: state should be type object');
  assert.equal(_typeof(emit), 'function', 'ChooComponentCache: emit should be type function');
  if (typeof lru === 'number') this.cache = new LRU(lru);else this.cache = lru || new LRU(100);
  this.state = state;
  this.emit = emit;
}

// Get & create component instances.
ChooComponentCache.prototype.render = function (Component, id) {
  assert.equal(_typeof(Component), 'function', 'ChooComponentCache.render: Component should be type function');
  assert.ok(typeof id === 'string' || typeof id === 'number', 'ChooComponentCache.render: id should be type string or type number');
  var el = this.cache.get(id);
  if (!el) {
    var args = [];
    for (var i = 2, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    args.unshift(Component, id, this.state, this.emit);
    el = newCall.apply(newCall, args);
    this.cache.set(id, el);
  }
  return el;
};

// Because you can't call `new` and `.apply()` at the same time. This is a mad
// hack, but hey it works so we gonna go for it. Whoop.
function newCall(Cls) {
  return new (Cls.bind.apply(Cls, arguments))(); // eslint-disable-line
}

},{"assert":65,"nanolru":75}],56:[function(require,module,exports){
"use strict";

module.exports = require('nanohtml');

},{"nanohtml":70}],57:[function(require,module,exports){
"use strict";

module.exports = require('nanohtml/raw');

},{"nanohtml/raw":73}],58:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var scrollToAnchor = require('scroll-to-anchor');
var documentReady = require('document-ready');
var nanotiming = require('nanotiming');
var nanorouter = require('nanorouter');
var nanomorph = require('nanomorph');
var nanoquery = require('nanoquery');
var nanohref = require('nanohref');
var nanoraf = require('nanoraf');
var nanobus = require('nanobus');
var assert = require('assert');
var Cache = require('./component/cache');
module.exports = Choo;
var HISTORY_OBJECT = {};
function Choo(opts) {
  var timing = nanotiming('choo.constructor');
  if (!(this instanceof Choo)) return new Choo(opts);
  opts = opts || {};
  assert.equal(_typeof(opts), 'object', 'choo: opts should be type object');
  var self = this;

  // define events used by choo
  this._events = {
    DOMCONTENTLOADED: 'DOMContentLoaded',
    DOMTITLECHANGE: 'DOMTitleChange',
    REPLACESTATE: 'replaceState',
    PUSHSTATE: 'pushState',
    NAVIGATE: 'navigate',
    POPSTATE: 'popState',
    RENDER: 'render'
  };

  // properties for internal use only
  this._historyEnabled = opts.history === undefined ? true : opts.history;
  this._hrefEnabled = opts.href === undefined ? true : opts.href;
  this._hashEnabled = opts.hash === undefined ? false : opts.hash;
  this._hasWindow = typeof window !== 'undefined';
  this._cache = opts.cache;
  this._loaded = false;
  this._stores = [ondomtitlechange];
  this._tree = null;

  // state
  var _state = {
    events: this._events,
    components: {}
  };
  if (this._hasWindow) {
    this.state = window.initialState ? Object.assign({}, window.initialState, _state) : _state;
    delete window.initialState;
  } else {
    this.state = _state;
  }

  // properties that are part of the API
  this.router = nanorouter({
    curry: true
  });
  this.emitter = nanobus('choo.emit');
  this.emit = this.emitter.emit.bind(this.emitter);

  // listen for title changes; available even when calling .toString()
  if (this._hasWindow) this.state.title = document.title;
  function ondomtitlechange(state) {
    self.emitter.prependListener(self._events.DOMTITLECHANGE, function (title) {
      assert.equal(_typeof(title), 'string', 'events.DOMTitleChange: title should be type string');
      state.title = title;
      if (self._hasWindow) document.title = title;
    });
  }
  timing();
}
Choo.prototype.route = function (route, handler) {
  var routeTiming = nanotiming("choo.route('" + route + "')");
  assert.equal(_typeof(route), 'string', 'choo.route: route should be type string');
  assert.equal(_typeof(handler), 'function', 'choo.handler: route should be type function');
  this.router.on(route, handler);
  routeTiming();
};
Choo.prototype.use = function (cb) {
  assert.equal(_typeof(cb), 'function', 'choo.use: cb should be type function');
  var self = this;
  this._stores.push(function (state) {
    var msg = 'choo.use';
    msg = cb.storeName ? msg + '(' + cb.storeName + ')' : msg;
    var endTiming = nanotiming(msg);
    cb(state, self.emitter, self);
    endTiming();
  });
};
Choo.prototype.start = function () {
  assert.equal(typeof window === "undefined" ? "undefined" : _typeof(window), 'object', 'choo.start: window was not found. .start() must be called in a browser, use .toString() if running in Node');
  var startTiming = nanotiming('choo.start');
  var self = this;
  if (this._historyEnabled) {
    this.emitter.prependListener(this._events.NAVIGATE, function () {
      self._matchRoute(self.state);
      if (self._loaded) {
        self.emitter.emit(self._events.RENDER);
        setTimeout(scrollToAnchor.bind(null, window.location.hash), 0);
      }
    });
    this.emitter.prependListener(this._events.POPSTATE, function () {
      self.emitter.emit(self._events.NAVIGATE);
    });
    this.emitter.prependListener(this._events.PUSHSTATE, function (href) {
      assert.equal(_typeof(href), 'string', 'events.pushState: href should be type string');
      window.history.pushState(HISTORY_OBJECT, null, href);
      self.emitter.emit(self._events.NAVIGATE);
    });
    this.emitter.prependListener(this._events.REPLACESTATE, function (href) {
      assert.equal(_typeof(href), 'string', 'events.replaceState: href should be type string');
      window.history.replaceState(HISTORY_OBJECT, null, href);
      self.emitter.emit(self._events.NAVIGATE);
    });
    window.onpopstate = function () {
      self.emitter.emit(self._events.POPSTATE);
    };
    if (self._hrefEnabled) {
      nanohref(function (location) {
        var href = location.href;
        var hash = location.hash;
        if (href === window.location.href) {
          if (!self._hashEnabled && hash) scrollToAnchor(hash);
          return;
        }
        self.emitter.emit(self._events.PUSHSTATE, href);
      });
    }
  }
  this._setCache(this.state);
  this._matchRoute(this.state);
  this._stores.forEach(function (initStore) {
    initStore(self.state);
  });
  this._tree = this._prerender(this.state);
  assert.ok(this._tree, 'choo.start: no valid DOM node returned for location ' + this.state.href);
  this.emitter.prependListener(self._events.RENDER, nanoraf(function () {
    var renderTiming = nanotiming('choo.render');
    var newTree = self._prerender(self.state);
    assert.ok(newTree, 'choo.render: no valid DOM node returned for location ' + self.state.href);
    assert.equal(self._tree.nodeName, newTree.nodeName, 'choo.render: The target node <' + self._tree.nodeName.toLowerCase() + '> is not the same type as the new node <' + newTree.nodeName.toLowerCase() + '>.');
    var morphTiming = nanotiming('choo.morph');
    nanomorph(self._tree, newTree);
    morphTiming();
    renderTiming();
  }));
  documentReady(function () {
    self.emitter.emit(self._events.DOMCONTENTLOADED);
    self._loaded = true;
  });
  startTiming();
  return this._tree;
};
Choo.prototype.mount = function mount(selector) {
  var mountTiming = nanotiming("choo.mount('" + selector + "')");
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== 'object') {
    assert.ok(typeof selector === 'string', 'choo.mount: selector should be type String');
    this.selector = selector;
    mountTiming();
    return this;
  }
  assert.ok(typeof selector === 'string' || _typeof(selector) === 'object', 'choo.mount: selector should be type String or HTMLElement');
  var self = this;
  documentReady(function () {
    var renderTiming = nanotiming('choo.render');
    var newTree = self.start();
    if (typeof selector === 'string') {
      self._tree = document.querySelector(selector);
    } else {
      self._tree = selector;
    }
    assert.ok(self._tree, 'choo.mount: could not query selector: ' + selector);
    assert.equal(self._tree.nodeName, newTree.nodeName, 'choo.mount: The target node <' + self._tree.nodeName.toLowerCase() + '> is not the same type as the new node <' + newTree.nodeName.toLowerCase() + '>.');
    var morphTiming = nanotiming('choo.morph');
    nanomorph(self._tree, newTree);
    morphTiming();
    renderTiming();
  });
  mountTiming();
};
Choo.prototype.toString = function (location, state) {
  state = state || {};
  state.components = state.components || {};
  state.events = Object.assign({}, state.events, this._events);
  assert.notEqual(typeof window === "undefined" ? "undefined" : _typeof(window), 'object', 'choo.mount: window was found. .toString() must be called in Node, use .start() or .mount() if running in the browser');
  assert.equal(_typeof(location), 'string', 'choo.toString: location should be type string');
  assert.equal(_typeof(state), 'object', 'choo.toString: state should be type object');
  this._setCache(state);
  this._matchRoute(state, location);
  this.emitter.removeAllListeners();
  this._stores.forEach(function (initStore) {
    initStore(state);
  });
  var html = this._prerender(state);
  assert.ok(html, 'choo.toString: no valid value returned for the route ' + location);
  assert(!Array.isArray(html), 'choo.toString: return value was an array for the route ' + location);
  return typeof html.outerHTML === 'string' ? html.outerHTML : html.toString();
};
Choo.prototype._matchRoute = function (state, locationOverride) {
  var location, queryString;
  if (locationOverride) {
    location = locationOverride.replace(/\?.+$/, '').replace(/\/$/, '');
    if (!this._hashEnabled) location = location.replace(/#.+$/, '');
    queryString = locationOverride;
  } else {
    location = window.location.pathname.replace(/\/$/, '');
    if (this._hashEnabled) location += window.location.hash.replace(/^#/, '/');
    queryString = window.location.search;
  }
  var matched = this.router.match(location);
  this._handler = matched.cb;
  state.href = location;
  state.query = nanoquery(queryString);
  state.route = matched.route;
  state.params = matched.params;
};
Choo.prototype._prerender = function (state) {
  var routeTiming = nanotiming("choo.prerender('" + state.route + "')");
  var res = this._handler(state, this.emit);
  routeTiming();
  return res;
};
Choo.prototype._setCache = function (state) {
  var cache = new Cache(state, this.emitter.emit.bind(this.emitter), this._cache);
  state.cache = renderComponent;
  function renderComponent(Component, id) {
    assert.equal(_typeof(Component), 'function', 'choo.state.cache: Component should be type function');
    var args = [];
    for (var i = 0, len = arguments.length; i < len; i++) {
      args.push(arguments[i]);
    }
    return cache.render.apply(cache, args);
  }

  // When the state gets stringified, make sure `state.cache` isn't
  // stringified too.
  renderComponent.toJSON = function () {
    return null;
  };
};

},{"./component/cache":55,"assert":65,"document-ready":60,"nanobus":66,"nanohref":67,"nanomorph":76,"nanoquery":79,"nanoraf":80,"nanorouter":81,"nanotiming":83,"scroll-to-anchor":85}],59:[function(require,module,exports){
"use strict";

var global = typeof self !== 'undefined' ? self : void 0;
var __self__ = function () {
  function F() {
    this.fetch = false;
    this.DOMException = global.DOMException;
  }
  F.prototype = global;
  return new F();
}();
(function (self) {
  var irrelevant = function (exports) {
    var support = {
      searchParams: 'URLSearchParams' in self,
      iterable: 'Symbol' in self && 'iterator' in Symbol,
      blob: 'FileReader' in self && 'Blob' in self && function () {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: 'FormData' in self,
      arrayBuffer: 'ArrayBuffer' in self
    };
    function isDataView(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj);
    }
    if (support.arrayBuffer) {
      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];
      var isArrayBufferView = ArrayBuffer.isView || function (obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }
    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }
      if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
      }
      return name.toLowerCase();
    }
    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }
      return value;
    }

    // Build a destructive iterator for the value list
    function iteratorFor(items) {
      var iterator = {
        next: function next() {
          var value = items.shift();
          return {
            done: value === undefined,
            value: value
          };
        }
      };
      if (support.iterable) {
        iterator[Symbol.iterator] = function () {
          return iterator;
        };
      }
      return iterator;
    }
    function Headers(headers) {
      this.map = {};
      if (headers instanceof Headers) {
        headers.forEach(function (value, name) {
          this.append(name, value);
        }, this);
      } else if (Array.isArray(headers)) {
        headers.forEach(function (header) {
          this.append(header[0], header[1]);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function (name) {
          this.append(name, headers[name]);
        }, this);
      }
    }
    Headers.prototype.append = function (name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ', ' + value : value;
    };
    Headers.prototype['delete'] = function (name) {
      delete this.map[normalizeName(name)];
    };
    Headers.prototype.get = function (name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null;
    };
    Headers.prototype.has = function (name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers.prototype.set = function (name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };
    Headers.prototype.forEach = function (callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };
    Headers.prototype.keys = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };
    Headers.prototype.values = function () {
      var items = [];
      this.forEach(function (value) {
        items.push(value);
      });
      return iteratorFor(items);
    };
    Headers.prototype.entries = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };
    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }
    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }
      body.bodyUsed = true;
    }
    function fileReaderReady(reader) {
      return new Promise(function (resolve, reject) {
        reader.onload = function () {
          resolve(reader.result);
        };
        reader.onerror = function () {
          reject(reader.error);
        };
      });
    }
    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise;
    }
    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise;
    }
    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);
      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }
      return chars.join('');
    }
    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0);
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
      }
    }
    function Body() {
      this.bodyUsed = false;
      this._initBody = function (body) {
        this._bodyInit = body;
        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          // IE 10-11 can't handle a DataView body.
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          this._bodyText = body = Object.prototype.toString.call(body);
        }
        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };
      if (support.blob) {
        this.blob = function () {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob');
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };
        this.arrayBuffer = function () {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
          } else {
            return this.blob().then(readBlobAsArrayBuffer);
          }
        };
      }
      this.text = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }
        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };
      if (support.formData) {
        this.formData = function () {
          return this.text().then(decode);
        };
      }
      this.json = function () {
        return this.text().then(JSON.parse);
      };
      return this;
    }

    // HTTP methods whose capitalization should be normalized
    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method;
    }
    function Request(input, options) {
      options = options || {};
      var body = options.body;
      if (input instanceof Request) {
        if (input.bodyUsed) {
          throw new TypeError('Already read');
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        this.signal = input.signal;
        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      } else {
        this.url = String(input);
      }
      this.credentials = options.credentials || this.credentials || 'same-origin';
      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }
      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.signal = options.signal || this.signal;
      this.referrer = null;
      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests');
      }
      this._initBody(body);
    }
    Request.prototype.clone = function () {
      return new Request(this, {
        body: this._bodyInit
      });
    };
    function decode(body) {
      var form = new FormData();
      body.trim().split('&').forEach(function (bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form;
    }
    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
      // https://tools.ietf.org/html/rfc7230#section-3.2
      var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
      preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers;
    }
    Body.call(Request.prototype);
    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }
      this.type = 'default';
      this.status = options.status === undefined ? 200 : options.status;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = 'statusText' in options ? options.statusText : 'OK';
      this.headers = new Headers(options.headers);
      this.url = options.url || '';
      this._initBody(bodyInit);
    }
    Body.call(Response.prototype);
    Response.prototype.clone = function () {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };
    Response.error = function () {
      var response = new Response(null, {
        status: 0,
        statusText: ''
      });
      response.type = 'error';
      return response;
    };
    var redirectStatuses = [301, 302, 303, 307, 308];
    Response.redirect = function (url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code');
      }
      return new Response(null, {
        status: status,
        headers: {
          location: url
        }
      });
    };
    exports.DOMException = self.DOMException;
    try {
      new exports.DOMException();
    } catch (err) {
      exports.DOMException = function (message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };
      exports.DOMException.prototype = Object.create(Error.prototype);
      exports.DOMException.prototype.constructor = exports.DOMException;
    }
    function fetch(input, init) {
      return new Promise(function (resolve, reject) {
        var request = new Request(input, init);
        if (request.signal && request.signal.aborted) {
          return reject(new exports.DOMException('Aborted', 'AbortError'));
        }
        var xhr = new XMLHttpRequest();
        function abortXhr() {
          xhr.abort();
        }
        xhr.onload = function () {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          resolve(new Response(body, options));
        };
        xhr.onerror = function () {
          reject(new TypeError('Network request failed'));
        };
        xhr.ontimeout = function () {
          reject(new TypeError('Network request failed'));
        };
        xhr.onabort = function () {
          reject(new exports.DOMException('Aborted', 'AbortError'));
        };
        xhr.open(request.method, request.url, true);
        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        } else if (request.credentials === 'omit') {
          xhr.withCredentials = false;
        }
        if ('responseType' in xhr && support.blob) {
          xhr.responseType = 'blob';
        }
        request.headers.forEach(function (value, name) {
          xhr.setRequestHeader(name, value);
        });
        if (request.signal) {
          request.signal.addEventListener('abort', abortXhr);
          xhr.onreadystatechange = function () {
            // DONE (success or failure)
            if (xhr.readyState === 4) {
              request.signal.removeEventListener('abort', abortXhr);
            }
          };
        }
        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      });
    }
    fetch.polyfill = true;
    if (!self.fetch) {
      self.fetch = fetch;
      self.Headers = Headers;
      self.Request = Request;
      self.Response = Response;
    }
    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response;
    exports.fetch = fetch;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    return exports;
  }({});
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
exports["default"] = ctx.fetch; // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers;
exports.Request = ctx.Request;
exports.Response = ctx.Response;
module.exports = exports;

},{}],60:[function(require,module,exports){
'use strict';

module.exports = ready;
function ready(callback) {
  if (typeof document === 'undefined') {
    throw new Error('document-ready only runs in the browser');
  }
  var state = document.readyState;
  if (state === 'complete' || state === 'interactive') {
    return setTimeout(callback, 0);
  }
  document.addEventListener('DOMContentLoaded', function onLoad() {
    callback();
  });
}

},{}],61:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var naiveFallback = function naiveFallback() {
  if ((typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self) return self;
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window) return window;
  throw new Error("Unable to resolve global `this`");
};
module.exports = function () {
  if (this) return this;

  // Unexpected strict mode (may happen if e.g. bundled into ESM module)

  // Fallback to standard globalThis if available
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object" && globalThis) return globalThis;

  // Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
  // In all ES5+ engines global object inherits from Object.prototype
  // (if you approached one that doesn't please report)
  try {
    Object.defineProperty(Object.prototype, "__global__", {
      get: function get() {
        return this;
      },
      configurable: true
    });
  } catch (error) {
    // Unfortunate case of updates to Object.prototype being restricted
    // via preventExtensions, seal or freeze
    return naiveFallback();
  }
  try {
    // Safari case (window.__global__ works, but __global__ does not)
    if (!__global__) return naiveFallback();
    return __global__;
  } finally {
    delete Object.prototype.__global__;
  }
}();

},{}],62:[function(require,module,exports){
"use strict";

module.exports = attributeToProperty;
var transform = {
  'class': 'className',
  'for': 'htmlFor',
  'http-equiv': 'httpEquiv'
};
function attributeToProperty(h) {
  return function (tagName, attrs, children) {
    for (var attr in attrs) {
      if (attr in transform) {
        attrs[transform[attr]] = attrs[attr];
        delete attrs[attr];
      }
    }
    return h(tagName, attrs, children);
  };
}

},{}],63:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var attrToProp = require('hyperscript-attribute-to-property');
var VAR = 0,
  TEXT = 1,
  OPEN = 2,
  CLOSE = 3,
  ATTR = 4;
var ATTR_KEY = 5,
  ATTR_KEY_W = 6;
var ATTR_VALUE_W = 7,
  ATTR_VALUE = 8;
var ATTR_VALUE_SQ = 9,
  ATTR_VALUE_DQ = 10;
var ATTR_EQ = 11,
  ATTR_BREAK = 12;
var COMMENT = 13;
module.exports = function (h, opts) {
  if (!opts) opts = {};
  var concat = opts.concat || function (a, b) {
    return String(a) + String(b);
  };
  if (opts.attrToProp !== false) {
    h = attrToProp(h);
  }
  return function (strings) {
    var state = TEXT,
      reg = '';
    var arglen = arguments.length;
    var parts = [];
    for (var i = 0; i < strings.length; i++) {
      if (i < arglen - 1) {
        var arg = arguments[i + 1];
        var p = parse(strings[i]);
        var xstate = state;
        if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE;
        if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE;
        if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE;
        if (xstate === ATTR) xstate = ATTR_KEY;
        if (xstate === OPEN) {
          if (reg === '/') {
            p.push([OPEN, '/', arg]);
            reg = '';
          } else {
            p.push([OPEN, arg]);
          }
        } else if (xstate === COMMENT && opts.comments) {
          reg += String(arg);
        } else if (xstate !== COMMENT) {
          p.push([VAR, xstate, arg]);
        }
        parts.push.apply(parts, p);
      } else parts.push.apply(parts, parse(strings[i]));
    }
    var tree = [null, {}, []];
    var stack = [[tree, -1]];
    for (var i = 0; i < parts.length; i++) {
      var cur = stack[stack.length - 1][0];
      var p = parts[i],
        s = p[0];
      if (s === OPEN && /^\//.test(p[1])) {
        var ix = stack[stack.length - 1][1];
        if (stack.length > 1) {
          stack.pop();
          stack[stack.length - 1][0][2][ix] = h(cur[0], cur[1], cur[2].length ? cur[2] : undefined);
        }
      } else if (s === OPEN) {
        var c = [p[1], {}, []];
        cur[2].push(c);
        stack.push([c, cur[2].length - 1]);
      } else if (s === ATTR_KEY || s === VAR && p[1] === ATTR_KEY) {
        var key = '';
        var copyKey;
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_KEY) {
            key = concat(key, parts[i][1]);
          } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {
            if (_typeof(parts[i][2]) === 'object' && !key) {
              for (copyKey in parts[i][2]) {
                if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {
                  cur[1][copyKey] = parts[i][2][copyKey];
                }
              }
            } else {
              key = concat(key, parts[i][2]);
            }
          } else break;
        }
        if (parts[i][0] === ATTR_EQ) i++;
        var j = i;
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][1]);else parts[i][1] === "" || (cur[1][key] = concat(cur[1][key], parts[i][1]));
          } else if (parts[i][0] === VAR && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][2]);else parts[i][2] === "" || (cur[1][key] = concat(cur[1][key], parts[i][2]));
          } else {
            if (key.length && !cur[1][key] && i === j && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
              // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
              // empty string is falsy, not well behaved value in browser
              cur[1][key] = key.toLowerCase();
            }
            if (parts[i][0] === CLOSE) {
              i--;
            }
            break;
          }
        }
      } else if (s === ATTR_KEY) {
        cur[1][p[1]] = true;
      } else if (s === VAR && p[1] === ATTR_KEY) {
        cur[1][p[2]] = true;
      } else if (s === CLOSE) {
        if (selfClosing(cur[0]) && stack.length) {
          var ix = stack[stack.length - 1][1];
          stack.pop();
          stack[stack.length - 1][0][2][ix] = h(cur[0], cur[1], cur[2].length ? cur[2] : undefined);
        }
      } else if (s === VAR && p[1] === TEXT) {
        if (p[2] === undefined || p[2] === null) p[2] = '';else if (!p[2]) p[2] = concat('', p[2]);
        if (Array.isArray(p[2][0])) {
          cur[2].push.apply(cur[2], p[2]);
        } else {
          cur[2].push(p[2]);
        }
      } else if (s === TEXT) {
        cur[2].push(p[1]);
      } else if (s === ATTR_EQ || s === ATTR_BREAK) {
        // no-op
      } else {
        throw new Error('unhandled: ' + s);
      }
    }
    if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) {
      tree[2].shift();
    }
    if (tree[2].length > 2 || tree[2].length === 2 && /\S/.test(tree[2][1])) {
      if (opts.createFragment) return opts.createFragment(tree[2]);
      throw new Error('multiple root elements must be wrapped in an enclosing tag');
    }
    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === 'string' && Array.isArray(tree[2][0][2])) {
      tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2]);
    }
    return tree[2][0];
    function parse(str) {
      var res = [];
      if (state === ATTR_VALUE_W) state = ATTR;
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i);
        if (state === TEXT && c === '<') {
          if (reg.length) res.push([TEXT, reg]);
          reg = '';
          state = OPEN;
        } else if (c === '>' && !quot(state) && state !== COMMENT) {
          if (state === OPEN && reg.length) {
            res.push([OPEN, reg]);
          } else if (state === ATTR_KEY) {
            res.push([ATTR_KEY, reg]);
          } else if (state === ATTR_VALUE && reg.length) {
            res.push([ATTR_VALUE, reg]);
          }
          res.push([CLOSE]);
          reg = '';
          state = TEXT;
        } else if (state === COMMENT && /-$/.test(reg) && c === '-') {
          if (opts.comments) {
            res.push([ATTR_VALUE, reg.substr(0, reg.length - 1)]);
          }
          reg = '';
          state = TEXT;
        } else if (state === OPEN && /^!--$/.test(reg)) {
          if (opts.comments) {
            res.push([OPEN, reg], [ATTR_KEY, 'comment'], [ATTR_EQ]);
          }
          reg = c;
          state = COMMENT;
        } else if (state === TEXT || state === COMMENT) {
          reg += c;
        } else if (state === OPEN && c === '/' && reg.length) {
          // no-op, self closing tag without a space <br/>
        } else if (state === OPEN && /\s/.test(c)) {
          if (reg.length) {
            res.push([OPEN, reg]);
          }
          reg = '';
          state = ATTR;
        } else if (state === OPEN) {
          reg += c;
        } else if (state === ATTR && /[^\s"'=/]/.test(c)) {
          state = ATTR_KEY;
          reg = c;
        } else if (state === ATTR && /\s/.test(c)) {
          if (reg.length) res.push([ATTR_KEY, reg]);
          res.push([ATTR_BREAK]);
        } else if (state === ATTR_KEY && /\s/.test(c)) {
          res.push([ATTR_KEY, reg]);
          reg = '';
          state = ATTR_KEY_W;
        } else if (state === ATTR_KEY && c === '=') {
          res.push([ATTR_KEY, reg], [ATTR_EQ]);
          reg = '';
          state = ATTR_VALUE_W;
        } else if (state === ATTR_KEY) {
          reg += c;
        } else if ((state === ATTR_KEY_W || state === ATTR) && c === '=') {
          res.push([ATTR_EQ]);
          state = ATTR_VALUE_W;
        } else if ((state === ATTR_KEY_W || state === ATTR) && !/\s/.test(c)) {
          res.push([ATTR_BREAK]);
          if (/[\w-]/.test(c)) {
            reg += c;
            state = ATTR_KEY;
          } else state = ATTR;
        } else if (state === ATTR_VALUE_W && c === '"') {
          state = ATTR_VALUE_DQ;
        } else if (state === ATTR_VALUE_W && c === "'") {
          state = ATTR_VALUE_SQ;
        } else if (state === ATTR_VALUE_DQ && c === '"') {
          res.push([ATTR_VALUE, reg], [ATTR_BREAK]);
          reg = '';
          state = ATTR;
        } else if (state === ATTR_VALUE_SQ && c === "'") {
          res.push([ATTR_VALUE, reg], [ATTR_BREAK]);
          reg = '';
          state = ATTR;
        } else if (state === ATTR_VALUE_W && !/\s/.test(c)) {
          state = ATTR_VALUE;
          i--;
        } else if (state === ATTR_VALUE && /\s/.test(c)) {
          res.push([ATTR_VALUE, reg], [ATTR_BREAK]);
          reg = '';
          state = ATTR;
        } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ) {
          reg += c;
        }
      }
      if (state === TEXT && reg.length) {
        res.push([TEXT, reg]);
        reg = '';
      } else if (state === ATTR_VALUE && reg.length) {
        res.push([ATTR_VALUE, reg]);
        reg = '';
      } else if (state === ATTR_VALUE_DQ && reg.length) {
        res.push([ATTR_VALUE, reg]);
        reg = '';
      } else if (state === ATTR_VALUE_SQ && reg.length) {
        res.push([ATTR_VALUE, reg]);
        reg = '';
      } else if (state === ATTR_KEY) {
        res.push([ATTR_KEY, reg]);
        reg = '';
      }
      return res;
    }
  };
  function strfn(x) {
    if (typeof x === 'function') return x;else if (typeof x === 'string') return x;else if (x && _typeof(x) === 'object') return x;else if (x === null || x === undefined) return x;else return concat('', x);
  }
};
function quot(state) {
  return state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ;
}
var closeRE = RegExp('^(' + ['area', 'base', 'basefont', 'bgsound', 'br', 'col', 'command', 'embed', 'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr', '!--',
// SVG TAGS
'animate', 'animateTransform', 'circle', 'cursor', 'desc', 'ellipse', 'feBlend', 'feColorMatrix', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'font-face-format', 'font-face-name', 'font-face-uri', 'glyph', 'glyphRef', 'hkern', 'image', 'line', 'missing-glyph', 'mpath', 'path', 'polygon', 'polyline', 'rect', 'set', 'stop', 'tref', 'use', 'view', 'vkern'].join('|') + ")(?:[.#][a-zA-Z0-9\x7F-\uFFFF_:-]+)*$");
function selfClosing(tag) {
  return closeRE.test(tag);
}

},{"hyperscript-attribute-to-property":62}],64:[function(require,module,exports){
"use strict";

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
};

},{}],65:[function(require,module,exports){
"use strict";

assert.notEqual = notEqual;
assert.notOk = notOk;
assert.equal = equal;
assert.ok = assert;
module.exports = assert;
function equal(a, b, m) {
  assert(a == b, m); // eslint-disable-line eqeqeq
}

function notEqual(a, b, m) {
  assert(a != b, m); // eslint-disable-line eqeqeq
}

function notOk(t, m) {
  assert(!t, m);
}
function assert(t, m) {
  if (!t) throw new Error(m || 'AssertionError');
}

},{}],66:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var splice = require('remove-array-items');
var nanotiming = require('nanotiming');
var assert = require('assert');
module.exports = Nanobus;
function Nanobus(name) {
  if (!(this instanceof Nanobus)) return new Nanobus(name);
  this._name = name || 'nanobus';
  this._starListeners = [];
  this._listeners = {};
}
Nanobus.prototype.emit = function (eventName) {
  assert.ok(typeof eventName === 'string' || _typeof(eventName) === 'symbol', 'nanobus.emit: eventName should be type string or symbol');
  var data = [];
  for (var i = 1, len = arguments.length; i < len; i++) {
    data.push(arguments[i]);
  }
  var emitTiming = nanotiming(this._name + "('" + eventName.toString() + "')");
  var listeners = this._listeners[eventName];
  if (listeners && listeners.length > 0) {
    this._emit(this._listeners[eventName], data);
  }
  if (this._starListeners.length > 0) {
    this._emit(this._starListeners, eventName, data, emitTiming.uuid);
  }
  emitTiming();
  return this;
};
Nanobus.prototype.on = Nanobus.prototype.addListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || _typeof(eventName) === 'symbol', 'nanobus.on: eventName should be type string or symbol');
  assert.equal(_typeof(listener), 'function', 'nanobus.on: listener should be type function');
  if (eventName === '*') {
    this._starListeners.push(listener);
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = [];
    this._listeners[eventName].push(listener);
  }
  return this;
};
Nanobus.prototype.prependListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || _typeof(eventName) === 'symbol', 'nanobus.prependListener: eventName should be type string or symbol');
  assert.equal(_typeof(listener), 'function', 'nanobus.prependListener: listener should be type function');
  if (eventName === '*') {
    this._starListeners.unshift(listener);
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = [];
    this._listeners[eventName].unshift(listener);
  }
  return this;
};
Nanobus.prototype.once = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || _typeof(eventName) === 'symbol', 'nanobus.once: eventName should be type string or symbol');
  assert.equal(_typeof(listener), 'function', 'nanobus.once: listener should be type function');
  var self = this;
  this.on(eventName, once);
  function once() {
    listener.apply(self, arguments);
    self.removeListener(eventName, once);
  }
  return this;
};
Nanobus.prototype.prependOnceListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || _typeof(eventName) === 'symbol', 'nanobus.prependOnceListener: eventName should be type string or symbol');
  assert.equal(_typeof(listener), 'function', 'nanobus.prependOnceListener: listener should be type function');
  var self = this;
  this.prependListener(eventName, once);
  function once() {
    listener.apply(self, arguments);
    self.removeListener(eventName, once);
  }
  return this;
};
Nanobus.prototype.removeListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || _typeof(eventName) === 'symbol', 'nanobus.removeListener: eventName should be type string or symbol');
  assert.equal(_typeof(listener), 'function', 'nanobus.removeListener: listener should be type function');
  if (eventName === '*') {
    this._starListeners = this._starListeners.slice();
    return remove(this._starListeners, listener);
  } else {
    if (typeof this._listeners[eventName] !== 'undefined') {
      this._listeners[eventName] = this._listeners[eventName].slice();
    }
    return remove(this._listeners[eventName], listener);
  }
  function remove(arr, listener) {
    if (!arr) return;
    var index = arr.indexOf(listener);
    if (index !== -1) {
      splice(arr, index, 1);
      return true;
    }
  }
};
Nanobus.prototype.removeAllListeners = function (eventName) {
  if (eventName) {
    if (eventName === '*') {
      this._starListeners = [];
    } else {
      this._listeners[eventName] = [];
    }
  } else {
    this._starListeners = [];
    this._listeners = {};
  }
  return this;
};
Nanobus.prototype.listeners = function (eventName) {
  var listeners = eventName !== '*' ? this._listeners[eventName] : this._starListeners;
  var ret = [];
  if (listeners) {
    var ilength = listeners.length;
    for (var i = 0; i < ilength; i++) ret.push(listeners[i]);
  }
  return ret;
};
Nanobus.prototype._emit = function (arr, eventName, data, uuid) {
  if (typeof arr === 'undefined') return;
  if (arr.length === 0) return;
  if (data === undefined) {
    data = eventName;
    eventName = null;
  }
  if (eventName) {
    if (uuid !== undefined) {
      data = [eventName].concat(data, uuid);
    } else {
      data = [eventName].concat(data);
    }
  }
  var length = arr.length;
  for (var i = 0; i < length; i++) {
    var listener = arr[i];
    listener.apply(listener, data);
  }
};

},{"assert":65,"nanotiming":83,"remove-array-items":84}],67:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var assert = require('assert');
var safeExternalLink = /(noopener|noreferrer) (noopener|noreferrer)/;
var protocolLink = /^[\w-_]+:/;
module.exports = href;
function href(cb, root) {
  assert.notEqual(typeof window === "undefined" ? "undefined" : _typeof(window), 'undefined', 'nanohref: expected window to exist');
  root = root || window.document;
  assert.equal(_typeof(cb), 'function', 'nanohref: cb should be type function');
  assert.equal(_typeof(root), 'object', 'nanohref: root should be type object');
  window.addEventListener('click', function (e) {
    if (e.button && e.button !== 0 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.defaultPrevented) return;
    var anchor = function traverse(node) {
      if (!node || node === root) return;
      if (node.localName !== 'a' || node.href === undefined) {
        return traverse(node.parentNode);
      }
      return node;
    }(e.target);
    if (!anchor) return;
    if (window.location.protocol !== anchor.protocol || window.location.hostname !== anchor.hostname || window.location.port !== anchor.port || anchor.hasAttribute('data-nanohref-ignore') || anchor.hasAttribute('download') || anchor.getAttribute('target') === '_blank' && safeExternalLink.test(anchor.getAttribute('rel')) || protocolLink.test(anchor.getAttribute('href'))) return;
    e.preventDefault();
    cb(anchor);
  });
}

},{"assert":65}],68:[function(require,module,exports){
'use strict';

var trailingNewlineRegex = /\n[\s]+$/;
var leadingNewlineRegex = /^\n[\s]+/;
var trailingSpaceRegex = /[\s]+$/;
var leadingSpaceRegex = /^[\s]+/;
var multiSpaceRegex = /[\n\s]+/g;
var TEXT_TAGS = ['a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'data', 'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'amp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr'];
var VERBATIM_TAGS = ['code', 'pre', 'textarea'];
module.exports = function appendChild(el, childs) {
  if (!Array.isArray(childs)) return;
  var nodeName = el.nodeName.toLowerCase();
  var hadText = false;
  var value, leader;
  for (var i = 0, len = childs.length; i < len; i++) {
    var node = childs[i];
    if (Array.isArray(node)) {
      appendChild(el, node);
      continue;
    }
    if (typeof node === 'number' || typeof node === 'boolean' || typeof node === 'function' || node instanceof Date || node instanceof RegExp) {
      node = node.toString();
    }
    var lastChild = el.childNodes[el.childNodes.length - 1];

    // Iterate over text nodes
    if (typeof node === 'string') {
      hadText = true;

      // If we already had text, append to the existing text
      if (lastChild && lastChild.nodeName === '#text') {
        lastChild.nodeValue += node;

        // We didn't have a text node yet, create one
      } else {
        node = el.ownerDocument.createTextNode(node);
        el.appendChild(node);
        lastChild = node;
      }

      // If this is the last of the child nodes, make sure we close it out
      // right
      if (i === len - 1) {
        hadText = false;
        // Trim the child text nodes if the current node isn't a
        // node where whitespace matters.
        if (TEXT_TAGS.indexOf(nodeName) === -1 && VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue.replace(leadingNewlineRegex, '').replace(trailingSpaceRegex, '').replace(trailingNewlineRegex, '').replace(multiSpaceRegex, ' ');
          if (value === '') {
            el.removeChild(lastChild);
          } else {
            lastChild.nodeValue = value;
          }
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          // The very first node in the list should not have leading
          // whitespace. Sibling text nodes should have whitespace if there
          // was any.
          leader = i === 0 ? '' : ' ';
          value = lastChild.nodeValue.replace(leadingNewlineRegex, leader).replace(leadingSpaceRegex, ' ').replace(trailingSpaceRegex, '').replace(trailingNewlineRegex, '').replace(multiSpaceRegex, ' ');
          lastChild.nodeValue = value;
        }
      }

      // Iterate over DOM nodes
    } else if (node && node.nodeType) {
      // If the last node was a text node, make sure it is properly closed out
      if (hadText) {
        hadText = false;

        // Trim the child text nodes if the current node isn't a
        // text node or a code node
        if (TEXT_TAGS.indexOf(nodeName) === -1 && VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue.replace(leadingNewlineRegex, '').replace(trailingNewlineRegex, ' ').replace(multiSpaceRegex, ' ');

          // Remove empty text nodes, append otherwise
          if (value === '') {
            el.removeChild(lastChild);
          } else {
            lastChild.nodeValue = value;
          }
          // Trim the child nodes but preserve the appropriate whitespace
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue.replace(leadingSpaceRegex, ' ').replace(leadingNewlineRegex, '').replace(trailingNewlineRegex, ' ').replace(multiSpaceRegex, ' ');
          lastChild.nodeValue = value;
        }
      }

      // Store the last nodename
      var _nodeName = node.nodeName;
      if (_nodeName) nodeName = _nodeName.toLowerCase();

      // Append the node to the DOM
      el.appendChild(node);
    }
  }
};

},{}],69:[function(require,module,exports){
'use strict';

module.exports = ['async', 'autofocus', 'autoplay', 'checked', 'controls', 'default', 'defaultchecked', 'defer', 'disabled', 'formnovalidate', 'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'selected'];

},{}],70:[function(require,module,exports){
"use strict";

module.exports = require('./dom')(document);

},{"./dom":72}],71:[function(require,module,exports){
'use strict';

module.exports = ['indeterminate'];

},{}],72:[function(require,module,exports){
'use strict';

var hyperx = require('hyperx');
var appendChild = require('./append-child');
var SVG_TAGS = require('./svg-tags');
var BOOL_PROPS = require('./bool-props');
// Props that need to be set directly rather than with el.setAttribute()
var DIRECT_PROPS = require('./direct-props');
var SVGNS = 'http://www.w3.org/2000/svg';
var XLINKNS = 'http://www.w3.org/1999/xlink';
var COMMENT_TAG = '!--';
module.exports = function (document) {
  function nanoHtmlCreateElement(tag, props, children) {
    var el;

    // If an svg tag, it needs a namespace
    if (SVG_TAGS.indexOf(tag) !== -1) {
      props.namespace = SVGNS;
    }

    // If we are using a namespace
    var ns = false;
    if (props.namespace) {
      ns = props.namespace;
      delete props.namespace;
    }

    // If we are extending a builtin element
    var isCustomElement = false;
    if (props.is) {
      isCustomElement = props.is;
      delete props.is;
    }

    // Create the element
    if (ns) {
      if (isCustomElement) {
        el = document.createElementNS(ns, tag, {
          is: isCustomElement
        });
      } else {
        el = document.createElementNS(ns, tag);
      }
    } else if (tag === COMMENT_TAG) {
      return document.createComment(props.comment);
    } else if (isCustomElement) {
      el = document.createElement(tag, {
        is: isCustomElement
      });
    } else {
      el = document.createElement(tag);
    }

    // Create the properties
    for (var p in props) {
      if (props.hasOwnProperty(p)) {
        var key = p.toLowerCase();
        var val = props[p];
        // Normalize className
        if (key === 'classname') {
          key = 'class';
          p = 'class';
        }
        // The for attribute gets transformed to htmlFor, but we just set as for
        if (p === 'htmlFor') {
          p = 'for';
        }
        // If a property is boolean, set itself to the key
        if (BOOL_PROPS.indexOf(key) !== -1) {
          if (String(val) === 'true') val = key;else if (String(val) === 'false') continue;
        }
        // If a property prefers being set directly vs setAttribute
        if (key.slice(0, 2) === 'on' || DIRECT_PROPS.indexOf(key) !== -1) {
          el[p] = val;
        } else {
          if (ns) {
            if (p === 'xlink:href') {
              el.setAttributeNS(XLINKNS, p, val);
            } else if (/^xmlns($|:)/i.test(p)) {
              // skip xmlns definitions
            } else {
              el.setAttributeNS(null, p, val);
            }
          } else {
            el.setAttribute(p, val);
          }
        }
      }
    }
    appendChild(el, children);
    return el;
  }
  function createFragment(nodes) {
    var fragment = document.createDocumentFragment();
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] == null) continue;
      if (Array.isArray(nodes[i])) {
        fragment.appendChild(createFragment(nodes[i]));
      } else {
        if (typeof nodes[i] === 'string') nodes[i] = document.createTextNode(nodes[i]);
        fragment.appendChild(nodes[i]);
      }
    }
    return fragment;
  }
  var exports = hyperx(nanoHtmlCreateElement, {
    comments: true,
    createFragment: createFragment
  });
  exports["default"] = exports;
  exports.createComment = nanoHtmlCreateElement;
  return exports;
};

},{"./append-child":68,"./bool-props":69,"./direct-props":71,"./svg-tags":74,"hyperx":63}],73:[function(require,module,exports){
'use strict';

function nanohtmlRawBrowser(tag) {
  var el = document.createElement('div');
  el.innerHTML = tag;
  return toArray(el.childNodes);
}
function toArray(arr) {
  return Array.isArray(arr) ? arr : [].slice.call(arr);
}
module.exports = nanohtmlRawBrowser;

},{}],74:[function(require,module,exports){
'use strict';

module.exports = ['svg', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter', 'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'set', 'stop', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern'];

},{}],75:[function(require,module,exports){
"use strict";

module.exports = LRU;
function LRU(opts) {
  if (!(this instanceof LRU)) return new LRU(opts);
  if (typeof opts === 'number') opts = {
    max: opts
  };
  if (!opts) opts = {};
  this.cache = {};
  this.head = this.tail = null;
  this.length = 0;
  this.max = opts.max || 1000;
  this.maxAge = opts.maxAge || 0;
}
Object.defineProperty(LRU.prototype, 'keys', {
  get: function get() {
    return Object.keys(this.cache);
  }
});
LRU.prototype.clear = function () {
  this.cache = {};
  this.head = this.tail = null;
  this.length = 0;
};
LRU.prototype.remove = function (key) {
  if (typeof key !== 'string') key = '' + key;
  if (!this.cache.hasOwnProperty(key)) return;
  var element = this.cache[key];
  delete this.cache[key];
  this._unlink(key, element.prev, element.next);
  return element.value;
};
LRU.prototype._unlink = function (key, prev, next) {
  this.length--;
  if (this.length === 0) {
    this.head = this.tail = null;
  } else {
    if (this.head === key) {
      this.head = prev;
      this.cache[this.head].next = null;
    } else if (this.tail === key) {
      this.tail = next;
      this.cache[this.tail].prev = null;
    } else {
      this.cache[prev].next = next;
      this.cache[next].prev = prev;
    }
  }
};
LRU.prototype.peek = function (key) {
  if (!this.cache.hasOwnProperty(key)) return;
  var element = this.cache[key];
  if (!this._checkAge(key, element)) return;
  return element.value;
};
LRU.prototype.set = function (key, value) {
  if (typeof key !== 'string') key = '' + key;
  var element;
  if (this.cache.hasOwnProperty(key)) {
    element = this.cache[key];
    element.value = value;
    if (this.maxAge) element.modified = Date.now();

    // If it's already the head, there's nothing more to do:
    if (key === this.head) return value;
    this._unlink(key, element.prev, element.next);
  } else {
    element = {
      value: value,
      modified: 0,
      next: null,
      prev: null
    };
    if (this.maxAge) element.modified = Date.now();
    this.cache[key] = element;

    // Eviction is only possible if the key didn't already exist:
    if (this.length === this.max) this.evict();
  }
  this.length++;
  element.next = null;
  element.prev = this.head;
  if (this.head) this.cache[this.head].next = key;
  this.head = key;
  if (!this.tail) this.tail = key;
  return value;
};
LRU.prototype._checkAge = function (key, element) {
  if (this.maxAge && Date.now() - element.modified > this.maxAge) {
    this.remove(key);
    return false;
  }
  return true;
};
LRU.prototype.get = function (key) {
  if (typeof key !== 'string') key = '' + key;
  if (!this.cache.hasOwnProperty(key)) return;
  var element = this.cache[key];
  if (!this._checkAge(key, element)) return;
  if (this.head !== key) {
    if (key === this.tail) {
      this.tail = element.next;
      this.cache[this.tail].prev = null;
    } else {
      // Set prev.next -> element.next:
      this.cache[element.prev].next = element.next;
    }

    // Set element.next.prev -> element.prev:
    this.cache[element.next].prev = element.prev;

    // Element is the new head
    this.cache[this.head].next = key;
    element.prev = this.head;
    element.next = null;
    this.head = key;
  }
  return element.value;
};
LRU.prototype.evict = function () {
  if (!this.tail) return;
  this.remove(this.tail);
};

},{}],76:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var assert = require('nanoassert');
var morph = require('./lib/morph');
var TEXT_NODE = 3;
// var DEBUG = false

module.exports = nanomorph;

// Morph one tree into another tree
//
// no parent
//   -> same: diff and walk children
//   -> not same: replace and return
// old node doesn't exist
//   -> insert new node
// new node doesn't exist
//   -> delete old node
// nodes are not the same
//   -> diff nodes and apply patch to old node
// nodes are the same
//   -> walk all child nodes and append to old node
function nanomorph(oldTree, newTree, options) {
  // if (DEBUG) {
  //   console.log(
  //   'nanomorph\nold\n  %s\nnew\n  %s',
  //   oldTree && oldTree.outerHTML,
  //   newTree && newTree.outerHTML
  // )
  // }
  assert.equal(_typeof(oldTree), 'object', 'nanomorph: oldTree should be an object');
  assert.equal(_typeof(newTree), 'object', 'nanomorph: newTree should be an object');
  if (options && options.childrenOnly) {
    updateChildren(newTree, oldTree);
    return oldTree;
  }
  assert.notEqual(newTree.nodeType, 11, 'nanomorph: newTree should have one root node (which is not a DocumentFragment)');
  return walk(newTree, oldTree);
}

// Walk and morph a dom tree
function walk(newNode, oldNode) {
  // if (DEBUG) {
  //   console.log(
  //   'walk\nold\n  %s\nnew\n  %s',
  //   oldNode && oldNode.outerHTML,
  //   newNode && newNode.outerHTML
  // )
  // }
  if (!oldNode) {
    return newNode;
  } else if (!newNode) {
    return null;
  } else if (newNode.isSameNode && newNode.isSameNode(oldNode)) {
    return oldNode;
  } else if (newNode.tagName !== oldNode.tagName || getComponentId(newNode) !== getComponentId(oldNode)) {
    return newNode;
  } else {
    morph(newNode, oldNode);
    updateChildren(newNode, oldNode);
    return oldNode;
  }
}
function getComponentId(node) {
  return node.dataset ? node.dataset.nanomorphComponentId : undefined;
}

// Update the children of elements
// (obj, obj) -> null
function updateChildren(newNode, oldNode) {
  // if (DEBUG) {
  //   console.log(
  //   'updateChildren\nold\n  %s\nnew\n  %s',
  //   oldNode && oldNode.outerHTML,
  //   newNode && newNode.outerHTML
  // )
  // }
  var oldChild, newChild, morphed, oldMatch;

  // The offset is only ever increased, and used for [i - offset] in the loop
  var offset = 0;
  for (var i = 0;; i++) {
    oldChild = oldNode.childNodes[i];
    newChild = newNode.childNodes[i - offset];
    // if (DEBUG) {
    //   console.log(
    //   '===\n- old\n  %s\n- new\n  %s',
    //   oldChild && oldChild.outerHTML,
    //   newChild && newChild.outerHTML
    // )
    // }
    // Both nodes are empty, do nothing
    if (!oldChild && !newChild) {
      break;

      // There is no new child, remove old
    } else if (!newChild) {
      oldNode.removeChild(oldChild);
      i--;

      // There is no old child, add new
    } else if (!oldChild) {
      oldNode.appendChild(newChild);
      offset++;

      // Both nodes are the same, morph
    } else if (same(newChild, oldChild)) {
      morphed = walk(newChild, oldChild);
      if (morphed !== oldChild) {
        oldNode.replaceChild(morphed, oldChild);
        offset++;
      }

      // Both nodes do not share an ID or a placeholder, try reorder
    } else {
      oldMatch = null;

      // Try and find a similar node somewhere in the tree
      for (var j = i; j < oldNode.childNodes.length; j++) {
        if (same(oldNode.childNodes[j], newChild)) {
          oldMatch = oldNode.childNodes[j];
          break;
        }
      }

      // If there was a node with the same ID or placeholder in the old list
      if (oldMatch) {
        morphed = walk(newChild, oldMatch);
        if (morphed !== oldMatch) offset++;
        oldNode.insertBefore(morphed, oldChild);

        // It's safe to morph two nodes in-place if neither has an ID
      } else if (!newChild.id && !oldChild.id) {
        morphed = walk(newChild, oldChild);
        if (morphed !== oldChild) {
          oldNode.replaceChild(morphed, oldChild);
          offset++;
        }

        // Insert the node at the index if we couldn't morph or find a matching node
      } else {
        oldNode.insertBefore(newChild, oldChild);
        offset++;
      }
    }
  }
}
function same(a, b) {
  if (a.id) return a.id === b.id;
  if (a.isSameNode) return a.isSameNode(b);
  if (a.tagName !== b.tagName) return false;
  if (a.type === TEXT_NODE) return a.nodeValue === b.nodeValue;
  return false;
}

},{"./lib/morph":78,"nanoassert":65}],77:[function(require,module,exports){
"use strict";

module.exports = [
// attribute events (can be set with attributes)
'onclick', 'ondblclick', 'onmousedown', 'onmouseup', 'onmouseover', 'onmousemove', 'onmouseout', 'onmouseenter', 'onmouseleave', 'ontouchcancel', 'ontouchend', 'ontouchmove', 'ontouchstart', 'ondragstart', 'ondrag', 'ondragenter', 'ondragleave', 'ondragover', 'ondrop', 'ondragend', 'onkeydown', 'onkeypress', 'onkeyup', 'onunload', 'onabort', 'onerror', 'onresize', 'onscroll', 'onselect', 'onchange', 'onsubmit', 'onreset', 'onfocus', 'onblur', 'oninput', 'onanimationend', 'onanimationiteration', 'onanimationstart',
// other common events
'oncontextmenu', 'onfocusin', 'onfocusout'];

},{}],78:[function(require,module,exports){
"use strict";

var events = require('./events');
var eventsLength = events.length;
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
module.exports = morph;

// diff elements and apply the resulting patch to the old node
// (obj, obj) -> null
function morph(newNode, oldNode) {
  var nodeType = newNode.nodeType;
  var nodeName = newNode.nodeName;
  if (nodeType === ELEMENT_NODE) {
    copyAttrs(newNode, oldNode);
  }
  if (nodeType === TEXT_NODE || nodeType === COMMENT_NODE) {
    if (oldNode.nodeValue !== newNode.nodeValue) {
      oldNode.nodeValue = newNode.nodeValue;
    }
  }

  // Some DOM nodes are weird
  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js
  if (nodeName === 'INPUT') updateInput(newNode, oldNode);else if (nodeName === 'OPTION') updateOption(newNode, oldNode);else if (nodeName === 'TEXTAREA') updateTextarea(newNode, oldNode);
  copyEvents(newNode, oldNode);
}
function copyAttrs(newNode, oldNode) {
  var oldAttrs = oldNode.attributes;
  var newAttrs = newNode.attributes;
  var attrNamespaceURI = null;
  var attrValue = null;
  var fromValue = null;
  var attrName = null;
  var attr = null;
  for (var i = newAttrs.length - 1; i >= 0; --i) {
    attr = newAttrs[i];
    attrName = attr.name;
    attrNamespaceURI = attr.namespaceURI;
    attrValue = attr.value;
    if (attrNamespaceURI) {
      attrName = attr.localName || attrName;
      fromValue = oldNode.getAttributeNS(attrNamespaceURI, attrName);
      if (fromValue !== attrValue) {
        oldNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
      }
    } else {
      if (!oldNode.hasAttribute(attrName)) {
        oldNode.setAttribute(attrName, attrValue);
      } else {
        fromValue = oldNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          // apparently values are always cast to strings, ah well
          if (attrValue === 'null' || attrValue === 'undefined') {
            oldNode.removeAttribute(attrName);
          } else {
            oldNode.setAttribute(attrName, attrValue);
          }
        }
      }
    }
  }

  // Remove any extra attributes found on the original DOM element that
  // weren't found on the target element.
  for (var j = oldAttrs.length - 1; j >= 0; --j) {
    attr = oldAttrs[j];
    if (attr.specified !== false) {
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          oldNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!newNode.hasAttributeNS(null, attrName)) {
          oldNode.removeAttribute(attrName);
        }
      }
    }
  }
}
function copyEvents(newNode, oldNode) {
  for (var i = 0; i < eventsLength; i++) {
    var ev = events[i];
    if (newNode[ev]) {
      // if new element has a whitelisted attribute
      oldNode[ev] = newNode[ev]; // update existing element
    } else if (oldNode[ev]) {
      // if existing element has it and new one doesnt
      oldNode[ev] = undefined; // remove it from existing element
    }
  }
}

function updateOption(newNode, oldNode) {
  updateAttribute(newNode, oldNode, 'selected');
}

// The "value" attribute is special for the <input> element since it sets the
// initial value. Changing the "value" attribute without changing the "value"
// property will have no effect since it is only used to the set the initial
// value. Similar for the "checked" attribute, and "disabled".
function updateInput(newNode, oldNode) {
  var newValue = newNode.value;
  var oldValue = oldNode.value;
  updateAttribute(newNode, oldNode, 'checked');
  updateAttribute(newNode, oldNode, 'disabled');

  // The "indeterminate" property can not be set using an HTML attribute.
  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox
  if (newNode.indeterminate !== oldNode.indeterminate) {
    oldNode.indeterminate = newNode.indeterminate;
  }

  // Persist file value since file inputs can't be changed programatically
  if (oldNode.type === 'file') return;
  if (newValue !== oldValue) {
    oldNode.setAttribute('value', newValue);
    oldNode.value = newValue;
  }
  if (newValue === 'null') {
    oldNode.value = '';
    oldNode.removeAttribute('value');
  }
  if (!newNode.hasAttributeNS(null, 'value')) {
    oldNode.removeAttribute('value');
  } else if (oldNode.type === 'range') {
    // this is so elements like slider move their UI thingy
    oldNode.value = newValue;
  }
}
function updateTextarea(newNode, oldNode) {
  var newValue = newNode.value;
  if (newValue !== oldNode.value) {
    oldNode.value = newValue;
  }
  if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {
    // Needed for IE. Apparently IE sets the placeholder as the
    // node value and vise versa. This ignores an empty update.
    if (newValue === '' && oldNode.firstChild.nodeValue === oldNode.placeholder) {
      return;
    }
    oldNode.firstChild.nodeValue = newValue;
  }
}
function updateAttribute(newNode, oldNode, name) {
  if (newNode[name] !== oldNode[name]) {
    oldNode[name] = newNode[name];
    if (newNode[name]) {
      oldNode.setAttribute(name, '');
    } else {
      oldNode.removeAttribute(name);
    }
  }
}

},{"./events":77}],79:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var reg = /([^?=&]+)(=([^&]*))?/g;
var assert = require('assert');
module.exports = qs;
function qs(url) {
  assert.equal(_typeof(url), 'string', 'nanoquery: url should be type string');
  var obj = {};
  url.replace(/^.*\?/, '').replace(reg, function (a0, a1, a2, a3) {
    var value = decodeURIComponent(a3);
    var key = decodeURIComponent(a1);
    if (obj.hasOwnProperty(key)) {
      if (Array.isArray(obj[key])) obj[key].push(value);else obj[key] = [obj[key], value];
    } else {
      obj[key] = value;
    }
  });
  return obj;
}

},{"assert":65}],80:[function(require,module,exports){
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var assert = require('assert');
module.exports = nanoraf;

// Only call RAF when needed
// (fn, fn?) -> fn
function nanoraf(render, raf) {
  assert.equal(_typeof(render), 'function', 'nanoraf: render should be a function');
  assert.ok(typeof raf === 'function' || typeof raf === 'undefined', 'nanoraf: raf should be a function or undefined');
  if (!raf) raf = window.requestAnimationFrame;
  var redrawScheduled = false;
  var args = null;
  return function frame() {
    if (args === null && !redrawScheduled) {
      redrawScheduled = true;
      raf(function redraw() {
        redrawScheduled = false;
        var length = args.length;
        var _args = new Array(length);
        for (var i = 0; i < length; i++) _args[i] = args[i];
        render.apply(render, _args);
        args = null;
      });
    }
    args = arguments;
  };
}

},{"assert":65}],81:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var assert = require('assert');
var wayfarer = require('wayfarer');

// electron support
var isLocalFile = /file:\/\//.test((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.location && window.location.origin);

/* eslint-disable no-useless-escape */
var electron = '^(file:\/\/|\/)(.*\.html?\/?)?';
var protocol = '^(http(s)?(:\/\/))?(www\.)?';
var domain = '[a-zA-Z0-9-_\.]+(:[0-9]{1,5})?(\/{1})?';
var qs = '[\?].*$';
/* eslint-enable no-useless-escape */

var stripElectron = new RegExp(electron);
var prefix = new RegExp(protocol + domain);
var normalize = new RegExp('#');
var suffix = new RegExp(qs);
module.exports = Nanorouter;
function Nanorouter(opts) {
  if (!(this instanceof Nanorouter)) return new Nanorouter(opts);
  opts = opts || {};
  this.router = wayfarer(opts["default"] || '/404');
}
Nanorouter.prototype.on = function (routename, listener) {
  assert.equal(_typeof(routename), 'string');
  routename = routename.replace(/^[#/]/, '');
  this.router.on(routename, listener);
};
Nanorouter.prototype.emit = function (routename) {
  assert.equal(_typeof(routename), 'string');
  routename = pathname(routename, isLocalFile);
  return this.router.emit(routename);
};
Nanorouter.prototype.match = function (routename) {
  assert.equal(_typeof(routename), 'string');
  routename = pathname(routename, isLocalFile);
  return this.router.match(routename);
};

// replace everything in a route but the pathname and hash
function pathname(routename, isElectron) {
  if (isElectron) routename = routename.replace(stripElectron, '');else routename = routename.replace(prefix, '');
  return decodeURI(routename.replace(suffix, '').replace(normalize, '/'));
}

},{"assert":65,"wayfarer":86}],82:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var assert = require('assert');
var hasWindow = typeof window !== 'undefined';
function createScheduler() {
  var scheduler;
  if (hasWindow) {
    if (!window._nanoScheduler) window._nanoScheduler = new NanoScheduler(true);
    scheduler = window._nanoScheduler;
  } else {
    scheduler = new NanoScheduler();
  }
  return scheduler;
}
function NanoScheduler(hasWindow) {
  this.hasWindow = hasWindow;
  this.hasIdle = this.hasWindow && window.requestIdleCallback;
  this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout;
  this.scheduled = false;
  this.queue = [];
}
NanoScheduler.prototype.push = function (cb) {
  assert.equal(_typeof(cb), 'function', 'nanoscheduler.push: cb should be type function');
  this.queue.push(cb);
  this.schedule();
};
NanoScheduler.prototype.schedule = function () {
  if (this.scheduled) return;
  this.scheduled = true;
  var self = this;
  this.method(function (idleDeadline) {
    var cb;
    while (self.queue.length && idleDeadline.timeRemaining() > 0) {
      cb = self.queue.shift();
      cb(idleDeadline);
    }
    self.scheduled = false;
    if (self.queue.length) self.schedule();
  });
};
NanoScheduler.prototype.setTimeout = function (cb) {
  setTimeout(cb, 0, {
    timeRemaining: function timeRemaining() {
      return 1;
    }
  });
};
module.exports = createScheduler;

},{"assert":65}],83:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var scheduler = require('nanoscheduler')();
var assert = require('assert');
var perf;
nanotiming.disabled = true;
try {
  perf = window.performance;
  nanotiming.disabled = window.localStorage.DISABLE_NANOTIMING === 'true' || !perf.mark;
} catch (e) {}
module.exports = nanotiming;
function nanotiming(name) {
  assert.equal(_typeof(name), 'string', 'nanotiming: name should be type string');
  if (nanotiming.disabled) return noop;
  var uuid = (perf.now() * 10000).toFixed() % Number.MAX_SAFE_INTEGER;
  var startName = 'start-' + uuid + '-' + name;
  perf.mark(startName);
  function end(cb) {
    var endName = 'end-' + uuid + '-' + name;
    perf.mark(endName);
    scheduler.push(function () {
      var err = null;
      try {
        var measureName = name + ' [' + uuid + ']';
        perf.measure(measureName, startName, endName);
        perf.clearMarks(startName);
        perf.clearMarks(endName);
      } catch (e) {
        err = e;
      }
      if (cb) cb(err, name);
    });
  }
  end.uuid = uuid;
  return end;
}
function noop(cb) {
  if (cb) {
    scheduler.push(function () {
      cb(new Error('nanotiming: performance API unavailable'));
    });
  }
}

},{"assert":65,"nanoscheduler":82}],84:[function(require,module,exports){
'use strict';

/**
 * Remove a range of items from an array
 *
 * @function removeItems
 * @param {Array<*>} arr The target array
 * @param {number} startIdx The index to begin removing from (inclusive)
 * @param {number} removeCount How many items to remove
 */
module.exports = function removeItems(arr, startIdx, removeCount) {
  var i,
    length = arr.length;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  var len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
};

},{}],85:[function(require,module,exports){
"use strict";

module.exports = scrollToAnchor;
function scrollToAnchor(anchor, options) {
  if (anchor) {
    try {
      var el = document.querySelector(anchor);
      if (el) el.scrollIntoView(options);
    } catch (e) {}
  }
}

},{}],86:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/* eslint-disable node/no-deprecated-api */
var assert = require('assert');
var trie = require('./trie');
module.exports = Wayfarer;

// create a router
// str -> obj
function Wayfarer(dft) {
  if (!(this instanceof Wayfarer)) return new Wayfarer(dft);
  var _default = (dft || '').replace(/^\//, '');
  var _trie = trie();
  emit._trie = _trie;
  emit.on = on;
  emit.emit = emit;
  emit.match = match;
  emit._wayfarer = true;
  return emit;

  // define a route
  // (str, fn) -> obj
  function on(route, cb) {
    assert.equal(_typeof(route), 'string');
    assert.equal(_typeof(cb), 'function');
    route = route || '/';
    if (cb._wayfarer && cb._trie) {
      _trie.mount(route, cb._trie.trie);
    } else {
      var node = _trie.create(route);
      node.cb = cb;
      node.route = route;
    }
    return emit;
  }

  // match and call a route
  // (str, obj?) -> null
  function emit(route) {
    var matched = match(route);
    var args = new Array(arguments.length);
    args[0] = matched.params;
    for (var i = 1; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return matched.cb.apply(matched.cb, args);
  }
  function match(route) {
    assert.notEqual(route, undefined, "'route' must be defined");
    var matched = _trie.match(route);
    if (matched && matched.cb) return new Route(matched);
    var dft = _trie.match(_default);
    if (dft && dft.cb) return new Route(dft);
    throw new Error("route '" + route + "' did not match");
  }
  function Route(matched) {
    this.cb = matched.cb;
    this.route = matched.route;
    this.params = matched.params;
  }
}

},{"./trie":87,"assert":65}],87:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/* eslint-disable node/no-deprecated-api */
var assert = require('assert');
module.exports = Trie;

// create a new trie
// null -> obj
function Trie() {
  if (!(this instanceof Trie)) return new Trie();
  this.trie = {
    nodes: {}
  };
}

// create a node on the trie at route
// and return a node
// str -> obj
Trie.prototype.create = function (route) {
  assert.equal(_typeof(route), 'string', 'route should be a string');
  // strip leading '/' and split routes
  var routes = route.replace(/^\//, '').split('/');
  function createNode(index, trie) {
    var thisRoute = has(routes, index) && routes[index];
    if (thisRoute === false) return trie;
    var node = null;
    if (/^:|^\*/.test(thisRoute)) {
      // if node is a name match, set name and append to ':' node
      if (!has(trie.nodes, '$$')) {
        node = {
          nodes: {}
        };
        trie.nodes.$$ = node;
      } else {
        node = trie.nodes.$$;
      }
      if (thisRoute[0] === '*') {
        trie.wildcard = true;
      }
      trie.name = thisRoute.replace(/^:|^\*/, '');
    } else if (!has(trie.nodes, thisRoute)) {
      node = {
        nodes: {}
      };
      trie.nodes[thisRoute] = node;
    } else {
      node = trie.nodes[thisRoute];
    }

    // we must recurse deeper
    return createNode(index + 1, node);
  }
  return createNode(0, this.trie);
};

// match a route on the trie
// and return the node
// str -> obj
Trie.prototype.match = function (route) {
  assert.equal(_typeof(route), 'string', 'route should be a string');
  var routes = route.replace(/^\//, '').split('/');
  var params = {};
  function search(index, trie) {
    // either there's no match, or we're done searching
    if (trie === undefined) return undefined;
    var thisRoute = routes[index];
    if (thisRoute === undefined) return trie;
    if (has(trie.nodes, thisRoute)) {
      // match regular routes first
      return search(index + 1, trie.nodes[thisRoute]);
    } else if (trie.name) {
      // match named routes
      try {
        params[trie.name] = decodeURIComponent(thisRoute);
      } catch (e) {
        return search(index, undefined);
      }
      return search(index + 1, trie.nodes.$$);
    } else if (trie.wildcard) {
      // match wildcards
      try {
        params.wildcard = decodeURIComponent(routes.slice(index).join('/'));
      } catch (e) {
        return search(index, undefined);
      }
      // return early, or else search may keep recursing through the wildcard
      return trie.nodes.$$;
    } else {
      // no matches found
      return search(index + 1);
    }
  }
  var node = search(0, this.trie);
  if (!node) return undefined;
  node = Object.assign({}, node);
  node.params = params;
  return node;
};

// mount a trie onto a node at route
// (str, obj) -> null
Trie.prototype.mount = function (route, trie) {
  assert.equal(_typeof(route), 'string', 'route should be a string');
  assert.equal(_typeof(trie), 'object', 'trie should be a object');
  var split = route.replace(/^\//, '').split('/');
  var node = null;
  var key = null;
  if (split.length === 1) {
    key = split[0];
    node = this.create(key);
  } else {
    var head = split.join('/');
    key = split[0];
    node = this.create(head);
  }
  Object.assign(node.nodes, trie.nodes);
  if (trie.name) node.name = trie.name;

  // delegate properties from '/' to the new node
  // '/' cannot be reached once mounted
  if (node.nodes['']) {
    Object.keys(node.nodes['']).forEach(function (key) {
      if (key === 'nodes') return;
      node[key] = node.nodes[''][key];
    });
    Object.assign(node.nodes, node.nodes[''].nodes);
    delete node.nodes[''].nodes;
  }
};
function has(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}

},{"assert":65}],88:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var _globalThis;
if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object') {
  _globalThis = globalThis;
} else {
  try {
    _globalThis = require('es5-ext/global');
  } catch (error) {} finally {
    if (!_globalThis && typeof window !== 'undefined') {
      _globalThis = window;
    }
    if (!_globalThis) {
      throw new Error('Could not determine global this');
    }
  }
}
var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
var websocket_version = require('./version');

/**
 * Expose a W3C WebSocket class with just one or two arguments.
 */
function W3CWebSocket(uri, protocols) {
  var native_instance;
  if (protocols) {
    native_instance = new NativeWebSocket(uri, protocols);
  } else {
    native_instance = new NativeWebSocket(uri);
  }

  /**
   * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
   * class). Since it is an Object it will be returned as it is when creating an
   * instance of W3CWebSocket via 'new W3CWebSocket()'.
   *
   * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
   */
  return native_instance;
}
if (NativeWebSocket) {
  ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function (prop) {
    Object.defineProperty(W3CWebSocket, prop, {
      get: function get() {
        return NativeWebSocket[prop];
      }
    });
  });
}

/**
 * Module exports.
 */
module.exports = {
  'w3cwebsocket': NativeWebSocket ? W3CWebSocket : null,
  'version': websocket_version
};

},{"./version":89,"es5-ext/global":61}],89:[function(require,module,exports){
"use strict";

module.exports = require('../package.json').version;

},{"../package.json":90}],90:[function(require,module,exports){
module.exports={
  "name": "websocket",
  "description": "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
  "keywords": [
    "websocket",
    "websockets",
    "socket",
    "networking",
    "comet",
    "push",
    "RFC-6455",
    "realtime",
    "server",
    "client"
  ],
  "author": "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
  "contributors": [
    "Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
  ],
  "version": "1.0.34",
  "repository": {
    "type": "git",
    "url": "https://github.com/theturtle32/WebSocket-Node.git"
  },
  "homepage": "https://github.com/theturtle32/WebSocket-Node",
  "engines": {
    "node": ">=4.0.0"
  },
  "dependencies": {
    "bufferutil": "^4.0.1",
    "debug": "^2.2.0",
    "es5-ext": "^0.10.50",
    "typedarray-to-buffer": "^3.1.5",
    "utf-8-validate": "^5.0.2",
    "yaeti": "^0.0.6"
  },
  "devDependencies": {
    "buffer-equal": "^1.0.0",
    "gulp": "^4.0.2",
    "gulp-jshint": "^2.0.4",
    "jshint-stylish": "^2.2.1",
    "jshint": "^2.0.0",
    "tape": "^4.9.1"
  },
  "config": {
    "verbose": false
  },
  "scripts": {
    "test": "tape test/unit/*.js",
    "gulp": "gulp"
  },
  "main": "index",
  "directories": {
    "lib": "./lib"
  },
  "browser": "lib/browser.js",
  "license": "Apache-2.0"
}

},{}],91:[function(require,module,exports){

},{}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = function _default(state, emitter) {};
exports["default"] = _default;

},{}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClickThroughs = getClickThroughs;
exports.getTwitRefs = getTwitRefs;
exports.parseSource = parseSource;
exports.renderActionDetail = renderActionDetail;
exports.renderActionType = renderActionType;
function parseSource(source) {
  if (!source.includes("https")) {
    source = "https://" + source;
  }
  var fbclid = new URL(source).searchParams.get("fbclid");
  if (fbclid) {
    return "FB " + fbclid;
  }
  return;
}
function getTwitRefs(ref) {
  if (!ref) return false;
  if (ref.includes('t.co')) {
    return true;
  }
}
function renderActionType(at) {
  // navigate is legacy
  if (at === "navigate") return "click";
  return at;
}
function renderActionDetail(ad) {
  // remove click and link
  // ad = '<div class="mr4">-</div>' + ad
  return ad.replace("click", "").replace("link", "");
}
function getClickThroughs(data) {
  if (!data.action) return false;
  if (data.action.includes("time.claims")) {
    return true;
  }
}

},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _html = _interopRequireDefault(require("choo/html"));
var _raw = _interopRequireDefault(require("choo/html/raw"));
var _utils = require("../utils");
var _templateObject;
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
var _default = function _default(state, emit) {
  function renderEntry(dayArr) {
    var entries = "";
    dayArr.reverse();
    for (var i = 0; i < dayArr.length; i++) {
      var _dayArr$i$data = dayArr[i].data,
        timestamp = _dayArr$i$data.timestamp,
        sessionId = _dayArr$i$data.sessionId,
        action_type = _dayArr$i$data.action_type,
        action = _dayArr$i$data.action,
        action_detail = _dayArr$i$data.action_detail,
        referrer = _dayArr$i$data.referrer;
      var date = new Date(timestamp);
      entries += "\n        <li>\n            <div class=\"df fdr fww\">\n                <div class=\"mr4 fwb\">\n                    ".concat(date.getHours().toString().padStart(2, '0'), ":").concat(date.getMinutes().toString().padStart(2, '0'), ":").concat(date.getSeconds().toString().padStart(2, '0'), "\n                </div>\n                <div class=\"session mr4 ").concat(sessionId ? '' : 'dn', "\">\n                  ").concat(sessionId ? sessionId.slice(0, 24) : '', "\n                </div>\n                <div class=\"uppercase mr4\">\n                    ").concat((0, _utils.renderActionType)(action_type), "\n                </div>\n                <div class=\"mr4 ").concat(action_type === "visit" ? 'dn' : '', "\">-</div>\n\n                ").concat(action_detail ? (0, _utils.renderActionDetail)(action_detail) : "", "\n                <div class=\"").concat(action ? 'df ' : 'dn', "\">\n                    (").concat(action ? renderAction(action) : "", ")\n                </div>\n                <div class=\"").concat(referrer ? 'df fdr' : 'dn', "\">\n                    Referrer: ").concat(referrer, "\n                </div>\n            </div>\n        </li>\n      ");
    }
    return entries;
  }
  function renderDay() {
    if (!state.data) return;
    var days = "";
    var entries = Object.entries(state.data);
    for (var i = 0; i < entries.length; i++) {
      days += "\n            <li>\n              <div class=\"entry-date df fdr jcsb\">\n                <div class=\"mr4\">".concat(entries[i][0], "</div>\n                <div class=\"df fdr\" style=\"opacity: 0.5\">\n                  <div class=\"mr4\">Visits: ").concat(entries[i][1].meta.visits, ", CT% ").concat(Math.round(entries[i][1].meta.clickThroughs / entries[i][1].meta.visits * 100), "(").concat(entries[i][1].meta.clickThroughs, ")</div>\n                  <div>(From FB: ").concat(entries[i][1].meta.fb, ", From T: ").concat(entries[i][1].meta.twit, ")</div>\n                </div>\n              \n              </div>\n              <ul>\n                ").concat(renderEntry(entries[i][1].data), "\n              </ul>\n            </li>\n          ");
    }
    return (0, _raw["default"])(days);
  }
  return (0, _html["default"])(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      <div>\n        <ul>\n          ", "\n        </ul>\n      </div>\n  "])), renderDay());
};
exports["default"] = _default;
function renderAction(action) {
  if (action.includes("time.claims")) {
    return "\u2192 <div class='action df'> ".concat(action, "</div>");
  }
  return " " + action;
}

},{"../utils":93,"choo/html":56,"choo/html/raw":57}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _html = _interopRequireDefault(require("choo/html"));
var _entries = _interopRequireDefault(require("./entries"));
var _templateObject;
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
var _default = function _default(state, emit) {
  return (0, _html["default"])(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    <body>\n      <main>\n          <div>\n            ", "\n          </div>\n      </main>\n    </body>\n  "])), (0, _entries["default"])(state, emit));
};
exports["default"] = _default;

},{"./entries":94,"choo/html":56}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy8ucG5wbS9icm93c2VyLXBhY2tANi4xLjAvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImNvbmZpZy5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStmdW5jdGlvbnMtanNAMi4wLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvZGlzdC9tYWluL0Z1bmN0aW9uc0NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrZnVuY3Rpb25zLWpzQDIuMC4wL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbWFpbi9oZWxwZXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2Z1bmN0aW9ucy1qc0AyLjAuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21haW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2Z1bmN0aW9ucy1qc0AyLjAuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21haW4vdHlwZXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2dvdHJ1ZS1qc0AyLjYuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2dvdHJ1ZS1qcy9kaXN0L21haW4vR29UcnVlQWRtaW5BcGkuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2dvdHJ1ZS1qc0AyLjYuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2dvdHJ1ZS1qcy9kaXN0L21haW4vR29UcnVlQ2xpZW50LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStnb3RydWUtanNAMi42LjEvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9nb3RydWUtanMvZGlzdC9tYWluL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStnb3RydWUtanNAMi42LjEvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9nb3RydWUtanMvZGlzdC9tYWluL2xpYi9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2dvdHJ1ZS1qc0AyLjYuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2dvdHJ1ZS1qcy9kaXN0L21haW4vbGliL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrZ290cnVlLWpzQDIuNi4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZ290cnVlLWpzL2Rpc3QvbWFpbi9saWIvZmV0Y2guanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2dvdHJ1ZS1qc0AyLjYuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2dvdHJ1ZS1qcy9kaXN0L21haW4vbGliL2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2dvdHJ1ZS1qc0AyLjYuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2dvdHJ1ZS1qcy9kaXN0L21haW4vbGliL2xvY2FsLXN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2dvdHJ1ZS1qc0AyLjYuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2dvdHJ1ZS1qcy9kaXN0L21haW4vbGliL3BvbHlmaWxscy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrZ290cnVlLWpzQDIuNi4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZ290cnVlLWpzL2Rpc3QvbWFpbi9saWIvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK2dvdHJ1ZS1qc0AyLjYuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2dvdHJ1ZS1qcy9kaXN0L21haW4vbGliL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3Bvc3RncmVzdC1qc0AxLjEuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L21haW4vUG9zdGdyZXN0QnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrcG9zdGdyZXN0LWpzQDEuMS4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvbWFpbi9Qb3N0Z3Jlc3RDbGllbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3Bvc3RncmVzdC1qc0AxLjEuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L21haW4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrcG9zdGdyZXN0LWpzQDEuMS4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvbWFpbi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3Bvc3RncmVzdC1qc0AxLjEuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L21haW4vUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrcG9zdGdyZXN0LWpzQDEuMS4xL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvbWFpbi9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3Bvc3RncmVzdC1qc0AxLjEuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L21haW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3Bvc3RncmVzdC1qc0AxLjEuMS9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L21haW4vdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrcmVhbHRpbWUtanNAMi4xLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21haW4vUmVhbHRpbWVDaGFubmVsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStyZWFsdGltZS1qc0AyLjEuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9SZWFsdGltZUNsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrcmVhbHRpbWUtanNAMi4xLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21haW4vUmVhbHRpbWVQcmVzZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrcmVhbHRpbWUtanNAMi4xLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21haW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3JlYWx0aW1lLWpzQDIuMS4wL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tYWluL2xpYi9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3JlYWx0aW1lLWpzQDIuMS4wL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tYWluL2xpYi9wdXNoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStyZWFsdGltZS1qc0AyLjEuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvc2VyaWFsaXplci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2UrcmVhbHRpbWUtanNAMi4xLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21haW4vbGliL3RpbWVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStyZWFsdGltZS1qc0AyLjEuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvdHJhbnNmb3JtZXJzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStyZWFsdGltZS1qc0AyLjEuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2Urc3RvcmFnZS1qc0AyLjEuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tYWluL1N0b3JhZ2VDbGllbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3N0b3JhZ2UtanNAMi4xLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbWFpbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2Urc3RvcmFnZS1qc0AyLjEuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tYWluL2xpYi9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3N0b3JhZ2UtanNAMi4xLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbWFpbi9saWIvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStzdG9yYWdlLWpzQDIuMS4wL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21haW4vbGliL2ZldGNoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStzdG9yYWdlLWpzQDIuMS4wL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21haW4vbGliL2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3N0b3JhZ2UtanNAMi4xLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbWFpbi9saWIvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2Urc3RvcmFnZS1qc0AyLjEuMC9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tYWluL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGkuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3N0b3JhZ2UtanNAMi4xLjAvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbWFpbi9wYWNrYWdlcy9TdG9yYWdlRmlsZUFwaS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9Ac3VwYWJhc2Urc3VwYWJhc2UtanNAMi4yLjIvbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21haW4vU3VwYWJhc2VDbGllbnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3N1cGFiYXNlLWpzQDIuMi4yL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tYWluL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStzdXBhYmFzZS1qc0AyLjIuMi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbWFpbi9saWIvU3VwYWJhc2VBdXRoQ2xpZW50LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStzdXBhYmFzZS1qc0AyLjIuMi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbWFpbi9saWIvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStzdXBhYmFzZS1qc0AyLjIuMi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbWFpbi9saWIvZmV0Y2guanMiLCJub2RlX21vZHVsZXMvLnBucG0vQHN1cGFiYXNlK3N1cGFiYXNlLWpzQDIuMi4yL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tYWluL2xpYi9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL0BzdXBhYmFzZStzdXBhYmFzZS1qc0AyLjIuMi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbWFpbi9saWIvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9iYXNlNjQtanNAMS41LjEvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9idWZmZXJANS4yLjEvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9jaG9vQDcuMS4wL25vZGVfbW9kdWxlcy9jaG9vL2NvbXBvbmVudC9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9jaG9vQDcuMS4wL25vZGVfbW9kdWxlcy9jaG9vL2h0bWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vY2hvb0A3LjEuMC9ub2RlX21vZHVsZXMvY2hvby9odG1sL3Jhdy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9jaG9vQDcuMS4wL25vZGVfbW9kdWxlcy9jaG9vL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2Nyb3NzLWZldGNoQDMuMS41L25vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9ueWZpbGwuanMiLCJub2RlX21vZHVsZXMvLnBucG0vZG9jdW1lbnQtcmVhZHlAMi4wLjIvbm9kZV9tb2R1bGVzL2RvY3VtZW50LXJlYWR5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2VzNS1leHRAMC4xMC42Mi9ub2RlX21vZHVsZXMvZXM1LWV4dC9nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvLnBucG0vaHlwZXJzY3JpcHQtYXR0cmlidXRlLXRvLXByb3BlcnR5QDEuMC4yL25vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC1hdHRyaWJ1dGUtdG8tcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vaHlwZXJ4QDIuNS40L25vZGVfbW9kdWxlcy9oeXBlcngvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vaWVlZTc1NEAxLjIuMS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9uYW5vYXNzZXJ0QDEuMS4wL25vZGVfbW9kdWxlcy9uYW5vYXNzZXJ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL25hbm9idXNANC41LjAvbm9kZV9tb2R1bGVzL25hbm9idXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vbmFub2hyZWZAMy4xLjAvbm9kZV9tb2R1bGVzL25hbm9ocmVmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL25hbm9odG1sQDEuMTAuMC9ub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2FwcGVuZC1jaGlsZC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9uYW5vaHRtbEAxLjEwLjAvbm9kZV9tb2R1bGVzL25hbm9odG1sL2xpYi9ib29sLXByb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL25hbm9odG1sQDEuMTAuMC9ub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbmFub2h0bWxAMS4xMC4wL25vZGVfbW9kdWxlcy9uYW5vaHRtbC9saWIvZGlyZWN0LXByb3BzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL25hbm9odG1sQDEuMTAuMC9ub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2RvbS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9uYW5vaHRtbEAxLjEwLjAvbm9kZV9tb2R1bGVzL25hbm9odG1sL2xpYi9yYXctYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9uYW5vaHRtbEAxLjEwLjAvbm9kZV9tb2R1bGVzL25hbm9odG1sL2xpYi9zdmctdGFncy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9uYW5vbHJ1QDEuMC4wL25vZGVfbW9kdWxlcy9uYW5vbHJ1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL25hbm9tb3JwaEA1LjQuMy9ub2RlX21vZHVsZXMvbmFub21vcnBoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL25hbm9tb3JwaEA1LjQuMy9ub2RlX21vZHVsZXMvbmFub21vcnBoL2xpYi9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbmFub21vcnBoQDUuNC4zL25vZGVfbW9kdWxlcy9uYW5vbW9ycGgvbGliL21vcnBoLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL25hbm9xdWVyeUAxLjMuMC9ub2RlX21vZHVsZXMvbmFub3F1ZXJ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vbmFub3JhZkAzLjEuMC9ub2RlX21vZHVsZXMvbmFub3JhZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9uYW5vcm91dGVyQDQuMC4wL25vZGVfbW9kdWxlcy9uYW5vcm91dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL25hbm9zY2hlZHVsZXJAMS4wLjMvbm9kZV9tb2R1bGVzL25hbm9zY2hlZHVsZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vbmFub3RpbWluZ0A3LjMuMS9ub2RlX21vZHVsZXMvbmFub3RpbWluZy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3JlbW92ZS1hcnJheS1pdGVtc0AxLjEuMS9ub2RlX21vZHVsZXMvcmVtb3ZlLWFycmF5LWl0ZW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3Njcm9sbC10by1hbmNob3JAMS4xLjAvbm9kZV9tb2R1bGVzL3Njcm9sbC10by1hbmNob3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vd2F5ZmFyZXJANy4wLjEvbm9kZV9tb2R1bGVzL3dheWZhcmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3dheWZhcmVyQDcuMC4xL25vZGVfbW9kdWxlcy93YXlmYXJlci90cmllLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3dlYnNvY2tldEAxLjAuMzQvbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS93ZWJzb2NrZXRAMS4wLjM0L25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvLnBucG0vd2Vic29ja2V0QDEuMC4zNC9ub2RlX21vZHVsZXMvd2Vic29ja2V0L3BhY2thZ2UuanNvbiIsInN0YXRpYy9hcHAuY3NzIiwic3RvcmUvdXguanMiLCJ1dGlscy5qcyIsInZpZXdzL2VudHJpZXMuanMiLCJ2aWV3cy9ob21lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O2VDQWU7RUFDWCxtQkFBbUIsRUFBRSxLQUFLO0VBQzFCLFlBQVksRUFBRSwwQ0FBMEM7RUFDeEQsYUFBYSxFQUFFO0FBQ25CLENBQUM7QUFBQTs7Ozs7QUNERDtBQUNBO0FBQ0E7QUFXQTtBQUdBO0FBQ0E7QUFBMkI7QUFBQTtBQUFBLCtDQW5CM0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBOztBQUVBO0VBQUEsdUNBQU8sa0JBQWtCO0FBQUE7QUFTekIsSUFBSSxRQUFRLEdBQUcsSUFBQSx3QkFBWSxFQUN6QixrQkFBTSxDQUFDLFlBQVksRUFDbkIsa0JBQU0sQ0FBQyxhQUFhLENBQ3JCO0FBR0QsSUFBTSxHQUFHLEdBQUcsSUFBQSxnQkFBSSxHQUFFO0FBS2xCLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLGdCQUFJLENBQUM7QUFFcEIsR0FBRyxDQUFDLEdBQUcsQ0FBQyxjQUFFLENBQUM7QUFFWCxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQUMsS0FBSyxFQUFFLE9BQU8sRUFBSztFQUMxQixPQUFPLENBQUMsRUFBRSxDQUFDLGtCQUFrQiwwRUFBRTtJQUFBO0lBQUE7TUFBQTtRQUFBO1VBQUE7VUFBQSxPQUVELFFBQVEsQ0FDakMsSUFBSSxDQUFDLGtCQUFNLENBQUMsbUJBQW1CLENBQUMsQ0FDaEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUNYLEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFDWCxTQUFTLEVBQUU7VUFDYixDQUFDLENBQUM7UUFBQTtVQUFBO1VBTEUsSUFBSSx5QkFBSixJQUFJO1VBQUUsS0FBSyx5QkFBTCxLQUFLO1VBQUEsS0FPYixLQUFLO1lBQUE7WUFBQTtVQUFBO1VBQUEsTUFBUSxLQUFLO1FBQUE7VUFFbEIsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFLO1lBRXpDO1lBQ0EsSUFBTSxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUU7Y0FDL0QsUUFBUSxFQUFFO1lBQ1osQ0FBQyxDQUFDO1lBRUYsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTTtZQUM1QixJQUFNLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVqQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO2NBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ25CO1lBRUEsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFFdkIsT0FBTyxNQUFNO1VBQ2YsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBRU47VUFFQSxNQUFNLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQztVQUM3Qjs7VUFFQSxLQUFLLENBQUMsSUFBSSxHQUFHLE1BQU07VUFDbkIsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFBQTtRQUFBO1VBQUE7TUFBQTtJQUFBO0VBQUEsQ0FFdkIsR0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO0FBR2pCLFNBQVMsWUFBWSxDQUFDLE1BQU0sRUFBRTtFQUM1QjtFQUNBLElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO0VBRXBDLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztFQUVmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0lBRXZDLElBQUksTUFBTSxHQUFHLENBQUM7SUFDZCxJQUFJLEVBQUUsR0FBRyxDQUFDO0lBQ1YsSUFBSSxJQUFJLEdBQUcsQ0FBQztJQUNaLElBQUksYUFBYSxHQUFHLENBQUM7SUFFckIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7TUFDN0MsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUNoQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxLQUFLLE9BQU8sRUFBRTtRQUN4QyxNQUFNLEVBQUU7TUFDVjtNQUVBLElBQUksSUFBQSx1QkFBZ0IsRUFBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDbEMsYUFBYSxFQUFFO01BQ2pCO01BQ0EsSUFBSSxJQUFBLGtCQUFXLEVBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUN0QyxJQUFJLEVBQUU7TUFDUjtNQUNBO01BQ0EsSUFBSSxNQUFNLEdBQUcsSUFBQSxrQkFBVyxFQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO01BQzdDLElBQUksTUFBTSxFQUFFO1FBQ1YsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTTtRQUMvQixFQUFFLEVBQUU7TUFDTjtJQUNGO0lBQ0EsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztNQUNkLE1BQU0sRUFBRSxNQUFNO01BQ2QsRUFBRSxFQUFFLEVBQUU7TUFDTixJQUFJLEVBQUUsSUFBSTtNQUNWLGFBQWEsRUFBRTtJQUNqQixDQUFDLENBQUM7SUFDRixNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUc7TUFDdEIsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDbkIsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BCLENBQUM7RUFDSDtFQUVBLE9BQU8sTUFBTTtBQUdmO0FBRUEsU0FBUyxjQUFjLENBQUMsTUFBTSxFQUFFO0VBQzlCO0VBQ0EsS0FBSyxJQUFNLEdBQUcsSUFBSSxNQUFNLEVBQUU7SUFFeEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQzdCLElBQUksRUFBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQUMsS0FBSyxFQUFFLElBQUksRUFBSztNQUUvQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztNQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSztNQUM3QjtNQUVBLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7TUFDckQsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1FBQy9CLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7TUFDakM7TUFDQSxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztNQUNsQixPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO01BRTVELEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7TUFFdkMsT0FBTyxLQUFLO0lBRVosQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOztJQUVOO0lBQ0E7O0lBRUE7SUFDQSxPQUFPLEVBQUM7RUFDVjtFQUNBLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0VBQ2QsT0FBTyxNQUFNO0FBQ2Y7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNocUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFHLElBQUksQ0FBQyxNQUFNO0VBQ3JCLElBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDakIsTUFBTSxJQUFJLFVBQVUsQ0FBQywyQ0FBMkMsQ0FBQztFQUNuRTtFQUNBLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUMvQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3BCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQzFCO0VBQ0EsT0FBTyxJQUFJO0FBQ2IsQ0FBQztBQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFNBQVMsTUFBTSxHQUFJO0VBQzNDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNO0VBQ3JCLElBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDakIsTUFBTSxJQUFJLFVBQVUsQ0FBQywyQ0FBMkMsQ0FBQztFQUNuRTtFQUNBLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUMvQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3BCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQzFCO0VBQ0EsT0FBTyxJQUFJO0FBQ2IsQ0FBQztBQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFNB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R0FBRyxHQUFHLFVBQVUsR0FBRyxHQUFHO0FBQ2hELENBQUM7QUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLFdBQVcsQ0FBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0VBQ3JFLE1BQU0sR0FBRyxNQUFNLEtBQUssQ0FBQztFQUNyQixJQUFJLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUM7RUFDbEQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBRTtFQUNoRCxPQUFRLEdBQUcsR0FBRyxNQUFNLEdBQUksR0FBRyxHQUFHLFVBQVUsR0FBRyxHQUFHO0FBQ2hELENBQUM7QUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLFdBQVcsQ0FBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0VBQ3JFLE1BQU0sR0FBRyxNQUFNLEtBQUssQ0FBQztFQUNyQixJQUFJLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUM7RUFFbEQsT0FBUSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBRSxHQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUcsR0FDdkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFHO0FBQzVCLENBQUM7QUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLFdBQVcsQ0FBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0VBQ3JFLE1BQU0sR0FBRyxNQUFNLEtBQUssQ0FBQztFQUNyQixJQUFJLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUM7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QUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUM5QyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7RUFDeEQ7RUFFQSxJQUFJLEdBQUcsR0FBRyxDQUFDO0VBQ1gsSUFBSSxDQUFDLEdBQUcsQ0FBQztFQUNULElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSTtFQUMzQixPQUFPLEVBQUUsQ0FBQyxHQUFHLFVBQVUsS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLEVBQUU7SUFDekMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBSSxLQUFLLEdBQUcsR0FBRyxHQUFJLElBQUk7RUFDekM7RUFFQSxPQUFPLE1BQU0sR0FBRyxVQUFVO0FBQzVCLENBQUM7QUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLFdBQVcsQ0FBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUU7RUFDeEYsS0FBSyxHQUFHLENBQUMsS0FBSztFQUNkLE1BQU0sR0FBRyxNQUFNLEtBQUssQ0FBQztFQUNyQixVQUFVLEdBQUcsVUFBVSxLQUFLLENBQUM7RUFDN0IsSUFBSSxDQUFDLFFBQVEsRUFBRTtJQUNiLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQzlDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztFQUN4RDtFQUVBLElBQUksQ0FBQyxHQUFHLFVBQVUsR0FBRyxDQUFDO0VBQ3RCLElBQUksR0FBRyxHQUFHLENBQUM7RUFDWCxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJ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QUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtNQUN4RCxHQUFHLEdBQUcsQ0FBQztJQUNUO0lBQ0EsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFFLEtBQUssR0FBRyxHQUFHLElBQUssQ0FBQyxJQUFJLEdBQUcsR0FBRyxJQUFJO0VBQ3REO0VBRUEsT0FBTyxNQUFNLEdBQUcsVUFBVTtBQUM1QixDQUFDO0FBRUQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsU0FBUyxTQUFTLENBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUU7RUFDeEUsS0FBSyxHQUFHLENBQUMsS0FBSztFQUNkLE1BQU0sR0FBRyxNQUFNLEtBQUssQ0FBQztFQUNyQixJQUFJLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDO0VBQzVELElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBSSxHQUFHLEtBQUssR0FBRyxDQUFDO0VBQ3ZDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBSSxLQUFLLEdBQUcsSUFBSztFQUM3QixPQUFPLE1BQU0sR0FBRyxDQUFDO0FBQ25CLENBQUM7QUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxTQUFTLFlBQVksQ0FBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRTtFQUM5RSxLQUFLLEdBQUcsQ0FBQyxLQUFLO0VBQ2QsTUFBTSxHQUFHLE1BQU0sS0FBSyxDQUFDO0VBQ3JCLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUM7RUFDaEUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFJLEtBQUssR0FBRyxJQUFLO0VBQzdCLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FB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QyxDQUFDLElBQUksQ0FBQyxDQUFFLElBQUksRUFBRSxHQUFHLENBQUUsQ0FBQztVQUN2QjtRQUNGLENBQUMsTUFBTSxJQUFJLE1BQU0sS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtVQUM5QyxHQUFHLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQztRQUNwQixDQUFDLE1BQU0sSUFBSSxNQUFNLEtBQUssT0FBTyxFQUFFO1VBQzdCLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBRSxDQUFDO1FBQzlCO1FBQ0EsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztNQUM1QixDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuRDtJQUVBLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQztJQUN2QixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7TUFDckMsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ2xDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUMxQixJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNsQyxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0s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QUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQzdDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBRyxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDM0UsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsS0FDMUIsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLFVBQVUsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxDQUFDLEVBQUU7WUFDM0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUM3QyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUcsRUFBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1VBQzNFLENBQUMsTUFBTTtZQUNMLElBQUksR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxD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LEdBQUcsQ0FBQyxDQUFDO0VBQ2QsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFJLE1BQU0sR0FBRyxDQUFDLEdBQUksQ0FBQztFQUMvQixJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQztFQUNyQixJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztFQUUxQixDQUFDLElBQUksQ0FBQztFQUVOLENBQUMsR0FBRyxDQUFDLEdBQUksQ0FBQyxDQUFDLElBQUssQ0FBQyxLQUFNLElBQUksQ0FBRTtFQUM3QixDQUFDLEtBQU0sQ0FBQyxLQUFNO0VBQ2QsS0FBSyxJQUFJLElBQUk7RUFDYixPQUFPLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFJLENBQUMsR0FBRyxHQUFHLEdBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQztFQUUzRSxDQUFDLEdBQUcsQ0FBQyxHQUFJLENBQUMsQ0FBQyxJQUFLLENBQUMsS0FBTSxJQUFJLENBQUU7RUFDN0IsQ0FBQyxLQUFNLENBQUMsS0FBTTtFQUNkLEtBQUssSUFBSSxJQUFJO0VBQ2IsT0FBTyxLQUFLLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBSSxDQUFDLEdBQUcsR0FBRyxHQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUM7RUFFM0UsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQ1gsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLO0VBQ2YsQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRTtJQUNyQixPQUFPLENBQUMsR0FBRyxHQUFHLEdBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLFFBQVM7RUFDNUMsQ0FBQyxNQUFNO0lBQ0wsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM7SUFDekIsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLO0VBQ2Y7RUFDQSxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztBQUNqRCxDQUFDO0FBRUQsT0FBTyxDQUFDLEtBQUssR0FBRyxVQUFVLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFO0VBQ25FLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0VBQ1gsSUFBSSxJQUFJLEdBQUksTUFBTSxHQUFHLENBQUMsR0FBSSxJQUFJLEdBQUcsQ0FBQztFQUNsQyxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQztFQUMxQixJQUFJLEtBQUssR0FBRyxJQUFJLElBQUksQ0FBQztFQUNyQixJQUFJLEVBQUUsR0FBSSxJQUFJLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFFO0VBQ2hFLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUksTUFBTSxHQUFHLENBQUU7RUFDL0IsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7RUFDckIsSUFBSSxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsSUFBSyxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDO0VBRTNELEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztFQUV2QixJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEtBQUssUUFBUSxFQUFFO0lBQ3RDLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7SUFDeEIsQ0FBQyxHQUFHLElBQUk7RUFDVixDQUFDLE1BQU07SUFDTCxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDMUMsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7TUFDckMsQ0FBQyxFQUFFO01BQ0gsQ0FBQyxJQUFJLENBQUM7SUFDUjtJQUNBLElBQUksQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLEVBQUU7TUFDbEIsS0FBSyxJQUFJLEVBQUUsR0FBRyxDQUFDO0lBQ2pCLENBQUMsTUFBTTtNQUNMLEtBQUssSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUN0QztJQUNBLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7TUFDbEIsQ0FBQyxFQUFFO01BQ0gsQ0FBQyxJQUFJLENBQUM7SUFDUjtJQUVBLElBQUksQ0FBQyxHQUFHLEtBQUssSUFBSSxJQUFJLEVBQUU7TUFDckIsQ0FBQyxHQUFHLENBQUM7TUFDTCxDQUFDLEdBQUcsSUFBSTtJQUNWLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQyxFQUFFO01BQ3pCLENBQUMsR0FBRyxDQUFFLEtBQUssR0FBRyxDQUFDLEdBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQztNQUN6QyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUs7SUFDZixDQUFDLE1BQU07TUFDTCxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM7TUFDdEQsQ0FBQyxHQUFHLENBQUM7SUFDUDtFQUNGO0VBRUEsT0FBTyxJQUFJLElBQUksQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDO0VBRS9FLENBQUMsR0FBSSxDQUFDLElBQUksSUFBSSxHQUFJLENBQUM7RUFDbkIsSUFBSSxJQUFJLElBQUk7RUFDWixPQUFPLElBQUksR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUM7RUFFOUUsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUc7QUFDbkMsQ0FBQzs7Ozs7QUNwRkQsTUFBTSxDQUFDLFFBQVEsR0FBRyxRQUFRO0FBQzFCLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSztBQUNwQixNQUFNLENBQUMsS0FBSyxHQUFHLEtBQUs7QUFDcEIsTUFBTSxDQUFDLEVBQUUsR0FBRyxNQUFNO0FBRWxCLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTTtBQUV2QixTQUFTLEtBQUssQ0FBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtFQUN2QixNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBQztBQUNwQjs7QUFFQSxTQUFTLFFBQVEsQ0FBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtFQUMxQixNQUFNLENBQUMsQ0FBQyxJQUFJ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LGFBQWEsQ0FBQyxFQUFFO0lBQ2pDLGdEQUFvQyxNQUFNO0VBRTVDO0VBRUEsT0FBTyxJQUFJLEdBQUcsTUFBTTtBQUV0Qjs7Ozs7Ozs7O0FDaEdBO0FBRUE7QUFBZ0M7QUFBQTtBQUFBO0FBQUEsZUFFakIsa0JBQUMsS0FBSyxFQUFFLElBQUksRUFBSztFQUU5QixXQUFPLGdCQUFJLHNMQUlDLElBQUEsbUJBQU8sRUFBQyxLQUFLLEVBQUMsSUFBSSxDQUFDO0FBS2pDLENBQUM7QUFBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBTVVBBQkFTRV9UQUJMRV9OQU1FOiBcInNlZVwiLFxuICAgIFNVUEFCQVNFX1VSTDogXCJodHRwczovL3BjZ3Nmb2R4anhhaGNycWd5b2RzLnN1cGFiYXNlLmNvXCIsXG4gICAgU1VQQUJBU0VfQU5PTjogXCJleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKcGMzTWlPaUp6ZFhCaFltRnpaU0lzSW5KbFppSTZJbkJqWjNObWIyUjRhbmhoYUdOeWNXZDViMlJ6SWl3aWNtOXNaU0k2SW1GdWIyNGlMQ0pwWVhRaU9qRTJOekE0TURJek9UQXNJbVY0Y0NJNk1UazROak0zT0RNNU1IMC5nTVE2Y1RKMEtfZkN1dTF3YWRvWkZEeFFoeUlMT2JEd2Rma1ZwNFpfbm1zXCJcbn0iLCIvLyBpbmRleC5qc1xuXG5pbXBvcnQoXCIuL3N0YXRpYy9hcHAuY3NzXCIpXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG5pbXBvcnQgY29uZmlnIGZyb20gXCIuL2NvbmZpZ1wiXG5pbXBvcnQge1xuICBwYXJzZVNvdXJjZSxcbiAgZ2V0VHdpdFJlZnMsXG4gIGdldENsaWNrVGhyb3VnaHNcbn0gZnJvbSAnLi91dGlscydcblxubGV0IGRhdGFiYXNlID0gY3JlYXRlQ2xpZW50KFxuICBjb25maWcuU1VQQUJBU0VfVVJMLFxuICBjb25maWcuU1VQQUJBU0VfQU5PTlxuKVxuXG5pbXBvcnQgY2hvbyBmcm9tIFwiY2hvb1wiXG5jb25zdCBhcHAgPSBjaG9vKClcblxuaW1wb3J0IGhvbWUgZnJvbSBcIi4vdmlld3MvaG9tZVwiXG5pbXBvcnQgdXggZnJvbSBcIi4vc3RvcmUvdXhcIlxuXG5hcHAucm91dGUoXCIvXCIsIGhvbWUpXG5cbmFwcC51c2UodXgpXG5cbmFwcC51c2UoKHN0YXRlLCBlbWl0dGVyKSA9PiB7XG4gIGVtaXR0ZXIub24oXCJET01Db250ZW50TG9hZGVkXCIsIGFzeW5jICgpID0+IHtcblxuICAgIGxldCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBkYXRhYmFzZVxuICAgICAgLmZyb20oY29uZmlnLlNVUEFCQVNFX1RBQkxFX05BTUUpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5vcmRlcignaWQnLCB7XG4gICAgICAgIGFzY2VuZGluZzogZmFsc2VcbiAgICAgIH0pXG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICBsZXQgZ3JvdXBzID0gZGF0YS5yZWR1Y2UoKGdyb3VwcywgaXRlbSkgPT4ge1xuXG4gICAgICAvLyB0aW1lem9uZSBjaGFuZ2UgaGVyZVxuICAgICAgY29uc3QgdHpEYXRlID0gbmV3IERhdGUoaXRlbS5jcmVhdGVkX2F0KS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCB7XG4gICAgICAgIHRpbWVab25lOiAnQW1lcmljYS9OZXdfWW9yaydcbiAgICAgIH0pXG5cbiAgICAgIGl0ZW0uZGF0YS50aW1lc3RhbXAgPSB0ekRhdGVcbiAgICAgIGNvbnN0IGRhdGUgPSB0ekRhdGUuc3BsaXQoJywnKVswXTtcblxuICAgICAgaWYgKCFncm91cHNbZGF0ZV0pIHtcbiAgICAgICAgZ3JvdXBzW2RhdGVdID0gW107XG4gICAgICB9XG5cbiAgICAgIGdyb3Vwc1tkYXRlXS5wdXNoKGl0ZW0pO1xuXG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH0sIHt9KTtcblxuICAgIC8vIGNvbnNvbGUubG9nKGdyb3VwcylcblxuICAgIGdyb3VwcyA9IGdldEFuYWx5dGljcyhncm91cHMpXG4gICAgLy8gZ3JvdXBzID0gZ3JvdXBCeVNlc3Npb24oZ3JvdXBzKVxuXG4gICAgc3RhdGUuZGF0YSA9IGdyb3Vwc1xuICAgIGVtaXR0ZXIuZW1pdChcInJlbmRlclwiKVxuXG4gIH0pXG59KVxuXG5hcHAubW91bnQoXCJib2R5XCIpXG5cblxuZnVuY3Rpb24gZ2V0QW5hbHl0aWNzKGdyb3Vwcykge1xuICAvLyBsb29wIHRocm91Z2ggZ3JvdXBzXG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZ3JvdXBzKVxuXG4gIGxldCBuZXdPYmogPSB7fVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXG4gICAgbGV0IHZpc2l0cyA9IDBcbiAgICBsZXQgZmIgPSAwXG4gICAgbGV0IHR3aXQgPSAwXG4gICAgbGV0IGNsaWNrVGhyb3VnaHMgPSAwXG5cbiAgICBmb3IgKGxldCBkID0gMDsgZCA8IGVudHJpZXNbaV1bMV0ubGVuZ3RoOyBkKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbnRyaWVzW2ldWzFdW2RdO1xuICAgICAgaWYgKGVsZW1lbnQuZGF0YS5hY3Rpb25fdHlwZSA9PT0gXCJ2aXNpdFwiKSB7XG4gICAgICAgIHZpc2l0cysrXG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRDbGlja1Rocm91Z2hzKGVsZW1lbnQuZGF0YSkpIHtcbiAgICAgICAgY2xpY2tUaHJvdWdocysrXG4gICAgICB9XG4gICAgICBpZiAoZ2V0VHdpdFJlZnMoZWxlbWVudC5kYXRhLnJlZmVycmVyKSkge1xuICAgICAgICB0d2l0KytcbiAgICAgIH1cbiAgICAgIC8vIHByZS1zZXNzaW9uSWQgbWFudWFsIGZhY2Vib29rIGdldFxuICAgICAgbGV0IGZiY2xpZCA9IHBhcnNlU291cmNlKGVsZW1lbnQuZGF0YS5zb3VyY2UpXG4gICAgICBpZiAoZmJjbGlkKSB7XG4gICAgICAgIGVsZW1lbnQuZGF0YS5zZXNzaW9uSWQgPSBmYmNsaWRcbiAgICAgICAgZmIrK1xuICAgICAgfVxuICAgIH1cbiAgICBlbnRyaWVzW2ldLnB1c2goe1xuICAgICAgdmlzaXRzOiB2aXNpdHMsXG4gICAgICBmYjogZmIsXG4gICAgICB0d2l0OiB0d2l0LFxuICAgICAgY2xpY2tUaHJvdWdoczogY2xpY2tUaHJvdWdoc1xuICAgIH0pXG4gICAgbmV3T2JqW2VudHJpZXNbaV1bMF1dID0ge1xuICAgICAgZGF0YTogZW50cmllc1tpXVsxXSxcbiAgICAgIG1ldGE6IGVudHJpZXNbaV1bMl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3T2JqXG5cblxufVxuXG5mdW5jdGlvbiBncm91cEJ5U2Vzc2lvbihncm91cHMpIHtcbiAgLy8gY29uc29sZS5sb2coZ3JvdXBzKVxuICBmb3IgKGNvbnN0IGtleSBpbiBncm91cHMpIHtcblxuICAgIGNvbnNvbGUubG9nKGdyb3Vwc1trZXldLmRhdGEpXG4gICAgbGV0IGcgPSBncm91cHNba2V5XS5kYXRhLnJlZHVjZSgoZ3JvdXAsIGl0ZW0pID0+IHtcblxuICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICAgIGlmICghaXRlbS5kYXRhLnNlc3Npb25JZCkge1xuICAgICAgICBpdGVtLmRhdGEuc2Vzc2lvbklkID0gXCJ4eXpcIlxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhpdGVtLmRhdGEuc2Vzc2lvbklkLCBpdGVtLmRhdGEuc2Vzc2lvbklkKVxuICAgICAgaWYgKCFncm91cFtpdGVtLmRhdGEuc2Vzc2lvbklkXSkge1xuICAgICAgICBncm91cFtpdGVtLmRhdGEuc2Vzc2lvbklkXSA9IFtdO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coZ3JvdXApXG4gICAgICBjb25zb2xlLmxvZyhpdGVtLmRhdGEuc2Vzc2lvbklkLCBncm91cFtpdGVtLmRhdGEuc2Vzc2lvbklkXSlcblxuICAgICAgZ3JvdXBbaXRlbS5kYXRhLnNlc3Npb25JZF0ucHVzaChpdGVtKVxuXG4gICAgcmV0dXJuIGdyb3VwXG5cbiAgICB9LCB7fSlcblxuICAgIC8vIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAvLyAgIGNvbnN0IGVsZW1lbnQgPSBvYmplY3Rba2V5XTtcbiAgICAgIFxuICAgIC8vIH1cbiAgICByZXR1cm4gZ1xuICB9XG4gIGNvbnNvbGUubG9nKGcpXG4gIHJldHVybiBncm91cHNcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBleHBvcnRzOyB9OyB2YXIgZXhwb3J0cyA9IHt9LCBPcCA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXksIGRlc2MpIHsgb2JqW2tleV0gPSBkZXNjLnZhbHVlOyB9LCAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSwgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSwgb2JqW2tleV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAoZXJyKSB7IGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7IH07IH0gZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkgeyB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvciwgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLCBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyByZXR1cm4gZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KSwgZ2VuZXJhdG9yOyB9IGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07IH0gY2F0Y2ggKGVycikgeyByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07IH0gfSBleHBvcnRzLndyYXAgPSB3cmFwOyB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307IGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pOyB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpOyBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7IHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgeyBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTsgfSk7IH0pOyB9IGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkgeyBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgeyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHsgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsIHZhbHVlID0gcmVzdWx0LnZhbHVlOyByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKHZhbHVlKSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHsgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJlamVjdChyZWNvcmQuYXJnKTsgfSB2YXIgcHJldmlvdXNQcm9taXNlOyBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobWV0aG9kLCBhcmcpIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHsgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiOyByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7IGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7IGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnOyByZXR1cm4gZG9uZVJlc3VsdCgpOyB9IGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHsgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsgaWYgKGRlbGVnYXRlKSB7IHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOyBpZiAoZGVsZWdhdGVSZXN1bHQpIHsgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OyB9IH0gaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHsgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7IGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpOyBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7IHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTsgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7IGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4geyB2YWx1ZTogcmVjb3JkLmFyZywgZG9uZTogY29udGV4dC5kb25lIH07IH0gXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsgdmFyIG1ldGhvZE5hbWUgPSBjb250ZXh0Lm1ldGhvZCwgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07IGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkgcmV0dXJuIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG1ldGhvZE5hbWUgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBtZXRob2ROYW1lICYmIChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBtZXRob2ROYW1lICsgXCInIG1ldGhvZFwiKSksIENvbnRpbnVlU2VudGluZWw7IHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7IHZhciBpbmZvID0gcmVjb3JkLmFyZzsgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTsgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7IH0gZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTsgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDsgfSBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7IHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7IGlmIChpdGVyYWJsZSkgeyB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07IGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7IGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkgeyB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0OyByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OyB9IH0gcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9OyB9IGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7IHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6ICEwIH07IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmVQcm9wZXJ0eShHcCwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgY29uZmlndXJhYmxlOiAhMCB9KSwgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikgeyB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTsgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjsgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7IHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7IHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkgeyB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCksIGtleXMgPSBbXTsgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7IHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IGtleXMubGVuZ3RoOykgeyB2YXIga2V5ID0ga2V5cy5wb3AoKTsgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpOyB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKCkgeyB0aGlzLmRvbmUgPSAhMDsgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZzsgcmV0dXJuIHRoaXMucnZhbDsgfSwgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247IHZhciBjb250ZXh0ID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7IHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7IH0gZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSwgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7IGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChoYXNDYXRjaCkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7IHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTsgYnJlYWs7IH0gfSBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7IHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9OyByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpOyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykgeyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsOyB9LCBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHsgdmFyIHRocm93biA9IHJlY29yZC5hcmc7IHJlc2V0VHJ5RW50cnkoZW50cnkpOyB9IHJldHVybiB0aHJvd247IH0gfSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7IH0sIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLCByZXN1bHROYW1lOiByZXN1bHROYW1lLCBuZXh0TG9jOiBuZXh0TG9jIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIGV4cG9ydHM7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIF9fYXdhaXRlciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5GdW5jdGlvbnNDbGllbnQgPSB2b2lkIDA7XG52YXIgaGVscGVyXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIEZ1bmN0aW9uc0NsaWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZ1bmN0aW9uc0NsaWVudCh1cmwpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICBfcmVmJGhlYWRlcnMgPSBfcmVmLmhlYWRlcnMsXG4gICAgICBoZWFkZXJzID0gX3JlZiRoZWFkZXJzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkaGVhZGVycyxcbiAgICAgIGN1c3RvbUZldGNoID0gX3JlZi5jdXN0b21GZXRjaDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVuY3Rpb25zQ2xpZW50KTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuZmV0Y2ggPSAoMCwgaGVscGVyXzEucmVzb2x2ZUZldGNoKShjdXN0b21GZXRjaCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqIEBwYXJhbSB0b2tlbiAtIHRoZSBuZXcgand0IHRva2VuIHNlbnQgaW4gdGhlIGF1dGhvcmlzYXRpb24gaGVhZGVyXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRnVuY3Rpb25zQ2xpZW50LCBbe1xuICAgIGtleTogXCJzZXRBdXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF1dGgodG9rZW4pIHtcbiAgICAgIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gXCJCZWFyZXIgXCIuY29uY2F0KHRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbnZva2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52b2tlKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgdmFyIGludm9rZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBoZWFkZXJzLCBmdW5jdGlvbkFyZ3MsIF9oZWFkZXJzLCBib2R5LCByZXNwb25zZSwgaXNSZWxheUVycm9yLCByZXNwb25zZVR5cGUsIGRhdGE7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICBoZWFkZXJzID0gaW52b2tlT3B0aW9ucy5oZWFkZXJzLCBmdW5jdGlvbkFyZ3MgPSBpbnZva2VPcHRpb25zLmJvZHk7XG4gICAgICAgICAgICAgIF9oZWFkZXJzID0ge307XG4gICAgICAgICAgICAgIGlmIChmdW5jdGlvbkFyZ3MgJiYgKGhlYWRlcnMgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCAnQ29udGVudC1UeXBlJykgfHwgIWhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBCbG9iIHx8IGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAvLyB3aWxsIHdvcmsgZm9yIEZpbGUgYXMgRmlsZSBpbmhlcml0cyBCbG9iXG4gICAgICAgICAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBBcnJheUJ1ZmZlciBhcyBpdCBpcyB0aGUgc2FtZSB1bmRlcmx5aW5nIHN0cnVjdHVyZSBhcyBhIEJsb2JcbiAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvbkFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBwbGFpbiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICd0ZXh0L3BsYWluJztcbiAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgY29udGVudC10eXBlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgIC8vIFJlcXVlc3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgcmlnaHQgYm91bmRhcnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQsIGFzc3VtZSB0aGlzIGlzIEpTT05cbiAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShmdW5jdGlvbkFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL1wiKS5jb25jYXQoZnVuY3Rpb25OYW1lKSwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIC8vIGhlYWRlcnMgcHJpb3JpdHkgaXMgKGhpZ2ggdG8gbG93KTpcbiAgICAgICAgICAgICAgICAvLyAxLiBpbnZva2UtbGV2ZWwgaGVhZGVyc1xuICAgICAgICAgICAgICAgIC8vIDIuIGNsaWVudC1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgLy8gMy4gZGVmYXVsdCBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9oZWFkZXJzKSwgdGhpcy5oZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChmZXRjaEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuRnVuY3Rpb25zRmV0Y2hFcnJvcihmZXRjaEVycm9yKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgaXNSZWxheUVycm9yID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtcmVsYXktZXJyb3InKTtcbiAgICAgICAgICAgICAgaWYgKCEoaXNSZWxheUVycm9yICYmIGlzUmVsYXlFcnJvciA9PT0gJ3RydWUnKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5GdW5jdGlvbnNSZWxheUVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5GdW5jdGlvbnNIdHRwRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RleHQvcGxhaW4nKS5zcGxpdCgnOycpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIyO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZVR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI4O1xuICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZm9ybURhdGEoKTtcbiAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMzO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM3O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0LnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgMzddXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGdW5jdGlvbnNDbGllbnQ7XG59KCk7XG5leHBvcnRzLkZ1bmN0aW9uc0NsaWVudCA9IEZ1bmN0aW9uc0NsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenRCUVVGQk8wRkJRMEU3UVVGUFowSXNTVUZGU0VFc1pVRkJaVHRGUVVzeFFpeDVRa0ZEUlVNc1IwRkJWeXhGUVU5TU8wbEJRVUVzSzBWQlFVWXNSVUZCUlR0TlFVRkJMRzlDUVV4S1F5eFBRVUZQTzAxQlFWQkJMRTlCUVU4c05rSkJRVWNzUlVGQlJUdE5RVU5hUXl4WFFVRlhMRkZCUVZoQkxGZEJRVmM3U1VGQlFUdEpRVTFpTEVsQlFVa3NRMEZCUTBZc1IwRkJSeXhIUVVGSFFTeEhRVUZITzBsQlEyUXNTVUZCU1N4RFFVRkRReXhQUVVGUExFZEJRVWRCTEU5QlFVODdTVUZEZEVJc1NVRkJTU3hEUVVGRFJTeExRVUZMTEVkQlFVY3NlVUpCUVZrc1JVRkJRMFFzVjBGQlZ5eERRVUZETzBWQlEzaERPMFZCUlVFN096czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkpRU3hwUWtGQlVVVXNTMEZCWVR0TlFVTnVRaXhKUVVGSkxFTkJRVU5JTEU5QlFVOHNRMEZCUTBrc1lVRkJZU3h2UWtGQllVUXNTMEZCU3l4RFFVRkZPMGxCUTJoRU8wbEJSVUU3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGSlRTeG5Ra0ZEU2tVc1dVRkJiMElzUlVGRGNVSTdUVUZCUVN4SlFVRjZRME1zYjBaQlFYVkRMRVZCUVVVN096czdPenM3TzJOQlJ5OUNUaXhQUVVGUExFZEJRWGxDVFN4aFFVRmhMRU5CUVRkRFRpeFBRVUZQTEVWQlFWRlBMRmxCUVZrc1IwRkJTMFFzWVVGQllTeERRVUZ3UTBVc1NVRkJTVHRqUVVWcVFrTXNVVUZCVVN4SFFVRXlRaXhGUVVGRk8yTkJSWHBETEVsQlEwVkdMRmxCUVZrc1MwRkRWbEFzVDBGQlR5eEpRVUZKTEVOQlFVTlZMRTFCUVUwc1EwRkJRME1zVTBGQlV5eERRVUZEUXl4alFVRmpMRU5CUVVORExFbEJRVWtzUTBGQlEySXNUMEZCVHl4RlFVRkZMR05CUVdNc1EwRkJReXhKUVVGTExFTkJRVU5CTEU5QlFVOHNRMEZCUXl4RlFVTjZSanRuUWtGRFFTeEpRVU5ITEU5QlFVOWpMRWxCUVVrc1MwRkJTeXhYUVVGWExFbEJRVWxRTEZsQlFWa3NXVUZCV1U4c1NVRkJTU3hKUVVNMVJGQXNXVUZCV1N4WlFVRlpVU3hYUVVGWExFVkJRMjVETzJ0Q1FVTkJPMnRDUVVOQk8ydENRVU5CVGl4UlFVRlJMRU5CUVVNc1kwRkJZeXhEUVVGRExFZEJRVWNzTUVKQlFUQkNPMnRDUVVOeVJFUXNTVUZCU1N4SFFVRkhSQ3haUVVGWk8ybENRVU53UWl4TlFVRk5MRWxCUVVrc1QwRkJUMEVzV1VGQldTeExRVUZMTEZGQlFWRXNSVUZCUlR0clFrRkRNME03YTBKQlEwRkZMRkZCUVZFc1EwRkJReXhqUVVGakxFTkJRVU1zUjBGQlJ5eFpRVUZaTzJ0Q1FVTjJRMFFzU1VGQlNTeEhRVUZIUkN4WlFVRlpPMmxDUVVOd1FpeE5RVUZOTEVsQlFVa3NUMEZCVDFNc1VVRkJVU3hMUVVGTExGZEJRVmNzU1VGQlNWUXNXVUZCV1N4WlFVRlpVeXhSUVVGUkxFVkJRVVU3YTBKQlF6bEZPMnRDUVVOQk8ydENRVU5CVWl4SlFVRkpMRWRCUVVkRUxGbEJRVms3YVVKQlEzQkNMRTFCUVUwN2EwSkJRMHc3YTBKQlEwRkZMRkZCUVZFc1EwRkJReXhqUVVGakxFTkJRVU1zUjBGQlJ5eHJRa0ZCYTBJN2EwSkJRemREUkN4SlFVRkpMRWRCUVVkVExFbEJRVWtzUTBGQlEwTXNVMEZCVXl4RFFVRkRXQ3haUVVGWkxFTkJRVU03T3p0alFVVjBRenRqUVVWblFpeFBRVUZOTEVsQlFVa3NRMEZCUTB3c1MwRkJTeXhYUVVGSkxFbEJRVWtzUTBGQlEwZ3NSMEZCUnl4alFVRkpUU3haUVVGWkxFZEJRVWs3WjBKQlF5OUVZeXhOUVVGTkxFVkJRVVVzVFVGQlRUdG5Ra0ZEWkR0blFrRkRRVHRuUWtGRFFUdG5Ra0ZEUVR0blFrRkRRVzVDTEU5QlFVOHNaMFJCUVU5VExGRkJRVkVzUjBGQlN5eEpRVUZKTEVOQlFVTlVMRTlCUVU4c1IwRkJTMEVzVDBGQlR5eERRVUZGTzJkQ1FVTnlSRkVzU1VGQlNTeEZRVUZLUVR0bFFVTkVMRU5CUVVNc1UwRkJUU3hEUVVGRExGVkJRVU5aTEZWQlFWVXNSVUZCU1R0blFrRkRkRUlzVFVGQlRTeEpRVUZKUXl3eVFrRkJiVUlzUTBGQlEwUXNWVUZCVlN4RFFVRkRPMk5CUXpORExFTkJRVU1zUTBGQlF6dFpRVUZCTzJOQlZrbEZMRkZCUVZFN1kwRlpVa01zV1VGQldTeEhRVUZIUkN4UlFVRlJMRU5CUVVOMFFpeFBRVUZQTEVOQlFVTjNRaXhIUVVGSExFTkJRVU1zWlVGQlpTeERRVUZETzJOQlFVRXNUVUZEZEVSRUxGbEJRVmtzU1VGQlNVRXNXVUZCV1N4TFFVRkxMRTFCUVUwN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMRTFCUTI1RExFbEJRVWxHTERKQ1FVRnRRaXhEUVVGRFF5eFJRVUZSTEVOQlFVTTdXVUZCUVR0alFVRkJMRWxCUjNCRFFTeFJRVUZSTEVOQlFVTkhMRVZCUVVVN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMRTFCUTFJc1NVRkJTVW9zTUVKQlFXdENMRU5CUVVORExGRkJRVkVzUTBGQlF6dFpRVUZCTzJOQlIzQkRTU3haUVVGWkxFZEJRVWNzUTBGQlF5eGpRVUZSTEVOQlFVTXhRaXhQUVVGUExFTkJRVU4zUWl4SFFVRkhMRU5CUVVNc1kwRkJZeXhEUVVGRExHMURRVUZKTEZsQlFWa3NSVUZCUlVjc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRReXhKUVVGSkxFVkJRVVU3WTBGQlFTeE5RVVV4UmtZc1dVRkJXU3hMUVVGTExHdENRVUZyUWp0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRTdZMEZET1VJc1QwRkJUVW9zVVVGQlVTeERRVUZEVHl4SlFVRkpMRVZCUVVVN1dVRkJRVHRqUVVFMVFrTXNTVUZCU1R0alFVRkJPMk5CUVVFN1dVRkJRVHRqUVVGQkxFMUJRMHRLTEZsQlFWa3NTMEZCU3l3d1FrRkJNRUk3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQk8yTkJRemRETEU5QlFVMUtMRkZCUVZFc1EwRkJRMU1zU1VGQlNTeEZRVUZGTzFsQlFVRTdZMEZCTlVKRUxFbEJRVWs3WTBGQlFUdGpRVUZCTzFsQlFVRTdZMEZCUVN4TlFVTkxTaXhaUVVGWkxFdEJRVXNzY1VKQlFYRkNPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVR0alFVTjRReXhQUVVGTlNpeFJRVUZSTEVOQlFVTlZMRkZCUVZFc1JVRkJSVHRaUVVGQk8yTkJRV2hEUml4SlFVRkpPMk5CUVVFN1kwRkJRVHRaUVVGQk8yTkJRVUU3WTBGSFJ5eFBRVUZOVWl4UlFVRlJMRU5CUVVOWExFbEJRVWtzUlVGQlJUdFpRVUZCTzJOQlFUVkNTQ3hKUVVGSk8xbEJRVUU3WTBGQlFTeHBRMEZIUXp0blFrRkJSVUVzU1VGQlNTeEZRVUZLUVN4SlFVRkpPMmRDUVVGRlNTeExRVUZMTEVWQlFVVTdZMEZCU1N4RFFVRkZPMWxCUVVFN1kwRkJRVHRqUVVGQk8yTkJRVUVzYVVOQlJYSkNPMmRDUVVGRlNpeEpRVUZKTEVWQlFVVXNTVUZCU1R0blFrRkJSVWtzUzBGQlN6dGpRVUZCTEVOQlFVVTdXVUZCUVR0WlFVRkJPMk5CUVVFN1ZVRkJRVHRSUVVGQk8wMUJRVUU3TzBWQlJTOUNPMFZCUVVFN1FVRkJRVHRCUVRGSFNFTWlMQ0p1WVcxbGN5STZXeUpHZFc1amRHbHZibk5EYkdsbGJuUWlMQ0oxY213aUxDSm9aV0ZrWlhKeklpd2lZM1Z6ZEc5dFJtVjBZMmdpTENKbVpYUmphQ0lzSW5SdmEyVnVJaXdpUVhWMGFHOXlhWHBoZEdsdmJpSXNJbVoxYm1OMGFXOXVUbUZ0WlNJc0ltbHVkbTlyWlU5d2RHbHZibk1pTENKbWRXNWpkR2x2YmtGeVozTWlMQ0ppYjJSNUlpd2lYMmhsWVdSbGNuTWlMQ0pQWW1wbFkzUWlMQ0p3Y205MGIzUjVjR1VpTENKb1lYTlBkMjVRY205d1pYSjBlU0lzSW1OaGJHd2lMQ0pDYkc5aUlpd2lRWEp5WVhsQ2RXWm1aWElpTENKR2IzSnRSR0YwWVNJc0lrcFRUMDRpTENKemRISnBibWRwWm5raUxDSnRaWFJvYjJRaUxDSm1aWFJqYUVWeWNtOXlJaXdpZEhsd1pYTmZNU0lzSW5KbGMzQnZibk5sSWl3aWFYTlNaV3hoZVVWeWNtOXlJaXdpWjJWMElpd2liMnNpTENKeVpYTndiMjV6WlZSNWNHVWlMQ0p6Y0d4cGRDSXNJblJ5YVcwaUxDSnFjMjl1SWl3aVpHRjBZU0lzSW1Kc2IySWlMQ0ptYjNKdFJHRjBZU0lzSW5SbGVIUWlMQ0psY25KdmNpSXNJbVY0Y0c5eWRITWlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDBaMWJtTjBhVzl1YzBOc2FXVnVkQzUwY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNlcyNTFiR3hkZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxudmFyIF9fY3JlYXRlQmluZGluZyA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgIGRlc2MgPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdm9pZCAwICYmICh2b2lkIDApLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZcbiAgfSk7XG59IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gdm9pZCAwICYmICh2b2lkIDApLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19hd2FpdGVyIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVzb2x2ZUZldGNoID0gdm9pZCAwO1xudmFyIHJlc29sdmVGZXRjaCA9IGZ1bmN0aW9uIHJlc29sdmVGZXRjaChjdXN0b21GZXRjaCkge1xuICB2YXIgX2ZldGNoO1xuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gZnVuY3Rpb24gX2ZldGNoKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgX3lpZWxkJFByb21pc2UkcmVzb2x2O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnY3Jvc3MtZmV0Y2gnKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIChfeWllbGQkUHJvbWlzZSRyZXNvbHYgPSBfY29udGV4dC5zZW50KS5mZXRjaC5hcHBseShfeWllbGQkUHJvbWlzZSRyZXNvbHYsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICB9KSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZmV0Y2guYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbmV4cG9ydHMucmVzb2x2ZUZldGNoID0gcmVzb2x2ZUZldGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN08wRkJSVThzU1VGQlRVRXNXVUZCV1N4SFFVRkhMRk5CUVdaQkxGbEJRVmtzUTBGQlNVTXNWMEZCYlVJc1JVRkJWenRGUVVONlJDeEpRVUZKUXl4TlFVRmhPMFZCUTJwQ0xFbEJRVWxFTEZkQlFWY3NSVUZCUlR0SlFVTm1ReXhOUVVGTkxFZEJRVWRFTEZkQlFWYzdSMEZEY2tJc1RVRkJUU3hKUVVGSkxFOUJRVTlGTEV0QlFVc3NTMEZCU3l4WFFVRlhMRVZCUVVVN1NVRkRka05FTEUxQlFVMHNSMEZCUnp0TlFVRkJMR3REUVVGVlJTeEpRVUZKTzFGQlFVcEJMRWxCUVVrN1RVRkJRVHROUVVGQkxFOUJRVWxETzFGQlFVRTdVVUZCUVR0VlFVRkJPMWxCUVVFN1kwRkJRVHRqUVVGUk8yZENRVUZCTERSQ1FVRmhMR0ZCUVdFN1kwRkJRU3hGUVVGRE8xbEJRVUU3WTBGQlFUdGpRVUZzUXl3clEwRkJiME5HTEV0QlFVc3NPRUpCUVVsRExFbEJRVWs3V1VGQlF6dGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQk8wbEJRVUU3UjBGREwwVXNUVUZCVFR0SlFVTk1SaXhOUVVGTkxFZEJRVWRETEV0QlFVczdPMFZCUldoQ0xFOUJRVTg3U1VGQlFTeFBRVUZoUkN4TlFVRk5MSGxDUVVGVE8wVkJRVUU3UVVGRGNrTXNRMEZCUXp0QlFWWlpTU3h2UWtGQldTSXNJbTVoYldWeklqcGJJbkpsYzI5c2RtVkdaWFJqYUNJc0ltTjFjM1J2YlVabGRHTm9JaXdpWDJabGRHTm9JaXdpWm1WMFkyZ2lMQ0poY21keklpd2lYMTloZDJGcGRHVnlJaXdpWlhod2IzSjBjeUpkTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdmFHVnNjR1Z5TG5SeklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJiblZzYkYxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5GdW5jdGlvbnNSZWxheUVycm9yID0gZXhwb3J0cy5GdW5jdGlvbnNIdHRwRXJyb3IgPSBleHBvcnRzLkZ1bmN0aW9uc0ZldGNoRXJyb3IgPSBleHBvcnRzLkZ1bmN0aW9uc0Vycm9yID0gZXhwb3J0cy5GdW5jdGlvbnNDbGllbnQgPSB2b2lkIDA7XG52YXIgRnVuY3Rpb25zQ2xpZW50XzEgPSByZXF1aXJlKFwiLi9GdW5jdGlvbnNDbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbnNDbGllbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gRnVuY3Rpb25zQ2xpZW50XzEuRnVuY3Rpb25zQ2xpZW50O1xuICB9XG59KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbnNFcnJvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0eXBlc18xLkZ1bmN0aW9uc0Vycm9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZ1bmN0aW9uc0ZldGNoRXJyb3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdHlwZXNfMS5GdW5jdGlvbnNGZXRjaEVycm9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZ1bmN0aW9uc0h0dHBFcnJvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0eXBlc18xLkZ1bmN0aW9uc0h0dHBFcnJvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbnNSZWxheUVycm9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHR5cGVzXzEuRnVuY3Rpb25zUmVsYXlFcnJvcjtcbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN08wRkJRVUU3UVVGQlUwRTdSVUZCUVVNN1JVRkJRVU03U1VGQlFTeDNRMEZCWlR0RlFVRkJPMEZCUVVFN1FVRkRlRUk3UVVGRFJVWTdSVUZCUVVNN1JVRkJRVU03U1VGQlFTdzJRa0ZCWXp0RlFVRkJPMEZCUVVFN1FVRkRaRVk3UlVGQlFVTTdSVUZCUVVNN1NVRkJRU3hyUTBGQmJVSTdSVUZCUVR0QlFVRkJPMEZCUTI1Q1JqdEZRVUZCUXp0RlFVRkJRenRKUVVGQkxHbERRVUZyUWp0RlFVRkJPMEZCUVVFN1FVRkRiRUpHTzBWQlFVRkRPMFZCUVVGRE8wbEJRVUVzYTBOQlFXMUNPMFZCUVVFN1FVRkJRU0lzSW01aGJXVnpJanBiSWs5aWFtVmpkQ0lzSW1WdWRXMWxjbUZpYkdVaUxDSm5aWFFpWFN3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwybHVaR1Y0TG5SeklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJiblZzYkYxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LnNldCkgeyBzZXQgPSBSZWZsZWN0LnNldDsgfSBlbHNlIHsgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyB2YXIgZGVzYzsgaWYgKGJhc2UpIHsgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5zZXQpIHsgZGVzYy5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBlbHNlIGlmICghZGVzYy53cml0YWJsZSkgeyByZXR1cm4gZmFsc2U7IH0gfSBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWNlaXZlciwgcHJvcGVydHkpOyBpZiAoZGVzYykgeyBpZiAoIWRlc2Mud3JpdGFibGUpIHsgcmV0dXJuIGZhbHNlOyB9IGRlc2MudmFsdWUgPSB2YWx1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgZGVzYyk7IH0gZWxzZSB7IF9kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHksIHZhbHVlKTsgfSByZXR1cm4gdHJ1ZTsgfTsgfSByZXR1cm4gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcik7IH1cbmZ1bmN0aW9uIF9zZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyLCBpc1N0cmljdCkgeyB2YXIgcyA9IHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgaWYgKCFzICYmIGlzU3RyaWN0KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZhaWxlZCB0byBzZXQgcHJvcGVydHknKTsgfSByZXR1cm4gdmFsdWU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpOyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkZ1bmN0aW9uc0h0dHBFcnJvciA9IGV4cG9ydHMuRnVuY3Rpb25zUmVsYXlFcnJvciA9IGV4cG9ydHMuRnVuY3Rpb25zRmV0Y2hFcnJvciA9IGV4cG9ydHMuRnVuY3Rpb25zRXJyb3IgPSB2b2lkIDA7XG52YXIgRnVuY3Rpb25zRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoRnVuY3Rpb25zRXJyb3IsIF9FcnJvcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRnVuY3Rpb25zRXJyb3IpO1xuICBmdW5jdGlvbiBGdW5jdGlvbnNFcnJvcihtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzU3VwZXIsIF90aGlzO1xuICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnRnVuY3Rpb25zRXJyb3InO1xuICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uc0Vycm9yKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF9zZXQoKF90aGlzU3VwZXIgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgX2dldFByb3RvdHlwZU9mKEZ1bmN0aW9uc0Vycm9yLnByb3RvdHlwZSkpLCBcIm5hbWVcIiwgbmFtZSwgX3RoaXNTdXBlciwgdHJ1ZSk7XG4gICAgX3RoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRnVuY3Rpb25zRXJyb3IpO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbmV4cG9ydHMuRnVuY3Rpb25zRXJyb3IgPSBGdW5jdGlvbnNFcnJvcjtcbnZhciBGdW5jdGlvbnNGZXRjaEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRnVuY3Rpb25zRXJyb3IpIHtcbiAgX2luaGVyaXRzKEZ1bmN0aW9uc0ZldGNoRXJyb3IsIF9GdW5jdGlvbnNFcnJvcik7XG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKEZ1bmN0aW9uc0ZldGNoRXJyb3IpO1xuICBmdW5jdGlvbiBGdW5jdGlvbnNGZXRjaEVycm9yKGNvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVuY3Rpb25zRmV0Y2hFcnJvcik7XG4gICAgcmV0dXJuIF9zdXBlcjIuY2FsbCh0aGlzLCAnRmFpbGVkIHRvIHNlbmQgYSByZXF1ZXN0IHRvIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc0ZldGNoRXJyb3InLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZ1bmN0aW9uc0ZldGNoRXJyb3IpO1xufShGdW5jdGlvbnNFcnJvcik7XG5leHBvcnRzLkZ1bmN0aW9uc0ZldGNoRXJyb3IgPSBGdW5jdGlvbnNGZXRjaEVycm9yO1xudmFyIEZ1bmN0aW9uc1JlbGF5RXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9GdW5jdGlvbnNFcnJvcjIpIHtcbiAgX2luaGVyaXRzKEZ1bmN0aW9uc1JlbGF5RXJyb3IsIF9GdW5jdGlvbnNFcnJvcjIpO1xuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihGdW5jdGlvbnNSZWxheUVycm9yKTtcbiAgZnVuY3Rpb24gRnVuY3Rpb25zUmVsYXlFcnJvcihjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uc1JlbGF5RXJyb3IpO1xuICAgIHJldHVybiBfc3VwZXIzLmNhbGwodGhpcywgJ1JlbGF5IEVycm9yIGludm9raW5nIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc1JlbGF5RXJyb3InLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZ1bmN0aW9uc1JlbGF5RXJyb3IpO1xufShGdW5jdGlvbnNFcnJvcik7XG5leHBvcnRzLkZ1bmN0aW9uc1JlbGF5RXJyb3IgPSBGdW5jdGlvbnNSZWxheUVycm9yO1xudmFyIEZ1bmN0aW9uc0h0dHBFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Z1bmN0aW9uc0Vycm9yMykge1xuICBfaW5oZXJpdHMoRnVuY3Rpb25zSHR0cEVycm9yLCBfRnVuY3Rpb25zRXJyb3IzKTtcbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoRnVuY3Rpb25zSHR0cEVycm9yKTtcbiAgZnVuY3Rpb24gRnVuY3Rpb25zSHR0cEVycm9yKGNvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVuY3Rpb25zSHR0cEVycm9yKTtcbiAgICByZXR1cm4gX3N1cGVyNC5jYWxsKHRoaXMsICdFZGdlIEZ1bmN0aW9uIHJldHVybmVkIGEgbm9uLTJ4eCBzdGF0dXMgY29kZScsICdGdW5jdGlvbnNIdHRwRXJyb3InLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZ1bmN0aW9uc0h0dHBFcnJvcik7XG59KEZ1bmN0aW9uc0Vycm9yKTtcbmV4cG9ydHMuRnVuY3Rpb25zSHR0cEVycm9yID0gRnVuY3Rpb25zSHR0cEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3U1VGblFtRkJMR05CUVdVN1JVRkJRVHRGUVVGQk8wVkJSVEZDTEhkQ1FVRlpReXhQUVVGbExFVkJRWGRETzBsQlFVRTdTVUZCUVN4SlFVRjBRME1zU1VGQlNTeDFSVUZCUnl4blFrRkJaMEk3U1VGQlFTeEpRVUZGUXl4UFFVRmhPMGxCUVVFN1NVRkRha1VzTUVKQlFVMUdMRTlCUVU4N1NVRkRZaXh6UjBGQllVTXNTVUZCU1R0SlFVTnFRaXhOUVVGTFF5eFBRVUZQTEVkQlFVZEJMRTlCUVU4N1NVRkJRVHRGUVVONFFqdEZRVUZETzBGQlFVRXNhVU5CVG1sRFF5eExRVUZMTzBGQlFYcERRenRCUVU5RExFbEJSVmxETEcxQ1FVRnZRanRGUVVGQk8wVkJRVUU3UlVGREwwSXNOa0pCUVZsSUxFOUJRVms3U1VGQlFUdEpRVUZCTERCQ1FVTm9RaXdyUTBGQkswTXNSVUZCUlN4eFFrRkJjVUlzUlVGQlJVRXNUMEZCVHp0RlFVTjJSanRGUVVGRE8wRkJRVUVzUlVGSWMwTklMR05CUVdNN1FVRkJka1JMTzBGQlNVTXNTVUZGV1VVc2JVSkJRVzlDTzBWQlFVRTdSVUZCUVR0RlFVTXZRaXcyUWtGQldVb3NUMEZCV1R0SlFVRkJPMGxCUVVFc01FSkJRMmhDTEhkRFFVRjNReXhGUVVGRkxIRkNRVUZ4UWl4RlFVRkZRU3hQUVVGUE8wVkJRMmhHTzBWQlFVTTdRVUZCUVN4RlFVaHpRMGdzWTBGQll6dEJRVUYyUkVzN1FVRkpReXhKUVVWWlJ5eHJRa0ZCYlVJN1JVRkJRVHRGUVVGQk8wVkJRemxDTERSQ1FVRlpUQ3hQUVVGWk8wbEJRVUU3U1VGQlFTd3dRa0ZEYUVJc09FTkJRVGhETEVWQlFVVXNiMEpCUVc5Q0xFVkJRVVZCTEU5QlFVODdSVUZEY2tZN1JVRkJRenRCUVVGQkxFVkJTSEZEU0N4alFVRmpPMEZCUVhSRVN5SXNJbTVoYldWeklqcGJJa1oxYm1OMGFXOXVjMFZ5Y205eUlpd2liV1Z6YzJGblpTSXNJbTVoYldVaUxDSmpiMjUwWlhoMElpd2lSWEp5YjNJaUxDSmxlSEJ2Y25Seklpd2lSblZ1WTNScGIyNXpSbVYwWTJoRmNuSnZjaUlzSWtaMWJtTjBhVzl1YzFKbGJHRjVSWEp5YjNJaUxDSkdkVzVqZEdsdmJuTklkSFJ3UlhKeWIzSWlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDNSNWNHVnpMblJ6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYmJuVnNiRjE5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IFwidXNlIHN0cmljdFwiOyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbnZhciBfX2F3YWl0ZXIgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19hd2FpdGVyIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59O1xudmFyIF9fcmVzdCA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX3Jlc3QgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgZmV0Y2hfMSA9IHJlcXVpcmUoXCIuL2xpYi9mZXRjaFwiKTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9saWIvaGVscGVyc1wiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2xpYi9lcnJvcnNcIik7XG52YXIgR29UcnVlQWRtaW5BcGkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHb1RydWVBZG1pbkFwaShfcmVmKSB7XG4gICAgdmFyIF9yZWYkdXJsID0gX3JlZi51cmwsXG4gICAgICB1cmwgPSBfcmVmJHVybCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHVybCxcbiAgICAgIF9yZWYkaGVhZGVycyA9IF9yZWYuaGVhZGVycyxcbiAgICAgIGhlYWRlcnMgPSBfcmVmJGhlYWRlcnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRoZWFkZXJzLFxuICAgICAgZmV0Y2ggPSBfcmVmLmZldGNoO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHb1RydWVBZG1pbkFwaSk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLmZldGNoID0gKDAsIGhlbHBlcnNfMS5yZXNvbHZlRmV0Y2gpKGZldGNoKTtcbiAgICB0aGlzLm1mYSA9IHtcbiAgICAgIGxpc3RGYWN0b3JzOiB0aGlzLl9saXN0RmFjdG9ycy5iaW5kKHRoaXMpLFxuICAgICAgZGVsZXRlRmFjdG9yOiB0aGlzLl9kZWxldGVGYWN0b3IuYmluZCh0aGlzKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsb2dnZWQtaW4gc2Vzc2lvbi5cbiAgICogQHBhcmFtIGp3dCBBIHZhbGlkLCBsb2dnZWQtaW4gSldULlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEdvVHJ1ZUFkbWluQXBpLCBbe1xuICAgIGtleTogXCJzaWduT3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25PdXQoand0KSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL2xvZ291dFwiKSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBqd3Q6IGp3dCxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNjtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0LnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQudDA7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCA2XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBpbnZpdGUgbGluayB0byBhbiBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBlbWFpbCBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIEEgVVJMIG9yIG1vYmlsZSBkZWVwbGluayB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgYXJlIGNvbmZpcm1lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIE9wdGlvbmFsIHVzZXIgbWV0YWRhdGFcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbnZpdGVVc2VyQnlFbWFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZpdGVVc2VyQnlFbWFpbChlbWFpbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvaW52aXRlXCIpLCB7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgZW1haWw6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl91c2VyUmVzcG9uc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA2O1xuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKF9jb250ZXh0Mi50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB1c2VyOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQyLnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQyLnQwO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCA2XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgZW1haWwgbGlua3MgYW5kIE9UUHMgdG8gYmUgc2VudCB2aWEgYSBjdXN0b20gZW1haWwgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSB1c2VyJ3MgZW1haWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFzc3dvcmQgVXNlciBwYXNzd29yZC4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgT3B0aW9uYWwgdXNlciBtZXRhZGF0YS4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIHJlZGlyZWN0IHVybCB3aGljaCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGdlbmVyYXRlZCBsaW5rXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVMaW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlTGluayhwYXJhbXMpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMsIHJlc3QsIGJvZHk7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7XG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucywgcmVzdCA9IF9fcmVzdChwYXJhbXMsIFtcIm9wdGlvbnNcIl0pO1xuICAgICAgICAgICAgICBib2R5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGlmICgnbmV3RW1haWwnIGluIHJlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIG5ld0VtYWlsIHdpdGggbmV3X2VtYWlsIGluIHJlcXVlc3QgYm9keVxuICAgICAgICAgICAgICAgIGJvZHkubmV3X2VtYWlsID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0Lm5ld0VtYWlsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBib2R5WyduZXdFbWFpbCddO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9hZG1pbi9nZW5lcmF0ZV9saW5rXCIpLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX2dlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDMuc2VudCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDMudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDMudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDMudDA7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzAsIDldXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFVzZXIgQWRtaW4gQVBJXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVXNlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVVc2VyKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL2FkbWluL3VzZXJzXCIpLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3VzZXJSZXNwb25zZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ0LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDY7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IF9jb250ZXh0NFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQ0LnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDQudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDQudDA7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzAsIDZdXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdXNlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IHdoaWNoIHN1cHBvcnRzIGBwYWdlYCBhbmQgYHBlclBhZ2VgIGFzIG51bWJlcnMsIHRvIGFsdGVyIHRoZSBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsaXN0VXNlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdFVzZXJzKHBhcmFtcykge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgICAgICB2YXIgcGFnaW5hdGlvbiwgcmVzcG9uc2UsIHVzZXJzLCB0b3RhbCwgbGlua3M7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDA7XG4gICAgICAgICAgICAgIHBhZ2luYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgbGFzdFBhZ2U6IDAsXG4gICAgICAgICAgICAgICAgdG90YWw6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdHRVQnLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvYWRtaW4vdXNlcnNcIiksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgcGFnZTogKF9iID0gKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICAgICAgICAgICAgICAgIHBlcl9wYWdlOiAoX2QgPSAoX2MgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGVyUGFnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fbm9SZXNvbHZlSnNvblJlc3BvbnNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDk7XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIHVzZXJzID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICAgIHRvdGFsID0gKF9lID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtdG90YWwtY291bnQnKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcbiAgICAgICAgICAgICAgbGlua3MgPSAoX2cgPSAoX2YgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3BsaXQoJywnKSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogW107XG4gICAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICAgICAgdmFyIHBhZ2UgPSBwYXJzZUludChsaW5rLnNwbGl0KCc7JylbMF0uc3BsaXQoJz0nKVsxXS5zdWJzdHJpbmcoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbltcIlwiLmNvbmNhdChyZWwsIFwiUGFnZVwiKV0gPSBwYWdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXNlcnMpLCBwYWdpbmF0aW9uKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMTY7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQ1LnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVzZXJzOiBbXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0NS50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0NS50MDtcbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMCwgMTZdXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGJ5IGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVpZCBUaGUgdXNlcidzIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFVzZXJCeUlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVzZXJCeUlkKHVpZCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ0dFVCcsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9hZG1pbi91c2Vycy9cIikuY29uY2F0KHVpZCksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3VzZXJSZXNwb25zZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ2LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDY7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQ2LnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDYudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDYudDA7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzAsIDZdXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBkYXRhIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVXNlckJ5SWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVXNlckJ5SWQodWlkLCBhdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUFVUJywgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL2FkbWluL3VzZXJzL1wiKS5jb25jYXQodWlkKSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl91c2VyUmVzcG9uc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ny5zZW50KTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSA2O1xuICAgICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKF9jb250ZXh0Ny50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB1c2VyOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQ3LnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ3LnQwO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcywgW1swLCA2XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSB1c2VyLiBSZXF1aXJlcyBhIGBzZXJ2aWNlX3JvbGVgIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdXNlciBpZCB5b3Ugd2FudCB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVVzZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlVXNlcihpZCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ0RFTEVURScsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9hZG1pbi91c2Vycy9cIikuY29uY2F0KGlkKSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fdXNlclJlc3BvbnNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDguc2VudCk7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gNjtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4LnQwID0gX2NvbnRleHQ4W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDgudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0OC50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0OC50MDtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMsIFtbMCwgNl1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2xpc3RGYWN0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saXN0RmFjdG9ycyhwYXJhbXMpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOSgpIHtcbiAgICAgICAgdmFyIF95aWVsZCwgZGF0YSwgZXJyb3I7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDkucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnR0VUJywgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL2FkbWluL3VzZXJzL1wiKS5jb25jYXQocGFyYW1zLnVzZXJJZCwgXCIvZmFjdG9yc1wiKSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogZnVuY3Rpb24geGZvcm0oZmFjdG9ycykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnM6IGZhY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX3lpZWxkID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICAgIGRhdGEgPSBfeWllbGQuZGF0YTtcbiAgICAgICAgICAgICAgZXJyb3IgPSBfeWllbGQuZXJyb3I7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQ5LnByZXYgPSA5O1xuICAgICAgICAgICAgICBfY29udGV4dDkudDAgPSBfY29udGV4dDlbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKF9jb250ZXh0OS50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDkudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDkudDA7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU5LCB0aGlzLCBbWzAsIDldXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZWxldGVGYWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZUZhY3RvcihwYXJhbXMpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ0RFTEVURScsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9hZG1pbi91c2Vycy9cIikuY29uY2F0KHBhcmFtcy51c2VySWQsIFwiL2ZhY3RvcnMvXCIpLmNvbmNhdChwYXJhbXMuaWQpLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBkYXRhID0gX2NvbnRleHQxMC5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDc7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAudDAgPSBfY29udGV4dDEwW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDEwLnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQxMC50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MTAudDA7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTAsIHRoaXMsIFtbMCwgN11dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEdvVHJ1ZUFkbWluQXBpO1xufSgpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBHb1RydWVBZG1pbkFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdRVUZCUVR0QlFVOUJPMEZCWlVFN1FVRkJjVVFzU1VGRmFFTkJMR05CUVdNN1JVRlZha01zT0VKQlZVTTdTVUZCUVN4dlFrRlVRME1zUjBGQlJ6dE5RVUZJUVN4SFFVRkhMSGxDUVVGSExFVkJRVVU3VFVGQlFTeHZRa0ZEVWtNc1QwRkJUenROUVVGUVFTeFBRVUZQTERaQ1FVRkhMRVZCUVVVN1RVRkRXa01zUzBGQlN5eFJRVUZNUVN4TFFVRkxPMGxCUVVFN1NVRlJUQ3hKUVVGSkxFTkJRVU5HTEVkQlFVY3NSMEZCUjBFc1IwRkJSenRKUVVOa0xFbEJRVWtzUTBGQlEwTXNUMEZCVHl4SFFVRkhRU3hQUVVGUE8wbEJRM1JDTEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhIUVVGSExEQkNRVUZaTEVWQlFVTkJMRXRCUVVzc1EwRkJRenRKUVVOb1F5eEpRVUZKTEVOQlFVTkRMRWRCUVVjc1IwRkJSenROUVVOVVF5eFhRVUZYTEVWQlFVVXNTVUZCU1N4RFFVRkRReXhaUVVGWkxFTkJRVU5ETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNN1RVRkRla05ETEZsQlFWa3NSVUZCUlN4SlFVRkpMRU5CUVVORExHRkJRV0VzUTBGQlEwWXNTVUZCU1N4RFFVRkRMRWxCUVVrN1MwRkRNME03UlVGRFNEdEZRVVZCT3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlNVMHNhVUpCUVZGSExFZEJRVmM3T3pzN096czdZMEZGY2tJc1QwRkJUU3h2UWtGQlVTeEZRVUZETEVsQlFVa3NRMEZCUTFBc1MwRkJTeXhGUVVGRkxFMUJRVTBzV1VGQlN5eEpRVUZKTEVOQlFVTkdMRWRCUVVjc1kwRkJWenRuUWtGRGRrUkRMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU5CTEU5QlFVODdaMEpCUTNKQ1VTeEhRVUZITEVWQlFVaEJMRWRCUVVjN1owSkJRMGhETEdGQlFXRXNSVUZCUlR0bFFVTm9RaXhEUVVGRE8xbEJRVUU3WTBGQlFTeHBRMEZEU3p0blFrRkJSVU1zU1VGQlNTeEZRVUZGTEVsQlFVazdaMEpCUVVWRExFdEJRVXNzUlVGQlJUdGpRVUZKTEVOQlFVVTdXVUZCUVR0alFVRkJPMk5CUVVFN1kwRkJRU3hMUVVVNVFpeDNRa0ZCVnl4alFVRlBPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVN4cFEwRkRZanRuUWtGQlJVUXNTVUZCU1N4RlFVRkZMRWxCUVVrN1owSkJRVVZETEV0QlFVczdZMEZCUVN4RFFVRkZPMWxCUVVFN1kwRkJRVHRaUVVGQk8xbEJRVUU3WTBGQlFUdFZRVUZCTzFGQlFVRTdUVUZCUVN4RFFVdHFRenM3U1VGRlJEczdPenM3TzBWQlFVRTdTVUZCUVR0SlFVRkJMRTlCVFUwc01rSkJRMHBETEV0QlFXRXNSVUZKVUR0TlFVRkJMRWxCU0U1RExEaEZRVWRKTEVWQlFVVTdPenM3T3pzN1kwRkhSeXhQUVVGTkxHOUNRVUZSTEVWQlFVTXNTVUZCU1N4RFFVRkRXaXhMUVVGTExFVkJRVVVzVFVGQlRTeFpRVUZMTEVsQlFVa3NRMEZCUTBZc1IwRkJSeXhqUVVGWE8yZENRVU01UkdVc1NVRkJTU3hGUVVGRk8ydENRVUZGUml4TFFVRkxMRVZCUVV4QkxFdEJRVXM3YTBKQlFVVkdMRWxCUVVrc1JVRkJSVWNzVDBGQlR5eERRVUZEU0R0blFrRkJTU3hEUVVGRk8yZENRVU51UTFZc1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlEwRXNUMEZCVHp0blFrRkRja0psTEZWQlFWVXNSVUZCUlVZc1QwRkJUeXhEUVVGRFJTeFZRVUZWTzJkQ1FVTTVRa01zUzBGQlN5eEZRVUZGUXp0bFFVTlNMRU5CUVVNN1dVRkJRVHRqUVVGQk8xbEJRVUU3WTBGQlFUdGpRVUZCTzJOQlFVRXNTMEZGUlN4M1FrRkJWeXhsUVVGUE8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3hyUTBGRFlqdG5Ra0ZCUlZBc1NVRkJTU3hGUVVGRk8ydENRVUZGVVN4SlFVRkpMRVZCUVVVN1owSkJRVWtzUTBGQlJUdG5Ra0ZCUlZBc1MwRkJTenRqUVVGQkxFTkJRVVU3V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQkxFTkJTek5ET3p0SlFVVkVPenM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlQwMHNjMEpCUVdGUkxFMUJRVEJDT3pzN096czdPMk5CUldwRFRpeFBRVUZQTEVkQlFXTk5MRTFCUVUwc1EwRkJNMEpPTEU5QlFVOHNSVUZCUzA4c1NVRkJTU3hWUVVGTFJDeE5RVUZOTEVWQlFUZENMRmRCUVc5Q0xFTkJRVk03WTBGRE4wSk1MRWxCUVVrc2JVTkJRV0ZOTEVsQlFVa3NSMEZCUzFBc1QwRkJUeXhEUVVGRk8yTkJRM3BETEVsQlFVa3NWVUZCVlN4SlFVRkpUeXhKUVVGSkxFVkJRVVU3WjBKQlEzUkNPMmRDUVVOQlRpeEpRVUZKTEVOQlFVTlBMRk5CUVZNc1IwRkJSMFFzU1VGQlNTeGhRVUZLUVN4SlFVRkpMSFZDUVVGS1FTeEpRVUZKTEVOQlFVVkZMRkZCUVZFN1owSkJReTlDTEU5QlFVOVNMRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU03TzJOQlEzaENPMk5CUTAwc1QwRkJUU3h2UWtGQlVTeEZRVUZETEVsQlFVa3NRMEZCUTJJc1MwRkJTeXhGUVVGRkxFMUJRVTBzV1VGQlN5eEpRVUZKTEVOQlFVTkdMRWRCUVVjc01rSkJRWGRDTzJkQ1FVTXpSV1VzU1VGQlNTeEZRVUZGUVN4SlFVRkpPMmRDUVVOV1pDeFBRVUZQTEVWQlFVVXNTVUZCU1N4RFFVRkRRU3hQUVVGUE8yZENRVU55UW1kQ0xFdEJRVXNzUlVGQlJVTXNOa0pCUVhGQ08yZENRVU0xUWtZc1ZVRkJWU3hGUVVGRlJpeFBRVUZQTEdGQlFWQkJMRTlCUVU4c2RVSkJRVkJCTEU5QlFVOHNRMEZCUlVVN1pVRkRkRUlzUTBGQlF6dFpRVUZCTzJOQlFVRTdXVUZCUVR0alFVRkJPMk5CUVVFN1kwRkJRU3hMUVVWRkxIZENRVUZYTEdWQlFVODdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEd0RFFVTmlPMmRDUVVOTVRDeEpRVUZKTEVWQlFVVTdhMEpCUTBwaExGVkJRVlVzUlVGQlJTeEpRVUZKTzJ0Q1FVTm9Ra3dzU1VGQlNTeEZRVUZGTzJsQ1FVTlFPMmRDUVVORVVDeExRVUZMTzJWQlEwNDdXVUZCUVR0alFVRkJPMWxCUVVFN1dVRkJRVHRqUVVGQk8xVkJRVUU3VVVGQlFUdE5RVUZCTEVOQlNVNDdPMGxCUlVRN1NVRkRRVHM3T3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVVsTkxHOUNRVUZYWVN4VlFVRXJRanM3T3pzN096dGpRVVZ5UXl4UFFVRk5MRzlDUVVGUkxFVkJRVU1zU1VGQlNTeERRVUZEZGtJc1MwRkJTeXhGUVVGRkxFMUJRVTBzV1VGQlN5eEpRVUZKTEVOQlFVTkdMRWRCUVVjc2JVSkJRV2RDTzJkQ1FVTnVSV1VzU1VGQlNTeEZRVUZGVlN4VlFVRlZPMmRDUVVOb1FuaENMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU5CTEU5QlFVODdaMEpCUTNKQ1owSXNTMEZCU3l4RlFVRkZRenRsUVVOU0xFTkJRVU03V1VGQlFUdGpRVUZCTzFsQlFVRTdZMEZCUVR0alFVRkJPMk5CUVVFc1MwRkZSU3gzUWtGQlZ5eGxRVUZQTzJkQ1FVRkJPMmRDUVVGQk8yTkJRVUU3WTBGQlFTeHJRMEZEWWp0blFrRkJSVkFzU1VGQlNTeEZRVUZGTzJ0Q1FVRkZVU3hKUVVGSkxFVkJRVVU3WjBKQlFVa3NRMEZCUlR0blFrRkJSVkFzUzBGQlN6dGpRVUZCTEVOQlFVVTdXVUZCUVR0alFVRkJPMWxCUVVFN1dVRkJRVHRqUVVGQk8xVkJRVUU3VVVGQlFUdE5RVUZCTEVOQlN6TkRPenRKUVVWRU96czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZOVFN4dFFrRkRTbEVzVFVGQmJVSTdPenM3T3pzN08yTkJUVmhOTEZWQlFWVXNSMEZCWlR0blFrRkJSVU1zVVVGQlVTeEZRVUZGTEVsQlFVazdaMEpCUVVWRExGRkJRVkVzUlVGQlJTeERRVUZETzJkQ1FVRkZReXhMUVVGTExFVkJRVVU3WTBGQlF5eERRVUZGTzJOQlFVRTdZMEZEZGtRc1QwRkJUU3h2UWtGQlVTeEZRVUZETEVsQlFVa3NRMEZCUXpOQ0xFdEJRVXNzUlVGQlJTeExRVUZMTEZsQlFVc3NTVUZCU1N4RFFVRkRSaXhIUVVGSExHMUNRVUZuUWp0blFrRkROVVZETEU5QlFVOHNSVUZCUlN4SlFVRkpMRU5CUVVOQkxFOUJRVTg3WjBKQlEzSkNVeXhoUVVGaExFVkJRVVVzU1VGQlNUdG5Ra0ZEYmtKdlFpeExRVUZMTEVWQlFVVTdhMEpCUTB4RExFbEJRVWtzUlVGQlJTeHJRa0ZCVFN4aFFVRk9XQ3hOUVVGTkxIVkNRVUZPUVN4TlFVRk5MRU5CUVVWWExFbEJRVWtzTUVOQlFVVkRMRkZCUVZFc1JVRkJSU3h0UTBGQlNTeEZRVUZGTzJ0Q1FVTndRME1zVVVGQlVTeEZRVUZGTEd0Q1FVRk5MR0ZCUVU1aUxFMUJRVTBzZFVKQlFVNUJMRTFCUVUwc1EwRkJSV01zVDBGQlR5d3dRMEZCUlVZc1VVRkJVU3hGUVVGRkxHMURRVUZKTzJsQ1FVTXhRenRuUWtGRFJHWXNTMEZCU3l4RlFVRkZRenRsUVVOU0xFTkJRVU03V1VGQlFUdGpRVkpKYVVJc1VVRkJVVHRqUVVGQkxFdEJVMVpCTEZGQlFWRXNRMEZCUTNaQ0xFdEJRVXM3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxFMUJRVkYxUWl4UlFVRlJMRU5CUVVOMlFpeExRVUZMTzFsQlFVRTdZMEZCUVR0alFVVXhRaXhQUVVGTmRVSXNVVUZCVVN4RFFVRkRReXhKUVVGSkxFVkJRVVU3V1VGQlFUdGpRVUUzUWtNc1MwRkJTenRqUVVOTVVpeExRVUZMTEVkQlFVY3NZMEZCVVN4RFFVRkROVUlzVDBGQlR5eERRVUZEY1VNc1IwRkJSeXhEUVVGRExHVkJRV1VzUTBGQlF5eHRRMEZCU1N4RFFVRkRPMk5CUTJ4RVF5eExRVUZMTEVkQlFVY3NiMEpCUVZFc1EwRkJRM1JETEU5QlFVOHNRMEZCUTNGRExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNNRU5CUVVWRkxFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNiVU5CUVVrc1JVRkJSVHRqUVVNMVJDeEpRVUZKUkN4TFFVRkxMRU5CUVVORkxFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVTdaMEpCUTNCQ1JpeExRVUZMTEVOQlFVTkhMRTlCUVU4c1EwRkJReXhWUVVGRFF5eEpRVUZaTEVWQlFVazdhMEpCUXpkQ0xFbEJRVTFhTEVsQlFVa3NSMEZCUjJFc1VVRkJVU3hEUVVGRFJDeEpRVUZKTEVOQlFVTklMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUTBFc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRTeXhUUVVGVExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMnRDUVVOMlJTeEpRVUZOUXl4SFFVRkhMRWRCUVVkRExFbEJRVWtzUTBGQlEwTXNTMEZCU3l4RFFVRkRUQ3hKUVVGSkxFTkJRVU5JTEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlEwRXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJ0Q1FVTjRSR1FzVlVGQlZTeFhRVUZKYjBJc1IwRkJSeXhWUVVGUExFZEJRVWRtTEVsQlFVazdaMEpCUTJwRExFTkJRVU1zUTBGQlF6dG5Ra0ZGUmt3c1ZVRkJWU3hEUVVGRFJ5eExRVUZMTEVkQlFVZGxMRkZCUVZFc1EwRkJRMllzUzBGQlN5eERRVUZET3p0alFVTnVReXhyUTBGRFRUdG5Ra0ZCUld4Q0xFbEJRVWtzYTBOQlFVOHdRaXhMUVVGTExFZEJRVXRZTEZWQlFWVXNRMEZCUlR0blFrRkJSV1FzUzBGQlN5eEZRVUZGTzJOQlFVa3NRMEZCUlR0WlFVRkJPMk5CUVVFN1kwRkJRVHRqUVVGQkxFdEJSWEpFTEhkQ1FVRlhMR1ZCUVU4N1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMR3REUVVOaU8yZENRVUZGUkN4SlFVRkpMRVZCUVVVN2EwSkJRVVV3UWl4TFFVRkxMRVZCUVVVN1owSkJRVVVzUTBGQlJUdG5Ra0ZCUlhwQ0xFdEJRVXM3WTBGQlFTeERRVUZGTzFsQlFVRTdZMEZCUVR0WlFVRkJPMWxCUVVFN1kwRkJRVHRWUVVGQk8xRkJRVUU3VFVGQlFUczdTVUZOTTBNN096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZQVFN4eFFrRkJXWEZETEVkQlFWYzdPenM3T3pzN1kwRkZiRUlzVDBGQlRTeHZRa0ZCVVN4RlFVRkRMRWxCUVVrc1EwRkJReTlETEV0QlFVc3NSVUZCUlN4TFFVRkxMRmxCUVVzc1NVRkJTU3hEUVVGRFJpeEhRVUZITERCQ1FVRm5RbWxFTEVkQlFVY3NSMEZCU1R0blFrRkRla1ZvUkN4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzJkQ1FVTnlRbWRDTEV0QlFVc3NSVUZCUlVNN1pVRkRVaXhEUVVGRE8xbEJRVUU3WTBGQlFUdFpRVUZCTzJOQlFVRTdZMEZCUVR0alFVRkJMRXRCUlVVc2QwSkJRVmNzWlVGQlR6dG5Ra0ZCUVR0blFrRkJRVHRqUVVGQk8yTkJRVUVzYTBOQlEySTdaMEpCUVVWUUxFbEJRVWtzUlVGQlJUdHJRa0ZCUlZFc1NVRkJTU3hGUVVGRk8yZENRVUZKTEVOQlFVVTdaMEpCUVVWUUxFdEJRVXM3WTBGQlFTeERRVUZGTzFsQlFVRTdZMEZCUVR0WlFVRkJPMWxCUVVFN1kwRkJRVHRWUVVGQk8xRkJRVUU3VFVGQlFTeERRVXN6UXpzN1NVRkZSRHM3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVOU5MSGRDUVVGbGNVTXNSMEZCVnl4RlFVRkZlRUlzVlVGQkswSTdPenM3T3pzN1kwRkZkRVFzVDBGQlRTeHZRa0ZCVVN4RlFVRkRMRWxCUVVrc1EwRkJRM1pDTEV0QlFVc3NSVUZCUlN4TFFVRkxMRmxCUVVzc1NVRkJTU3hEUVVGRFJpeEhRVUZITERCQ1FVRm5RbWxFTEVkQlFVY3NSMEZCU1R0blFrRkRla1ZzUXl4SlFVRkpMRVZCUVVWVkxGVkJRVlU3WjBKQlEyaENlRUlzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTBFc1QwRkJUenRuUWtGRGNrSm5RaXhMUVVGTExFVkJRVVZETzJWQlExSXNRMEZCUXp0WlFVRkJPMk5CUVVFN1dVRkJRVHRqUVVGQk8yTkJRVUU3WTBGQlFTeExRVVZGTEhkQ1FVRlhMR1ZCUVU4N1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMR3REUVVOaU8yZENRVUZGVUN4SlFVRkpMRVZCUVVVN2EwSkJRVVZSTEVsQlFVa3NSVUZCUlR0blFrRkJTU3hEUVVGRk8yZENRVUZGVUN4TFFVRkxPMk5CUVVFc1EwRkJSVHRaUVVGQk8yTkJRVUU3V1VGQlFUdFpRVUZCTzJOQlFVRTdWVUZCUVR0UlFVRkJPMDFCUVVFc1EwRkxNME03TzBsQlJVUTdPenM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGUFRTeHZRa0ZCVjNORExFVkJRVlU3T3pzN096czdZMEZGYUVJc1QwRkJUU3h2UWtGQlVTeEZRVUZETEVsQlFVa3NRMEZCUTJoRUxFdEJRVXNzUlVGQlJTeFJRVUZSTEZsQlFVc3NTVUZCU1N4RFFVRkRSaXhIUVVGSExEQkNRVUZuUW10RUxFVkJRVVVzUjBGQlNUdG5Ra0ZETTBWcVJDeFBRVUZQTEVWQlFVVXNTVUZCU1N4RFFVRkRRU3hQUVVGUE8yZENRVU55UW1kQ0xFdEJRVXNzUlVGQlJVTTdaVUZEVWl4RFFVRkRPMWxCUVVFN1kwRkJRVHRaUVVGQk8yTkJRVUU3WTBGQlFUdGpRVUZCTEV0QlJVVXNkMEpCUVZjc1pVRkJUenRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc2EwTkJRMkk3WjBKQlFVVlFMRWxCUVVrc1JVRkJSVHRyUWtGQlJWRXNTVUZCU1N4RlFVRkZPMmRDUVVGSkxFTkJRVVU3WjBKQlFVVlFMRXRCUVVzN1kwRkJRU3hEUVVGRk8xbEJRVUU3WTBGQlFUdFpRVUZCTzFsQlFVRTdZMEZCUVR0VlFVRkJPMUZCUVVFN1RVRkJRU3hEUVVzelF6czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkZZU3h6UWtGRFdsRXNUVUZCY1VNN096czdPenM3TzJOQlIxZ3NUMEZCVFN4dlFrRkJVU3hGUVVOd1F5eEpRVUZKTEVOQlFVTnNRaXhMUVVGTExFVkJRMVlzUzBGQlN5eFpRVU5HTEVsQlFVa3NRMEZCUTBZc1IwRkJSeXd3UWtGQlowSnZRaXhOUVVGTkxFTkJRVU1yUWl4TlFVRk5MR1ZCUTNoRE8yZENRVU5GYkVRc1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlEwRXNUMEZCVHp0blFrRkRja0puUWl4TFFVRkxMRVZCUVVVc1pVRkJRMjFETEU5QlFWa3NSVUZCU1R0clFrRkRkRUlzVDBGQlR6dHZRa0ZCUlhwRExFbEJRVWtzUlVGQlJUdHpRa0ZCUlhsRExFOUJRVThzUlVGQlVFRTdiMEpCUVU4c1EwRkJSVHR2UWtGQlJYaERMRXRCUVVzc1JVRkJSVHRyUWtGQlNTeERRVUZGTzJkQ1FVTXpRenRsUVVORUxFTkJRMFk3V1VGQlFUdGpRVUZCTzJOQlZrOUVMRWxCUVVrc1ZVRkJTa0VzU1VGQlNUdGpRVUZGUXl4TFFVRkxMRlZCUVV4QkxFdEJRVXM3WTBGQlFTeHJRMEZYV2p0blFrRkJSVVFzU1VGQlNTeEZRVUZLUVN4SlFVRkpPMmRDUVVGRlF5eExRVUZMTEVWQlFVeEJPMk5CUVVzc1EwRkJSVHRaUVVGQk8yTkJRVUU3WTBGQlFUdGpRVUZCTEV0QlJXeENMSGRDUVVGWExHVkJRVTg3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHdERRVU5pTzJkQ1FVRkZSQ3hKUVVGSkxFVkJRVVVzU1VGQlNUdG5Ra0ZCUlVNc1MwRkJTenRqUVVGQkxFTkJRVVU3V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQkxFTkJTMnBET3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVVWaExIVkNRVU5hVVN4TlFVRnpRenM3T3pzN096czdZMEZIZGtJc1QwRkJUU3h2UWtGQlVTeEZRVU42UWl4SlFVRkpMRU5CUVVOc1FpeExRVUZMTEVWQlExWXNVVUZCVVN4WlFVTk1MRWxCUVVrc1EwRkJRMFlzUjBGQlJ5d3dRa0ZCWjBKdlFpeE5RVUZOTEVOQlFVTXJRaXhOUVVGTkxITkNRVUZaTDBJc1RVRkJUU3hEUVVGRE9FSXNSVUZCUlN4SFFVTTNSRHRuUWtGRFJXcEVMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU5CTzJWQlEyWXNRMEZEUmp0WlFVRkJPMk5CVUV0VkxFbEJRVWs3WTBGQlFTeHRRMEZUU0R0blFrRkJSVUVzU1VGQlNTeEZRVUZLUVN4SlFVRkpPMmRDUVVGRlF5eExRVUZMTEVWQlFVVTdZMEZCU1N4RFFVRkZPMWxCUVVFN1kwRkJRVHRqUVVGQk8yTkJRVUVzUzBGRmVFSXNkMEpCUVZjc1owSkJRVTg3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHMURRVU5pTzJkQ1FVRkZSQ3hKUVVGSkxFVkJRVVVzU1VGQlNUdG5Ra0ZCUlVNc1MwRkJTenRqUVVGQkxFTkJRVVU3V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQkxFTkJTMnBET3p0RlFVRkJPMFZCUVVFN1FVRkJRVHRCUVhoVFNIbERJaXdpYm1GdFpYTWlPbHNpUjI5VWNuVmxRV1J0YVc1QmNHa2lMQ0oxY213aUxDSm9aV0ZrWlhKeklpd2labVYwWTJnaUxDSnRabUVpTENKc2FYTjBSbUZqZEc5eWN5SXNJbDlzYVhOMFJtRmpkRzl5Y3lJc0ltSnBibVFpTENKa1pXeGxkR1ZHWVdOMGIzSWlMQ0pmWkdWc1pYUmxSbUZqZEc5eUlpd2lhbmQwSWl3aWJtOVNaWE52YkhabFNuTnZiaUlzSW1SaGRHRWlMQ0psY25KdmNpSXNJbVZ0WVdsc0lpd2liM0IwYVc5dWN5SXNJbUp2WkhraUxDSnlaV1JwY21WamRGUnZJaXdpZUdadmNtMGlMQ0ptWlhSamFGOHhJaXdpZFhObGNpSXNJbkJoY21GdGN5SXNJbkpsYzNRaUxDSnVaWGRmWlcxaGFXd2lMQ0p1WlhkRmJXRnBiQ0lzSW5CeWIzQmxjblJwWlhNaUxDSmhkSFJ5YVdKMWRHVnpJaXdpY0dGbmFXNWhkR2x2YmlJc0ltNWxlSFJRWVdkbElpd2liR0Z6ZEZCaFoyVWlMQ0owYjNSaGJDSXNJbkYxWlhKNUlpd2ljR0ZuWlNJc0luUnZVM1J5YVc1bklpd2ljR1Z5WDNCaFoyVWlMQ0p3WlhKUVlXZGxJaXdpY21WemNHOXVjMlVpTENKcWMyOXVJaXdpZFhObGNuTWlMQ0puWlhRaUxDSnNhVzVyY3lJc0luTndiR2wwSWl3aWJHVnVaM1JvSWl3aVptOXlSV0ZqYUNJc0lteHBibXNpTENKd1lYSnpaVWx1ZENJc0luTjFZbk4wY21sdVp5SXNJbkpsYkNJc0lrcFRUMDRpTENKd1lYSnpaU0lzSW5WcFpDSXNJbWxrSWl3aWRYTmxja2xrSWl3aVptRmpkRzl5Y3lJc0ltVjRjRzl5ZEhNaVhTd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMGR2VkhKMVpVRmtiV2x1UVhCcExuUnpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiYm5Wc2JGMTkiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBleHBvcnRzOyB9OyB2YXIgZXhwb3J0cyA9IHt9LCBPcCA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXksIGRlc2MpIHsgb2JqW2tleV0gPSBkZXNjLnZhbHVlOyB9LCAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSwgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSwgb2JqW2tleV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAoZXJyKSB7IGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7IH07IH0gZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkgeyB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvciwgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLCBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyByZXR1cm4gZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KSwgZ2VuZXJhdG9yOyB9IGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07IH0gY2F0Y2ggKGVycikgeyByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07IH0gfSBleHBvcnRzLndyYXAgPSB3cmFwOyB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307IGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pOyB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpOyBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7IHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgeyBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTsgfSk7IH0pOyB9IGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkgeyBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgeyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHsgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsIHZhbHVlID0gcmVzdWx0LnZhbHVlOyByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKHZhbHVlKSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHsgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJlamVjdChyZWNvcmQuYXJnKTsgfSB2YXIgcHJldmlvdXNQcm9taXNlOyBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobWV0aG9kLCBhcmcpIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHsgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiOyByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7IGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7IGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnOyByZXR1cm4gZG9uZVJlc3VsdCgpOyB9IGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHsgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsgaWYgKGRlbGVnYXRlKSB7IHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOyBpZiAoZGVsZWdhdGVSZXN1bHQpIHsgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OyB9IH0gaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHsgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7IGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpOyBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7IHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTsgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7IGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4geyB2YWx1ZTogcmVjb3JkLmFyZywgZG9uZTogY29udGV4dC5kb25lIH07IH0gXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsgdmFyIG1ldGhvZE5hbWUgPSBjb250ZXh0Lm1ldGhvZCwgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07IGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkgcmV0dXJuIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG1ldGhvZE5hbWUgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBtZXRob2ROYW1lICYmIChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBtZXRob2ROYW1lICsgXCInIG1ldGhvZFwiKSksIENvbnRpbnVlU2VudGluZWw7IHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7IHZhciBpbmZvID0gcmVjb3JkLmFyZzsgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTsgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7IH0gZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTsgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDsgfSBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7IHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7IGlmIChpdGVyYWJsZSkgeyB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07IGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7IGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkgeyB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0OyByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OyB9IH0gcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9OyB9IGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7IHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6ICEwIH07IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmVQcm9wZXJ0eShHcCwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgY29uZmlndXJhYmxlOiAhMCB9KSwgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikgeyB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTsgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjsgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7IHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7IHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkgeyB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCksIGtleXMgPSBbXTsgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7IHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IGtleXMubGVuZ3RoOykgeyB2YXIga2V5ID0ga2V5cy5wb3AoKTsgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpOyB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKCkgeyB0aGlzLmRvbmUgPSAhMDsgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZzsgcmV0dXJuIHRoaXMucnZhbDsgfSwgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247IHZhciBjb250ZXh0ID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7IHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7IH0gZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSwgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7IGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChoYXNDYXRjaCkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7IHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTsgYnJlYWs7IH0gfSBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7IHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9OyByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpOyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykgeyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsOyB9LCBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHsgdmFyIHRocm93biA9IHJlY29yZC5hcmc7IHJlc2V0VHJ5RW50cnkoZW50cnkpOyB9IHJldHVybiB0aHJvd247IH0gfSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7IH0sIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLCByZXN1bHROYW1lOiByZXN1bHROYW1lLCBuZXh0TG9jOiBuZXh0TG9jIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIGV4cG9ydHM7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIF9fYXdhaXRlciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdm9pZCAwICYmICh2b2lkIDApLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgR29UcnVlQWRtaW5BcGlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Hb1RydWVBZG1pbkFwaVwiKSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9saWIvY29uc3RhbnRzXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vbGliL2Vycm9yc1wiKTtcbnZhciBmZXRjaF8xID0gcmVxdWlyZShcIi4vbGliL2ZldGNoXCIpO1xudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2xpYi9oZWxwZXJzXCIpO1xudmFyIGxvY2FsX3N0b3JhZ2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9saWIvbG9jYWwtc3RvcmFnZVwiKSk7XG52YXIgcG9seWZpbGxzXzEgPSByZXF1aXJlKFwiLi9saWIvcG9seWZpbGxzXCIpO1xuKDAsIHBvbHlmaWxsc18xLnBvbHlmaWxsR2xvYmFsVGhpcykoKTsgLy8gTWFrZSBcImdsb2JhbFRoaXNcIiBhdmFpbGFibGVcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHVybDogY29uc3RhbnRzXzEuR09UUlVFX1VSTCxcbiAgc3RvcmFnZUtleTogY29uc3RhbnRzXzEuU1RPUkFHRV9LRVksXG4gIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gIGhlYWRlcnM6IGNvbnN0YW50c18xLkRFRkFVTFRfSEVBREVSU1xufTtcbnZhciBHb1RydWVDbGllbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgKi9cbiAgZnVuY3Rpb24gR29UcnVlQ2xpZW50KG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR29UcnVlQ2xpZW50KTtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5uZXR3b3JrUmV0cmllcyA9IDA7XG4gICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhc3luYyBjbGllbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICogV2hlbiBudWxsIG9yIG5vdCB5ZXQgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMgYHVua25vd25gXG4gICAgICogT25jZSByZXNvbHZlZCB0aGUgdGhlIGF1dGggc3RhdGUgaXMga25vd24gYW5kIGl0J3Mgc2F2ZSB0byBjYWxsIGFueSBmdXJ0aGVyIGNsaWVudCBtZXRob2RzLlxuICAgICAqIEtlZXAgZXh0cmEgY2FyZSB0byBuZXZlciByZWplY3Qgb3IgdGhyb3cgdW5jYXVnaHQgZXJyb3JzXG4gICAgICovXG4gICAgdGhpcy5pbml0aWFsaXplUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPSB0cnVlO1xuICAgIHZhciBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5pbk1lbW9yeVNlc3Npb24gPSBudWxsO1xuICAgIHRoaXMuc3RvcmFnZUtleSA9IHNldHRpbmdzLnN0b3JhZ2VLZXk7XG4gICAgdGhpcy5hdXRvUmVmcmVzaFRva2VuID0gc2V0dGluZ3MuYXV0b1JlZnJlc2hUb2tlbjtcbiAgICB0aGlzLnBlcnNpc3RTZXNzaW9uID0gc2V0dGluZ3MucGVyc2lzdFNlc3Npb247XG4gICAgdGhpcy5zdG9yYWdlID0gc2V0dGluZ3Muc3RvcmFnZSB8fCBsb2NhbF9zdG9yYWdlXzFbXCJkZWZhdWx0XCJdO1xuICAgIHRoaXMuYWRtaW4gPSBuZXcgR29UcnVlQWRtaW5BcGlfMVtcImRlZmF1bHRcIl0oe1xuICAgICAgdXJsOiBzZXR0aW5ncy51cmwsXG4gICAgICBoZWFkZXJzOiBzZXR0aW5ncy5oZWFkZXJzLFxuICAgICAgZmV0Y2g6IHNldHRpbmdzLmZldGNoXG4gICAgfSk7XG4gICAgdGhpcy51cmwgPSBzZXR0aW5ncy51cmw7XG4gICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycztcbiAgICB0aGlzLmZldGNoID0gKDAsIGhlbHBlcnNfMS5yZXNvbHZlRmV0Y2gpKHNldHRpbmdzLmZldGNoKTtcbiAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHNldHRpbmdzLmRldGVjdFNlc3Npb25JblVybDtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLm1mYSA9IHtcbiAgICAgIHZlcmlmeTogdGhpcy5fdmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICBlbnJvbGw6IHRoaXMuX2Vucm9sbC5iaW5kKHRoaXMpLFxuICAgICAgdW5lbnJvbGw6IHRoaXMuX3VuZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICBjaGFsbGVuZ2U6IHRoaXMuX2NoYWxsZW5nZS5iaW5kKHRoaXMpLFxuICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICBjaGFsbGVuZ2VBbmRWZXJpZnk6IHRoaXMuX2NoYWxsZW5nZUFuZFZlcmlmeS5iaW5kKHRoaXMpLFxuICAgICAgZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsOiB0aGlzLl9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwuYmluZCh0aGlzKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjbGllbnQgc2Vzc2lvbiBlaXRoZXIgZnJvbSB0aGUgdXJsIG9yIGZyb20gc3RvcmFnZS5cbiAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnQsIGJ1dCBzaG91bGQgYWxzbyBiZSBjYWxsZWRcbiAgICogbWFudWFsbHkgd2hlbiBjaGVja2luZyBmb3IgYW4gZXJyb3IgZnJvbSBhbiBhdXRoIHJlZGlyZWN0IChvYXV0aCwgbWFnaWNsaW5rLCBwYXNzd29yZCByZWNvdmVyeSwgZXRjKS5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhHb1RydWVDbGllbnQsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplUHJvbWlzZSkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElNUE9SVEFOVDpcbiAgICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAgICogICAgdGhlIHdob2xlIGxpZmV0aW1lIG9mIHRoZSBjbGllbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkX2dldFNlc3NpLCBkYXRhLCBlcnJvciwgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjtcbiAgICAgICAgICAgICAgaWYgKCEodGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgJiYgdGhpcy5faXNJbXBsaWNpdEdyYW50RmxvdygpKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNlc3Npb25Gcm9tVXJsKCk7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJF9nZXRTZXNzaSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIGRhdGEgPSBfeWllbGQkdGhpcyRfZ2V0U2Vzc2kuZGF0YTtcbiAgICAgICAgICAgICAgZXJyb3IgPSBfeWllbGQkdGhpcyRfZ2V0U2Vzc2kuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbiwgcmVkaXJlY3RUeXBlID0gZGF0YS5yZWRpcmVjdFR5cGU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgICBpZiAocmVkaXJlY3RUeXBlID09PSAncmVjb3ZlcnknKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKF9jb250ZXh0LnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IGVycm9yc18xLkF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uJywgX2NvbnRleHQudDApXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI5O1xuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjkpO1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMiwgMjQsIDI5LCAzMl1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqIEByZXR1cm5zIEEgbG9nZ2VkLWluIHNlc3Npb24gaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9OXG4gICAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaWduVXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnblVwKGNyZWRlbnRpYWxzKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgcmVzLCBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMsIHBob25lLCBfcGFzc3dvcmQsIF9vcHRpb25zLCBfcmVzLCBkYXRhLCBlcnJvciwgc2Vzc2lvbiwgdXNlcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpZiAoISgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZW1haWwgPSBjcmVkZW50aWFscy5lbWFpbCwgcGFzc3dvcmQgPSBjcmVkZW50aWFscy5wYXNzd29yZCwgb3B0aW9ucyA9IGNyZWRlbnRpYWxzLm9wdGlvbnM7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9zaWdudXBcIiksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICBkYXRhOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eToge1xuICAgICAgICAgICAgICAgICAgICBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fc2Vzc2lvblJlc3BvbnNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBpZiAoISgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGhvbmUgPSBjcmVkZW50aWFscy5waG9uZSwgX3Bhc3N3b3JkID0gY3JlZGVudGlhbHMucGFzc3dvcmQsIF9vcHRpb25zID0gY3JlZGVudGlhbHMub3B0aW9ucztcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9zaWdudXBcIiksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgcGhvbmU6IHBob25lLFxuICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IF9wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IChfYiA9IF9vcHRpb25zID09PSBudWxsIHx8IF9vcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFfdG9rZW46IF9vcHRpb25zID09PSBudWxsIHx8IF9vcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucy5jYXB0Y2hhVG9rZW5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9zZXNzaW9uUmVzcG9uc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIF9yZXMgPSByZXMsIGRhdGEgPSBfcmVzLmRhdGEsIGVycm9yID0gX3Jlcy5lcnJvcjtcbiAgICAgICAgICAgICAgaWYgKCEoZXJyb3IgfHwgIWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgIHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICAgIHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgIGlmICghZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI2O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgIHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB1c2VyOiB1c2VyLFxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogc2Vzc2lvblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDMwO1xuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKF9jb250ZXh0Mi50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0Mi50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Mi50MDtcbiAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbMCwgMzBdXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHdpdGggYW4gZW1haWwgYW5kIHBhc3N3b3JkIG9yIHBob25lIGFuZCBwYXNzd29yZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaWduSW5XaXRoUGFzc3dvcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbkluV2l0aFBhc3N3b3JkKGNyZWRlbnRpYWxzKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICB2YXIgcmVzLCBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMsIHBob25lLCBfcGFzc3dvcmQyLCBfb3B0aW9uczIsIF9yZXMyLCBkYXRhLCBlcnJvcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpZiAoISgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZW1haWwgPSBjcmVkZW50aWFscy5lbWFpbCwgcGFzc3dvcmQgPSBjcmVkZW50aWFscy5wYXNzd29yZCwgb3B0aW9ucyA9IGNyZWRlbnRpYWxzLm9wdGlvbnM7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkXCIpLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgIGVtYWlsOiBlbWFpbCxcbiAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSxcbiAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9zZXNzaW9uUmVzcG9uc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGlmICghKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwaG9uZSA9IGNyZWRlbnRpYWxzLnBob25lLCBfcGFzc3dvcmQyID0gY3JlZGVudGlhbHMucGFzc3dvcmQsIF9vcHRpb25zMiA9IGNyZWRlbnRpYWxzLm9wdGlvbnM7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvdG9rZW4/Z3JhbnRfdHlwZT1wYXNzd29yZFwiKSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICBwaG9uZTogcGhvbmUsXG4gICAgICAgICAgICAgICAgICBwYXNzd29yZDogX3Bhc3N3b3JkMixcbiAgICAgICAgICAgICAgICAgIGRhdGE6IChfYiA9IF9vcHRpb25zMiA9PT0gbnVsbCB8fCBfb3B0aW9uczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zMi5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFfdG9rZW46IF9vcHRpb25zMiA9PT0gbnVsbCB8fCBfb3B0aW9uczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zMi5jYXB0Y2hhVG9rZW5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9zZXNzaW9uUmVzcG9uc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIF9yZXMyID0gcmVzLCBkYXRhID0gX3JlczIuZGF0YSwgZXJyb3IgPSBfcmVzMi5lcnJvcjtcbiAgICAgICAgICAgICAgaWYgKCEoZXJyb3IgfHwgIWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgIGlmICghZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyODtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDMudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDMudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDMudDA7XG4gICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzAsIDI4XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciB2aWEgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaWduSW5XaXRoT0F1dGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbkluV2l0aE9BdXRoKGNyZWRlbnRpYWxzKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5faGFuZGxlUHJvdmlkZXJTaWduSW4oY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICBzY29wZXM6IChfYiA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zY29wZXMsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IChfYyA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5xdWVyeVBhcmFtc1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIG1hZ2ljbGluayBvciBhIG9uZS10aW1lIHBhc3N3b3JkIChPVFApLlxuICAgICAqIElmIHRoZSBge3sgLkNvbmZpcm1hdGlvblVSTCB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYSBtYWdpY2xpbmsgd2lsbCBiZSBzZW50LlxuICAgICAqIElmIHRoZSBge3sgLlRva2VuIH19YCB2YXJpYWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGVtYWlsIHRlbXBsYXRlLCBhbiBPVFAgd2lsbCBiZSBzZW50LlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBwaG9uZSBzaWduLWlucywgb25seSBhbiBPVFAgd2lsbCBiZSBzZW50LiBZb3Ugd29uJ3QgYmUgYWJsZSB0byBzZW5kIGEgbWFnaWNsaW5rIGZvciBwaG9uZSBzaWduLWlucy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaWduSW5XaXRoT3RwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25JbldpdGhPdHAoY3JlZGVudGlhbHMpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICAgICAgdmFyIGVtYWlsLCBvcHRpb25zLCBfeWllbGQsIGVycm9yLCBwaG9uZSwgX29wdGlvbnMzLCBfeWllbGQyLCBfZXJyb3I7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaWYgKCEoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVtYWlsID0gY3JlZGVudGlhbHMuZW1haWwsIG9wdGlvbnMgPSBjcmVkZW50aWFscy5vcHRpb25zO1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvb3RwXCIpLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgIGVtYWlsOiBlbWFpbCxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSxcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZV91c2VyOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2hvdWxkQ3JlYXRlVXNlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG9cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF95aWVsZCA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICBlcnJvciA9IF95aWVsZC5lcnJvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBpZiAoISgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGhvbmUgPSBjcmVkZW50aWFscy5waG9uZSwgX29wdGlvbnMzID0gY3JlZGVudGlhbHMub3B0aW9ucztcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9vdHBcIiksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgcGhvbmU6IHBob25lLFxuICAgICAgICAgICAgICAgICAgZGF0YTogKF9jID0gX29wdGlvbnMzID09PSBudWxsIHx8IF9vcHRpb25zMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMzLmRhdGEpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LFxuICAgICAgICAgICAgICAgICAgY3JlYXRlX3VzZXI6IChfZCA9IF9vcHRpb25zMyA9PT0gbnVsbCB8fCBfb3B0aW9uczMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zMy5zaG91bGRDcmVhdGVVc2VyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHtcbiAgICAgICAgICAgICAgICAgICAgY2FwdGNoYV90b2tlbjogX29wdGlvbnMzID09PSBudWxsIHx8IF9vcHRpb25zMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMzLmNhcHRjaGFUb2tlblxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBfeWllbGQyID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICAgIF9lcnJvciA9IF95aWVsZDIuZXJyb3I7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9lcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlci4nKTtcbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMjA7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQ1LnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQ1LnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ1LnQwO1xuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1swLCAyMF1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciBnaXZlbiBhIFVzZXIgc3VwcGxpZWQgT1RQIHJlY2VpdmVkIHZpYSBtb2JpbGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmVyaWZ5T3RwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeU90cChwYXJhbXMpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoKSB7XG4gICAgICAgIHZhciBfeWllbGQzLCBkYXRhLCBlcnJvciwgc2Vzc2lvbiwgdXNlcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDU7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvdmVyaWZ5XCIpLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwge1xuICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHtcbiAgICAgICAgICAgICAgICAgICAgY2FwdGNoYV90b2tlbjogKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYXB0Y2hhVG9rZW5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiAoX2IgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3Nlc3Npb25SZXNwb25zZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgX3lpZWxkMyA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgICBkYXRhID0gX3lpZWxkMy5kYXRhO1xuICAgICAgICAgICAgICBlcnJvciA9IF95aWVsZDMuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93ICdBbiBlcnJvciBvY2N1cnJlZCBvbiB0b2tlbiB2ZXJpZmljYXRpb24uJztcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICAgIHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgIGlmICghKHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE3O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogdXNlcixcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IHNlc3Npb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAyMTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gX2NvbnRleHQ2W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDYudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDYudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDYudDA7XG4gICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzAsIDIxXV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyBhIHNpbmdsZS1zaWduIG9uIHVzaW5nIGFuIGVudGVycHJpc2UgSWRlbnRpdHkgUHJvdmlkZXIuIEFcbiAgICAgKiBzdWNjZXNzZnVsIFNTTyBhdHRlbXB0IHdpbGwgcmVkaXJlY3QgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgaWRlbnRpdHlcbiAgICAgKiBwcm92aWRlciBhdXRob3JpemF0aW9uIHBhZ2UuIFRoZSByZWRpcmVjdCBVUkwgaXMgaW1wbGVtZW50YXRpb24gYW5kIFNTT1xuICAgICAqIHByb3RvY29sIHNwZWNpZmljLlxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgaXQgYnkgcHJvdmlkaW5nIGEgU1NPIGRvbWFpbi4gVHlwaWNhbGx5IHlvdSBjYW4gZXh0cmFjdCB0aGlzXG4gICAgICogZG9tYWluIGJ5IGFza2luZyB1c2VycyBmb3IgdGhlaXIgZW1haWwgYWRkcmVzcy4gSWYgdGhpcyBkb21haW4gaXNcbiAgICAgKiByZWdpc3RlcmVkIG9uIHRoZSBBdXRoIGluc3RhbmNlIHRoZSByZWRpcmVjdCB3aWxsIHVzZSB0aGF0IG9yZ2FuaXphdGlvbidzXG4gICAgICogY3VycmVudGx5IGFjdGl2ZSBTU08gSWRlbnRpdHkgUHJvdmlkZXIgZm9yIHRoZSBsb2dpbi5cbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGJ1aWx0IGFuIG9yZ2FuaXphdGlvbi1zcGVjaWZpYyBsb2dpbiBwYWdlLCB5b3UgY2FuIHVzZSB0aGVcbiAgICAgKiBvcmdhbml6YXRpb24ncyBTU08gSWRlbnRpdHkgUHJvdmlkZXIgVVVJRCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBhdmFpbGFiaWxpdHkgaXMgY29uZGl0aW9uYWwgb24gY29ycmVjdFxuICAgICAqIHNldHRpbmdzIG9uIHRoZSBBdXRoIHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2lnbkluV2l0aFNTT1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduSW5XaXRoU1NPKHBhcmFtcykge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA1O1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL3Nzb1wiKSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgJ3Byb3ZpZGVySWQnIGluIHBhcmFtcyA/IHtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZFxuICAgICAgICAgICAgICAgIH0gOiBudWxsKSwgJ2RvbWFpbicgaW4gcGFyYW1zID8ge1xuICAgICAgICAgICAgICAgICAgZG9tYWluOiBwYXJhbXMuZG9tYWluXG4gICAgICAgICAgICAgICAgfSA6IG51bGwpLCB7XG4gICAgICAgICAgICAgICAgICByZWRpcmVjdF90bzogKF9iID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KSwgKChfYyA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FwdGNoYVRva2VuKSA/IHtcbiAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFfdG9rZW46IHBhcmFtcy5vcHRpb25zLmNhcHRjaGFUb2tlblxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gOiBudWxsKSwge1xuICAgICAgICAgICAgICAgICAgc2tpcF9odHRwX3JlZGlyZWN0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9zc29SZXNwb25zZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ3LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDg7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQ3LnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0Ny50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Ny50MDtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMsIFtbMCwgOF1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2Vzc2lvbiwgcmVmcmVzaGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICogVGhlIHNlc3Npb24gcmV0dXJuZWQgY2FuIGJlIG51bGwgaWYgdGhlIHNlc3Npb24gaXMgbm90IGRldGVjdGVkIHdoaWNoIGNhbiBoYXBwZW4gaW4gdGhlIGV2ZW50IGEgdXNlciBpcyBub3Qgc2lnbmVkLWluIG9yIGhhcyBsb2dnZWQgb3V0LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNlc3Npb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2Vzc2lvbigpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTZXNzaW9uLCBtYXliZVNlc3Npb24sIGhhc0V4cGlyZWQsIF95aWVsZCR0aGlzJF9jYWxsUmVmciwgc2Vzc2lvbiwgZXJyb3I7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5wZXJzaXN0U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA2O1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGhlbHBlcnNfMS5nZXRJdGVtQXN5bmMpKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgbWF5YmVTZXNzaW9uID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICAgIGlmICghKG1heWJlU2Vzc2lvbiAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24gPSBtYXliZVNlc3Npb247XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24gPSB0aGlzLmluTWVtb3J5U2Vzc2lvbjtcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgaGFzRXhwaXJlZCA9IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQgPyBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0IDw9IERhdGUubm93KCkgLyAxMDAwIDogZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogY3VycmVudFNlc3Npb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICBfeWllbGQkdGhpcyRfY2FsbFJlZnIgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgICAgc2Vzc2lvbiA9IF95aWVsZCR0aGlzJF9jYWxsUmVmci5zZXNzaW9uO1xuICAgICAgICAgICAgICBlcnJvciA9IF95aWVsZCR0aGlzJF9jYWxsUmVmci5lcnJvcjtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBzZXNzaW9uOiBzZXNzaW9uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHVzZXIgZGV0YWlscyBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBzZXNzaW9uLlxuICAgICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIGp3dC4gSWYgbm8gand0IGlzIHByb3ZpZGVkLCBnZXRVc2VyKCkgd2lsbCBhdHRlbXB0IHRvIGdldCB0aGUgand0IGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRVc2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVzZXIoand0KSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvLCBkYXRhLCBlcnJvcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXNzaW9uKCk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldFNlc3NpbyA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgICBkYXRhID0gX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvLmRhdGE7XG4gICAgICAgICAgICAgIGVycm9yID0gX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvLmVycm9yO1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvIEF1dGhvcml6YXRpb24gaGVhZGVyIGlmIHRoZXJlIGlzIG5vIGV4aXN0aW5nIHNlc3Npb25cbiAgICAgICAgICAgICAgand0ID0gKF9iID0gKF9hID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDEyO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdHRVQnLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvdXNlclwiKSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBqd3Q6IGp3dCxcbiAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fdXNlclJlc3BvbnNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ5LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQ5LnByZXYgPSAxNTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ5LnQwID0gX2NvbnRleHQ5W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDkudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0OS50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0OS50MDtcbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTksIHRoaXMsIFtbMCwgMTVdXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBkYXRhLCBpZiB0aGVyZSBpcyBhIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVVzZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVXNlcihhdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvMiwgc2Vzc2lvbkRhdGEsIHNlc3Npb25FcnJvciwgc2Vzc2lvbiwgX3lpZWxkNCwgZGF0YSwgdXNlckVycm9yO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvMiA9IF9jb250ZXh0MTAuc2VudDtcbiAgICAgICAgICAgICAgc2Vzc2lvbkRhdGEgPSBfeWllbGQkdGhpcyRnZXRTZXNzaW8yLmRhdGE7XG4gICAgICAgICAgICAgIHNlc3Npb25FcnJvciA9IF95aWVsZCR0aGlzJGdldFNlc3NpbzIuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uRGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBzZXNzaW9uID0gc2Vzc2lvbkRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BVVCcsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi91c2VyXCIpLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fdXNlclJlc3BvbnNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgX3lpZWxkNCA9IF9jb250ZXh0MTAuc2VudDtcbiAgICAgICAgICAgICAgZGF0YSA9IF95aWVsZDQuZGF0YTtcbiAgICAgICAgICAgICAgdXNlckVycm9yID0gX3lpZWxkNC5lcnJvcjtcbiAgICAgICAgICAgICAgaWYgKCF1c2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyB1c2VyRXJyb3I7XG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBzZXNzaW9uLnVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDIxO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnVVNFUl9VUERBVEVEJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogc2Vzc2lvbi51c2VyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDI1O1xuICAgICAgICAgICAgICBfY29udGV4dDEwLnQwID0gX2NvbnRleHQxMFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQxMC50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDEwLnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQxMC50MDtcbiAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMCwgdGhpcywgW1swLCAyNV1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIEpXVCAod2l0aG91dCBwZXJmb3JtaW5nIGFueSB2YWxpZGF0aW9uKS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZGVjb2RlSldUXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWNvZGVKV1Qoand0KSB7XG4gICAgICByZXR1cm4gKDAsIGhlbHBlcnNfMS5kZWNvZGVKV1RQYXlsb2FkKShqd3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZXNzaW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uLiBJZiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGV4cGlyZWQsIHNldFNlc3Npb24gd2lsbCB0YWtlIGNhcmUgb2YgcmVmcmVzaGluZyBpdCB0byBvYnRhaW4gYSBuZXcgc2Vzc2lvbi5cbiAgICAgKiBJZiB0aGUgcmVmcmVzaCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4gaW4gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbiB0aGF0IG1pbmltYWxseSBjb250YWlucyBhbiBhY2Nlc3MgdG9rZW4gYW5kIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2Vzc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKCkge1xuICAgICAgICB2YXIgdGltZU5vdywgZXhwaXJlc0F0LCBoYXNFeHBpcmVkLCBzZXNzaW9uLCBwYXlsb2FkLCBfeWllbGQkdGhpcyRfY2FsbFJlZnIyLCByZWZyZXNoZWRTZXNzaW9uLCBlcnJvciwgX3lpZWxkJHRoaXMkZ2V0VXNlciwgZGF0YSwgX2Vycm9yMjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAwO1xuICAgICAgICAgICAgICBpZiAoISghY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuIHx8ICFjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHRpbWVOb3cgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gdGltZU5vdztcbiAgICAgICAgICAgICAgaGFzRXhwaXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICBwYXlsb2FkID0gKDAsIGhlbHBlcnNfMS5kZWNvZGVKV1RQYXlsb2FkKShjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgICBpZiAocGF5bG9hZC5leHApIHtcbiAgICAgICAgICAgICAgICBleHBpcmVzQXQgPSBwYXlsb2FkLmV4cDtcbiAgICAgICAgICAgICAgICBoYXNFeHBpcmVkID0gZXhwaXJlc0F0IDw9IHRpbWVOb3c7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkX2NhbGxSZWZyMiA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgcmVmcmVzaGVkU2Vzc2lvbiA9IF95aWVsZCR0aGlzJF9jYWxsUmVmcjIuc2Vzc2lvbjtcbiAgICAgICAgICAgICAgZXJyb3IgPSBfeWllbGQkdGhpcyRfY2FsbFJlZnIyLmVycm9yO1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgaWYgKHJlZnJlc2hlZFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzZXNzaW9uOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgIHNlc3Npb24gPSByZWZyZXNoZWRTZXNzaW9uO1xuICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAyNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VXNlcihjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0VXNlciA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgZGF0YSA9IF95aWVsZCR0aGlzJGdldFVzZXIuZGF0YTtcbiAgICAgICAgICAgICAgX2Vycm9yMiA9IF95aWVsZCR0aGlzJGdldFVzZXIuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghX2Vycm9yMikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IF9lcnJvcjI7XG4gICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICBzZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNBdCAtIHRpbWVOb3csXG4gICAgICAgICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDMyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IHNlc3Npb24udXNlcixcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IHNlc3Npb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMzU7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEudDAgPSBfY29udGV4dDExW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDExLnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDM5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDExLnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQxMS50MDtcbiAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcywgW1swLCAzNV1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXNzaW9uLCByZWdhcmRsZXNzIG9mIGV4cGlyeSBzdGF0dXMuXG4gICAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgICAqIElmIHRoZSBjdXJyZW50IHNlc3Npb24ncyByZWZyZXNoIHRva2VuIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uLiBJZiBwYXNzZWQgaW4sIGl0IG11c3QgY29udGFpbiBhIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFNlc3Npb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIoKSB7XG4gICAgICAgIHZhciBfeWllbGQkdGhpcyRnZXRTZXNzaW8zLCBkYXRhLCBfZXJyb3IzLCBfeWllbGQkdGhpcyRfY2FsbFJlZnIzLCBzZXNzaW9uLCBlcnJvcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDEyLnByZXYgPSAwO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXNzaW9uKCk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldFNlc3NpbzMgPSBfY29udGV4dDEyLnNlbnQ7XG4gICAgICAgICAgICAgIGRhdGEgPSBfeWllbGQkdGhpcyRnZXRTZXNzaW8zLmRhdGE7XG4gICAgICAgICAgICAgIF9lcnJvcjMgPSBfeWllbGQkdGhpcyRnZXRTZXNzaW8zLmVycm9yO1xuICAgICAgICAgICAgICBpZiAoIV9lcnJvcjMpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IF9lcnJvcjM7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gKF9hID0gZGF0YS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gPT09IG51bGwgfHwgY3VycmVudFNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJF9jYWxsUmVmcjMgPSBfY29udGV4dDEyLnNlbnQ7XG4gICAgICAgICAgICAgIHNlc3Npb24gPSBfeWllbGQkdGhpcyRfY2FsbFJlZnIzLnNlc3Npb247XG4gICAgICAgICAgICAgIGVycm9yID0gX3lpZWxkJHRoaXMkX2NhbGxSZWZyMy5lcnJvcjtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IHNlc3Npb24udXNlcixcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IHNlc3Npb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5wcmV2ID0gMjQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTIudDAgPSBfY29udGV4dDEyW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDEyLnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDI4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDEyLnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQxMi50MDtcbiAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMiwgdGhpcywgW1swLCAyNF1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gYSBVUkwgc3RyaW5nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFNlc3Npb25Gcm9tVXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTZXNzaW9uRnJvbVVybCgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMoKSB7XG4gICAgICAgIHZhciBlcnJvcl9kZXNjcmlwdGlvbiwgZXJyb3JfY29kZSwgX2Vycm9yNCwgcHJvdmlkZXJfdG9rZW4sIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sIGFjY2Vzc190b2tlbiwgZXhwaXJlc19pbiwgcmVmcmVzaF90b2tlbiwgdG9rZW5fdHlwZSwgdGltZU5vdywgZXhwaXJlc19hdCwgX3lpZWxkJHRoaXMkZ2V0VXNlcjIsIGRhdGEsIGVycm9yLCB1c2VyLCBzZXNzaW9uLCByZWRpcmVjdFR5cGU7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTMkKF9jb250ZXh0MTMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDEzLnByZXYgPSBfY29udGV4dDEzLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMy5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBicm93c2VyIGRldGVjdGVkLicpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpZiAodGhpcy5faXNJbXBsaWNpdEdyYW50RmxvdygpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdOb3QgYSB2YWxpZCBpbXBsaWNpdCBncmFudCBmbG93IHVybC4nKTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgZXJyb3JfZGVzY3JpcHRpb24gPSAoMCwgaGVscGVyc18xLmdldFBhcmFtZXRlckJ5TmFtZSkoJ2Vycm9yX2Rlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICAgIGlmICghZXJyb3JfZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlcnJvcl9jb2RlID0gKDAsIGhlbHBlcnNfMS5nZXRQYXJhbWV0ZXJCeU5hbWUpKCdlcnJvcl9jb2RlJyk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcl9jb2RlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gZXJyb3JfY29kZSBkZXRlY3RlZC4nKTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIF9lcnJvcjQgPSAoMCwgaGVscGVyc18xLmdldFBhcmFtZXRlckJ5TmFtZSkoJ2Vycm9yJyk7XG4gICAgICAgICAgICAgIGlmIChfZXJyb3I0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gZXJyb3IgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKGVycm9yX2Rlc2NyaXB0aW9uLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IF9lcnJvcjQsXG4gICAgICAgICAgICAgICAgY29kZTogZXJyb3JfY29kZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIHByb3ZpZGVyX3Rva2VuID0gKDAsIGhlbHBlcnNfMS5nZXRQYXJhbWV0ZXJCeU5hbWUpKCdwcm92aWRlcl90b2tlbicpO1xuICAgICAgICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuID0gKDAsIGhlbHBlcnNfMS5nZXRQYXJhbWV0ZXJCeU5hbWUpKCdwcm92aWRlcl9yZWZyZXNoX3Rva2VuJyk7XG4gICAgICAgICAgICAgIGFjY2Vzc190b2tlbiA9ICgwLCBoZWxwZXJzXzEuZ2V0UGFyYW1ldGVyQnlOYW1lKSgnYWNjZXNzX3Rva2VuJyk7XG4gICAgICAgICAgICAgIGlmIChhY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBhY2Nlc3NfdG9rZW4gZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBleHBpcmVzX2luID0gKDAsIGhlbHBlcnNfMS5nZXRQYXJhbWV0ZXJCeU5hbWUpKCdleHBpcmVzX2luJyk7XG4gICAgICAgICAgICAgIGlmIChleHBpcmVzX2luKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gZXhwaXJlc19pbiBkZXRlY3RlZC4nKTtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW4gPSAoMCwgaGVscGVyc18xLmdldFBhcmFtZXRlckJ5TmFtZSkoJ3JlZnJlc2hfdG9rZW4nKTtcbiAgICAgICAgICAgICAgaWYgKHJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyByZWZyZXNoX3Rva2VuIGRldGVjdGVkLicpO1xuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgdG9rZW5fdHlwZSA9ICgwLCBoZWxwZXJzXzEuZ2V0UGFyYW1ldGVyQnlOYW1lKSgndG9rZW5fdHlwZScpO1xuICAgICAgICAgICAgICBpZiAodG9rZW5fdHlwZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDI4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIHRva2VuX3R5cGUgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgICAgICAgIGV4cGlyZXNfYXQgPSB0aW1lTm93ICsgcGFyc2VJbnQoZXhwaXJlc19pbik7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDMyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVc2VyKGFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICBfeWllbGQkdGhpcyRnZXRVc2VyMiA9IF9jb250ZXh0MTMuc2VudDtcbiAgICAgICAgICAgICAgZGF0YSA9IF95aWVsZCR0aGlzJGdldFVzZXIyLmRhdGE7XG4gICAgICAgICAgICAgIGVycm9yID0gX3lpZWxkJHRoaXMkZ2V0VXNlcjIuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAzNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgIHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgIHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfdG9rZW46IHByb3ZpZGVyX3Rva2VuLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW46IHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19pbjogcGFyc2VJbnQoZXhwaXJlc19pbiksXG4gICAgICAgICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc19hdCxcbiAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6IHRva2VuX3R5cGUsXG4gICAgICAgICAgICAgICAgdXNlcjogdXNlclxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZWRpcmVjdFR5cGUgPSAoMCwgaGVscGVyc18xLmdldFBhcmFtZXRlckJ5TmFtZSkoJ3R5cGUnKTsgLy8gUmVtb3ZlIHRva2VucyBmcm9tIFVSTFxuICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IHNlc3Npb24sXG4gICAgICAgICAgICAgICAgICByZWRpcmVjdFR5cGU6IHJlZGlyZWN0VHlwZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICBfY29udGV4dDEzLnByZXYgPSA0NDtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMy50MCA9IF9jb250ZXh0MTNbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKF9jb250ZXh0MTMudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gNDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBzZXNzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUeXBlOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQxMy50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNDg6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MTMudDA7XG4gICAgICAgICAgICBjYXNlIDQ5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTMsIHRoaXMsIFtbMCwgNDRdXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgY29udGFpbnMgcGFyYW1ldGVycyBnaXZlbiBieSBhbiBpbXBsaWNpdCBvYXV0aCBncmFudCBmbG93IChodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OS5odG1sI3NlY3Rpb24tNC4yKVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9pc0ltcGxpY2l0R3JhbnRGbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0ltcGxpY2l0R3JhbnRGbG93KCkge1xuICAgICAgcmV0dXJuICgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpICYmIChCb29sZWFuKCgwLCBoZWxwZXJzXzEuZ2V0UGFyYW1ldGVyQnlOYW1lKSgnYWNjZXNzX3Rva2VuJykpIHx8IEJvb2xlYW4oKDAsIGhlbHBlcnNfMS5nZXRQYXJhbWV0ZXJCeU5hbWUpKCdlcnJvcl9kZXNjcmlwdGlvbicpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2lkZSBhIGJyb3dzZXIgY29udGV4dCwgYHNpZ25PdXQoKWAgd2lsbCByZW1vdmUgdGhlIGxvZ2dlZCBpbiB1c2VyIGZyb20gdGhlIGJyb3dzZXIgc2Vzc2lvblxuICAgICAqIGFuZCBsb2cgdGhlbSBvdXQgLSByZW1vdmluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbHN0b3JhZ2UgYW5kIHRoZW4gdHJpZ2dlciBhIGBcIlNJR05FRF9PVVRcImAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBGb3Igc2VydmVyLXNpZGUgbWFuYWdlbWVudCwgeW91IGNhbiByZXZva2UgYWxsIHJlZnJlc2ggdG9rZW5zIGZvciBhIHVzZXIgYnkgcGFzc2luZyBhIHVzZXIncyBKV1QgdGhyb3VnaCB0byBgYXV0aC5hcGkuc2lnbk91dChKV1Q6IHN0cmluZylgLlxuICAgICAqIFRoZXJlIGlzIG5vIHdheSB0byByZXZva2UgYSB1c2VyJ3MgYWNjZXNzIHRva2VuIGp3dCB1bnRpbCBpdCBleHBpcmVzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgYSBzaG9ydGVyIGV4cGlyeSBvbiB0aGUgand0IGZvciB0aGlzIHJlYXNvbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaWduT3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25PdXQoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE0KCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvNCwgZGF0YSwgc2Vzc2lvbkVycm9yLCBhY2Nlc3NUb2tlbiwgX3lpZWxkJHRoaXMkYWRtaW4kc2lnLCBlcnJvcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNCQoX2NvbnRleHQxNCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MTQucHJldiA9IF9jb250ZXh0MTQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXNzaW9uKCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldFNlc3NpbzQgPSBfY29udGV4dDE0LnNlbnQ7XG4gICAgICAgICAgICAgIGRhdGEgPSBfeWllbGQkdGhpcyRnZXRTZXNzaW80LmRhdGE7XG4gICAgICAgICAgICAgIHNlc3Npb25FcnJvciA9IF95aWVsZCR0aGlzJGdldFNlc3NpbzQuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gKF9hID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgICBpZiAoIWFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkbWluLnNpZ25PdXQoYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkYWRtaW4kc2lnID0gX2NvbnRleHQxNC5zZW50O1xuICAgICAgICAgICAgICBlcnJvciA9IF95aWVsZCR0aGlzJGFkbWluJHNpZy5lcnJvcjtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoQXBpRXJyb3IpKGVycm9yKSAmJiAoZXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfT1VUJywgbnVsbCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTQsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNlaXZlIGEgbm90aWZpY2F0aW9uIGV2ZXJ5IHRpbWUgYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBhbiBhdXRoIGV2ZW50IGhhcHBlbnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25BdXRoU3RhdGVDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25BdXRoU3RhdGVDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgaWQgPSAoMCwgaGVscGVyc18xLnV1aWQpKCk7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIF90aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnNbXCJkZWxldGVcIl0oaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvblxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHBhc3N3b3JkIHJlc2V0IHJlcXVlc3QgdG8gYW4gZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBjbGljayB0aGUgcGFzc3dvcmQgcmVzZXQgbGluay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0Y2hhVG9rZW4gVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlc2V0UGFzc3dvcmRGb3JFbWFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFBhc3N3b3JkRm9yRW1haWwoZW1haWwpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTUoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTUkKF9jb250ZXh0MTUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDE1LnByZXYgPSBfY29udGV4dDE1Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQxNS5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9yZWNvdmVyXCIpLCB7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgZW1haWw6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHtcbiAgICAgICAgICAgICAgICAgICAgY2FwdGNoYV90b2tlbjogb3B0aW9ucy5jYXB0Y2hhVG9rZW5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG9cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDE1LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dDE1LnByZXYgPSA2O1xuICAgICAgICAgICAgICBfY29udGV4dDE1LnQwID0gX2NvbnRleHQxNVtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQxNS50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE1Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0MTUudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDE1LnQwO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE1LCB0aGlzLCBbWzAsIDZdXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBKV1QuXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBIHZhbGlkIHJlZnJlc2ggdG9rZW4gdGhhdCB3YXMgcmV0dXJuZWQgb24gbG9naW4uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlZnJlc2hBY2Nlc3NUb2tlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbikge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNiQoX2NvbnRleHQxNikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MTYucHJldiA9IF9jb250ZXh0MTYubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDE2LnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL3Rva2VuP2dyYW50X3R5cGU9cmVmcmVzaF90b2tlblwiKSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9zZXNzaW9uUmVzcG9uc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDE2LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dDE2LnByZXYgPSA2O1xuICAgICAgICAgICAgICBfY29udGV4dDE2LnQwID0gX2NvbnRleHQxNltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQxNi50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGwsXG4gICAgICAgICAgICAgICAgICB1c2VyOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQxNi50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MTYudDA7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTYsIHRoaXMsIFtbMCwgNl1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVmFsaWRTZXNzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1ZhbGlkU2Vzc2lvbihtYXliZVNlc3Npb24pIHtcbiAgICAgIHZhciBpc1ZhbGlkU2Vzc2lvbiA9IF90eXBlb2YobWF5YmVTZXNzaW9uKSA9PT0gJ29iamVjdCcgJiYgbWF5YmVTZXNzaW9uICE9PSBudWxsICYmICdhY2Nlc3NfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJiAncmVmcmVzaF90b2tlbicgaW4gbWF5YmVTZXNzaW9uICYmICdleHBpcmVzX2F0JyBpbiBtYXliZVNlc3Npb247XG4gICAgICByZXR1cm4gaXNWYWxpZFNlc3Npb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVQcm92aWRlclNpZ25JblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUHJvdmlkZXJTaWduSW4ocHJvdmlkZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciB1cmwgPSB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihwcm92aWRlciwge1xuICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgIHNjb3Blczogb3B0aW9ucy5zY29wZXMsXG4gICAgICAgIHF1ZXJ5UGFyYW1zOiBvcHRpb25zLnF1ZXJ5UGFyYW1zXG4gICAgICB9KTtcbiAgICAgIC8vIHRyeSB0byBvcGVuIG9uIHRoZSBicm93c2VyXG4gICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc0Jyb3dzZXIpKCkpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyLFxuICAgICAgICAgIHVybDogdXJsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvdmVycyB0aGUgc2Vzc2lvbiBmcm9tIExvY2FsU3RvcmFnZSBhbmQgcmVmcmVzaGVzXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgaXMgYXN5bmMgdG8gYWNjb21tb2RhdGUgZm9yIEFzeW5jU3RvcmFnZSBlLmcuIGluIFJlYWN0IG5hdGl2ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVjb3ZlckFuZFJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlY292ZXJBbmRSZWZyZXNoKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgIHZhciBjdXJyZW50U2Vzc2lvbiwgdGltZU5vdywgX3lpZWxkJHRoaXMkX2NhbGxSZWZyNCwgZXJyb3I7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTckKF9jb250ZXh0MTcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDE3LnByZXYgPSBfY29udGV4dDE3Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQxNy5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBoZWxwZXJzXzEuZ2V0SXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gX2NvbnRleHQxNy5zZW50O1xuICAgICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZFNlc3Npb24oY3VycmVudFNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIShjdXJyZW50U2Vzc2lvbiAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0MTcubmV4dCA9IDg7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcInJldHVyblwiKTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgICBpZiAoISgoKF9hID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHkpIDwgdGltZU5vdyArIGNvbnN0YW50c18xLkVYUElSWV9NQVJHSU4pKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gMzI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEodGhpcy5hdXRvUmVmcmVzaFRva2VuICYmIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gMjg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrUmV0cmllcysrO1xuICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBfeWllbGQkdGhpcyRfY2FsbFJlZnI0ID0gX2NvbnRleHQxNy5zZW50O1xuICAgICAgICAgICAgICBlcnJvciA9IF95aWVsZCR0aGlzJF9jYWxsUmVmcjQuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnNfMS5BdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciAmJiB0aGlzLm5ldHdvcmtSZXRyaWVzIDwgY29uc3RhbnRzXzEuTkVUV09SS19GQUlMVVJFLk1BWF9SRVRSSUVTKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTcubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLnJlZnJlc2hUb2tlblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5yZWZyZXNoVG9rZW5UaW1lcik7XG4gICAgICAgICAgICAgIHRoaXMucmVmcmVzaFRva2VuVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgICB9LCBNYXRoLnBvdyhjb25zdGFudHNfMS5ORVRXT1JLX0ZBSUxVUkUuUkVUUllfSU5URVJWQUwsIHRoaXMubmV0d29ya1JldHJpZXMpICogMTAwIC8vIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtSZXRyaWVzID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAzNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICBpZiAoIXRoaXMucGVyc2lzdFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAzNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAzNTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgIHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSA0MjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICBfY29udGV4dDE3LnByZXYgPSAzODtcbiAgICAgICAgICAgICAgX2NvbnRleHQxNy50MCA9IF9jb250ZXh0MTdbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihfY29udGV4dDE3LnQwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE3LCB0aGlzLCBbWzAsIDM4XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsbFJlZnJlc2hUb2tlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsbFJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE4KCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkX3JlZnJlc2hBLCBkYXRhLCBlcnJvciwgcmVzdWx0LCBfcmVzdWx0O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE4JChfY29udGV4dDE4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQxOC5wcmV2ID0gX2NvbnRleHQxOC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICghdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE4LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5wcm9taXNlKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX2NvbnRleHQxOC5wcmV2ID0gMjtcbiAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBuZXcgaGVscGVyc18xLkRlZmVycmVkKCk7XG4gICAgICAgICAgICAgIGlmIChyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSA4O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbik7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJF9yZWZyZXNoQSA9IF9jb250ZXh0MTguc2VudDtcbiAgICAgICAgICAgICAgZGF0YSA9IF95aWVsZCR0aGlzJF9yZWZyZXNoQS5kYXRhO1xuICAgICAgICAgICAgICBlcnJvciA9IF95aWVsZCR0aGlzJF9yZWZyZXNoQS5lcnJvcjtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxOC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1RPS0VOX1JFRlJFU0hFRCcsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uOiBkYXRhLnNlc3Npb24sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTgucHJldiA9IDIzO1xuICAgICAgICAgICAgICBfY29udGV4dDE4LnQwID0gX2NvbnRleHQxOFtcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQxOC50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHNlc3Npb246IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0MTgudDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgKF9hID0gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNvbHZlKF9yZXN1bHQpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoXCJyZXR1cm5cIiwgX3Jlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICAoX2IgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdChfY29udGV4dDE4LnQwKTtcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQxOC50MDtcbiAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTgucHJldiA9IDMxO1xuICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE4LmZpbmlzaCgzMSk7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTgsIHRoaXMsIFtbMiwgMjMsIDMxLCAzNF1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX25vdGlmeUFsbFN1YnNjcmliZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudCwgc2Vzc2lvbikge1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCBjdXJyZW50U2Vzc2lvbiBhbmQgY3VycmVudFVzZXJcbiAgICAgKiBwcm9jZXNzIHRvIF9zdGFydEF1dG9SZWZyZXNoVG9rZW4gaWYgcG9zc2libGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2F2ZVNlc3Npb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmVTZXNzaW9uKHNlc3Npb24pIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTkoKSB7XG4gICAgICAgIHZhciBleHBpcmVzQXQsIHRpbWVOb3csIGV4cGlyZXNJbiwgcmVmcmVzaER1cmF0aW9uQmVmb3JlRXhwaXJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOSQoX2NvbnRleHQxOSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MTkucHJldiA9IF9jb250ZXh0MTkubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoIXRoaXMucGVyc2lzdFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluTWVtb3J5U2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gc2Vzc2lvbi5leHBpcmVzX2F0O1xuICAgICAgICAgICAgICBpZiAoZXhwaXJlc0F0KSB7XG4gICAgICAgICAgICAgICAgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgICAgIGV4cGlyZXNJbiA9IGV4cGlyZXNBdCAtIHRpbWVOb3c7XG4gICAgICAgICAgICAgICAgcmVmcmVzaER1cmF0aW9uQmVmb3JlRXhwaXJlcyA9IGV4cGlyZXNJbiA+IGNvbnN0YW50c18xLkVYUElSWV9NQVJHSU4gPyBjb25zdGFudHNfMS5FWFBJUllfTUFSR0lOIDogMC41O1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbigoZXhwaXJlc0luIC0gcmVmcmVzaER1cmF0aW9uQmVmb3JlRXhwaXJlcykgKiAxMDAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoISh0aGlzLnBlcnNpc3RTZXNzaW9uICYmIHNlc3Npb24uZXhwaXJlc19hdCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE5Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0MTkubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZXJzaXN0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE5LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcnNpc3RTZXNzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJzaXN0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgcmV0dXJuICgwLCBoZWxwZXJzXzEuc2V0SXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgY3VycmVudFNlc3Npb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlU2Vzc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlU2Vzc2lvbigpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMjAoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMjAkKF9jb250ZXh0MjApIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIwLnByZXYgPSBfY29udGV4dDIwLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnBlcnNpc3RTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDIwLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGhlbHBlcnNfMS5yZW1vdmVJdGVtQXN5bmMpKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHRoaXMuaW5NZW1vcnlTZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRva2VuVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWZyZXNoVG9rZW5UaW1lcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjAuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIwLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYW5kIHJlLWNyZWF0ZSByZWZyZXNoIHRva2VuIHRpbWVyXG4gICAgICogQHBhcmFtIHZhbHVlIHRpbWUgaW50ZXJ2YWxzIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0gc2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydEF1dG9SZWZyZXNoVG9rZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbih2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5yZWZyZXNoVG9rZW5UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMucmVmcmVzaFRva2VuVGltZXIpO1xuICAgICAgaWYgKHZhbHVlIDw9IDAgfHwgIXRoaXMuYXV0b1JlZnJlc2hUb2tlbikgcmV0dXJuO1xuICAgICAgdGhpcy5yZWZyZXNoVG9rZW5UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzMywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMjEoKSB7XG4gICAgICAgICAgdmFyIF95aWVsZCR0aGlzJGdldFNlc3NpbzUsIHNlc3Npb24sIHNlc3Npb25FcnJvciwgX3lpZWxkJHRoaXMkX2NhbGxSZWZyNSwgZXJyb3I7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyMSQoX2NvbnRleHQyMSkge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyMS5wcmV2ID0gX2NvbnRleHQyMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtSZXRyaWVzKys7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXNzaW9uKCk7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBfeWllbGQkdGhpcyRnZXRTZXNzaW81ID0gX2NvbnRleHQyMS5zZW50O1xuICAgICAgICAgICAgICAgIHNlc3Npb24gPSBfeWllbGQkdGhpcyRnZXRTZXNzaW81LmRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICBzZXNzaW9uRXJyb3IgPSBfeWllbGQkdGhpcyRnZXRTZXNzaW81LmVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghKCFzZXNzaW9uRXJyb3IgJiYgc2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjEubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjEubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oc2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF95aWVsZCR0aGlzJF9jYWxsUmVmcjUgPSBfY29udGV4dDIxLnNlbnQ7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBfeWllbGQkdGhpcyRfY2FsbFJlZnI1LmVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHRoaXMubmV0d29ya1JldHJpZXMgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yc18xLkF1dGhSZXRyeWFibGVGZXRjaEVycm9yICYmIHRoaXMubmV0d29ya1JldHJpZXMgPCBjb25zdGFudHNfMS5ORVRXT1JLX0ZBSUxVUkUuTUFYX1JFVFJJRVMpIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbihNYXRoLnBvdyhjb25zdGFudHNfMS5ORVRXT1JLX0ZBSUxVUkUuUkVUUllfSU5URVJWQUwsIHRoaXMubmV0d29ya1JldHJpZXMpICogMTAwKTsgLy8gZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjEuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUyMSwgdGhpcyk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0sIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5yZWZyZXNoVG9rZW5UaW1lci51bnJlZiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5yZWZyZXNoVG9rZW5UaW1lci51bnJlZigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgaWYgKCEoMCwgaGVscGVyc18xLmlzQnJvd3NlcikoKSB8fCAhKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzNCwgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMjIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIyJChfY29udGV4dDIyKSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MjIucHJldiA9IF9jb250ZXh0MjIubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIGlmICghKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIyLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIyLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY292ZXJBbmRSZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIyLnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTIyLCB0aGlzKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UnLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgcmVsZXZhbnQgbG9naW4gVVJMIGZvciBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gQSBVUkwgb3IgbW9iaWxlIGFkZHJlc3MgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGFyZSBjb25maXJtZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2NvcGVzIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2Ygc2NvcGVzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXJ5UGFyYW1zIEFuIG9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgY29udGFpbmluZyBxdWVyeSBwYXJhbWV0ZXJzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRVcmxGb3JQcm92aWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VXJsRm9yUHJvdmlkZXIocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB1cmxQYXJhbXMgPSBbXCJwcm92aWRlcj1cIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KHByb3ZpZGVyKSldO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvKSB7XG4gICAgICAgIHVybFBhcmFtcy5wdXNoKFwicmVkaXJlY3RfdG89XCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnJlZGlyZWN0VG8pKSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjb3Blcykge1xuICAgICAgICB1cmxQYXJhbXMucHVzaChcInNjb3Blcz1cIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuc2NvcGVzKSkpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeVBhcmFtcykge1xuICAgICAgICB2YXIgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMucXVlcnlQYXJhbXMpO1xuICAgICAgICB1cmxQYXJhbXMucHVzaChxdWVyeS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvYXV0aG9yaXplP1wiKS5jb25jYXQodXJsUGFyYW1zLmpvaW4oJyYnKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bmVucm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5lbnJvbGwocGFyYW1zKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIzKCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvNiwgc2Vzc2lvbkRhdGEsIHNlc3Npb25FcnJvcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyMyQoX2NvbnRleHQyMykge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MjMucHJldiA9IF9jb250ZXh0MjMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDIzLnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dDIzLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXNzaW9uKCk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldFNlc3NpbzYgPSBfY29udGV4dDIzLnNlbnQ7XG4gICAgICAgICAgICAgIHNlc3Npb25EYXRhID0gX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvNi5kYXRhO1xuICAgICAgICAgICAgICBzZXNzaW9uRXJyb3IgPSBfeWllbGQkdGhpcyRnZXRTZXNzaW82LmVycm9yO1xuICAgICAgICAgICAgICBpZiAoIXNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjMubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjMuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjMubmV4dCA9IDEwO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdERUxFVEUnLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvZmFjdG9ycy9cIikuY29uY2F0KHBhcmFtcy5mYWN0b3JJZCksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIzLnNlbnQpO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQyMy5wcmV2ID0gMTM7XG4gICAgICAgICAgICAgIF9jb250ZXh0MjMudDAgPSBfY29udGV4dDIzW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDIzLnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjMubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIzLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQyMy50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MjMudDA7XG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMy5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjMsIHRoaXMsIFtbMCwgMTNdXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVucm9sbHMgYSBmYWN0b3JcbiAgICAgKiBAcGFyYW0gZnJpZW5kbHlOYW1lIEh1bWFuIHJlYWRhYmxlIG5hbWUgYXNzaWduZWQgdG8gYSBkZXZpY2VcbiAgICAgKiBAcGFyYW0gZmFjdG9yVHlwZSBkZXZpY2Ugd2hpY2ggd2UncmUgdmFsaWRhdGluZyBhZ2FpbnN0LiBDYW4gb25seSBiZSBUT1RQIGZvciBub3cuXG4gICAgICogQHBhcmFtIGlzc3VlciBkb21haW4gd2hpY2ggdGhlIHVzZXIgaXMgZW5yb2xsaW5nIHdpdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZW5yb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnJvbGwocGFyYW1zKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNCgpIHtcbiAgICAgICAgdmFyIF95aWVsZCR0aGlzJGdldFNlc3NpbzcsIHNlc3Npb25EYXRhLCBzZXNzaW9uRXJyb3IsIF95aWVsZDUsIGRhdGEsIGVycm9yO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI0JChfY29udGV4dDI0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyNC5wcmV2ID0gX2NvbnRleHQyNC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjQucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvNyA9IF9jb250ZXh0MjQuc2VudDtcbiAgICAgICAgICAgICAgc2Vzc2lvbkRhdGEgPSBfeWllbGQkdGhpcyRnZXRTZXNzaW83LmRhdGE7XG4gICAgICAgICAgICAgIHNlc3Npb25FcnJvciA9IF95aWVsZCR0aGlzJGdldFNlc3NpbzcuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHNlc3Npb25FcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvZmFjdG9yc1wiKSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgIGZyaWVuZGx5X25hbWU6IHBhcmFtcy5mcmllbmRseU5hbWUsXG4gICAgICAgICAgICAgICAgICBmYWN0b3JfdHlwZTogcGFyYW1zLmZhY3RvclR5cGUsXG4gICAgICAgICAgICAgICAgICBpc3N1ZXI6IHBhcmFtcy5pc3N1ZXJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgX3lpZWxkNSA9IF9jb250ZXh0MjQuc2VudDtcbiAgICAgICAgICAgICAgZGF0YSA9IF95aWVsZDUuZGF0YTtcbiAgICAgICAgICAgICAgZXJyb3IgPSBfeWllbGQ1LmVycm9yO1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGlmICgoX2IgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudG90cCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnFyX2NvZGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnRvdHAucXJfY29kZSA9IFwiZGF0YTppbWFnZS9zdmcreG1sO3V0Zi04LFwiLmNvbmNhdChkYXRhLnRvdHAucXJfY29kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQyNC5wcmV2ID0gMTk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MjQudDAgPSBfY29udGV4dDI0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShfY29udGV4dDI0LnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQyNC50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MjQudDA7XG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjQsIHRoaXMsIFtbMCwgMTldXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBhIGRldmljZSBhcyBwYXJ0IG9mIHRoZSBlbnJvbGxtZW50IHN0ZXAuXG4gICAgICogQHBhcmFtIGZhY3RvcklkIFN5c3RlbSBhc3NpZ25lZCBpZGVudGlmaWVyIGZvciBhdXRoZW50aWNhdG9yIGRldmljZSBhcyByZXR1cm5lZCBieSBlbnJvbGxcbiAgICAgKiBAcGFyYW0gY29kZSBDb2RlIEdlbmVyYXRlZCBieSBhbiBhdXRoZW50aWNhdG9yIGRldmljZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl92ZXJpZnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZlcmlmeShwYXJhbXMpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMjUoKSB7XG4gICAgICAgIHZhciBfeWllbGQkdGhpcyRnZXRTZXNzaW84LCBzZXNzaW9uRGF0YSwgc2Vzc2lvbkVycm9yLCBfeWllbGQ2LCBkYXRhLCBlcnJvcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNSQoX2NvbnRleHQyNSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MjUucHJldiA9IF9jb250ZXh0MjUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDI1LnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXNzaW9uKCk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldFNlc3NpbzggPSBfY29udGV4dDI1LnNlbnQ7XG4gICAgICAgICAgICAgIHNlc3Npb25EYXRhID0gX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvOC5kYXRhO1xuICAgICAgICAgICAgICBzZXNzaW9uRXJyb3IgPSBfeWllbGQkdGhpcyRnZXRTZXNzaW84LmVycm9yO1xuICAgICAgICAgICAgICBpZiAoIXNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjUubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjUubmV4dCA9IDEwO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL2ZhY3RvcnMvXCIpLmNvbmNhdChwYXJhbXMuZmFjdG9ySWQsIFwiL3ZlcmlmeVwiKSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICAgICAgICAgICAgY2hhbGxlbmdlX2lkOiBwYXJhbXMuY2hhbGxlbmdlSWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgX3lpZWxkNiA9IF9jb250ZXh0MjUuc2VudDtcbiAgICAgICAgICAgICAgZGF0YSA9IF95aWVsZDYuZGF0YTtcbiAgICAgICAgICAgICAgZXJyb3IgPSBfeWllbGQ2LmVycm9yO1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNS5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjUubmV4dCA9IDE3O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZVNlc3Npb24oT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgZXhwaXJlc19hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyBkYXRhLmV4cGlyZXNfaW5cbiAgICAgICAgICAgICAgfSwgZGF0YSkpO1xuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ01GQV9DSEFMTEVOR0VfVkVSSUZJRUQnLCBkYXRhKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjUucHJldiA9IDIxO1xuICAgICAgICAgICAgICBfY29udGV4dDI1LnQwID0gX2NvbnRleHQyNVtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQyNS50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0MjUudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDI1LnQwO1xuICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI1LCB0aGlzLCBbWzAsIDIxXV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hhbGxlbmdlIHdoaWNoIGEgdXNlciBjYW4gdmVyaWZ5IGFnYWluc3RcbiAgICAgKiBAcGFyYW0gZmFjdG9ySWQgU3lzdGVtIGFzc2lnbmVkIGlkZW50aWZpZXIgZm9yIGF1dGhlbnRpY2F0b3IgZGV2aWNlIGFzIHJldHVybmVkIGJ5IGVucm9sbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jaGFsbGVuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoYWxsZW5nZShwYXJhbXMpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMjYoKSB7XG4gICAgICAgIHZhciBfeWllbGQkdGhpcyRnZXRTZXNzaW85LCBzZXNzaW9uRGF0YSwgc2Vzc2lvbkVycm9yO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI2JChfY29udGV4dDI2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyNi5wcmV2ID0gX2NvbnRleHQyNi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjYucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0MjYubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvOSA9IF9jb250ZXh0MjYuc2VudDtcbiAgICAgICAgICAgICAgc2Vzc2lvbkRhdGEgPSBfeWllbGQkdGhpcyRnZXRTZXNzaW85LmRhdGE7XG4gICAgICAgICAgICAgIHNlc3Npb25FcnJvciA9IF95aWVsZCR0aGlzJGdldFNlc3NpbzkuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNi5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHNlc3Npb25FcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgX2NvbnRleHQyNi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvZmFjdG9ycy9cIikuY29uY2F0KHBhcmFtcy5mYWN0b3JJZCwgXCIvY2hhbGxlbmdlXCIpLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW5cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyNi5zZW50KTtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjYucHJldiA9IDEzO1xuICAgICAgICAgICAgICBfY29udGV4dDI2LnQwID0gX2NvbnRleHQyNltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoX2NvbnRleHQyNi50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDI2Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0MjYudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDI2LnQwO1xuICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjYuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI2LCB0aGlzLCBbWzAsIDEzXV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hhbGxlbmdlIGFuZCBpbW1lZGlhdGVseSB2ZXJpZmllcyBpdFxuICAgICAqIEBwYXJhbSBmYWN0b3JJZCBTeXN0ZW0gYXNzaWduZWQgaWRlbnRpZmllciBmb3IgYXV0aGVudGljYXRvciBkZXZpY2UgYXMgcmV0dXJuZWQgYnkgZW5yb2xsXG4gICAgICogQHBhcmFtIGNvZGUgQ29kZSBHZW5lcmF0ZWQgYnkgYW4gYXV0aGVudGljYXRvciBkZXZpY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY2hhbGxlbmdlQW5kVmVyaWZ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGFsbGVuZ2VBbmRWZXJpZnkocGFyYW1zKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI3KCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkX2NoYWxsZW5nLCBjaGFsbGVuZ2VEYXRhLCBjaGFsbGVuZ2VFcnJvcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNyQoX2NvbnRleHQyNykge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MjcucHJldiA9IF9jb250ZXh0MjcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDI3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hhbGxlbmdlKHtcbiAgICAgICAgICAgICAgICBmYWN0b3JJZDogcGFyYW1zLmZhY3RvcklkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfeWllbGQkdGhpcyRfY2hhbGxlbmcgPSBfY29udGV4dDI3LnNlbnQ7XG4gICAgICAgICAgICAgIGNoYWxsZW5nZURhdGEgPSBfeWllbGQkdGhpcyRfY2hhbGxlbmcuZGF0YTtcbiAgICAgICAgICAgICAgY2hhbGxlbmdlRXJyb3IgPSBfeWllbGQkdGhpcyRfY2hhbGxlbmcuZXJyb3I7XG4gICAgICAgICAgICAgIGlmICghY2hhbGxlbmdlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDI3Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI3LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogY2hhbGxlbmdlRXJyb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjcubmV4dCA9IDk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJpZnkoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgY29kZTogcGFyYW1zLmNvZGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI3LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDI3LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mjcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI3LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgYWxsIGRldmljZXMgZm9yIGEgZ2l2ZW4gdXNlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9saXN0RmFjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGlzdEZhY3RvcnMoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI4KCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkZ2V0VXNlcjMsIHVzZXIsIHVzZXJFcnJvciwgZmFjdG9ycywgdG90cDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyOCQoX2NvbnRleHQyOCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MjgucHJldiA9IF9jb250ZXh0MjgubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDI4Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldFVzZXIzID0gX2NvbnRleHQyOC5zZW50O1xuICAgICAgICAgICAgICB1c2VyID0gX3lpZWxkJHRoaXMkZ2V0VXNlcjMuZGF0YS51c2VyO1xuICAgICAgICAgICAgICB1c2VyRXJyb3IgPSBfeWllbGQkdGhpcyRnZXRVc2VyMy5lcnJvcjtcbiAgICAgICAgICAgICAgaWYgKCF1c2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDI4Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI4LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogdXNlckVycm9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBmYWN0b3JzID0gKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5mYWN0b3JzKSB8fCBbXTtcbiAgICAgICAgICAgICAgdG90cCA9IGZhY3RvcnMuZmlsdGVyKGZ1bmN0aW9uIChmYWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yLmZhY3Rvcl90eXBlID09PSAndG90cCcgJiYgZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI4LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgYWxsOiBmYWN0b3JzLFxuICAgICAgICAgICAgICAgICAgdG90cDogdG90cFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjgsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGFuZCBuZXh0IGF1dGhlbnRpY2F0b3IgYXNzdXJhbmNlIGxldmVsIChBQUwpXG4gICAgICogYW5kIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMgZm9yIHRoZSBzZXNzaW9uIChBTVIpXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMjkoKSB7XG4gICAgICAgIHZhciBfeWllbGQkdGhpcyRnZXRTZXNzaW8xMCwgc2Vzc2lvbiwgc2Vzc2lvbkVycm9yLCBwYXlsb2FkLCBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgdmVyaWZpZWRGYWN0b3JzLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI5JChfY29udGV4dDI5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyOS5wcmV2ID0gX2NvbnRleHQyOS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjkubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0U2Vzc2lvMTAgPSBfY29udGV4dDI5LnNlbnQ7XG4gICAgICAgICAgICAgIHNlc3Npb24gPSBfeWllbGQkdGhpcyRnZXRTZXNzaW8xMC5kYXRhLnNlc3Npb247XG4gICAgICAgICAgICAgIHNlc3Npb25FcnJvciA9IF95aWVsZCR0aGlzJGdldFNlc3NpbzEwLmVycm9yO1xuICAgICAgICAgICAgICBpZiAoIXNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjkubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjkuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBzZXNzaW9uRXJyb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyOS5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIG5leHRMZXZlbDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHM6IFtdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgcGF5bG9hZCA9IHRoaXMuX2RlY29kZUpXVChzZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChwYXlsb2FkLmFhbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHBheWxvYWQuYWFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5leHRMZXZlbCA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgdmVyaWZpZWRGYWN0b3JzID0gKF9iID0gKF9hID0gc2Vzc2lvbi51c2VyLmZhY3RvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoZnVuY3Rpb24gKGZhY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnO1xuICAgICAgICAgICAgICB9KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG5leHRMZXZlbCA9ICdhYWwyJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzID0gcGF5bG9hZC5hbXIgfHwgW107XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI5LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgY3VycmVudExldmVsOiBjdXJyZW50TGV2ZWwsXG4gICAgICAgICAgICAgICAgICBuZXh0TGV2ZWw6IG5leHRMZXZlbCxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHM6IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mjkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI5LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEdvVHJ1ZUNsaWVudDtcbn0oKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gR29UcnVlQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3UVVGQlFUdEJRVU5CTzBGQlQwRTdRVUZWUVR0QlFVTkJPMEZCVjBFN1FVRkRRVHRCUVhWRFFTeHJRMEZCYTBJc1IwRkJSU3hGUVVGRE8wRkJSWEpDTEVsQlFVMUJMR1ZCUVdVc1IwRkJOa1E3UlVGRGFFWkRMRWRCUVVjc1JVRkJSVU1zYzBKQlFWVTdSVUZEWmtNc1ZVRkJWU3hGUVVGRlJDeDFRa0ZCVnp0RlFVTjJRa1VzWjBKQlFXZENMRVZCUVVVc1NVRkJTVHRGUVVOMFFrTXNZMEZCWXl4RlFVRkZMRWxCUVVrN1JVRkRjRUpETEd0Q1FVRnJRaXhGUVVGRkxFbEJRVWs3UlVGRGVFSkRMRTlCUVU4c1JVRkJSVXc3UTBGRFZqdEJRVUZCTEVsQlJXOUNUU3haUVVGWk8wVkJNRU12UWpzN08wVkJSMEVzYzBKQlFWbERMRTlCUVRSQ08wbEJRVUU3U1VGeVFqbENMSGRDUVVGdFFpeEhRVUU0UWl4SlFVRkpReXhIUVVGSExFVkJRVVU3U1VGRk1VUXNiVUpCUVdNc1IwRkJSeXhEUVVGRE8wbEJRMnhDTEhWQ1FVRnJRaXhIUVVFMFF5eEpRVUZKTzBsQlF6VkZPenM3T3pzN1NVRk5WU3h6UWtGQmFVSXNSMEZCY1VNc1NVRkJTVHRKUVVNeFJDeDFRa0ZCYTBJc1IwRkJSeXhKUVVGSk8wbEJWMnBETEVsQlFVMURMRkZCUVZFc2JVTkJRVkZZTEdWQlFXVXNSMEZCUzFNc1QwRkJUeXhEUVVGRk8wbEJRMjVFTEVsQlFVa3NRMEZCUTBjc1pVRkJaU3hIUVVGSExFbEJRVWs3U1VGRE0wSXNTVUZCU1N4RFFVRkRWQ3hWUVVGVkxFZEJRVWRSTEZGQlFWRXNRMEZCUTFJc1ZVRkJWVHRKUVVOeVF5eEpRVUZKTEVOQlFVTkRMR2RDUVVGblFpeEhRVUZIVHl4UlFVRlJMRU5CUVVOUUxHZENRVUZuUWp0SlFVTnFSQ3hKUVVGSkxFTkJRVU5ETEdOQlFXTXNSMEZCUjAwc1VVRkJVU3hEUVVGRFRpeGpRVUZqTzBsQlF6ZERMRWxCUVVrc1EwRkJRMUVzVDBGQlR5eEhRVUZIUml4UlFVRlJMRU5CUVVORkxFOUJRVThzU1VGQlNVTXNNRUpCUVcxQ08wbEJRM1JFTEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhIUVVGSExFbEJRVWxETERKQ1FVRmpMRU5CUVVNN1RVRkRPVUptTEVkQlFVY3NSVUZCUlZVc1VVRkJVU3hEUVVGRFZpeEhRVUZITzAxQlEycENUU3hQUVVGUExFVkJRVVZKTEZGQlFWRXNRMEZCUTBvc1QwRkJUenROUVVONlFsVXNTMEZCU3l4RlFVRkZUaXhSUVVGUkxFTkJRVU5OTzB0QlEycENMRU5CUVVNN1NVRkZSaXhKUVVGSkxFTkJRVU5vUWl4SFFVRkhMRWRCUVVkVkxGRkJRVkVzUTBGQlExWXNSMEZCUnp0SlFVTjJRaXhKUVVGSkxFTkJRVU5OTEU5QlFVOHNSMEZCUjBrc1VVRkJVU3hEUVVGRFNpeFBRVUZQTzBsQlF5OUNMRWxCUVVrc1EwRkJRMVVzUzBGQlN5eEhRVUZITERCQ1FVRlpMRVZCUVVOT0xGRkJRVkVzUTBGQlEwMHNTMEZCU3l4RFFVRkRPMGxCUTNwRExFbEJRVWtzUTBGQlExZ3NhMEpCUVd0Q0xFZEJRVWRMTEZGQlFWRXNRMEZCUTB3c2EwSkJRV3RDTzBsQlJYSkVMRWxCUVVrc1EwRkJRMWtzVlVGQlZTeEZRVUZGTzBsQlEycENMRWxCUVVrc1EwRkJRME1zUjBGQlJ5eEhRVUZITzAxQlExUkRMRTFCUVUwc1JVRkJSU3hKUVVGSkxFTkJRVU5ETEU5QlFVOHNRMEZCUTBNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF6dE5RVU12UWtNc1RVRkJUU3hGUVVGRkxFbEJRVWtzUTBGQlEwTXNUMEZCVHl4RFFVRkRSaXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETzAxQlF5OUNSeXhSUVVGUkxFVkJRVVVzU1VGQlNTeERRVUZEUXl4VFFVRlRMRU5CUVVOS0xFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTTdUVUZEYmtOTExGTkJRVk1zUlVGQlJTeEpRVUZKTEVOQlFVTkRMRlZCUVZVc1EwRkJRMDRzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXp0TlFVTnlRMDhzVjBGQlZ5eEZRVUZGTEVsQlFVa3NRMEZCUTBNc1dVRkJXU3hEUVVGRFVpeEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRPMDFCUTNwRFV5eHJRa0ZCYTBJc1JVRkJSU3hKUVVGSkxFTkJRVU5ETEcxQ1FVRnRRaXhEUVVGRFZpeEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRPMDFCUTNaRVZ5dzRRa0ZCT0VJc1JVRkJSU3hKUVVGSkxFTkJRVU5ETEN0Q1FVRXJRaXhEUVVGRFdpeEpRVUZKTEVOQlFVTXNTVUZCU1R0TFFVTXZSVHRGUVVOSU8wVkJSVUU3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlMwRXNjMEpCUVZVN1RVRkRVaXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZEWVN4cFFrRkJhVUlzUlVGQlJUdFJRVU16UWl4SlFVRkpMRU5CUVVOQkxHbENRVUZwUWl4SFFVRkhMRWxCUVVrc1EwRkJRME1zVjBGQlZ5eEZRVUZGT3p0TlFVYzNReXhQUVVGUExFbEJRVWtzUTBGQlEwUXNhVUpCUVdsQ08wbEJReTlDTzBsQlJVRTdPenM3T3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVUxakxIVkNRVUZYT3pzN096czdiVUpCUTI1Q0xFbEJRVWtzUTBGQlEwRXNhVUpCUVdsQ08yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3hwUTBGRGFrSXNTVUZCU1N4RFFVRkRRU3hwUWtGQmFVSTdXVUZCUVR0alFVRkJPMk5CUVVFc1RVRkpla0lzU1VGQlNTeERRVUZETjBJc2EwSkJRV3RDTEVsQlFVa3NTVUZCU1N4RFFVRkRLMElzYjBKQlFXOUNMRVZCUVVVN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJPMk5CUTJoRExFOUJRVTBzU1VGQlNTeERRVUZEUXl4clFrRkJhMElzUlVGQlJUdFpRVUZCTzJOQlFVRTdZMEZCTDBORExFbEJRVWtzZVVKQlFVcEJMRWxCUVVrN1kwRkJSVU1zUzBGQlN5eDVRa0ZCVEVFc1MwRkJTenRqUVVGQkxFdEJSV1pCTEV0QlFVczdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTzJOQlIxQXNUMEZCVFN4SlFVRkpMRU5CUVVORExHTkJRV01zUlVGQlJUdFpRVUZCTzJOQlFVRXNhVU5CUlhCQ08yZENRVUZGUkN4TFFVRkxMRVZCUVV4Qk8yTkJRVXNzUTBGQlJUdFpRVUZCTzJOQlIxWkZMRTlCUVU4c1IwRkJiVUpJTEVsQlFVa3NRMEZCT1VKSExFOUJRVThzUlVGQlJVTXNXVUZCV1N4SFFVRkxTaXhKUVVGSkxFTkJRWEpDU1N4WlFVRlpPMk5CUVVFN1kwRkZOMElzVDBGQlRTeEpRVUZKTEVOQlFVTkRMRmxCUVZrc1EwRkJRMFlzVDBGQlR5eERRVUZETzFsQlFVRTdZMEZEYUVNc1NVRkJTU3hEUVVGRFJ5eHhRa0ZCY1VJc1EwRkJReXhYUVVGWExFVkJRVVZJTEU5QlFVOHNRMEZCUXp0alFVTm9SQ3hKUVVGSlF5eFpRVUZaTEV0QlFVc3NWVUZCVlN4RlFVRkZPMmRDUVVNdlFpeEpRVUZKTEVOQlFVTkZMSEZDUVVGeFFpeERRVUZETEcxQ1FVRnRRaXhGUVVGRlNDeFBRVUZQTEVOQlFVTTdPMk5CUTNwRUxHbERRVVZOTzJkQ1FVRkZSaXhMUVVGTExFVkJRVVU3WTBGQlNTeERRVUZGTzFsQlFVRTdZMEZCUVR0alFVbDRRaXhQUVVGTkxFbEJRVWtzUTBGQlEwMHNhMEpCUVd0Q0xFVkJRVVU3V1VGQlFUdGpRVUZCTEdsRFFVTjRRanRuUWtGQlJVNHNTMEZCU3l4RlFVRkZPMk5CUVVrc1EwRkJSVHRaUVVGQk8yTkJRVUU3WTBGQlFUdGpRVUZCTEV0QlJXeENMSGRDUVVGWExHTkJRVTg3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHbERRVU5pTzJkQ1FVRkZRU3hMUVVGTE8yTkJRVUVzUTBGQlJUdFpRVUZCTzJOQlFVRXNhVU5CUjFnN1owSkJRMHhCTEV0QlFVc3NSVUZCUlN4SlFVRkpUeXg1UWtGQlowSXNRMEZCUXl4M1EwRkJkME03WlVGRGNrVTdXVUZCUVR0alFVRkJPMk5CUlVRc1NVRkJTU3hEUVVGRFF5eDFRa0ZCZFVJc1JVRkJSVHRqUVVGQk8xbEJRVUU3V1VGQlFUdGpRVUZCTzFWQlFVRTdVVUZCUVR0TlFVRkJMRU5CUldwRE96dEpRVVZFT3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVdE5MR2RDUVVGUFF5eFhRVUV3UXpzN096czdPenM3TzJOQlJXNUVMRTlCUVUwc1NVRkJTU3hEUVVGRFVpeGpRVUZqTEVWQlFVVTdXVUZCUVR0alFVRkJMRTFCUjNaQ0xFOUJRVThzU1VGQlNWRXNWMEZCVnp0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlEyaENReXhMUVVGTExFZEJRWGRDUkN4WFFVRlhMRU5CUVhoRFF5eExRVUZMTEVWQlFVVkRMRkZCUVZFc1IwRkJZMFlzVjBGQlZ5eERRVUZxUTBVc1VVRkJVU3hGUVVGRk1VTXNUMEZCVHl4SFFVRkxkME1zVjBGQlZ5eERRVUYyUW5oRExFOUJRVTg3WTBGQlFUdGpRVU14UWl4UFFVRk5MRzlDUVVGUkxFVkJRVU1zU1VGQlNTeERRVUZEVVN4TFFVRkxMRVZCUVVVc1RVRkJUU3haUVVGTExFbEJRVWtzUTBGQlEyaENMRWRCUVVjc1kwRkJWenRuUWtGRE4wUk5MRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU5CTEU5QlFVODdaMEpCUTNKQ05rTXNWVUZCVlN4RlFVRkZNME1zVDBGQlR5eGhRVUZRUVN4UFFVRlBMSFZDUVVGUVFTeFBRVUZQTEVOQlFVVTBReXhsUVVGbE8yZENRVU53UTBNc1NVRkJTU3hGUVVGRk8ydENRVU5LU2l4TFFVRkxMRVZCUVV4QkxFdEJRVXM3YTBKQlEweERMRkZCUVZFc1JVRkJVa0VzVVVGQlVUdHJRa0ZEVWxvc1NVRkJTU3hGUVVGRkxHRkJRVThzWVVGQlVEbENMRTlCUVU4c2RVSkJRVkJCTEU5QlFVOHNRMEZCUlRoQ0xFbEJRVWtzYlVOQlFVa3NSVUZCUlR0clFrRkRla0puUWl4dlFrRkJiMElzUlVGQlJUdHZRa0ZCUlVNc1lVRkJZU3hGUVVGRkwwTXNUMEZCVHl4aFFVRlFRU3hQUVVGUExIVkNRVUZRUVN4UFFVRlBMRU5CUVVWblJEdHJRa0ZCV1R0cFFrRkROMFE3WjBKQlEwUkRMRXRCUVVzc1JVRkJSVU03WlVGRFVpeERRVUZETzFsQlFVRTdZMEZXUmtNc1IwRkJSenRqUVVGQk8yTkJRVUU3V1VGQlFUdGpRVUZCTEUxQlYwMHNUMEZCVHl4SlFVRkpXQ3hYUVVGWE8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkRka0paTEV0QlFVc3NSMEZCZDBKYUxGZEJRVmNzUTBGQmVFTlpMRXRCUVVzc1JVRkJSVllzVTBGQlVTeEhRVUZqUml4WFFVRlhMRU5CUVdwRFJTeFJRVUZSTEVWQlFVVXhReXhSUVVGUExFZEJRVXQzUXl4WFFVRlhMRU5CUVhaQ2VFTXNUMEZCVHp0alFVRkJPMk5CUXpGQ0xFOUJRVTBzYjBKQlFWRXNSVUZCUXl4SlFVRkpMRU5CUVVOUkxFdEJRVXNzUlVGQlJTeE5RVUZOTEZsQlFVc3NTVUZCU1N4RFFVRkRhRUlzUjBGQlJ5eGpRVUZYTzJkQ1FVTTNSRTBzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTBFc1QwRkJUenRuUWtGRGNrSXJReXhKUVVGSkxFVkJRVVU3YTBKQlEwcFBMRXRCUVVzc1JVRkJURUVzUzBGQlN6dHJRa0ZEVEZZc1VVRkJVU3hGUVVGU1FTeFRRVUZSTzJ0Q1FVTlNXaXhKUVVGSkxFVkJRVVVzWTBGQlR5eGhRVUZRT1VJc1VVRkJUeXgxUWtGQlVFRXNVVUZCVHl4RFFVRkZPRUlzU1VGQlNTeHRRMEZCU1N4RlFVRkZPMnRDUVVONlFtZENMRzlDUVVGdlFpeEZRVUZGTzI5Q1FVRkZReXhoUVVGaExFVkJRVVV2UXl4UlFVRlBMR0ZCUVZCQkxGRkJRVThzZFVKQlFWQkJMRkZCUVU4c1EwRkJSV2RFTzJ0Q1FVRlpPMmxDUVVNM1JEdG5Ra0ZEUkVNc1MwRkJTeXhGUVVGRlF6dGxRVU5TTEVOQlFVTTdXVUZCUVR0alFWUkdReXhIUVVGSE8yTkJRVUU3WTBGQlFUdFpRVUZCTzJOQlFVRXNUVUZYUnl4SlFVRkpZaXh2UTBGQk1rSXNRMEZEYmtNc2FVVkJRV2xGTEVOQlEyeEZPMWxCUVVFN1kwRkJRU3hQUVVkeFFtRXNSMEZCUnl4RlFVRnVRbkpDTEVsQlFVa3NVVUZCU2tFc1NVRkJTU3hGUVVGRlF5eExRVUZMTEZGQlFVeEJMRXRCUVVzN1kwRkJRU3hOUVVWbVFTeExRVUZMTEVsQlFVa3NRMEZCUTBRc1NVRkJTVHRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc2EwTkJRMVE3WjBKQlFVVkJMRWxCUVVrc1JVRkJSVHRyUWtGQlJYVkNMRWxCUVVrc1JVRkJSU3hKUVVGSk8ydENRVUZGY0VJc1QwRkJUeXhGUVVGRk8yZENRVUZKTEVOQlFVVTdaMEpCUVVWR0xFdEJRVXNzUlVGQlJVRTdZMEZCU3l4RFFVRkZPMWxCUVVFN1kwRkhlRVJGTEU5QlFVOHNSMEZCYlVKSUxFbEJRVWtzUTBGQlEwY3NUMEZCVHp0alFVTjBRMjlDTEVsQlFVa3NSMEZCWjBKMlFpeEpRVUZKTEVOQlFVTjFRaXhKUVVGSk8yTkJRVUVzUzBGRkwwSjJRaXhKUVVGSkxFTkJRVU5ITEU5QlFVODdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTzJOQlEyUXNUMEZCVFN4SlFVRkpMRU5CUVVORkxGbEJRVmtzUTBGQlEwd3NTVUZCU1N4RFFVRkRSeXhQUVVGUExFTkJRVU03V1VGQlFUdGpRVU55UXl4SlFVRkpMRU5CUVVOSExIRkNRVUZ4UWl4RFFVRkRMRmRCUVZjc1JVRkJSVWdzVDBGQlR5eERRVUZETzFsQlFVRTdZMEZCUVN4clEwRkhNME03WjBKQlFVVklMRWxCUVVrc1JVRkJSVHRyUWtGQlJYVkNMRWxCUVVrc1JVRkJTa0VzU1VGQlNUdHJRa0ZCUlhCQ0xFOUJRVThzUlVGQlVFRTdaMEpCUVU4c1EwRkJSVHRuUWtGQlJVWXNTMEZCU3l4RlFVRkZPMk5CUVVrc1EwRkJSVHRaUVVGQk8yTkJRVUU3WTBGQlFUdGpRVUZCTEV0QlJUTkRMSGRDUVVGWExHVkJRVTg3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHdERRVU5pTzJkQ1FVRkZSQ3hKUVVGSkxFVkJRVVU3YTBKQlFVVjFRaXhKUVVGSkxFVkJRVVVzU1VGQlNUdHJRa0ZCUlhCQ0xFOUJRVThzUlVGQlJUdG5Ra0ZCU1N4RFFVRkZPMmRDUVVGRlJpeExRVUZMTzJOQlFVRXNRMEZCUlR0WlFVRkJPMk5CUVVFN1dVRkJRVHRaUVVGQk8yTkJRVUU3VlVGQlFUdFJRVUZCTzAxQlFVRTdPMGxCVHpORU96czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkhUU3cwUWtGQmJVSlRMRmRCUVRCRE96czdPenM3T3pzN1kwRkZMMFFzVDBGQlRTeEpRVUZKTEVOQlFVTlNMR05CUVdNc1JVRkJSVHRaUVVGQk8yTkJRVUVzVFVGSGRrSXNUMEZCVHl4SlFVRkpVU3hYUVVGWE8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkRhRUpETEV0QlFVc3NSMEZCZDBKRUxGZEJRVmNzUTBGQmVFTkRMRXRCUVVzc1JVRkJSVU1zVVVGQlVTeEhRVUZqUml4WFFVRlhMRU5CUVdwRFJTeFJRVUZSTEVWQlFVVXhReXhQUVVGUExFZEJRVXQzUXl4WFFVRlhMRU5CUVhaQ2VFTXNUMEZCVHp0alFVRkJPMk5CUXpGQ0xFOUJRVTBzYjBKQlFWRXNSVUZCUXl4SlFVRkpMRU5CUVVOUkxFdEJRVXNzUlVGQlJTeE5RVUZOTEZsQlFVc3NTVUZCU1N4RFFVRkRhRUlzUjBGQlJ5eHBRMEZCT0VJN1owSkJRMmhHVFN4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzJkQ1FVTnlRaXRETEVsQlFVa3NSVUZCUlR0clFrRkRTa29zUzBGQlN5eEZRVUZNUVN4TFFVRkxPMnRDUVVOTVF5eFJRVUZSTEVWQlFWSkJMRkZCUVZFN2EwSkJRMUphTEVsQlFVa3NSVUZCUlN4aFFVRlBMR0ZCUVZBNVFpeFBRVUZQTEhWQ1FVRlFRU3hQUVVGUExFTkJRVVU0UWl4SlFVRkpMRzFEUVVGSkxFVkJRVVU3YTBKQlEzcENaMElzYjBKQlFXOUNMRVZCUVVVN2IwSkJRVVZETEdGQlFXRXNSVUZCUlM5RExFOUJRVThzWVVGQlVFRXNUMEZCVHl4MVFrRkJVRUVzVDBGQlR5eERRVUZGWjBRN2EwSkJRVms3YVVKQlF6ZEVPMmRDUVVORVF5eExRVUZMTEVWQlFVVkRPMlZCUTFJc1EwRkJRenRaUVVGQk8yTkJWRVpETEVkQlFVYzdZMEZCUVR0alFVRkJPMWxCUVVFN1kwRkJRU3hOUVZWTkxFOUJRVThzU1VGQlNWZ3NWMEZCVnp0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlEzWkNXU3hMUVVGTExFZEJRWGRDV2l4WFFVRlhMRU5CUVhoRFdTeExRVUZMTEVWQlFVVldMRlZCUVZFc1IwRkJZMFlzVjBGQlZ5eERRVUZxUTBVc1VVRkJVU3hGUVVGRk1VTXNVMEZCVHl4SFFVRkxkME1zVjBGQlZ5eERRVUYyUW5oRExFOUJRVTg3WTBGQlFUdGpRVU14UWl4UFFVRk5MRzlDUVVGUkxFVkJRVU1zU1VGQlNTeERRVUZEVVN4TFFVRkxMRVZCUVVVc1RVRkJUU3haUVVGTExFbEJRVWtzUTBGQlEyaENMRWRCUVVjc2FVTkJRVGhDTzJkQ1FVTm9SazBzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTBFc1QwRkJUenRuUWtGRGNrSXJReXhKUVVGSkxFVkJRVVU3YTBKQlEwcFBMRXRCUVVzc1JVRkJURUVzUzBGQlN6dHJRa0ZEVEZZc1VVRkJVU3hGUVVGU1FTeFZRVUZSTzJ0Q1FVTlNXaXhKUVVGSkxFVkJRVVVzWlVGQlR5eGhRVUZRT1VJc1UwRkJUeXgxUWtGQlVFRXNVMEZCVHl4RFFVRkZPRUlzU1VGQlNTeHRRMEZCU1N4RlFVRkZPMnRDUVVONlFtZENMRzlDUVVGdlFpeEZRVUZGTzI5Q1FVRkZReXhoUVVGaExFVkJRVVV2UXl4VFFVRlBMR0ZCUVZCQkxGTkJRVThzZFVKQlFWQkJMRk5CUVU4c1EwRkJSV2RFTzJ0Q1FVRlpPMmxDUVVNM1JEdG5Ra0ZEUkVNc1MwRkJTeXhGUVVGRlF6dGxRVU5TTEVOQlFVTTdXVUZCUVR0alFWUkdReXhIUVVGSE8yTkJRVUU3WTBGQlFUdFpRVUZCTzJOQlFVRXNUVUZYUnl4SlFVRkpZaXh2UTBGQk1rSXNRMEZEYmtNc2FVVkJRV2xGTEVOQlEyeEZPMWxCUVVFN1kwRkJRU3hSUVVWeFFtRXNSMEZCUnl4RlFVRnVRbkpDTEVsQlFVa3NVMEZCU2tFc1NVRkJTU3hGUVVGRlF5eExRVUZMTEZOQlFVeEJMRXRCUVVzN1kwRkJRU3hOUVVObVFTeExRVUZMTEVsQlFVa3NRMEZCUTBRc1NVRkJTVHRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc2EwTkJRVk03WjBKQlFVVkJMRWxCUVVrc1JVRkJSVHRyUWtGQlJYVkNMRWxCUVVrc1JVRkJSU3hKUVVGSk8ydENRVUZGY0VJc1QwRkJUeXhGUVVGRk8yZENRVUZKTEVOQlFVVTdaMEpCUVVWR0xFdEJRVXNzUlVGQlRFRTdZMEZCU3l4RFFVRkZPMWxCUVVFN1kwRkJRU3hMUVVOeVJVUXNTVUZCU1N4RFFVRkRSeXhQUVVGUE8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRVHRqUVVOa0xFOUJRVTBzU1VGQlNTeERRVUZEUlN4WlFVRlpMRU5CUVVOTUxFbEJRVWtzUTBGQlEwY3NUMEZCVHl4RFFVRkRPMWxCUVVFN1kwRkRja01zU1VGQlNTeERRVUZEUnl4eFFrRkJjVUlzUTBGQlF5eFhRVUZYTEVWQlFVVk9MRWxCUVVrc1EwRkJRMGNzVDBGQlR5eERRVUZETzFsQlFVRTdZMEZCUVN4clEwRkZhRVE3WjBKQlFVVklMRWxCUVVrc1JVRkJTa0VzU1VGQlNUdG5Ra0ZCUlVNc1MwRkJTeXhGUVVGTVFUdGpRVUZMTEVOQlFVVTdXVUZCUVR0alFVRkJPMk5CUVVFN1kwRkJRU3hMUVVWc1FpeDNRa0ZCVnl4bFFVRlBPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVN4clEwRkRZanRuUWtGQlJVUXNTVUZCU1N4RlFVRkZPMnRDUVVGRmRVSXNTVUZCU1N4RlFVRkZMRWxCUVVrN2EwSkJRVVZ3UWl4UFFVRlBMRVZCUVVVN1owSkJRVWtzUTBGQlJUdG5Ra0ZCUlVZc1MwRkJTenRqUVVGQkxFTkJRVVU3V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQk96dEpRVTB6UkRzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlIwMHNlVUpCUVdkQ1V5eFhRVUYxUXpzN096czdPenRqUVVNelJDeFBRVUZOTEVsQlFVa3NRMEZCUTFJc1kwRkJZeXhGUVVGRk8xbEJRVUU3WTBGQlFTeHJRMEZEY0VJc1NVRkJTU3hEUVVGRGMwSXNjVUpCUVhGQ0xFTkJRVU5rTEZkQlFWY3NRMEZCUTJVc1VVRkJVU3hGUVVGRk8yZENRVU4wUkZvc1ZVRkJWU3hGUVVGRkxHbENRVUZYTEVOQlFVTXpReXhQUVVGUExEQkRRVUZGTWtNc1ZVRkJWVHRuUWtGRE0wTmhMRTFCUVUwc1JVRkJSU3hwUWtGQlZ5eERRVUZEZUVRc1QwRkJUeXd3UTBGQlJYZEVMRTFCUVUwN1owSkJRMjVEUXl4WFFVRlhMRVZCUVVVc2FVSkJRVmNzUTBGQlEzcEVMRTlCUVU4c01FTkJRVVY1UkR0bFFVTnVReXhEUVVGRE8xbEJRVUU3V1VGQlFUdGpRVUZCTzFWQlFVRTdVVUZCUVR0TlFVRkJPenRKUVVkS096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZOVFN4MVFrRkJZMnBDTEZkQlFUaERPenM3T3pzN096czdZMEZGT1VRc1QwRkJUU3hKUVVGSkxFTkJRVU5TTEdOQlFXTXNSVUZCUlR0WlFVRkJPMk5CUVVFc1RVRkZka0lzVDBGQlR5eEpRVUZKVVN4WFFVRlhPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZEYUVKRExFdEJRVXNzUjBGQlkwUXNWMEZCVnl4RFFVRTVRa01zUzBGQlN5eEZRVUZGZWtNc1QwRkJUeXhIUVVGTGQwTXNWMEZCVnl4RFFVRjJRbmhETEU5QlFVODdZMEZCUVR0alFVTktMRTlCUVUwc2IwSkJRVkVzUlVGQlF5eEpRVUZKTEVOQlFVTlJMRXRCUVVzc1JVRkJSU3hOUVVGTkxGbEJRVXNzU1VGQlNTeERRVUZEYUVJc1IwRkJSeXhYUVVGUk8yZENRVU4wUlUwc1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlEwRXNUMEZCVHp0blFrRkRja0lyUXl4SlFVRkpMRVZCUVVVN2EwSkJRMHBLTEV0QlFVc3NSVUZCVEVFc1MwRkJTenRyUWtGRFRGZ3NTVUZCU1N4RlFVRkZMR0ZCUVU4c1lVRkJVRGxDTEU5QlFVOHNkVUpCUVZCQkxFOUJRVThzUTBGQlJUaENMRWxCUVVrc2JVTkJRVWtzUlVGQlJUdHJRa0ZEZWtJMFFpeFhRVUZYTEVWQlFVVXNZVUZCVHl4aFFVRlFNVVFzVDBGQlR5eDFRa0ZCVUVFc1QwRkJUeXhEUVVGRk1rUXNaMEpCUVdkQ0xHMURRVUZKTEVsQlFVazdhMEpCUXpsRFlpeHZRa0ZCYjBJc1JVRkJSVHR2UWtGQlJVTXNZVUZCWVN4RlFVRkZMME1zVDBGQlR5eGhRVUZRUVN4UFFVRlBMSFZDUVVGUVFTeFBRVUZQTEVOQlFVVm5SRHRyUWtGQldUdHBRa0ZETjBRN1owSkJRMFJNTEZWQlFWVXNSVUZCUlRORExFOUJRVThzWVVGQlVFRXNUMEZCVHl4MVFrRkJVRUVzVDBGQlR5eERRVUZGTkVNN1pVRkRkRUlzUTBGQlF6dFpRVUZCTzJOQlFVRTdZMEZVVFdJc1MwRkJTeXhWUVVGTVFTeExRVUZMTzJOQlFVRXNhME5CVlU0N1owSkJRVVZFTEVsQlFVa3NSVUZCUlR0clFrRkJSWFZDTEVsQlFVa3NSVUZCUlN4SlFVRkpPMnRDUVVGRmNFSXNUMEZCVHl4RlFVRkZPMmRDUVVGSkxFTkJRVVU3WjBKQlFVVkdMRXRCUVVzc1JVRkJURUU3WTBGQlN5eERRVUZGTzFsQlFVRTdZMEZCUVN4TlFVVnVSQ3hQUVVGUExFbEJRVWxUTEZkQlFWYzdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVU5vUWxrc1MwRkJTeXhIUVVGaldpeFhRVUZYTEVOQlFUbENXU3hMUVVGTExFVkJRVVZ3UkN4VFFVRlBMRWRCUVV0M1F5eFhRVUZYTEVOQlFYWkNlRU1zVDBGQlR6dGpRVUZCTzJOQlEwb3NUMEZCVFN4dlFrRkJVU3hGUVVGRExFbEJRVWtzUTBGQlExRXNTMEZCU3l4RlFVRkZMRTFCUVUwc1dVRkJTeXhKUVVGSkxFTkJRVU5vUWl4SFFVRkhMRmRCUVZFN1owSkJRM1JGVFN4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzJkQ1FVTnlRaXRETEVsQlFVa3NSVUZCUlR0clFrRkRTazhzUzBGQlN5eEZRVUZNUVN4TFFVRkxPMnRDUVVOTWRFSXNTVUZCU1N4RlFVRkZMR1ZCUVU4c1lVRkJVRGxDTEZOQlFVOHNkVUpCUVZCQkxGTkJRVThzUTBGQlJUaENMRWxCUVVrc2JVTkJRVWtzUlVGQlJUdHJRa0ZEZWtJMFFpeFhRVUZYTEVWQlFVVXNaVUZCVHl4aFFVRlFNVVFzVTBGQlR5eDFRa0ZCVUVFc1UwRkJUeXhEUVVGRk1rUXNaMEpCUVdkQ0xHMURRVUZKTEVsQlFVazdhMEpCUXpsRFlpeHZRa0ZCYjBJc1JVRkJSVHR2UWtGQlJVTXNZVUZCWVN4RlFVRkZMME1zVTBGQlR5eGhRVUZRUVN4VFFVRlBMSFZDUVVGUVFTeFRRVUZQTEVOQlFVVm5SRHRyUWtGQldUczdaVUZGTDBRc1EwRkJRenRaUVVGQk8yTkJRVUU3WTBGU1RXcENMRTFCUVVzc1YwRkJURUVzUzBGQlN6dGpRVUZCTEd0RFFWTk9PMmRDUVVGRlJDeEpRVUZKTEVWQlFVVTdhMEpCUVVWMVFpeEpRVUZKTEVWQlFVVXNTVUZCU1R0clFrRkJSWEJDTEU5QlFVOHNSVUZCUlR0blFrRkJTU3hEUVVGRk8yZENRVUZGUml4TFFVRkxMRVZCUVV4Qk8yTkJRVXNzUTBGQlJUdFpRVUZCTzJOQlFVRXNUVUZGYWtRc1NVRkJTVThzYjBOQlFUSkNMRU5CUVVNc2JVUkJRVzFFTEVOQlFVTTdXVUZCUVR0alFVRkJPMk5CUVVFN1kwRkJRU3hMUVVWMFJpeDNRa0ZCVnl4bFFVRlBPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVN4clEwRkRZanRuUWtGQlJWSXNTVUZCU1N4RlFVRkZPMnRDUVVGRmRVSXNTVUZCU1N4RlFVRkZMRWxCUVVrN2EwSkJRVVZ3UWl4UFFVRlBMRVZCUVVVN1owSkJRVWtzUTBGQlJUdG5Ra0ZCUlVZc1MwRkJTenRqUVVGQkxFTkJRVVU3V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQk96dEpRVTh6UkRzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlIwMHNiVUpCUVZVMlFpeE5RVUYxUWpzN096czdPenM3TzJOQlJXNURMRTlCUVUwc1NVRkJTU3hEUVVGRE5VSXNZMEZCWXl4RlFVRkZPMWxCUVVFN1kwRkJRVHRqUVVWSUxFOUJRVTBzYjBKQlFWRXNSVUZCUXl4SlFVRkpMRU5CUVVONFFpeExRVUZMTEVWQlFVVXNUVUZCVFN4WlFVRkxMRWxCUVVrc1EwRkJRMmhDTEVkQlFVY3NZMEZCVnp0blFrRkRMMFZOTEU5QlFVOHNSVUZCUlN4SlFVRkpMRU5CUVVOQkxFOUJRVTg3WjBKQlEzSkNLME1zU1VGQlNTeHJRMEZEUTJVc1RVRkJUVHRyUWtGRFZHUXNiMEpCUVc5Q0xFVkJRVVU3YjBKQlFVVkRMR0ZCUVdFc1JVRkJSU3haUVVGTkxFTkJRVU12UXl4UFFVRlBMREJEUVVGRlowUTdhMEpCUVZrN1owSkJRVVVzUlVGRGRFVTdaMEpCUTBSTUxGVkJRVlVzUlVGQlJTeFpRVUZOTEVOQlFVTXpReXhQUVVGUExEQkRRVUZGTWtNc1ZVRkJWVHRuUWtGRGRFTk5MRXRCUVVzc1JVRkJSVU03WlVGRFVpeERRVUZETzFsQlFVRTdZMEZCUVR0alFWSk5jRUlzU1VGQlNTeFhRVUZLUVN4SlFVRkpPMk5CUVVWRExFdEJRVXNzVjBGQlRFRXNTMEZCU3p0alFVRkJMRXRCVldaQkxFdEJRVXM3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxFMUJRMFJCTEV0QlFVczdXVUZCUVR0alFVRkJMRWxCUjFKRUxFbEJRVWs3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxFMUJRMFFzTUVOQlFUQkRPMWxCUVVFN1kwRkhOVU5ITEU5QlFVOHNSMEZCYlVKSUxFbEJRVWtzUTBGQlEwY3NUMEZCVHp0alFVTjBRMjlDTEVsQlFVa3NSMEZCVTNaQ0xFbEJRVWtzUTBGQlEzVkNMRWxCUVVrN1kwRkJRU3hOUVVWNFFuQkNMRTlCUVU4c1lVRkJVRUVzVDBGQlR5eDFRa0ZCVUVFc1QwRkJUeXhEUVVGRk5FSXNXVUZCV1R0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRTdZMEZEZGtJc1QwRkJUU3hKUVVGSkxFTkJRVU14UWl4WlFVRlpMRU5CUVVOR0xFOUJRV3RDTEVOQlFVTTdXVUZCUVR0alFVTXpReXhKUVVGSkxFTkJRVU5ITEhGQ1FVRnhRaXhEUVVGRExGZEJRVmNzUlVGQlJVZ3NUMEZCVHl4RFFVRkRPMWxCUVVFN1kwRkJRU3hyUTBGSE0wTTdaMEpCUVVWSUxFbEJRVWtzUlVGQlJUdHJRa0ZCUlhWQ0xFbEJRVWtzUlVGQlNrRXNTVUZCU1R0clFrRkJSWEJDTEU5QlFVOHNSVUZCVUVFN1owSkJRVThzUTBGQlJUdG5Ra0ZCUlVZc1MwRkJTeXhGUVVGRk8yTkJRVWtzUTBGQlJUdFpRVUZCTzJOQlFVRTdZMEZCUVR0alFVRkJMRXRCUlRORExIZENRVUZYTEdWQlFVODdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEd0RFFVTmlPMmRDUVVGRlJDeEpRVUZKTEVWQlFVVTdhMEpCUVVWMVFpeEpRVUZKTEVWQlFVVXNTVUZCU1R0clFrRkJSWEJDTEU5QlFVOHNSVUZCUlR0blFrRkJTU3hEUVVGRk8yZENRVUZGUml4TFFVRkxPMk5CUVVFc1EwRkJSVHRaUVVGQk8yTkJRVUU3V1VGQlFUdFpRVUZCTzJOQlFVRTdWVUZCUVR0UlFVRkJPMDFCUVVFN08wbEJUek5FT3pzN096czdPenM3T3pzN096czdPenM3TzBWQlFVRTdTVUZCUVR0SlFVRkJMRTlCYlVKTkxIVkNRVUZqTmtJc1RVRkJjVUk3T3pzN096czdPMk5CUlhKRExFOUJRVTBzU1VGQlNTeERRVUZETlVJc1kwRkJZeXhGUVVGRk8xbEJRVUU3WTBGQlFUdGpRVVZ3UWl4UFFVRk5MRzlDUVVGUkxFVkJRVU1zU1VGQlNTeERRVUZEZUVJc1MwRkJTeXhGUVVGRkxFMUJRVTBzV1VGQlN5eEpRVUZKTEVOQlFVTm9RaXhIUVVGSExGZEJRVkU3WjBKQlF6TkVjVVFzU1VGQlNTdzBSVUZEUlN4WlFVRlpMRWxCUVVsbExFMUJRVTBzUjBGQlJ6dHJRa0ZCUlVVc1YwRkJWeXhGUVVGRlJpeE5RVUZOTEVOQlFVTkhPMmRDUVVGVkxFTkJRVVVzUjBGQlJ5eEpRVUZKTEVOQlFVTXNSVUZEYmtVc1VVRkJVU3hKUVVGSlNDeE5RVUZOTEVkQlFVYzdhMEpCUVVWSkxFMUJRVTBzUlVGQlJVb3NUVUZCVFN4RFFVRkRTVHRuUWtGQlRTeERRVUZGTEVkQlFVY3NTVUZCU1N4RFFVRkRPMnRDUVVNeFJFTXNWMEZCVnl4RlFVRkZMR3RDUVVGTkxFTkJRVU5xUlN4UFFVRlBMREJEUVVGRk1rTXNWVUZCVlN4dFEwRkJTWFZDTzJkQ1FVRlRMRWxCUTJoRUxHRkJRVTBzWVVGQlRrNHNUVUZCVFN4MVFrRkJUa0VzVFVGQlRTeERRVUZGTlVRc1QwRkJUeXd3UTBGQlJXZEVMRmxCUVZrc1NVRkROMEk3YTBKQlFVVkdMRzlDUVVGdlFpeEZRVUZGTzI5Q1FVRkZReXhoUVVGaExFVkJRVVZoTEUxQlFVMHNRMEZCUXpWRUxFOUJRVThzUTBGQlEyZEVPMnRDUVVGWk8yZENRVUZGTEVOQlFVVXNSMEZEZUVVc1NVRkJTU3hEUVVGRE8ydENRVU5VYlVJc2EwSkJRV3RDTEVWQlFVVTdaMEpCUVVrc1JVRkRla0k3WjBKQlEwUnlSU3hQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZEUVN4UFFVRlBPMmRDUVVOeVFtMUVMRXRCUVVzc1JVRkJSVU03WlVGRFVpeERRVUZETzFsQlFVRTdZMEZCUVR0WlFVRkJPMk5CUVVFN1kwRkJRVHRqUVVGQkxFdEJSVVVzZDBKQlFWY3NaVUZCVHp0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRXNhME5CUTJJN1owSkJRVVZ3UWl4SlFVRkpMRVZCUVVVc1NVRkJTVHRuUWtGQlJVTXNTMEZCU3p0alFVRkJMRU5CUVVVN1dVRkJRVHRqUVVGQk8xbEJRVUU3V1VGQlFUdGpRVUZCTzFWQlFVRTdVVUZCUVR0TlFVRkJPenRKUVUxc1F6czdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVWxOTEhOQ1FVRlZPenM3T3pzN08yTkJjMEprTEU5QlFVMHNTVUZCU1N4RFFVRkRUQ3hwUWtGQmFVSTdXVUZCUVR0alFVVjRRakJETEdOQlFXTXNSMEZCYlVJc1NVRkJTVHRqUVVGQkxFdEJSWEpETEVsQlFVa3NRMEZCUTNoRkxHTkJRV003WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQk8yTkJRMEVzVDBGQlRTd3dRa0ZCV1N4RlFVRkRMRWxCUVVrc1EwRkJRMUVzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTFZc1ZVRkJWU3hEUVVGRE8xbEJRVUU3WTBGQmFFVXlSU3haUVVGWk8yTkJRVUVzVFVGRlpFRXNXVUZCV1N4TFFVRkxMRWxCUVVrN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMRXRCUTI1Q0xFbEJRVWtzUTBGQlEwTXNaVUZCWlN4RFFVRkRSQ3haUVVGWkxFTkJRVU03WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVOd1EwUXNZMEZCWXl4SFFVRkhReXhaUVVGWk8yTkJRVUU3WTBGQlFUdFpRVUZCTzJOQlFVRTdZMEZGTjBJc1QwRkJUU3hKUVVGSkxFTkJRVU55UXl4alFVRmpMRVZCUVVVN1dVRkJRVHRqUVVGQk8yTkJRVUU3V1VGQlFUdGpRVWt2UW05RExHTkJRV01zUjBGQlJ5eEpRVUZKTEVOQlFVTnFSU3hsUVVGbE8xbEJRVUU3WTBGQlFTeEpRVWRzUTJsRkxHTkJRV003WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHdERRVU5XTzJkQ1FVRkZkRU1zU1VGQlNTeEZRVUZGTzJ0Q1FVRkZSeXhQUVVGUExFVkJRVVU3WjBKQlFVa3NRMEZCUlR0blFrRkJSVVlzUzBGQlN5eEZRVUZGTzJOQlFVa3NRMEZCUlR0WlFVRkJPMk5CUnpORGQwTXNWVUZCVlN4SFFVRkhTQ3hqUVVGakxFTkJRVU5KTEZWQlFWVXNSMEZEZUVOS0xHTkJRV01zUTBGQlEwa3NWVUZCVlN4SlFVRkpReXhKUVVGSkxFTkJRVU5ETEVkQlFVY3NSVUZCUlN4SFFVRkhMRWxCUVVrc1IwRkRPVU1zUzBGQlN6dGpRVUZCTEVsQlEwcElMRlZCUVZVN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMR3REUVVOT08yZENRVUZGZWtNc1NVRkJTU3hGUVVGRk8ydENRVUZGUnl4UFFVRlBMRVZCUVVWdFF6dG5Ra0ZCWXl4RFFVRkZPMmRDUVVGRmNrTXNTMEZCU3l4RlFVRkZPMk5CUVVrc1EwRkJSVHRaUVVGQk8yTkJRVUU3WTBGSGFFTXNUMEZCVFN4SlFVRkpMRU5CUVVNMFF5eHBRa0ZCYVVJc1EwRkJRMUFzWTBGQll5eERRVUZEVVN4aFFVRmhMRU5CUVVNN1dVRkJRVHRqUVVGQk8yTkJRVGRGTTBNc1QwRkJUeXg1UWtGQlVFRXNUMEZCVHp0alFVRkZSaXhMUVVGTExIbENRVUZNUVN4TFFVRkxPMk5CUVVFc1MwRkRiRUpCTEV0QlFVczdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEd0RFFVTkJPMmRDUVVGRlJDeEpRVUZKTEVWQlFVVTdhMEpCUVVWSExFOUJRVThzUlVGQlJUdG5Ra0ZCU1N4RFFVRkZPMmRDUVVGRlJpeExRVUZMTEVWQlFVeEJPMk5CUVVzc1EwRkJSVHRaUVVGQk8yTkJRVUVzYTBOQlIzQkRPMmRDUVVGRlJDeEpRVUZKTEVWQlFVVTdhMEpCUVVWSExFOUJRVThzUlVGQlVFRTdaMEpCUVU4c1EwRkJSVHRuUWtGQlJVWXNTMEZCU3l4RlFVRkZPMk5CUVVrc1EwRkJSVHRaUVVGQk8xbEJRVUU3WTBGQlFUdFZRVUZCTzFGQlFVRTdUVUZCUVN4RFFVTXhRenM3U1VGRlJEczdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVWxOTEdsQ1FVRlJPRU1zUjBGQldUczdPenM3T3pzN2EwSkJSV3BDUVN4SFFVRkhPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVR0alFVTnJRaXhQUVVGTkxFbEJRVWtzUTBGQlEwTXNWVUZCVlN4RlFVRkZPMWxCUVVFN1kwRkJRVHRqUVVGMlEyaEVMRWxCUVVrc2VVSkJRVXBCTEVsQlFVazdZMEZCUlVNc1MwRkJTeXg1UWtGQlRFRXNTMEZCU3p0alFVRkJMRXRCUTJaQkxFdEJRVXM3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxFMUJRMFJCTEV0QlFVczdXVUZCUVR0alFVZGlPMk5CUTBFNFF5eEhRVUZITEVkQlFVY3NaMEpCUVVrc1EwRkJRelZETEU5QlFVOHNNRU5CUVVVMFFpeFpRVUZaTEcxRFFVRkpTeXhUUVVGVE8xbEJRVUU3WTBGQlFUdGpRVWQ0UXl4UFFVRk5MRzlDUVVGUkxFVkJRVU1zU1VGQlNTeERRVUZETVVRc1MwRkJTeXhGUVVGRkxFdEJRVXNzV1VGQlN5eEpRVUZKTEVOQlFVTm9RaXhIUVVGSExGbEJRVk03WjBKQlF6TkVUU3hQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZEUVN4UFFVRlBPMmRDUVVOeVFpdEZMRWRCUVVjc1JVRkJSVUVzUjBGQlJ6dG5Ra0ZEVWpWQ0xFdEJRVXNzUlVGQlJVTTdaVUZEVWl4RFFVRkRPMWxCUVVFN1kwRkJRVHRaUVVGQk8yTkJRVUU3WTBGQlFUdGpRVUZCTEV0QlJVVXNkMEpCUVZjc1pVRkJUenRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc2EwTkJRMkk3WjBKQlFVVndRaXhKUVVGSkxFVkJRVVU3YTBKQlFVVjFRaXhKUVVGSkxFVkJRVVU3WjBKQlFVa3NRMEZCUlR0blFrRkJSWFJDTEV0QlFVczdZMEZCUVN4RFFVRkZPMWxCUVVFN1kwRkJRVHRaUVVGQk8xbEJRVUU3WTBGQlFUdFZRVUZCTzFGQlFVRTdUVUZCUVRzN1NVRlBOVU03T3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVVkTkxHOUNRVUZYWjBRc1ZVRkJNRUk3T3pzN096czdPMk5CUlZrc1QwRkJUU3hKUVVGSkxFTkJRVU5FTEZWQlFWVXNSVUZCUlR0WlFVRkJPMk5CUVVFN1kwRkJOVVJGTEZkQlFWY3NNRUpCUVdwQ2JFUXNTVUZCU1R0alFVRnpRbTFFTEZsQlFWa3NNRUpCUVc1Q2JFUXNTMEZCU3p0alFVRkJMRXRCUXpWQ2EwUXNXVUZCV1R0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRXNUVUZEVWtFc1dVRkJXVHRaUVVGQk8yTkJRVUVzU1VGRlprUXNWMEZCVnl4RFFVRkRMME1zVDBGQlR6dG5Ra0ZCUVR0blFrRkJRVHRqUVVGQk8yTkJRVUVzVFVGRGFFSXNTVUZCU1Vzc1owTkJRWFZDTEVWQlFVVTdXVUZCUVR0alFVVXZRa3dzVDBGQlR5eEhRVUZaSzBNc1YwRkJWeXhEUVVGREwwTXNUMEZCVHp0alFVRkJPMk5CUTFRc1QwRkJUU3h2UWtGQlVTeEZRVUZETEVsQlFVa3NRMEZCUTNwQ0xFdEJRVXNzUlVGQlJTeExRVUZMTEZsQlFVc3NTVUZCU1N4RFFVRkRhRUlzUjBGQlJ5eFpRVUZUTzJkQ1FVTjJSazBzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTBFc1QwRkJUenRuUWtGRGNrSXJReXhKUVVGSkxFVkJRVVZyUXl4VlFVRlZPMmRDUVVOb1FrWXNSMEZCUnl4RlFVRkZOVU1zVDBGQlR5eERRVUZETkVJc1dVRkJXVHRuUWtGRGVrSmFMRXRCUVVzc1JVRkJSVU03WlVGRFVpeERRVUZETzFsQlFVRTdZMEZCUVR0alFVeE5jRUlzU1VGQlNTeFhRVUZLUVN4SlFVRkpPMk5CUVZOdlJDeFRRVUZUTEZkQlFXaENia1FzUzBGQlN6dGpRVUZCTEV0QlRXWnRSQ3hUUVVGVE8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3hOUVVGUlFTeFRRVUZUTzFsQlFVRTdZMEZET1VKcVJDeFBRVUZQTEVOQlFVTnZRaXhKUVVGSkxFZEJRVWQyUWl4SlFVRkpMRU5CUVVOMVFpeEpRVUZaTzJOQlFVRTdZMEZEYUVNc1QwRkJUU3hKUVVGSkxFTkJRVU5zUWl4WlFVRlpMRU5CUVVOR0xFOUJRVThzUTBGQlF6dFpRVUZCTzJOQlEyaERMRWxCUVVrc1EwRkJRMGNzY1VKQlFYRkNMRU5CUVVNc1kwRkJZeXhGUVVGRlNDeFBRVUZQTEVOQlFVTTdZMEZCUVN4dFEwRkZOVU03WjBKQlFVVklMRWxCUVVrc1JVRkJSVHRyUWtGQlJYVkNMRWxCUVVrc1JVRkJSWEJDTEU5QlFVOHNRMEZCUTI5Q08yZENRVUZKTEVOQlFVVTdaMEpCUVVWMFFpeExRVUZMTEVWQlFVVTdZMEZCU1N4RFFVRkZPMWxCUVVFN1kwRkJRVHRqUVVGQk8yTkJRVUVzUzBGRmFFUXNkMEpCUVZjc1owSkJRVTg3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHMURRVU5pTzJkQ1FVRkZSQ3hKUVVGSkxFVkJRVVU3YTBKQlFVVjFRaXhKUVVGSkxFVkJRVVU3WjBKQlFVa3NRMEZCUlR0blFrRkJSWFJDTEV0QlFVczdZMEZCUVN4RFFVRkZPMWxCUVVFN1kwRkJRVHRaUVVGQk8xbEJRVUU3WTBGQlFUdFZRVUZCTzFGQlFVRTdUVUZCUVN4RFFVc3pRenM3U1VGRlJEczdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJSMUVzYjBKQlFWYzRReXhIUVVGWE8wMUJTelZDTEU5QlFVOHNPRUpCUVdkQ0xFVkJRVU5CTEVkQlFVY3NRMEZCUXp0SlFVTTVRanRKUVVWQk96czdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVXROTEc5Q1FVRlhWQ3hqUVVkb1FqczdPenM3T3p0dlFrRkZUeXhEUVVGRFFTeGpRVUZqTEVOQlFVTlFMRmxCUVZrc1NVRkJTU3hEUVVGRFR5eGpRVUZqTEVOQlFVTlJMR0ZCUVdFN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMRTFCUTNwRUxFbEJRVWwwUXl4blEwRkJkVUlzUlVGQlJUdFpRVUZCTzJOQlJ5OUNOa01zVDBGQlR5eEhRVUZIVml4SlFVRkpMRU5CUVVORExFZEJRVWNzUlVGQlJTeEhRVUZITEVsQlFVazdZMEZETjBKVkxGTkJRVk1zUjBGQlIwUXNUMEZCVHp0alFVTnVRbG9zVlVGQlZTeEhRVUZITEVsQlFVazdZMEZEYWtKMFF5eFBRVUZQTEVkQlFXMUNMRWxCUVVrN1kwRkROVUp2UkN4UFFVRlBMRWRCUVVjc09FSkJRV2RDTEVWQlFVTnFRaXhqUVVGakxFTkJRVU5RTEZsQlFWa3NRMEZCUXp0alFVTTNSQ3hKUVVGSmQwSXNUMEZCVHl4RFFVRkRReXhIUVVGSExFVkJRVVU3WjBKQlEyWkdMRk5CUVZNc1IwRkJSME1zVDBGQlR5eERRVUZEUXl4SFFVRkhPMmRDUVVOMlFtWXNWVUZCVlN4SFFVRkhZU3hUUVVGVExFbEJRVWxFTEU5QlFVODdPMk5CUTJ4RExFdEJSVWRhTEZWQlFWVTdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTzJOQlEybERMRTlCUVUwc1NVRkJTU3hEUVVGRFNTeHBRa0ZCYVVJc1EwRkRka1ZRTEdOQlFXTXNRMEZCUTFFc1lVRkJZU3hEUVVNM1FqdFpRVUZCTzJOQlFVRTdZMEZHWjBKWExHZENRVUZuUWl3d1FrRkJla0owUkN4UFFVRlBPMk5CUVc5Q1JpeExRVUZMTERCQ1FVRk1RU3hMUVVGTE8yTkJRVUVzUzBGSGNFTkJMRXRCUVVzN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMRzFEUVVOQk8yZENRVUZGUkN4SlFVRkpMRVZCUVVVN2EwSkJRVVYxUWl4SlFVRkpMRVZCUVVVc1NVRkJTVHRyUWtGQlJYQkNMRTlCUVU4c1JVRkJSVHRuUWtGQlNTeERRVUZGTzJkQ1FVRkZSaXhMUVVGTExFVkJRVVZCTzJOQlFVc3NRMEZCUlR0WlFVRkJPMk5CUVVFc1NVRkhla1IzUkN4blFrRkJaMEk3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHMURRVU5hTzJkQ1FVRkZla1FzU1VGQlNTeEZRVUZGTzJ0Q1FVRkZkVUlzU1VGQlNTeEZRVUZGTEVsQlFVazdhMEpCUVVWd1FpeFBRVUZQTEVWQlFVVTdaMEpCUVVrc1EwRkJSVHRuUWtGQlJVWXNTMEZCU3l4RlFVRkZPMk5CUVVrc1EwRkJSVHRaUVVGQk8yTkJSVGRFUlN4UFFVRlBMRWRCUVVkelJDeG5Ra0ZCWjBJN1kwRkJRVHRqUVVGQk8xbEJRVUU3WTBGQlFUdGpRVVZHTEU5QlFVMHNTVUZCU1N4RFFVRkRReXhQUVVGUExFTkJRVU53UWl4alFVRmpMRU5CUVVOUUxGbEJRVmtzUTBGQlF6dFpRVUZCTzJOQlFVRTdZMEZCTDBRdlFpeEpRVUZKTEhWQ1FVRktRU3hKUVVGSk8yTkJRVVZETEU5QlFVc3NkVUpCUVV4QkxFdEJRVXM3WTBGQlFTeExRVU5tUVN4UFFVRkxPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVN4TlFVTkVRU3hQUVVGTE8xbEJRVUU3WTBGRllrVXNUMEZCVHl4SFFVRkhPMmRDUVVOU05FSXNXVUZCV1N4RlFVRkZUeXhqUVVGakxFTkJRVU5RTEZsQlFWazdaMEpCUTNwRFpTeGhRVUZoTEVWQlFVVlNMR05CUVdNc1EwRkJRMUVzWVVGQllUdG5Ra0ZETTBOMlFpeEpRVUZKTEVWQlFVVjJRaXhKUVVGSkxFTkJRVU4xUWl4SlFVRkpPMmRDUVVObWIwTXNWVUZCVlN4RlFVRkZMRkZCUVZFN1owSkJRM0JDUXl4VlFVRlZMRVZCUVVWT0xGTkJRVk1zUjBGQlIwUXNUMEZCVHp0blFrRkRMMEpZTEZWQlFWVXNSVUZCUlZrN1pVRkRZanRqUVVGQk8yTkJRMFFzVDBGQlRTeEpRVUZKTEVOQlFVTnFSQ3haUVVGWkxFTkJRVU5HTEU5QlFVOHNRMEZCUXp0WlFVRkJPMk5CUVVFc2JVTkJSek5DTzJkQ1FVRkZTQ3hKUVVGSkxFVkJRVVU3YTBKQlFVVjFRaXhKUVVGSkxFVkJRVVZ3UWl4UFFVRlBMRU5CUVVOdlFpeEpRVUZKTzJ0Q1FVRkZjRUlzVDBGQlR5eEZRVUZRUVR0blFrRkJUeXhEUVVGRk8yZENRVUZGUml4TFFVRkxMRVZCUVVVN1kwRkJTU3hEUVVGRk8xbEJRVUU3WTBGQlFUdGpRVUZCTzJOQlFVRXNTMEZGZWtRc2QwSkJRVmNzWjBKQlFVODdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEcxRFFVTmlPMmRDUVVGRlJDeEpRVUZKTEVWQlFVVTdhMEpCUVVWSExFOUJRVThzUlVGQlJTeEpRVUZKTzJ0Q1FVRkZiMElzU1VGQlNTeEZRVUZGTzJkQ1FVRkpMRU5CUVVVN1owSkJRVVYwUWl4TFFVRkxPMk5CUVVFc1EwRkJSVHRaUVVGQk8yTkJRVUU3V1VGQlFUdFpRVUZCTzJOQlFVRTdWVUZCUVR0UlFVRkJPMDFCUVVFc1EwRkxNVVE3TzBsQlJVUTdPenM3T3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVUxTkxIZENRVUZsY1VNc1kwRkJNRU03T3pzN096czdPMnRDUVVWMFJFRXNZMEZCWXp0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRTdZMEZEVHl4UFFVRk5MRWxCUVVrc1EwRkJRMVVzVlVGQlZTeEZRVUZGTzFsQlFVRTdZMEZCUVR0alFVRjJRMmhFTEVsQlFVa3NNRUpCUVVwQkxFbEJRVWs3WTBGQlJVTXNUMEZCU3l3d1FrRkJURUVzUzBGQlN6dGpRVUZCTEV0QlEyWkJMRTlCUVVzN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMRTFCUTBSQkxFOUJRVXM3V1VGQlFUdGpRVWRpY1VNc1kwRkJZeXhIUVVGSExGVkJRVWtzUTBGQlEyNURMRTlCUVU4c2JVTkJRVWxwUXl4VFFVRlRPMWxCUVVFN1kwRkJRU3hKUVVkMlEwVXNZMEZCWXl4aFFVRmtRU3hqUVVGakxIVkNRVUZrUVN4alFVRmpMRU5CUVVWUkxHRkJRV0U3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxFMUJRekZDTEVsQlFVbDBReXhuUTBGQmRVSXNSVUZCUlR0WlFVRkJPMk5CUVVFN1kwRkhWaXhQUVVGTkxFbEJRVWtzUTBGQlEzRkRMR2xDUVVGcFFpeERRVUZEVUN4alFVRmpMRU5CUVVOUkxHRkJRV0VzUTBGQlF6dFpRVUZCTzJOQlFVRTdZMEZCTjBVelF5eFBRVUZQTERCQ1FVRlFRU3hQUVVGUE8yTkJRVVZHTEV0QlFVc3NNRUpCUVV4QkxFdEJRVXM3WTBGQlFTeExRVU5zUWtFc1MwRkJTenRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc2JVTkJRMEU3WjBKQlFVVkVMRWxCUVVrc1JVRkJSVHRyUWtGQlJYVkNMRWxCUVVrc1JVRkJSU3hKUVVGSk8ydENRVUZGY0VJc1QwRkJUeXhGUVVGRk8yZENRVUZKTEVOQlFVVTdaMEpCUVVWR0xFdEJRVXNzUlVGQlJVRTdZMEZCU3l4RFFVRkZPMWxCUVVFN1kwRkJRU3hKUVVkNlJFVXNUMEZCVHp0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRXNiVU5CUTBnN1owSkJRVVZJTEVsQlFVa3NSVUZCUlR0clFrRkJSWFZDTEVsQlFVa3NSVUZCUlN4SlFVRkpPMnRDUVVGRmNFSXNUMEZCVHl4RlFVRkZPMmRDUVVGSkxFTkJRVVU3WjBKQlFVVkdMRXRCUVVzc1JVRkJSVHRqUVVGSkxFTkJRVVU3V1VGQlFUdGpRVUZCTEcxRFFVZDBSRHRuUWtGQlJVUXNTVUZCU1N4RlFVRkZPMnRDUVVGRmRVSXNTVUZCU1N4RlFVRkZjRUlzVDBGQlR5eERRVUZEYjBJc1NVRkJTVHRyUWtGQlJYQkNMRTlCUVU4c1JVRkJVRUU3WjBKQlFVOHNRMEZCUlR0blFrRkJSVVlzUzBGQlN5eEZRVUZGTzJOQlFVa3NRMEZCUlR0WlFVRkJPMk5CUVVFN1kwRkJRVHRqUVVGQkxFdEJSWHBFTEhkQ1FVRlhMR2RDUVVGUE8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3h0UTBGRFlqdG5Ra0ZCUlVRc1NVRkJTU3hGUVVGRk8ydENRVUZGZFVJc1NVRkJTU3hGUVVGRkxFbEJRVWs3YTBKQlFVVndRaXhQUVVGUExFVkJRVVU3WjBKQlFVa3NRMEZCUlR0blFrRkJSVVlzUzBGQlN6dGpRVUZCTEVOQlFVVTdXVUZCUVR0alFVRkJPMWxCUVVFN1dVRkJRVHRqUVVGQk8xVkJRVUU3VVVGQlFUdE5RVUZCT3p0SlFVOHpSRHM3TzBWQlFVRTdTVUZCUVR0SlFVRkJMRTlCUjJNc09FSkJRV3RDT3pzN096czdPMnRDUVZGMlFpeDFRa0ZCVXl4SFFVRkZPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVN4TlFVRlJMRWxCUVVsUExIVkRRVUU0UWl4RFFVRkRMSE5DUVVGelFpeERRVUZETzFsQlFVRTdZMEZCUVN4SlFVTTNSU3hKUVVGSkxFTkJRVU5XTEc5Q1FVRnZRaXhGUVVGRk8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3hOUVVONFFpeEpRVUZKVlN4MVEwRkJPRUlzUTBGQlF5eHpRMEZCYzBNc1EwRkJRenRaUVVGQk8yTkJSelZGY1VRc2FVSkJRV2xDTEVkQlFVY3NaME5CUVd0Q0xFVkJRVU1zYlVKQlFXMUNMRU5CUVVNN1kwRkJRU3hMUVVNM1JFRXNhVUpCUVdsQ08yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkRZa01zVlVGQlZTeEhRVUZITEdkRFFVRnJRaXhGUVVGRExGbEJRVmtzUTBGQlF6dGpRVUZCTEVsQlF6bERRU3hWUVVGVk8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3hOUVVGUkxFbEJRVWwwUkN4MVEwRkJPRUlzUTBGQlF5eDVRa0ZCZVVJc1EwRkJRenRaUVVGQk8yTkJRemxGVUN4UFFVRkxMRWRCUVVjc1owTkJRV3RDTEVWQlFVTXNUMEZCVHl4RFFVRkRPMk5CUVVFc1NVRkRjRU5CTEU5QlFVczdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEUxQlFWRXNTVUZCU1U4c2RVTkJRVGhDTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU03V1VGQlFUdGpRVUZCTEUxQlJYQkZMRWxCUVVsQkxIVkRRVUU0UWl4RFFVRkRjVVFzYVVKQlFXbENMRVZCUVVVN1owSkJRVVUxUkN4TFFVRkxMRVZCUVV4QkxFOUJRVXM3WjBKQlFVVTRSQ3hKUVVGSkxFVkJRVVZFTzJOQlFWVXNRMEZCUlN4RFFVRkRPMWxCUVVFN1kwRkhjRVpGTEdOQlFXTXNSMEZCUnl4blEwRkJhMElzUlVGQlF5eG5Ra0ZCWjBJc1EwRkJRenRqUVVOeVJFTXNjMEpCUVhOQ0xFZEJRVWNzWjBOQlFXdENMRVZCUVVNc2QwSkJRWGRDTEVOQlFVTTdZMEZEY2tWc1F5eFpRVUZaTEVkQlFVY3NaME5CUVd0Q0xFVkJRVU1zWTBGQll5eERRVUZETzJOQlFVRXNTVUZEYkVSQkxGbEJRVms3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxFMUJRVkVzU1VGQlNYWkNMSFZEUVVFNFFpeERRVUZETERKQ1FVRXlRaXhEUVVGRE8xbEJRVUU3WTBGRGJFWnZSQ3hWUVVGVkxFZEJRVWNzWjBOQlFXdENMRVZCUVVNc1dVRkJXU3hEUVVGRE8yTkJRVUVzU1VGRE9VTkJMRlZCUVZVN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMRTFCUVZFc1NVRkJTWEJFTEhWRFFVRTRRaXhEUVVGRExIbENRVUY1UWl4RFFVRkRPMWxCUVVFN1kwRkRPVVZ6UXl4aFFVRmhMRWRCUVVjc1owTkJRV3RDTEVWQlFVTXNaVUZCWlN4RFFVRkRPMk5CUVVFc1NVRkRjRVJCTEdGQlFXRTdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEUxQlFWRXNTVUZCU1hSRExIVkRRVUU0UWl4RFFVRkRMRFJDUVVFMFFpeERRVUZETzFsQlFVRTdZMEZEY0VadFJDeFZRVUZWTEVkQlFVY3NaME5CUVd0Q0xFVkJRVU1zV1VGQldTeERRVUZETzJOQlFVRXNTVUZET1VOQkxGVkJRVlU3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxFMUJRVkVzU1VGQlNXNUVMSFZEUVVFNFFpeERRVUZETEhsQ1FVRjVRaXhEUVVGRE8xbEJRVUU3WTBGRk9VVTJReXhQUVVGUExFZEJRVWRoTEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhEUVVGRGVFSXNTVUZCU1N4RFFVRkRReXhIUVVGSExFVkJRVVVzUjBGQlJ5eEpRVUZKTEVOQlFVTTdZMEZEZGtOR0xGVkJRVlVzUjBGQlIxY3NUMEZCVHl4SFFVRkhaU3hSUVVGUkxFTkJRVU5TTEZWQlFWVXNRMEZCUXp0alFVRkJPMk5CUlhwQ0xFOUJRVTBzU1VGQlNTeERRVUZEUml4UFFVRlBMRU5CUVVNelFpeFpRVUZaTEVOQlFVTTdXVUZCUVR0alFVRkJPMk5CUVdoRUwwSXNTVUZCU1N4M1FrRkJTa0VzU1VGQlNUdGpRVUZGUXl4TFFVRkxMSGRDUVVGTVFTeExRVUZMTzJOQlFVRXNTMEZEWmtFc1MwRkJTenRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc1RVRkJVVUVzUzBGQlN6dFpRVUZCTzJOQlEyaENjMElzU1VGQlNTeEhRVUZUZGtJc1NVRkJTU3hEUVVGRGRVSXNTVUZCU1R0alFVTjBRbkJDTEU5QlFVOHNSMEZCV1R0blFrRkRka0kyUkN4alFVRmpMRVZCUVdSQkxHTkJRV003WjBKQlEyUkRMSE5DUVVGelFpeEZRVUYwUWtFc2MwSkJRWE5DTzJkQ1FVTjBRbXhETEZsQlFWa3NSVUZCV2tFc1dVRkJXVHRuUWtGRFdqWkNMRlZCUVZVc1JVRkJSVkVzVVVGQlVTeERRVUZEVWl4VlFVRlZMRU5CUVVNN1owSkJRMmhEYkVJc1ZVRkJWU3hGUVVGV1FTeFZRVUZWTzJkQ1FVTldTU3hoUVVGaExFVkJRV0pCTEdGQlFXRTdaMEpCUTJKaExGVkJRVlVzUlVGQlZrRXNWVUZCVlR0blFrRkRWbkJETEVsQlFVa3NSVUZCU2tFN1pVRkRSRHRqUVVOTGJrSXNXVUZCV1N4SFFVRkhMR2REUVVGclFpeEZRVUZETEUxQlFVMHNRMEZCUXl4RlFVVXZRenRqUVVOQmFVVXNUVUZCVFN4RFFVRkRReXhSUVVGUkxFTkJRVU5ETEVsQlFVa3NSMEZCUnl4RlFVRkZPMk5CUVVFc2JVTkJSV3hDTzJkQ1FVRkZka1VzU1VGQlNTeEZRVUZGTzJ0Q1FVRkZSeXhQUVVGUExFVkJRVkJCTEU5QlFVODdhMEpCUVVWRExGbEJRVmtzUlVGQldrRTdaMEpCUVZrc1EwRkJSVHRuUWtGQlJVZ3NTMEZCU3l4RlFVRkZPMk5CUVVrc1EwRkJSVHRaUVVGQk8yTkJRVUU3WTBGQlFUdGpRVUZCTEV0QlJXNUVMSGRDUVVGWExHZENRVUZQTzJkQ1FVRkJPMmRDUVVGQk8yTkJRVUU3WTBGQlFTeHRRMEZEWWp0blFrRkJSVVFzU1VGQlNTeEZRVUZGTzJ0Q1FVRkZSeXhQUVVGUExFVkJRVVVzU1VGQlNUdHJRa0ZCUlVNc1dVRkJXU3hGUVVGRk8yZENRVUZKTEVOQlFVVTdaMEpCUVVWSUxFdEJRVXM3WTBGQlFTeERRVUZGTzFsQlFVRTdZMEZCUVR0WlFVRkJPMWxCUVVFN1kwRkJRVHRWUVVGQk8xRkJRVUU3VFVGQlFTeERRVXRzUlRzN1NVRkZSRHM3TzBWQlFVRTdTVUZCUVR0SlFVRkJMRTlCUjFFc1owTkJRVzlDTzAxQlF6RkNMRTlCUTBVc2RVSkJRVk1zUjBGQlJTeExRVU5XZFVVc1QwRkJUeXhEUVVGRExHZERRVUZyUWl4RlFVRkRMR05CUVdNc1EwRkJReXhEUVVGRExFbEJRekZEUVN4UFFVRlBMRU5CUVVNc1owTkJRV3RDTEVWQlFVTXNiVUpCUVcxQ0xFTkJRVU1zUTBGQlF5eERRVUZETzBsQlJYWkVPMGxCUlVFN096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZQVFN4dFFrRkJUenM3T3pzN096czdZMEZETWtJc1QwRkJUU3hKUVVGSkxFTkJRVU40UWl4VlFVRlZMRVZCUVVVN1dVRkJRVHRqUVVGQk8yTkJRWEpFYUVRc1NVRkJTU3d3UWtGQlNrRXNTVUZCU1R0alFVRlRiVVFzV1VGQldTd3dRa0ZCYmtKc1JDeExRVUZMTzJOQlFVRXNTMEZEWm10RUxGbEJRVms3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHMURRVU5RTzJkQ1FVRkZiRVFzUzBGQlN5eEZRVUZGYTBRN1kwRkJXU3hEUVVGRk8xbEJRVUU3WTBGRk1VSnpRaXhYUVVGWExFZEJRVWNzVlVGQlNTeERRVUZEZEVVc1QwRkJUeXd3UTBGQlJUUkNMRmxCUVZrN1kwRkJRU3hMUVVNeFF6QkRMRmRCUVZjN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJPMk5CUTBzc1QwRkJUU3hKUVVGSkxFTkJRVU5xUnl4TFFVRkxMRU5CUVVOclJ5eFBRVUZQTEVOQlFVTkVMRmRCUVZjc1EwRkJRenRaUVVGQk8yTkJRVUU3WTBGQkwwTjRSU3hMUVVGTExIbENRVUZNUVN4TFFVRkxPMk5CUVVFc1MwRkRWRUVzUzBGQlN6dG5Ra0ZCUVR0blFrRkJRVHRqUVVGQk8yTkJRVUVzU1VGSFJDd3lRa0ZCWXl4RlFVRkRRU3hMUVVGTExFTkJRVU1zUzBGQlMwRXNTMEZCU3l4RFFVRkRNRVVzVFVGQlRTeExRVUZMTEVkQlFVY3NTVUZCU1RGRkxFdEJRVXNzUTBGQlF6QkZMRTFCUVUwc1MwRkJTeXhIUVVGSExFTkJRVU03WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHMURRVU53UlR0blFrRkJSVEZGTEV0QlFVc3NSVUZCVEVFN1kwRkJTeXhEUVVGRk8xbEJRVUU3WTBGQlFUdGpRVWwwUWl4UFFVRk5MRWxCUVVrc1EwRkJRME1zWTBGQll5eEZRVUZGTzFsQlFVRTdZMEZETTBJc1NVRkJTU3hEUVVGRFNTeHhRa0ZCY1VJc1EwRkJReXhaUVVGWkxFVkJRVVVzU1VGQlNTeERRVUZETzJOQlFVRXNiVU5CUTNaRE8yZENRVUZGVEN4TFFVRkxMRVZCUVVVN1kwRkJTU3hEUVVGRk8xbEJRVUU3V1VGQlFUdGpRVUZCTzFWQlFVRTdVVUZCUVR0TlFVRkJPenRKUVVkNFFqczdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVWxCTERKQ1FVRnJRakpGTEZGQlFXMUZPMDFCUVVFN1RVRkhia1lzU1VGQlRVTXNSVUZCUlN4SFFVRlhMR3RDUVVGSkxFZEJRVVU3VFVGRGVrSXNTVUZCVFVNc1dVRkJXU3hIUVVGcFFqdFJRVU5xUTBRc1JVRkJSU3hGUVVGR1FTeEZRVUZGTzFGQlEwWkVMRkZCUVZFc1JVRkJVa0VzVVVGQlVUdFJRVU5TUnl4WFFVRlhMRVZCUVVVc2RVSkJRVXM3VlVGRGFFSXNTMEZCU1N4RFFVRkRReXh0UWtGQmJVSXNWVUZCVHl4RFFVRkRTQ3hGUVVGRkxFTkJRVU03VVVGRGNrTTdUMEZEUkR0TlFVVkVMRWxCUVVrc1EwRkJRMGNzYlVKQlFXMUNMRU5CUVVORExFZEJRVWNzUTBGQlEwb3NSVUZCUlN4RlFVRkZReXhaUVVGWkxFTkJRVU03VFVGRk9VTXNUMEZCVHp0UlFVRkZPVVVzU1VGQlNTeEZRVUZGTzFWQlFVVTRSU3haUVVGWkxFVkJRVnBCTzFGQlFWazdUVUZCUlN4RFFVRkZPMGxCUTI1RE8wbEJSVUU3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVMU5MQ3RDUVVOS2JrVXNTMEZCWVN4RlFVbFFPMDFCUVVFc1NVRklUbnBETERoRlFVZEpMRVZCUVVVN096czdPenM3WTBGVFJ5eFBRVUZOTEc5Q1FVRlJMRVZCUVVNc1NVRkJTU3hEUVVGRFVTeExRVUZMTEVWQlFVVXNUVUZCVFN4WlFVRkxMRWxCUVVrc1EwRkJRMmhDTEVkQlFVY3NaVUZCV1R0blFrRkRMMFJ4UkN4SlFVRkpMRVZCUVVVN2EwSkJRVVZLTEV0QlFVc3NSVUZCVEVFc1MwRkJTenRyUWtGQlJVc3NiMEpCUVc5Q0xFVkJRVVU3YjBKQlFVVkRMR0ZCUVdFc1JVRkJSUzlETEU5QlFVOHNRMEZCUTJkRU8ydENRVUZaTzJkQ1FVRkZMRU5CUVVVN1owSkJRemxGYkVRc1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlEwRXNUMEZCVHp0blFrRkRja0kyUXl4VlFVRlZMRVZCUVVVelF5eFBRVUZQTEVOQlFVTXlRenRsUVVOeVFpeERRVUZETzFsQlFVRTdZMEZCUVR0WlFVRkJPMk5CUVVFN1kwRkJRVHRqUVVGQkxFdEJSVVVzZDBKQlFWY3NaMEpCUVU4N1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMRzFEUVVOaU8yZENRVUZGWWl4SlFVRkpMRVZCUVVVc1NVRkJTVHRuUWtGQlJVTXNTMEZCU3p0alFVRkJMRU5CUVVVN1dVRkJRVHRqUVVGQk8xbEJRVUU3V1VGQlFUdGpRVUZCTzFWQlFVRTdVVUZCUVR0TlFVRkJMRU5CUzJwRE96dEpRVVZFT3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlNXTXNOa0pCUVc5Q2FVWXNXVUZCYjBJN096czdPenM3WTBGRk0wTXNUMEZCVFN4dlFrRkJVU3hGUVVGRExFbEJRVWtzUTBGQlEzaEhMRXRCUVVzc1JVRkJSU3hOUVVGTkxGbEJRVXNzU1VGQlNTeERRVUZEYUVJc1IwRkJSeXh6UTBGQmJVTTdaMEpCUTNSR2NVUXNTVUZCU1N4RlFVRkZPMnRDUVVGRkswSXNZVUZCWVN4RlFVRkZiME03WjBKQlFWa3NRMEZCUlR0blFrRkRja05zU0N4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzJkQ1FVTnlRbTFFTEV0QlFVc3NSVUZCUlVNN1pVRkRVaXhEUVVGRE8xbEJRVUU3WTBGQlFUdFpRVUZCTzJOQlFVRTdZMEZCUVR0alFVRkJMRXRCUlVVc2QwSkJRVmNzWjBKQlFVODdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEcxRFFVTmlPMmRDUVVGRmNFSXNTVUZCU1N4RlFVRkZPMnRDUVVGRlJ5eFBRVUZQTEVWQlFVVXNTVUZCU1R0clFrRkJSVzlDTEVsQlFVa3NSVUZCUlR0blFrRkJTU3hEUVVGRk8yZENRVUZGZEVJc1MwRkJTenRqUVVGQkxFTkJRVVU3V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQkxFTkJTVEZFT3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVVWUExIbENRVUZuUW5ORExGbEJRWEZDTzAxQlF6TkRMRWxCUVUwMFF5eGpRVUZqTEVkQlEyeENMRkZCUVU4MVF5eFpRVUZaTEUxQlFVc3NVVUZCVVN4SlFVTm9RMEVzV1VGQldTeExRVUZMTEVsQlFVa3NTVUZEY2tJc1kwRkJZeXhKUVVGSlFTeFpRVUZaTEVsQlF6bENMR1ZCUVdVc1NVRkJTVUVzV1VGQldTeEpRVU12UWl4WlFVRlpMRWxCUVVsQkxGbEJRVms3VFVGRk9VSXNUMEZCVHpSRExHTkJRV003U1VGRGRrSTdSVUZCUXp0SlFVRkJPMGxCUVVFc1QwRkZUeXdyUWtGRFRqRkVMRkZCUVd0Q0xFVkJTMW83VFVGQlFTeEpRVXBPZGtRc09FVkJTVWtzUlVGQlJUdE5RVVZPTEVsQlFVMVNMRWRCUVVjc1IwRkJWeXhKUVVGSkxFTkJRVU13U0N4clFrRkJhMElzUTBGQlF6TkVMRkZCUVZFc1JVRkJSVHRSUVVOd1JGb3NWVUZCVlN4RlFVRkZNME1zVDBGQlR5eERRVUZETWtNc1ZVRkJWVHRSUVVNNVFtRXNUVUZCVFN4RlFVRkZlRVFzVDBGQlR5eERRVUZEZDBRc1RVRkJUVHRSUVVOMFFrTXNWMEZCVnl4RlFVRkZla1FzVDBGQlR5eERRVUZEZVVRN1QwRkRkRUlzUTBGQlF6dE5RVU5HTzAxQlEwRXNTVUZCU1N4MVFrRkJVeXhIUVVGRkxFVkJRVVU3VVVGRFpqQkRMRTFCUVUwc1EwRkJRME1zVVVGQlVTeERRVUZEWlN4SlFVRkpMRWRCUVVjelNDeEhRVUZIT3p0TlFVVTFRaXhQUVVGUE8xRkJRVVZ6UXl4SlFVRkpMRVZCUVVVN1ZVRkJSWGxDTEZGQlFWRXNSVUZCVWtFc1VVRkJVVHRWUVVGRkwwUXNSMEZCUnl4RlFVRklRVHRSUVVGSExFTkJRVVU3VVVGQlJYVkRMRXRCUVVzc1JVRkJSVHROUVVGSkxFTkJRVVU3U1VGRGFrUTdTVUZGUVRzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVbGpMRGhDUVVGclFqczdPenM3T3pzN096dGpRVVZNTEU5QlFVMHNNRUpCUVZrc1JVRkJReXhKUVVGSkxFTkJRVU16UWl4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFZpeFZRVUZWTEVOQlFVTTdXVUZCUVR0alFVRnNSVEJGTEdOQlFXTTdZMEZCUVN4SlFVTm1MRWxCUVVrc1EwRkJRMFVzWlVGQlpTeERRVUZEUml4alFVRmpMRU5CUVVNN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMRTFCUTI1RFFTeGpRVUZqTEV0QlFVc3NTVUZCU1R0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRTdZMEZEZWtJc1QwRkJUU3hKUVVGSkxFTkJRVU53UXl4alFVRmpMRVZCUVVVN1dVRkJRVHRqUVVGQk8xbEJRVUU3WTBGTmVrSnRSQ3hQUVVGUExFZEJRVWRoTEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhEUVVGRGVFSXNTVUZCU1N4RFFVRkRReXhIUVVGSExFVkJRVVVzUjBGQlJ5eEpRVUZKTEVOQlFVTTdZMEZCUVN4TlFVVjZReXhEUVVGRExHOUNRVUZqTEVOQlFVTkdMRlZCUVZVc2JVTkJRVWswUXl4UlFVRlJMRWxCUVVscVF5eFBRVUZQTEVkQlFVY3hSaXg1UWtGQllUdG5Ra0ZCUVR0blFrRkJRVHRqUVVGQk8yTkJRVUVzVFVGREwwUXNTVUZCU1N4RFFVRkRSU3huUWtGQlowSXNTVUZCU1hsRkxHTkJRV01zUTBGQlExRXNZVUZCWVR0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlEzWkVMRWxCUVVrc1EwRkJRM2xETEdOQlFXTXNSVUZCUlR0alFVRkJPMk5CUTBnc1QwRkJUU3hKUVVGSkxFTkJRVU14UXl4cFFrRkJhVUlzUTBGQlExQXNZMEZCWXl4RFFVRkRVU3hoUVVGaExFTkJRVU03V1VGQlFUdGpRVUZCTzJOQlFYQkZOME1zUzBGQlN5d3dRa0ZCVEVFc1MwRkJTenRqUVVGQkxFdEJRMVJCTEV0QlFVczdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVU5RZFVZc1QwRkJUeXhEUVVGRFF5eEhRVUZITEVOQlFVTjRSaXhMUVVGTExFTkJRVU41Uml4UFFVRlBMRU5CUVVNN1kwRkJRU3hOUVVWNFFucEdMRXRCUVVzc1dVRkJXVThzWjBOQlFYVkNMRWxCUTNoRExFbEJRVWtzUTBGQlF5dEZMR05CUVdNc1IwRkJSelZJTERKQ1FVRmxMRU5CUVVOblNTeFhRVUZYTzJkQ1FVRkJPMmRDUVVGQk8yTkJRVUU3WTBGRmFrUXNTVUZCU1N4SlFVRkpMRU5CUVVORExHbENRVUZwUWl4RlFVRkZReXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZEUkN4cFFrRkJhVUlzUTBGQlF6dGpRVU5vUlN4SlFVRkpMRU5CUVVOQkxHbENRVUZwUWl4SFFVRkhSU3hWUVVGVkxFTkJRMnBETzJkQ1FVRkJMRTlCUVUwc1RVRkJTU3hEUVVGRGRrWXNhMEpCUVd0Q0xFVkJRVVU3WTBGQlFTeEhRVU12UWpKRUxHOURRVUZsTEVOQlFVTTJRaXhqUVVGakxFVkJRVWtzU1VGQlNTeERRVUZEVWl4alFVRmpMRWxCUVVjc1IwRkJSeXhEUVVGRE8yTkJRVUVzUTBGRE4wUTdZMEZCUVR0WlFVRkJPMk5CUVVFN1kwRkhTQ3hQUVVGTkxFbEJRVWtzUTBGQlEzSkdMR05CUVdNc1JVRkJSVHRaUVVGQk8yTkJSVGRDTEVsQlFVa3NRMEZCUTNGR0xHTkJRV01zUjBGQlJ5eERRVUZETzJOQlFVRTdZMEZCUVR0WlFVRkJPMk5CUVVFN1kwRkZka0lzVDBGQlRTeEpRVUZKTEVOQlFVTnlSaXhqUVVGakxFVkJRVVU3V1VGQlFUdGpRVUZCTzJOQlFVRTdXVUZCUVR0alFVRkJMRXRCUjNwQ0xFbEJRVWtzUTBGQlEzQkRMR05CUVdNN1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJPMk5CUTNKQ0xFOUJRVTBzU1VGQlNTeERRVUZEZFVNc1dVRkJXU3hEUVVGRGFVTXNZMEZCWXl4RFFVRkRPMWxCUVVFN1kwRkZla01zU1VGQlNTeERRVUZEYUVNc2NVSkJRWEZDTEVOQlFVTXNWMEZCVnl4RlFVRkZaME1zWTBGQll5eERRVUZETzFsQlFVRTdZMEZCUVR0alFVRkJPMWxCUVVFN1kwRkJRVHRqUVVGQk8yTkJSM3BFYTBRc1QwRkJUeXhEUVVGRGRrWXNTMEZCU3l4bFFVRkxPMk5CUVVFN1dVRkJRVHRaUVVGQk8yTkJRVUU3VlVGQlFUdFJRVUZCTzAxQlFVRTdPMFZCUjNKQ08wbEJRVUU3U1VGQlFTeFBRVVZoTERKQ1FVRnJRbWxHTEZsQlFXOUNPenM3T3pzN08yMUNRVVU1UXl4SlFVRkpMRU5CUVVOakxHdENRVUZyUWp0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRXNiVU5CUTJ4Q0xFbEJRVWtzUTBGQlEwRXNhMEpCUVd0Q0xFTkJRVU5ETEU5QlFVODdXVUZCUVR0alFVRkJPMk5CU1hSRExFbEJRVWtzUTBGQlEwUXNhMEpCUVd0Q0xFZEJRVWNzU1VGQlNVVXNhMEpCUVZFc1JVRkJNRUk3WTBGQlFTeEpRVVV6UkdoQ0xGbEJRVms3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxFMUJRMVFzU1VGQlNURkZMR2REUVVGMVFpeEZRVUZGTzFsQlFVRTdZMEZCUVR0alFVVmlMRTlCUVUwc1NVRkJTU3hEUVVGRE1rWXNiVUpCUVcxQ0xFTkJRVU5xUWl4WlFVRlpMRU5CUVVNN1dVRkJRVHRqUVVGQk8yTkJRVFZFYkVZc1NVRkJTU3g1UWtGQlNrRXNTVUZCU1R0alFVRkZReXhMUVVGTExIbENRVUZNUVN4TFFVRkxPMk5CUVVFc1MwRkRaa0VzUzBGQlN6dG5Ra0ZCUVR0blFrRkJRVHRqUVVGQk8yTkJRVUVzVFVGQlVVRXNTMEZCU3p0WlFVRkJPMk5CUVVFc1NVRkRha0pFTEVsQlFVa3NRMEZCUTBjc1QwRkJUenRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc1RVRkJVU3hKUVVGSlN5eG5RMEZCZFVJc1JVRkJSVHRaUVVGQk8yTkJRVUU3WTBGRmRFUXNUMEZCVFN4SlFVRkpMRU5CUVVOSUxGbEJRVmtzUTBGQlEwd3NTVUZCU1N4RFFVRkRSeXhQUVVGUExFTkJRVU03V1VGQlFUdGpRVU55UXl4SlFVRkpMRU5CUVVOSExIRkNRVUZ4UWl4RFFVRkRMR2xDUVVGcFFpeEZRVUZGVGl4SlFVRkpMRU5CUVVOSExFOUJRVThzUTBGQlF6dGpRVVZ5UkdsSExFMUJRVTBzUjBGQlJ6dG5Ra0ZCUldwSExFOUJRVThzUlVGQlJVZ3NTVUZCU1N4RFFVRkRSeXhQUVVGUE8yZENRVUZGUml4TFFVRkxMRVZCUVVVN1kwRkJTU3hEUVVGRk8yTkJSWEpFTEVsQlFVa3NRMEZCUXl0R0xHdENRVUZyUWl4RFFVRkRTeXhQUVVGUExFTkJRVU5FTEUxQlFVMHNRMEZCUXp0alFVRkJMRzFEUVVWb1EwRXNUVUZCVFR0WlFVRkJPMk5CUVVFN1kwRkJRVHRqUVVGQkxFdEJSVlFzZDBKQlFWY3NaMEpCUVU4N1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVTmtRU3hQUVVGTkxFZEJRVWM3WjBKQlFVVnFSeXhQUVVGUExFVkJRVVVzU1VGQlNUdG5Ra0ZCUlVZc1MwRkJTenRqUVVGQkxFTkJRVVU3WTBGRmRrTXNWVUZCU1N4RFFVRkRLMFlzYTBKQlFXdENMREJEUVVGRlN5eFBRVUZQTEVOQlFVTkVMRTlCUVUwc1EwRkJRenRqUVVGQkxHMURRVVZxUTBFc1QwRkJUVHRaUVVGQk8yTkJSMllzVlVGQlNTeERRVUZEU2l4clFrRkJhMElzTUVOQlFVVk5MRTFCUVUwc1pVRkJUenRqUVVGQk8xbEJRVUU3WTBGQlFUdGpRVWQwUXl4SlFVRkpMRU5CUVVOT0xHdENRVUZyUWl4SFFVRkhMRWxCUVVrN1kwRkJRVHRaUVVGQk8xbEJRVUU3WTBGQlFUdFZRVUZCTzFGQlFVRTdUVUZCUVRzN1JVRkZha003U1VGQlFUdEpRVUZCTEU5QlJVOHNLMEpCUVhOQ1R5eExRVUZ6UWl4RlFVRkZjRWNzVDBGQmRVSTdUVUZETTBVc1NVRkJTU3hEUVVGRE5rVXNiVUpCUVcxQ0xFTkJRVU4zUWl4UFFVRlBMRU5CUVVNc1ZVRkJRME1zUTBGQlF6dFJRVUZCTEU5QlFVdEJMRU5CUVVNc1EwRkJRemRDTEZGQlFWRXNRMEZCUXpKQ0xFdEJRVXNzUlVGQlJYQkhMRTlCUVU4c1EwRkJRenROUVVGQkxFVkJRVU03U1VGRGNrVTdTVUZGUVRzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVbGpMSE5DUVVGaFFTeFBRVUZuUWpzN096czdPMk5CUTNwRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTnlReXhqUVVGakxFVkJRVVU3WjBKQlEzaENMRWxCUVVrc1EwRkJRMDhzWlVGQlpTeEhRVUZIT0VJc1QwRkJUenM3WTBGSE1VSnRSQ3hUUVVGVExFZEJRVWR1UkN4UFFVRlBMRU5CUVVOMVF5eFZRVUZWTzJOQlEzQkRMRWxCUVVsWkxGTkJRVk1zUlVGQlJUdG5Ra0ZEVUVRc1QwRkJUeXhIUVVGSFlTeEpRVUZKTEVOQlFVTkRMRXRCUVVzc1EwRkJRM2hDTEVsQlFVa3NRMEZCUTBNc1IwRkJSeXhGUVVGRkxFZEJRVWNzU1VGQlNTeERRVUZETzJkQ1FVTjJRemhFTEZOQlFWTXNSMEZCUjNCRUxGTkJRVk1zUjBGQlIwUXNUMEZCVHp0blFrRkRMMEp6UkN3MFFrRkJORUlzUjBGQlIwUXNVMEZCVXl4SFFVRkhMMGtzZVVKQlFXRXNSMEZCUjBFc2VVSkJRV0VzUjBGQlJ5eEhRVUZITzJkQ1FVTndSaXhKUVVGSkxFTkJRVU5wU2l4elFrRkJjMElzUTBGQlF5eERRVUZEUml4VFFVRlRMRWRCUVVkRExEUkNRVUUwUWl4SlFVRkpMRWxCUVVrc1EwRkJRenM3WTBGREwwVXNUVUZGUnl4SlFVRkpMRU5CUVVNM1NTeGpRVUZqTEVsQlFVbHhReXhQUVVGUExFTkJRVU4xUXl4VlFVRlZPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVR0alFVTXpReXhQUVVGTkxFbEJRVWtzUTBGQlEyMUZMR1ZCUVdVc1EwRkJRekZITEU5QlFVOHNRMEZCUXp0WlFVRkJPMWxCUVVFN1kwRkJRVHRWUVVGQk8xRkJRVUU3VFVGQlFTeERRVVYwUXpzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGRlR5eDVRa0ZCWjBKdFF5eGpRVUYxUWp0TlFVTTNReXhQUVVGUExEQkNRVUZaTEVWQlFVTXNTVUZCU1N4RFFVRkRhRVVzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTFZc1ZVRkJWU3hGUVVGRk1FVXNZMEZCWXl4RFFVRkRPMGxCUTNCRk8wVkJRVU03U1VGQlFUdEpRVUZCTEU5QlJXRXNNRUpCUVdNN096czdPMjFDUVVOMFFpeEpRVUZKTEVOQlFVTjRSU3hqUVVGak8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRVHRqUVVOeVFpeFBRVUZOTERaQ1FVRmxMRVZCUVVNc1NVRkJTU3hEUVVGRFVTeFBRVUZQTEVWQlFVVXNTVUZCU1N4RFFVRkRWaXhWUVVGVkxFTkJRVU03V1VGQlFUdGpRVUZCTzJOQlFVRTdXVUZCUVR0alFVVndSQ3hKUVVGSkxFTkJRVU5UTEdWQlFXVXNSMEZCUnl4SlFVRkpPMWxCUVVFN1kwRkhOMElzU1VGQlNTeEpRVUZKTEVOQlFVTjFTQ3hwUWtGQmFVSXNSVUZCUlR0blFrRkRNVUpETEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVORUxHbENRVUZwUWl4RFFVRkRPenRaUVVOeVF6dFpRVUZCTzJOQlFVRTdWVUZCUVR0UlFVRkJPMDFCUVVFc1EwRkRSanM3U1VGRlJEczdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZMVVN4blEwRkJkVUpyUWl4TFFVRmhPMDFCUVVFN1RVRkRNVU1zU1VGQlNTeEpRVUZKTEVOQlFVTnNRaXhwUWtGQmFVSXNSVUZCUlVNc1dVRkJXU3hEUVVGRExFbEJRVWtzUTBGQlEwUXNhVUpCUVdsQ0xFTkJRVU03VFVGRGFFVXNTVUZCU1d0Q0xFdEJRVXNzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVOcVNpeG5Ra0ZCWjBJc1JVRkJSVHROUVVVeFF5eEpRVUZKTEVOQlFVTXJTQ3hwUWtGQmFVSXNSMEZCUjBVc1ZVRkJWU3hEUVVGRE8xRkJRVUVzVDBGQlYybENPMVZCUVVFN1ZVRkJRVHRaUVVGQk8yTkJRVUU3WjBKQlF6ZERMRWxCUVVrc1EwRkJRM2hDTEdOQlFXTXNSVUZCUlR0blFrRkJRVHRuUWtGSmFrSXNUMEZCVFN4SlFVRkpMRU5CUVVOMlF5eFZRVUZWTEVWQlFVVTdZMEZCUVR0blFrRkJRVHRuUWtGR2FrSTNReXhQUVVGUExEQkNRVUZtU0N4SlFVRkpMRU5CUVVsSExFOUJRVTg3WjBKQlExSm5SQ3haUVVGWkxEQkNRVUZ1UW14RUxFdEJRVXM3WjBKQlFVRXNUVUZGU0N4RFFVRkRhMFFzV1VGQldTeEpRVUZKYUVRc1QwRkJUenRyUWtGQlFUdHJRa0ZCUVR0blFrRkJRVHRuUWtGQlFUdG5Ra0ZEVWl4UFFVRk5MRWxCUVVrc1EwRkJRekJETEdsQ1FVRnBRaXhEUVVGRE1VTXNUMEZCVHl4RFFVRkRNa01zWVVGQllTeERRVUZETzJOQlFVRTdaMEpCUVVFN1owSkJRVGRFTjBNc1MwRkJTeXd3UWtGQlRFRXNTMEZCU3p0blFrRkRZaXhKUVVGSkxFTkJRVU5CTEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVOelJpeGpRVUZqTEVkQlFVY3NRMEZCUXp0blFrRkRia01zU1VGRFJYUkdMRXRCUVVzc1dVRkJXVThzWjBOQlFYVkNMRWxCUTNoRExFbEJRVWtzUTBGQlF5dEZMR05CUVdNc1IwRkJSelZJTERKQ1FVRmxMRU5CUVVOblNTeFhRVUZYTEVWQlJXcEVMRWxCUVVrc1EwRkJRMmxDTEhOQ1FVRnpRaXhEUVVGRE1VTXNiME5CUVdVc1EwRkJRelpDTEdOQlFXTXNSVUZCU1N4SlFVRkpMRU5CUVVOU0xHTkJRV01zU1VGQlJ5eEhRVUZITEVOQlFVTXNSVUZCUXp0alFVRkJPMk5CUVVFN1owSkJRVUU3V1VGQlFUdFZRVUZCTzFGQlFVRXNRMEZGT1VZN1RVRkJRU3hIUVVGRmRVSXNTMEZCU3l4RFFVRkRPMDFCUTFRc1NVRkJTU3hQUVVGUExFbEJRVWtzUTBGQlEyeENMR2xDUVVGcFFpeERRVUZEYjBJc1MwRkJTeXhMUVVGTExGVkJRVlVzUlVGQlJTeEpRVUZKTEVOQlFVTndRaXhwUWtGQmFVSXNRMEZCUTI5Q0xFdEJRVXNzUlVGQlJUdEpRVU40Ump0RlFVRkRPMGxCUVVFN1NVRkJRU3hQUVVWUExHMURRVUYxUWp0TlFVRkJPMDFCUXpkQ0xFbEJRVWtzUTBGQlF5eDFRa0ZCVXl4SFFVRkZMRWxCUVVrc1JVRkJRek5ETEUxQlFVMHNZVUZCVGtFc1RVRkJUU3gxUWtGQlRrRXNUVUZCVFN4RFFVRkZORU1zWjBKQlFXZENMRWRCUVVVN1VVRkROME1zVDBGQlR5eExRVUZMT3p0TlFVZGtMRWxCUVVrN1VVRkRSalZETEUxQlFVMHNZVUZCVGtFc1RVRkJUU3gxUWtGQlRrRXNUVUZCVFN4RFFVRkZORU1zWjBKQlFXZENMRU5CUVVNc2EwSkJRV3RDTEVWQlFVVTdWVUZCUVN4UFFVRlhSanRaUVVGQk8yTkJRVUU3WjBKQlFVRTdhMEpCUVVFc1RVRkRiRVJITEZGQlFWRXNRMEZCUTBNc1pVRkJaU3hMUVVGTExGTkJRVk03YjBKQlFVRTdiMEpCUVVFN2EwSkJRVUU3YTBKQlFVRTdhMEpCUTNoRExFOUJRVTBzU1VGQlNTeERRVUZEZGtnc2FVSkJRV2xDTzJkQ1FVRkJPMnRDUVVGQk8ydENRVU0xUWl4UFFVRk5MRWxCUVVrc1EwRkJRMWNzYTBKQlFXdENMRVZCUVVVN1owSkJRVUU3WjBKQlFVRTdhMEpCUVVFN1kwRkJRVHRaUVVGQk8xVkJRVUVzUTBGRmJFTTdVVUZCUVN4RlFVRkRPMDlCUTBnc1EwRkJReXhQUVVGUFRpeExRVUZMTEVWQlFVVTdVVUZEWkhWR0xFOUJRVThzUTBGQlEzWkdMRXRCUVVzc1EwRkJReXg1UWtGQmVVSXNSVUZCUlVFc1MwRkJTeXhEUVVGRE96dEpRVVZ1UkR0SlFVVkJPenM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGTlVTdzBRa0ZEVG5kQ0xGRkJRV3RDTEVWQlEyeENka1FzVDBGSlF6dE5RVVZFTEVsQlFVMXJTaXhUUVVGVExFZEJRV0VzYjBKQlFXRkRMR3RDUVVGclFpeERRVUZETlVZc1VVRkJVU3hEUVVGRExFVkJRVWM3VFVGRGVFVXNTVUZCU1haRUxFOUJRVThzWVVGQlVFRXNUMEZCVHl4MVFrRkJVRUVzVDBGQlR5eERRVUZGTWtNc1ZVRkJWU3hGUVVGRk8xRkJRM1pDZFVjc1UwRkJVeXhEUVVGRFJTeEpRVUZKTEhWQ1FVRm5Ra1FzYTBKQlFXdENMRU5CUVVOdVNpeFBRVUZQTEVOQlFVTXlReXhWUVVGVkxFTkJRVU1zUlVGQlJ6czdUVUZGZWtVc1NVRkJTVE5ETEU5QlFVOHNZVUZCVUVFc1QwRkJUeXgxUWtGQlVFRXNUMEZCVHl4RFFVRkZkMFFzVFVGQlRTeEZRVUZGTzFGQlEyNUNNRVlzVTBGQlV5eERRVUZEUlN4SlFVRkpMR3RDUVVGWFJDeHJRa0ZCYTBJc1EwRkJRMjVLTEU5QlFVOHNRMEZCUTNkRUxFMUJRVTBzUTBGQlF5eEZRVUZIT3p0TlFVVm9SU3hKUVVGSmVFUXNUMEZCVHl4aFFVRlFRU3hQUVVGUExIVkNRVUZRUVN4UFFVRlBMRU5CUVVWNVJDeFhRVUZYTEVWQlFVVTdVVUZEZUVJc1NVRkJUVFJHTEV0QlFVc3NSMEZCUnl4SlFVRkpReXhsUVVGbExFTkJRVU4wU2l4UFFVRlBMRU5CUVVONVJDeFhRVUZYTEVOQlFVTTdVVUZEZEVSNVJpeFRRVUZUTEVOQlFVTkZMRWxCUVVrc1EwRkJRME1zUzBGQlN5eERRVUZEUlN4UlFVRlJMRVZCUVVVc1EwRkJRenM3VFVGRmJFTXNhVUpCUVZVc1NVRkJTU3hEUVVGREwwb3NSMEZCUnl4M1FrRkJZekJLTEZOQlFWTXNRMEZCUTAwc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF6dEpRVU55UkR0RlFVRkRPMGxCUVVFN1NVRkJRU3hQUVVWaExHMUNRVUZWTlVZc1RVRkJlVUk3T3pzN096czdPenRqUVVWTkxFOUJRVTBzU1VGQlNTeERRVUZEYTBJc1ZVRkJWU3hGUVVGRk8xbEJRVUU3WTBGQlFUdGpRVUUxUkVVc1YwRkJWeXd3UWtGQmFrSnNSQ3hKUVVGSk8yTkJRWE5DYlVRc1dVRkJXU3d3UWtGQmJrSnNSQ3hMUVVGTE8yTkJRVUVzUzBGRE5VSnJSQ3haUVVGWk8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3h0UTBGRFVEdG5Ra0ZCUlc1RUxFbEJRVWtzUlVGQlJTeEpRVUZKTzJkQ1FVRkZReXhMUVVGTExFVkJRVVZyUkR0alFVRlpMRU5CUVVVN1dVRkJRVHRqUVVGQk8yTkJSM0pETEU5QlFVMHNiMEpCUVZFc1JVRkJReXhKUVVGSkxFTkJRVU42UlN4TFFVRkxMRVZCUVVVc1VVRkJVU3haUVVGTExFbEJRVWtzUTBGQlEyaENMRWRCUVVjc2MwSkJRVmx2UlN4TlFVRk5MRU5CUVVNMlJpeFJRVUZSTEVkQlFVazdaMEpCUTNCR00wb3NUMEZCVHl4RlFVRkZMRWxCUVVrc1EwRkJRMEVzVDBGQlR6dG5Ra0ZEY2tJclJTeEhRVUZITEVWQlFVVXNhVUpCUVZjc1lVRkJXRWNzVjBGQlZ5eDFRa0ZCV0VFc1YwRkJWeXhEUVVGRkwwTXNUMEZCVHl3d1EwRkJSVFJDTzJWQlF6VkNMRU5CUVVNN1dVRkJRVHRqUVVGQk8xbEJRVUU3WTBGQlFUdGpRVUZCTzJOQlFVRXNTMEZGUlN4M1FrRkJWeXhuUWtGQlR6dG5Ra0ZCUVR0blFrRkJRVHRqUVVGQk8yTkJRVUVzYlVOQlEySTdaMEpCUVVVdlFpeEpRVUZKTEVWQlFVVXNTVUZCU1R0blFrRkJSVU1zUzBGQlN6dGpRVUZCTEVOQlFVVTdXVUZCUVR0alFVRkJPMWxCUVVFN1dVRkJRVHRqUVVGQk8xVkJRVUU3VVVGQlFUdE5RVUZCT3p0SlFVMXNRenM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlRXTXNhVUpCUVZFMlFpeE5RVUYxUWpzN096czdPenM3TzJOQlJWVXNUMEZCVFN4SlFVRkpMRU5CUVVOclFpeFZRVUZWTEVWQlFVVTdXVUZCUVR0alFVRkJPMk5CUVRWRVJTeFhRVUZYTERCQ1FVRnFRbXhFTEVsQlFVazdZMEZCYzBKdFJDeFpRVUZaTERCQ1FVRnVRbXhFTEV0QlFVczdZMEZCUVN4TFFVTTFRbXRFTEZsQlFWazdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEcxRFFVTlFPMmRDUVVGRmJrUXNTVUZCU1N4RlFVRkZMRWxCUVVrN1owSkJRVVZETEV0QlFVc3NSVUZCUld0RU8yTkJRVmtzUTBGQlJUdFpRVUZCTzJOQlFVRTdZMEZIY0VJc1QwRkJUU3h2UWtGQlVTeEZRVUZETEVsQlFVa3NRMEZCUTNwRkxFdEJRVXNzUlVGQlJTeE5RVUZOTEZsQlFVc3NTVUZCU1N4RFFVRkRhRUlzUjBGQlJ5eGxRVUZaTzJkQ1FVTm9SbkZFTEVsQlFVa3NSVUZCUlR0clFrRkRTalpITEdGQlFXRXNSVUZCUlRsR0xFMUJRVTBzUTBGQlF5dEdMRmxCUVZrN2EwSkJRMnhEUXl4WFFVRlhMRVZCUVVWb1J5eE5RVUZOTEVOQlFVTnBSeXhWUVVGVk8ydENRVU01UWtNc1RVRkJUU3hGUVVGRmJFY3NUVUZCVFN4RFFVRkRhMGM3YVVKQlEyaENPMmRDUVVORWFFc3NUMEZCVHl4RlFVRkZMRWxCUVVrc1EwRkJRMEVzVDBGQlR6dG5Ra0ZEY2tJclJTeEhRVUZITEVWQlFVVXNhVUpCUVZjc1lVRkJXRWNzVjBGQlZ5eDFRa0ZCV0VFc1YwRkJWeXhEUVVGRkwwTXNUMEZCVHl3d1EwRkJSVFJDTzJWQlF6VkNMRU5CUVVNN1dVRkJRVHRqUVVGQk8yTkJVazB2UWl4SlFVRkpMRmRCUVVwQkxFbEJRVWs3WTBGQlJVTXNTMEZCU3l4WFFVRk1RU3hMUVVGTE8yTkJRVUVzUzBGVlprRXNTMEZCU3p0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRXNiVU5CUTBFN1owSkJRVVZFTEVsQlFVa3NSVUZCUlN4SlFVRkpPMmRDUVVGRlF5eExRVUZMTEVWQlFVeEJPMk5CUVVzc1EwRkJSVHRaUVVGQk8yTkJSemxDTEVsQlFVa3NWVUZCU1N4aFFVRktSQ3hKUVVGSkxIVkNRVUZLUVN4SlFVRkpMRU5CUVVWcFNTeEpRVUZKTERCRFFVRkZReXhQUVVGUExFVkJRVVU3WjBKQlEzWkNiRWtzU1VGQlNTeERRVUZEYVVrc1NVRkJTU3hEUVVGRFF5eFBRVUZQTEhORFFVRXJRbXhKTEVsQlFVa3NRMEZCUTJsSkxFbEJRVWtzUTBGQlEwTXNUMEZCVHl4RFFVRkZPenRqUVVOd1JTeHRRMEZGVFR0blFrRkJSV3hKTEVsQlFVa3NSVUZCU2tFc1NVRkJTVHRuUWtGQlJVTXNTMEZCU3l4RlFVRkZPMk5CUVVrc1EwRkJSVHRaUVVGQk8yTkJRVUU3WTBGQlFUdGpRVUZCTEV0QlJYaENMSGRDUVVGWExHZENRVUZQTzJkQ1FVRkJPMmRDUVVGQk8yTkJRVUU3WTBGQlFTeHRRMEZEWWp0blFrRkJSVVFzU1VGQlNTeEZRVUZGTEVsQlFVazdaMEpCUVVWRExFdEJRVXM3WTBGQlFTeERRVUZGTzFsQlFVRTdZMEZCUVR0WlFVRkJPMWxCUVVFN1kwRkJRVHRWUVVGQk8xRkJRVUU3VFVGQlFUczdTVUZOYkVNN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJTMk1zYVVKQlFWRTJRaXhOUVVGMVFqczdPenM3T3pzN08yTkJSVlVzVDBGQlRTeEpRVUZKTEVOQlFVTnJRaXhWUVVGVkxFVkJRVVU3V1VGQlFUdGpRVUZCTzJOQlFUVkVSU3hYUVVGWExEQkNRVUZxUW14RUxFbEJRVWs3WTBGQmMwSnRSQ3haUVVGWkxEQkNRVUZ1UW14RUxFdEJRVXM3WTBGQlFTeExRVU0xUW10RUxGbEJRVms3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHMURRVU5RTzJkQ1FVRkZia1FzU1VGQlNTeEZRVUZGTEVsQlFVazdaMEpCUVVWRExFdEJRVXNzUlVGQlJXdEVPMk5CUVZrc1EwRkJSVHRaUVVGQk8yTkJRVUU3WTBGSGNFSXNUMEZCVFN4dlFrRkJVU3hGUVVOd1F5eEpRVUZKTEVOQlFVTjZSU3hMUVVGTExFVkJRMVlzVFVGQlRTeFpRVU5JTEVsQlFVa3NRMEZCUTJoQ0xFZEJRVWNzYzBKQlFWbHZSU3hOUVVGTkxFTkJRVU0yUml4UlFVRlJMR05CUTNSRE8yZENRVU5GTlVjc1NVRkJTU3hGUVVGRk8ydENRVUZGWjBRc1NVRkJTU3hGUVVGRmFrTXNUVUZCVFN4RFFVRkRhVU1zU1VGQlNUdHJRa0ZCUlc5RkxGbEJRVmtzUlVGQlJYSkhMRTFCUVUwc1EwRkJRM05ITzJkQ1FVRlhMRU5CUVVVN1owSkJRemRFY0Vzc1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlEwRXNUMEZCVHp0blFrRkRja0lyUlN4SFFVRkhMRVZCUVVVc2FVSkJRVmNzWVVGQldFY3NWMEZCVnl4MVFrRkJXRUVzVjBGQlZ5eERRVUZGTDBNc1QwRkJUeXd3UTBGQlJUUkNPMlZCUXpWQ0xFTkJRMFk3V1VGQlFUdGpRVUZCTzJOQlZFOHZRaXhKUVVGSkxGZEJRVXBCTEVsQlFVazdZMEZCUlVNc1MwRkJTeXhYUVVGTVFTeExRVUZMTzJOQlFVRXNTMEZWWmtFc1MwRkJTenRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc2JVTkJRMEU3WjBKQlFVVkVMRWxCUVVrc1JVRkJSU3hKUVVGSk8yZENRVUZGUXl4TFFVRkxMRVZCUVV4Qk8yTkJRVXNzUTBGQlJUdFpRVUZCTzJOQlFVRTdZMEZIT1VJc1QwRkJUU3hKUVVGSkxFTkJRVU5KTEZsQlFWazdaMEpCUTNKQ2NVTXNWVUZCVlN4RlFVRkZkMElzU1VGQlNTeERRVUZEUXl4TFFVRkxMRU5CUVVONFFpeEpRVUZKTEVOQlFVTkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFbEJRVWtzUTBGQlF5eEhRVUZITlVNc1NVRkJTU3hEUVVGRE5FUTdZMEZCVlN4SFFVTjRSRFZFTEVsQlFVa3NSVUZEVUR0WlFVRkJPMk5CUTBZc1NVRkJTU3hEUVVGRFRTeHhRa0ZCY1VJc1EwRkJReXgzUWtGQmQwSXNSVUZCUlU0c1NVRkJTU3hEUVVGRE8yTkJRVUVzYlVOQlJXNUVPMmRDUVVGRlFTeEpRVUZKTEVWQlFVcEJMRWxCUVVrN1owSkJRVVZETEV0QlFVc3NSVUZCVEVFN1kwRkJTeXhEUVVGRk8xbEJRVUU3WTBGQlFUdGpRVUZCTzJOQlFVRXNTMEZGYkVJc2QwSkJRVmNzWjBKQlFVODdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEcxRFFVTmlPMmRDUVVGRlJDeEpRVUZKTEVWQlFVVXNTVUZCU1R0blFrRkJSVU1zUzBGQlN6dGpRVUZCTEVOQlFVVTdXVUZCUVR0alFVRkJPMWxCUVVFN1dVRkJRVHRqUVVGQk8xVkJRVUU3VVVGQlFUdE5RVUZCT3p0SlFVMXNRenM3T3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVVsakxHOUNRVUZYTmtJc1RVRkJNRUk3T3pzN096czdPenRqUVVWSkxFOUJRVTBzU1VGQlNTeERRVUZEYTBJc1ZVRkJWU3hGUVVGRk8xbEJRVUU3WTBGQlFUdGpRVUUxUkVVc1YwRkJWeXd3UWtGQmFrSnNSQ3hKUVVGSk8yTkJRWE5DYlVRc1dVRkJXU3d3UWtGQmJrSnNSQ3hMUVVGTE8yTkJRVUVzUzBGRE5VSnJSQ3haUVVGWk8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3h0UTBGRFVEdG5Ra0ZCUlc1RUxFbEJRVWtzUlVGQlJTeEpRVUZKTzJkQ1FVRkZReXhMUVVGTExFVkJRVVZyUkR0alFVRlpMRU5CUVVVN1dVRkJRVHRqUVVGQk8yTkJSM0pETEU5QlFVMHNiMEpCUVZFc1JVRkRia0lzU1VGQlNTeERRVUZEZWtVc1MwRkJTeXhGUVVOV0xFMUJRVTBzV1VGRFNDeEpRVUZKTEVOQlFVTm9RaXhIUVVGSExITkNRVUZaYjBVc1RVRkJUU3hEUVVGRE5rWXNVVUZCVVN4cFFrRkRkRU03WjBKQlEwVXpTaXhQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZEUVN4UFFVRlBPMmRDUVVOeVFpdEZMRWRCUVVjc1JVRkJSU3hwUWtGQlZ5eGhRVUZZUnl4WFFVRlhMSFZDUVVGWVFTeFhRVUZYTEVOQlFVVXZReXhQUVVGUExEQkRRVUZGTkVJN1pVRkROVUlzUTBGRFJqdFpRVUZCTzJOQlFVRTdXVUZCUVR0alFVRkJPMk5CUVVFN1kwRkJRU3hMUVVWSExIZENRVUZYTEdkQ1FVRlBPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVN4dFEwRkRZanRuUWtGQlJTOUNMRWxCUVVrc1JVRkJSU3hKUVVGSk8yZENRVUZGUXl4TFFVRkxPMk5CUVVFc1EwRkJSVHRaUVVGQk8yTkJRVUU3V1VGQlFUdFpRVUZCTzJOQlFVRTdWVUZCUVR0UlFVRkJPMDFCUVVFN08wbEJUV3hET3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVdGpMRFpDUVVOYU5rSXNUVUZCYlVNN096czdPenM3WTBGRmIwSXNUMEZCVFN4SlFVRkpMRU5CUVVONlF5eFZRVUZWTEVOQlFVTTdaMEpCUXpORmMwa3NVVUZCVVN4RlFVRkZOMFlzVFVGQlRTeERRVUZETmtZN1pVRkRiRUlzUTBGQlF6dFpRVUZCTzJOQlFVRTdZMEZHV1ZVc1lVRkJZU3g1UWtGQmJrSnlTU3hKUVVGSk8yTkJRWGRDYzBrc1kwRkJZeXg1UWtGQmNrSnlTU3hMUVVGTE8yTkJRVUVzUzBGSE9VSnhTU3hqUVVGak8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3h0UTBGRFZEdG5Ra0ZCUlhSSkxFbEJRVWtzUlVGQlJTeEpRVUZKTzJkQ1FVRkZReXhMUVVGTExFVkJRVVZ4U1R0alFVRmpMRU5CUVVVN1dVRkJRVHRqUVVGQk8yTkJSWFpETEU5QlFVMHNTVUZCU1N4RFFVRkRlRW9zVDBGQlR5eERRVUZETzJkQ1FVTjRRalpKTEZGQlFWRXNSVUZCUlRkR0xFMUJRVTBzUTBGQlF6WkdMRkZCUVZFN1owSkJRM3BDVXl4WFFVRlhMRVZCUVVWRExHRkJRV0VzUTBGQlEzaEVMRVZCUVVVN1owSkJRemRDWkN4SlFVRkpMRVZCUVVWcVF5eE5RVUZOTEVOQlFVTnBRenRsUVVOa0xFTkJRVU03V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQkxFTkJRMGc3TzBsQlJVUTdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVWRqTEhkQ1FVRlpPenM3T3pzN08yTkJTWEJDTEU5QlFVMHNTVUZCU1N4RFFVRkRUQ3hQUVVGUExFVkJRVVU3V1VGQlFUdGpRVUZCTzJOQlJtUnVReXhKUVVGSkxIZENRVUZhZGtJc1NVRkJTU3hEUVVGSmRVSXNTVUZCU1R0alFVTk1Oa0lzVTBGQlV5eDNRa0ZCYUVKdVJDeExRVUZMTzJOQlFVRXNTMEZGU0cxRUxGTkJRVk03WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHMURRVU5LTzJkQ1FVRkZjRVFzU1VGQlNTeEZRVUZGTEVsQlFVazdaMEpCUVVWRExFdEJRVXNzUlVGQlJXMUVPMk5CUVZNc1EwRkJSVHRaUVVGQk8yTkJSMjVEYlVZc1QwRkJUeXhIUVVGSExFdEJRVWtzWVVGQlNtaElMRWxCUVVrc2RVSkJRVXBCTEVsQlFVa3NRMEZCUldkSUxFOUJRVThzUzBGQlNTeEZRVUZGTzJOQlF6ZENUaXhKUVVGSkxFZEJRVWROTEU5QlFVOHNRMEZCUTBNc1RVRkJUU3hEUVVONlFpeFZRVUZEUXl4TlFVRk5PMmRDUVVGQkxFOUJRVXRCTEUxQlFVMHNRMEZCUTFnc1YwRkJWeXhMUVVGTExFMUJRVTBzU1VGQlNWY3NUVUZCVFN4RFFVRkRPVVFzVFVGQlRTeExRVUZMTEZWQlFWVTdZMEZCUVN4RlFVTXhSVHRqUVVGQkxHMURRVVZOTzJkQ1FVTk1NMFVzU1VGQlNTeEZRVUZGTzJ0Q1FVTktNRWtzUjBGQlJ5eEZRVUZGU0N4UFFVRlBPMnRDUVVOYVRpeEpRVUZKTEVWQlFVcEJPMmxDUVVORU8yZENRVU5FYUVrc1MwRkJTeXhGUVVGRk8yVkJRMUk3V1VGQlFUdFpRVUZCTzJOQlFVRTdWVUZCUVR0UlFVRkJPMDFCUVVFc1EwRkRSanM3U1VGRlJEczdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVWxqTERKRFFVRXJRanM3T3pzN096czdZMEZKZGtNc1QwRkJUU3hKUVVGSkxFTkJRVU1yUXl4VlFVRlZMRVZCUVVVN1dVRkJRVHRqUVVGQk8yTkJSbXBDTjBNc1QwRkJUeXd5UWtGQlprZ3NTVUZCU1N4RFFVRkpSeXhQUVVGUE8yTkJRMUpuUkN4WlFVRlpMREpDUVVGdVFteEVMRXRCUVVzN1kwRkJRU3hMUVVWSWEwUXNXVUZCV1R0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRXNiVU5CUTFBN1owSkJRVVZ1UkN4SlFVRkpMRVZCUVVVc1NVRkJTVHRuUWtGQlJVTXNTMEZCU3l4RlFVRkZhMFE3WTBGQldTeERRVUZGTzFsQlFVRTdZMEZCUVN4SlFVVjJRMmhFTEU5QlFVODdaMEpCUVVFN1owSkJRVUU3WTBGQlFUdGpRVUZCTEcxRFFVTklPMmRDUVVOTVNDeEpRVUZKTEVWQlFVVTdhMEpCUVVVeVNTeFpRVUZaTEVWQlFVVXNTVUZCU1R0clFrRkJSVU1zVTBGQlV5eEZRVUZGTEVsQlFVazdhMEpCUVVWRExEUkNRVUUwUWl4RlFVRkZPMmRDUVVGRkxFTkJRVVU3WjBKQlF5OUZOVWtzUzBGQlN5eEZRVUZGTzJWQlExSTdXVUZCUVR0alFVZEhjMFFzVDBGQlR5eEhRVUZITEVsQlFVa3NRMEZCUTNWR0xGVkJRVlVzUTBGQlF6TkpMRTlCUVU4c1EwRkJRelJDTEZsQlFWa3NRMEZCUXp0alFVVnFSRFJITEZsQlFWa3NSMEZCZDBNc1NVRkJTVHRqUVVVMVJDeEpRVUZKY0VZc1QwRkJUeXhEUVVGRGQwWXNSMEZCUnl4RlFVRkZPMmRDUVVObVNpeFpRVUZaTEVkQlFVZHdSaXhQUVVGUExFTkJRVU4zUml4SFFVRkhPenRqUVVkNFFrZ3NVMEZCVXl4SFFVRjNRMFFzV1VGQldUdGpRVVV6UkVzc1pVRkJaU3hIUVVOdVFpeHRRa0ZCVHl4RFFVRkRla2dzU1VGQlNTeERRVUZEWjBnc1QwRkJUeXd3UTBGQlJVTXNUVUZCVFN4RFFVRkRMRlZCUVVORExFMUJRV003WjBKQlFVRXNUMEZCUzBFc1RVRkJUU3hEUVVGRE9VUXNUVUZCVFN4TFFVRkxMRlZCUVZVN1kwRkJRU3hGUVVGRExHMURRVUZKTEVWQlFVVTdZMEZGZEVZc1NVRkJTWEZGTEdWQlFXVXNRMEZCUTBNc1RVRkJUU3hIUVVGSExFTkJRVU1zUlVGQlJUdG5Ra0ZET1VKTUxGTkJRVk1zUjBGQlJ5eE5RVUZOT3p0alFVZGtReXcwUWtGQk5FSXNSMEZCUjNSR0xFOUJRVThzUTBGQlF6SkdMRWRCUVVjc1NVRkJTU3hGUVVGRk8yTkJRVUVzYlVOQlJTOURPMmRDUVVGRmJFb3NTVUZCU1N4RlFVRkZPMnRDUVVGRk1ra3NXVUZCV1N4RlFVRmFRU3haUVVGWk8ydENRVUZGUXl4VFFVRlRMRVZCUVZSQkxGTkJRVk03YTBKQlFVVkRMRFJDUVVFMFFpeEZRVUUxUWtFN1owSkJRVFJDTEVOQlFVVTdaMEpCUVVVMVNTeExRVUZMTEVWQlFVVTdZMEZCU1N4RFFVRkZPMWxCUVVFN1dVRkJRVHRqUVVGQk8xVkJRVUU3VVVGQlFUdE5RVUZCT3p0RlFVTjRSanRGUVVGQk8wRkJRVUU3UVVFeGRrTklhMG9pTENKdVlXMWxjeUk2V3lKRVJVWkJWVXhVWDA5UVZFbFBUbE1pTENKMWNtd2lMQ0pqYjI1emRHRnVkSE5mTVNJc0luTjBiM0poWjJWTFpYa2lMQ0poZFhSdlVtVm1jbVZ6YUZSdmEyVnVJaXdpY0dWeWMybHpkRk5sYzNOcGIyNGlMQ0prWlhSbFkzUlRaWE56YVc5dVNXNVZjbXdpTENKb1pXRmtaWEp6SWl3aVIyOVVjblZsUTJ4cFpXNTBJaXdpYjNCMGFXOXVjeUlzSWsxaGNDSXNJbk5sZEhScGJtZHpJaXdpYVc1TlpXMXZjbmxUWlhOemFXOXVJaXdpYzNSdmNtRm5aU0lzSW14dlkyRnNYM04wYjNKaFoyVmZNU0lzSW1Ga2JXbHVJaXdpUjI5VWNuVmxRV1J0YVc1QmNHbGZNU0lzSW1abGRHTm9JaXdpYVc1cGRHbGhiR2w2WlNJc0ltMW1ZU0lzSW5abGNtbG1lU0lzSWw5MlpYSnBabmtpTENKaWFXNWtJaXdpWlc1eWIyeHNJaXdpWDJWdWNtOXNiQ0lzSW5WdVpXNXliMnhzSWl3aVgzVnVaVzV5YjJ4c0lpd2lZMmhoYkd4bGJtZGxJaXdpWDJOb1lXeHNaVzVuWlNJc0lteHBjM1JHWVdOMGIzSnpJaXdpWDJ4cGMzUkdZV04wYjNKeklpd2lZMmhoYkd4bGJtZGxRVzVrVm1WeWFXWjVJaXdpWDJOb1lXeHNaVzVuWlVGdVpGWmxjbWxtZVNJc0ltZGxkRUYxZEdobGJuUnBZMkYwYjNKQmMzTjFjbUZ1WTJWTVpYWmxiQ0lzSWw5blpYUkJkWFJvWlc1MGFXTmhkRzl5UVhOemRYSmhibU5sVEdWMlpXd2lMQ0pwYm1sMGFXRnNhWHBsVUhKdmJXbHpaU0lzSWw5cGJtbDBhV0ZzYVhwbElpd2lYMmx6U1cxd2JHbGphWFJIY21GdWRFWnNiM2NpTENKZloyVjBVMlZ6YzJsdmJrWnliMjFWY213aUxDSmtZWFJoSWl3aVpYSnliM0lpTENKZmNtVnRiM1psVTJWemMybHZiaUlzSW5ObGMzTnBiMjRpTENKeVpXUnBjbVZqZEZSNWNHVWlMQ0pmYzJGMlpWTmxjM05wYjI0aUxDSmZibTkwYVdaNVFXeHNVM1ZpYzJOeWFXSmxjbk1pTENKZmNtVmpiM1psY2tGdVpGSmxabkpsYzJnaUxDSmxjbkp2Y25OZk1TSXNJbDlvWVc1a2JHVldhWE5wWW1sc2FYUjVRMmhoYm1kbElpd2lZM0psWkdWdWRHbGhiSE1pTENKbGJXRnBiQ0lzSW5CaGMzTjNiM0prSWl3aWNtVmthWEpsWTNSVWJ5SXNJbVZ0WVdsc1VtVmthWEpsWTNSVWJ5SXNJbUp2WkhraUxDSm5iM1J5ZFdWZmJXVjBZVjl6WldOMWNtbDBlU0lzSW1OaGNIUmphR0ZmZEc5clpXNGlMQ0pqWVhCMFkyaGhWRzlyWlc0aUxDSjRabTl5YlNJc0ltWmxkR05vWHpFaUxDSnlaWE1pTENKd2FHOXVaU0lzSW5WelpYSWlMQ0pmYUdGdVpHeGxVSEp2ZG1sa1pYSlRhV2R1U1c0aUxDSndjbTkyYVdSbGNpSXNJbk5qYjNCbGN5SXNJbkYxWlhKNVVHRnlZVzF6SWl3aVkzSmxZWFJsWDNWelpYSWlMQ0p6YUc5MWJHUkRjbVZoZEdWVmMyVnlJaXdpY0dGeVlXMXpJaXdpWVdOalpYTnpYM1J2YTJWdUlpd2ljSEp2ZG1sa1pYSmZhV1FpTENKd2NtOTJhV1JsY2tsa0lpd2laRzl0WVdsdUlpd2ljbVZrYVhKbFkzUmZkRzhpTENKMWJtUmxabWx1WldRaUxDSnphMmx3WDJoMGRIQmZjbVZrYVhKbFkzUWlMQ0pqZFhKeVpXNTBVMlZ6YzJsdmJpSXNJbTFoZVdKbFUyVnpjMmx2YmlJc0lsOXBjMVpoYkdsa1UyVnpjMmx2YmlJc0ltaGhjMFY0Y0dseVpXUWlMQ0psZUhCcGNtVnpYMkYwSWl3aVJHRjBaU0lzSW01dmR5SXNJbDlqWVd4c1VtVm1jbVZ6YUZSdmEyVnVJaXdpY21WbWNtVnphRjkwYjJ0bGJpSXNJbXAzZENJc0ltZGxkRk5sYzNOcGIyNGlMQ0poZEhSeWFXSjFkR1Z6SWl3aWMyVnpjMmx2YmtSaGRHRWlMQ0p6WlhOemFXOXVSWEp5YjNJaUxDSjFjMlZ5UlhKeWIzSWlMQ0owYVcxbFRtOTNJaXdpWlhod2FYSmxjMEYwSWl3aWNHRjViRzloWkNJc0ltVjRjQ0lzSW5KbFpuSmxjMmhsWkZObGMzTnBiMjRpTENKblpYUlZjMlZ5SWl3aWRHOXJaVzVmZEhsd1pTSXNJbVY0Y0dseVpYTmZhVzRpTENKbGNuSnZjbDlrWlhOamNtbHdkR2x2YmlJc0ltVnljbTl5WDJOdlpHVWlMQ0pqYjJSbElpd2ljSEp2ZG1sa1pYSmZkRzlyWlc0aUxDSndjbTkyYVdSbGNsOXlaV1p5WlhOb1gzUnZhMlZ1SWl3aVRXRjBhQ0lzSW5KdmRXNWtJaXdpY0dGeWMyVkpiblFpTENKM2FXNWtiM2NpTENKc2IyTmhkR2x2YmlJc0ltaGhjMmdpTENKQ2IyOXNaV0Z1SWl3aVlXTmpaWE56Vkc5clpXNGlMQ0p6YVdkdVQzVjBJaXdpYzNSaGRIVnpJaXdpWTJGc2JHSmhZMnNpTENKcFpDSXNJbk4xWW5OamNtbHdkR2x2YmlJc0luVnVjM1ZpYzJOeWFXSmxJaXdpYzNSaGRHVkRhR0Z1WjJWRmJXbDBkR1Z5Y3lJc0luTmxkQ0lzSW5KbFpuSmxjMmhVYjJ0bGJpSXNJbWx6Vm1Gc2FXUlRaWE56YVc5dUlpd2lYMmRsZEZWeWJFWnZjbEJ5YjNacFpHVnlJaXdpYUhKbFppSXNJa2x1Wm1sdWFYUjVJaXdpYm1WMGQyOXlhMUpsZEhKcFpYTWlMQ0pqYjI1emIyeGxJaXdpYkc5bklpd2liV1Z6YzJGblpTSXNJazFCV0Y5U1JWUlNTVVZUSWl3aWNtVm1jbVZ6YUZSdmEyVnVWR2x0WlhJaUxDSmpiR1ZoY2xScGJXVnZkWFFpTENKelpYUlVhVzFsYjNWMElpd2lVa1ZVVWxsZlNVNVVSVkpXUVV3aUxDSnlaV1p5WlhOb2FXNW5SR1ZtWlhKeVpXUWlMQ0p3Y205dGFYTmxJaXdpYUdWc2NHVnljMTh4SWl3aVgzSmxabkpsYzJoQlkyTmxjM05VYjJ0bGJpSXNJbkpsYzNWc2RDSXNJbkpsYzI5c2RtVWlMQ0p5WldwbFkzUWlMQ0psZG1WdWRDSXNJbVp2Y2tWaFkyZ2lMQ0o0SWl3aVpYaHdhWEpsYzBsdUlpd2ljbVZtY21WemFFUjFjbUYwYVc5dVFtVm1iM0psUlhod2FYSmxjeUlzSWw5emRHRnlkRUYxZEc5U1pXWnlaWE5vVkc5clpXNGlMQ0pmY0dWeWMybHpkRk5sYzNOcGIyNGlMQ0oyWVd4MVpTSXNJbDlmWVhkaGFYUmxjaUlzSW5WdWNtVm1JaXdpWVdSa1JYWmxiblJNYVhOMFpXNWxjaUlzSW1SdlkzVnRaVzUwSWl3aWRtbHphV0pwYkdsMGVWTjBZWFJsSWl3aWRYSnNVR0Z5WVcxeklpd2laVzVqYjJSbFZWSkpRMjl0Y0c5dVpXNTBJaXdpY0hWemFDSXNJbkYxWlhKNUlpd2lWVkpNVTJWaGNtTm9VR0Z5WVcxeklpd2lkRzlUZEhKcGJtY2lMQ0pxYjJsdUlpd2labUZqZEc5eVNXUWlMQ0ptY21sbGJtUnNlVjl1WVcxbElpd2labkpwWlc1a2JIbE9ZVzFsSWl3aVptRmpkRzl5WDNSNWNHVWlMQ0ptWVdOMGIzSlVlWEJsSWl3aWFYTnpkV1Z5SWl3aWRHOTBjQ0lzSW5GeVgyTnZaR1VpTENKamFHRnNiR1Z1WjJWZmFXUWlMQ0pqYUdGc2JHVnVaMlZKWkNJc0ltTm9ZV3hzWlc1blpVUmhkR0VpTENKamFHRnNiR1Z1WjJWRmNuSnZjaUlzSW1aaFkzUnZjbk1pTENKbWFXeDBaWElpTENKbVlXTjBiM0lpTENKaGJHd2lMQ0pqZFhKeVpXNTBUR1YyWld3aUxDSnVaWGgwVEdWMlpXd2lMQ0pqZFhKeVpXNTBRWFYwYUdWdWRHbGpZWFJwYjI1TlpYUm9iMlJ6SWl3aVgyUmxZMjlrWlVwWFZDSXNJbUZoYkNJc0luWmxjbWxtYVdWa1JtRmpkRzl5Y3lJc0lteGxibWQwYUNJc0ltRnRjaUlzSW1WNGNHOXlkSE1pWFN3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwwZHZWSEoxWlVOc2FXVnVkQzUwY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNlcyNTFiR3hkZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gdm9pZCAwICYmICh2b2lkIDApLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgZGVzYyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcbnZhciBfX2V4cG9ydFN0YXIgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19leHBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtLCBleHBvcnRzKSB7XG4gIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdm9pZCAwICYmICh2b2lkIDApLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkdvVHJ1ZUNsaWVudCA9IGV4cG9ydHMuR29UcnVlQWRtaW5BcGkgPSB2b2lkIDA7XG52YXIgR29UcnVlQWRtaW5BcGlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Hb1RydWVBZG1pbkFwaVwiKSk7XG5leHBvcnRzLkdvVHJ1ZUFkbWluQXBpID0gR29UcnVlQWRtaW5BcGlfMVtcImRlZmF1bHRcIl07XG52YXIgR29UcnVlQ2xpZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vR29UcnVlQ2xpZW50XCIpKTtcbmV4cG9ydHMuR29UcnVlQ2xpZW50ID0gR29UcnVlQ2xpZW50XzFbXCJkZWZhdWx0XCJdO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi90eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzBGQlFVRTdRVUZGVTBFc2VVSkJSa1pETERKQ1FVRmpPMEZCUTNKQ08wRkJRM2xDUkN4MVFrRkViRUpGTEhsQ1FVRlpPMEZCUlc1Q1F6dEJRVU5CUVNJc0ltNWhiV1Z6SWpwYkltVjRjRzl5ZEhNaUxDSkhiMVJ5ZFdWQlpHMXBia0Z3YVY4eElpd2lSMjlVY25WbFEyeHBaVzUwWHpFaUxDSmZYMlY0Y0c5eWRGTjBZWElpWFN3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwybHVaR1Y0TG5SeklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJiblZzYkYxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ORVRXT1JLX0ZBSUxVUkUgPSBleHBvcnRzLkVYUElSWV9NQVJHSU4gPSBleHBvcnRzLkRFRkFVTFRfSEVBREVSUyA9IGV4cG9ydHMuQVVESUVOQ0UgPSBleHBvcnRzLlNUT1JBR0VfS0VZID0gZXhwb3J0cy5HT1RSVUVfVVJMID0gdm9pZCAwO1xudmFyIHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5leHBvcnRzLkdPVFJVRV9VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo5OTk5JztcbmV4cG9ydHMuU1RPUkFHRV9LRVkgPSAnc3VwYWJhc2UuYXV0aC50b2tlbic7XG5leHBvcnRzLkFVRElFTkNFID0gJyc7XG5leHBvcnRzLkRFRkFVTFRfSEVBREVSUyA9IHtcbiAgJ1gtQ2xpZW50LUluZm8nOiBcImdvdHJ1ZS1qcy9cIi5jb25jYXQodmVyc2lvbl8xLnZlcnNpb24pXG59O1xuZXhwb3J0cy5FWFBJUllfTUFSR0lOID0gMTA7IC8vIGluIHNlY29uZHNcbmV4cG9ydHMuTkVUV09SS19GQUlMVVJFID0ge1xuICBNQVhfUkVUUklFUzogMTAsXG4gIFJFVFJZX0lOVEVSVkFMOiAyIC8vIGluIGRlY2lzZWNvbmRzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPMEZCUVVFN1FVRkRZVUVzYTBKQlFWVXNSMEZCUnl4MVFrRkJkVUk3UVVGRGNFTkJMRzFDUVVGWExFZEJRVWNzY1VKQlFYRkNPMEZCUTI1RFFTeG5Ra0ZCVVN4SFFVRkhMRVZCUVVVN1FVRkRZa0VzZFVKQlFXVXNSMEZCUnp0RlFVRkZMR1ZCUVdVc2MwSkJRV1ZETEdsQ1FVRlBPMEZCUVVVc1EwRkJSVHRCUVVNM1JFUXNjVUpCUVdFc1IwRkJSeXhGUVVGRkxFVkJRVU03UVVGRGJrSkJMSFZDUVVGbExFZEJRVWM3UlVGRE4wSkZMRmRCUVZjc1JVRkJSU3hGUVVGRk8wVkJRMlpETEdOQlFXTXNSVUZCUlN4RFFVRkRMRU5CUVVVN1EwRkRjRUlpTENKdVlXMWxjeUk2V3lKbGVIQnZjblJ6SWl3aWRtVnljMmx2Ymw4eElpd2lUVUZZWDFKRlZGSkpSVk1pTENKU1JWUlNXVjlKVGxSRlVsWkJUQ0pkTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk5emNtTXZiR2xpTDJOdmJuTjBZVzUwY3k1MGN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXMjUxYkd4ZGZRPT0iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciA9IGV4cG9ydHMuQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yID0gZXhwb3J0cy5BdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgPSBleHBvcnRzLkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yID0gZXhwb3J0cy5DdXN0b21BdXRoRXJyb3IgPSBleHBvcnRzLkF1dGhVbmtub3duRXJyb3IgPSBleHBvcnRzLmlzQXV0aEFwaUVycm9yID0gZXhwb3J0cy5BdXRoQXBpRXJyb3IgPSBleHBvcnRzLmlzQXV0aEVycm9yID0gZXhwb3J0cy5BdXRoRXJyb3IgPSB2b2lkIDA7XG52YXIgQXV0aEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEF1dGhFcnJvciwgX0Vycm9yKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihBdXRoRXJyb3IpO1xuICBmdW5jdGlvbiBBdXRoRXJyb3IobWVzc2FnZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXV0aEVycm9yKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLl9faXNBdXRoRXJyb3IgPSB0cnVlO1xuICAgIF90aGlzLm5hbWUgPSAnQXV0aEVycm9yJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdXRoRXJyb3IpO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbmV4cG9ydHMuQXV0aEVycm9yID0gQXV0aEVycm9yO1xuZnVuY3Rpb24gaXNBdXRoRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIF90eXBlb2YoZXJyb3IpID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc0F1dGhFcnJvcicgaW4gZXJyb3I7XG59XG5leHBvcnRzLmlzQXV0aEVycm9yID0gaXNBdXRoRXJyb3I7XG52YXIgQXV0aEFwaUVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXV0aEVycm9yKSB7XG4gIF9pbmhlcml0cyhBdXRoQXBpRXJyb3IsIF9BdXRoRXJyb3IpO1xuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihBdXRoQXBpRXJyb3IpO1xuICBmdW5jdGlvbiBBdXRoQXBpRXJyb3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgdmFyIF90aGlzMjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXV0aEFwaUVycm9yKTtcbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgX3RoaXMyLm5hbWUgPSAnQXV0aEFwaUVycm9yJztcbiAgICBfdGhpczIuc3RhdHVzID0gc3RhdHVzO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEF1dGhBcGlFcnJvciwgW3tcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXV0aEFwaUVycm9yO1xufShBdXRoRXJyb3IpO1xuZXhwb3J0cy5BdXRoQXBpRXJyb3IgPSBBdXRoQXBpRXJyb3I7XG5mdW5jdGlvbiBpc0F1dGhBcGlFcnJvcihlcnJvcikge1xuICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoQXBpRXJyb3InO1xufVxuZXhwb3J0cy5pc0F1dGhBcGlFcnJvciA9IGlzQXV0aEFwaUVycm9yO1xudmFyIEF1dGhVbmtub3duRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdXRoRXJyb3IyKSB7XG4gIF9pbmhlcml0cyhBdXRoVW5rbm93bkVycm9yLCBfQXV0aEVycm9yMik7XG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKEF1dGhVbmtub3duRXJyb3IpO1xuICBmdW5jdGlvbiBBdXRoVW5rbm93bkVycm9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICB2YXIgX3RoaXMzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdXRoVW5rbm93bkVycm9yKTtcbiAgICBfdGhpczMgPSBfc3VwZXIzLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgX3RoaXMzLm5hbWUgPSAnQXV0aFVua25vd25FcnJvcic7XG4gICAgX3RoaXMzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdXRoVW5rbm93bkVycm9yKTtcbn0oQXV0aEVycm9yKTtcbmV4cG9ydHMuQXV0aFVua25vd25FcnJvciA9IEF1dGhVbmtub3duRXJyb3I7XG52YXIgQ3VzdG9tQXV0aEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXV0aEVycm9yMykge1xuICBfaW5oZXJpdHMoQ3VzdG9tQXV0aEVycm9yLCBfQXV0aEVycm9yMyk7XG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKEN1c3RvbUF1dGhFcnJvcik7XG4gIGZ1bmN0aW9uIEN1c3RvbUF1dGhFcnJvcihtZXNzYWdlLCBuYW1lLCBzdGF0dXMpIHtcbiAgICB2YXIgX3RoaXM0O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21BdXRoRXJyb3IpO1xuICAgIF90aGlzNCA9IF9zdXBlcjQuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBfdGhpczQubmFtZSA9IG5hbWU7XG4gICAgX3RoaXM0LnN0YXR1cyA9IHN0YXR1cztcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG4gIF9jcmVhdGVDbGFzcyhDdXN0b21BdXRoRXJyb3IsIFt7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1c1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEN1c3RvbUF1dGhFcnJvcjtcbn0oQXV0aEVycm9yKTtcbmV4cG9ydHMuQ3VzdG9tQXV0aEVycm9yID0gQ3VzdG9tQXV0aEVycm9yO1xudmFyIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ3VzdG9tQXV0aEVycm9yKSB7XG4gIF9pbmhlcml0cyhBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciwgX0N1c3RvbUF1dGhFcnJvcik7XG4gIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKTtcbiAgZnVuY3Rpb24gQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKTtcbiAgICByZXR1cm4gX3N1cGVyNS5jYWxsKHRoaXMsICdBdXRoIHNlc3Npb24gbWlzc2luZyEnLCAnQXV0aFNlc3Npb25NaXNzaW5nRXJyb3InLCA0MDApO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IpO1xufShDdXN0b21BdXRoRXJyb3IpO1xuZXhwb3J0cy5BdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciA9IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yO1xudmFyIEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0N1c3RvbUF1dGhFcnJvcjIpIHtcbiAgX2luaGVyaXRzKEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciwgX0N1c3RvbUF1dGhFcnJvcjIpO1xuICB2YXIgX3N1cGVyNiA9IF9jcmVhdGVTdXBlcihBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IpO1xuICBmdW5jdGlvbiBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IobWVzc2FnZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IpO1xuICAgIHJldHVybiBfc3VwZXI2LmNhbGwodGhpcywgbWVzc2FnZSwgJ0F1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcicsIDQwMCk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IpO1xufShDdXN0b21BdXRoRXJyb3IpO1xuZXhwb3J0cy5BdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgPSBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3I7XG52YXIgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ3VzdG9tQXV0aEVycm9yMykge1xuICBfaW5oZXJpdHMoQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLCBfQ3VzdG9tQXV0aEVycm9yMyk7XG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcik7XG4gIGZ1bmN0aW9uIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzNTtcbiAgICB2YXIgZGV0YWlscyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKTtcbiAgICBfdGhpczUgPSBfc3VwZXI3LmNhbGwodGhpcywgbWVzc2FnZSwgJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcicsIDUwMCk7XG4gICAgX3RoaXM1LmRldGFpbHMgPSBudWxsO1xuICAgIF90aGlzNS5kZXRhaWxzID0gZGV0YWlscztcbiAgICByZXR1cm4gX3RoaXM1O1xuICB9XG4gIF9jcmVhdGVDbGFzcyhBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsIFt7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yO1xufShDdXN0b21BdXRoRXJyb3IpO1xuZXhwb3J0cy5BdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IgPSBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3I7XG52YXIgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdXN0b21BdXRoRXJyb3I0KSB7XG4gIF9pbmhlcml0cyhBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciwgX0N1c3RvbUF1dGhFcnJvcjQpO1xuICB2YXIgX3N1cGVyOCA9IF9jcmVhdGVTdXBlcihBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcik7XG4gIGZ1bmN0aW9uIEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKG1lc3NhZ2UsIHN0YXR1cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcik7XG4gICAgcmV0dXJuIF9zdXBlcjguY2FsbCh0aGlzLCBtZXNzYWdlLCAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InLCBzdGF0dXMpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IpO1xufShDdXN0b21BdXRoRXJyb3IpO1xuZXhwb3J0cy5BdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciA9IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096dEpRVUZoUVN4VFFVRlZPMFZCUVVFN1JVRkJRVHRGUVVkeVFpeHRRa0ZCV1VNc1QwRkJaVHRKUVVGQk8wbEJRVUU3U1VGRGVrSXNNRUpCUVUxQkxFOUJRVTg3U1VGSVRDeHRRa0ZCWVN4SFFVRkhMRWxCUVVrN1NVRkpOVUlzVFVGQlMwTXNTVUZCU1N4SFFVRkhMRmRCUVZjN1NVRkJRVHRGUVVONlFqdEZRVUZETzBGQlFVRXNhVU5CVGpSQ1F5eExRVUZMTzBGQlFYQkRRenRCUVZOQkxGTkJRV2RDUXl4WFFVRlhMRU5CUVVORExFdEJRV003UlVGRGVFTXNUMEZCVHl4UlFVRlBRU3hMUVVGTExFMUJRVXNzVVVGQlVTeEpRVUZKUVN4TFFVRkxMRXRCUVVzc1NVRkJTU3hKUVVGSkxHVkJRV1VzU1VGQlNVRXNTMEZCU3p0QlFVTm9SanRCUVVaQlJqdEJRVVZETEVsQlJWbEhMRmxCUVdFN1JVRkJRVHRGUVVGQk8wVkJSM2hDTEhOQ1FVRlpUaXhQUVVGbExFVkJRVVZQTEUxQlFXTTdTVUZCUVR0SlFVRkJPMGxCUTNwRExEUkNRVUZOVUN4UFFVRlBPMGxCUTJJc1QwRkJTME1zU1VGQlNTeEhRVUZITEdOQlFXTTdTVUZETVVJc1QwRkJTMDBzVFVGQlRTeEhRVUZIUVN4TlFVRk5PMGxCUVVFN1JVRkRkRUk3UlVGQlF6dEpRVUZCTzBsQlFVRXNUMEZGUkN4clFrRkJUVHROUVVOS0xFOUJRVTg3VVVGRFRFNHNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJRMEVzU1VGQlNUdFJRVU5tUkN4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzFGQlEzSkNUeXhOUVVGTkxFVkJRVVVzU1VGQlNTeERRVUZEUVR0UFFVTmtPMGxCUTBnN1JVRkJRenRGUVVGQk8wRkJRVUVzUlVGbUswSlNMRk5CUVZNN1FVRkJNME5KTzBGQmEwSkJMRk5CUVdkQ1N5eGpRVUZqTEVOQlFVTklMRXRCUVdNN1JVRkRNME1zVDBGQlQwUXNWMEZCVnl4RFFVRkRReXhMUVVGTExFTkJRVU1zU1VGQlNVRXNTMEZCU3l4RFFVRkRTaXhKUVVGSkxFdEJRVXNzWTBGQll6dEJRVU0xUkR0QlFVWkJSVHRCUVVWRExFbEJSVmxOTEdkQ1FVRnBRanRGUVVGQk8wVkJRVUU3UlVGSE5VSXNNRUpCUVZsVUxFOUJRV1VzUlVGQlJWVXNZVUZCYzBJN1NVRkJRVHRKUVVGQk8wbEJRMnBFTERSQ1FVRk5WaXhQUVVGUE8wbEJRMklzVDBGQlMwTXNTVUZCU1N4SFFVRkhMR3RDUVVGclFqdEpRVU01UWl4UFFVRkxVeXhoUVVGaExFZEJRVWRCTEdGQlFXRTdTVUZCUVR0RlFVTndRenRGUVVGRE8wRkJRVUVzUlVGUWJVTllMRk5CUVZNN1FVRkJMME5KTzBGQlVVTXNTVUZGV1ZFc1pVRkJaMEk3UlVGQlFUdEZRVUZCTzBWQlJ6TkNMSGxDUVVGWldDeFBRVUZsTEVWQlFVVkRMRWxCUVZrc1JVRkJSVTBzVFVGQll6dEpRVUZCTzBsQlFVRTdTVUZEZGtRc05FSkJRVTFRTEU5QlFVODdTVUZEWWl4UFFVRkxReXhKUVVGSkxFZEJRVWRCTEVsQlFVazdTVUZEYUVJc1QwRkJTMDBzVFVGQlRTeEhRVUZIUVN4TlFVRk5PMGxCUVVFN1JVRkRkRUk3UlVGQlF6dEpRVUZCTzBsQlFVRXNUMEZGUkN4clFrRkJUVHROUVVOS0xFOUJRVTg3VVVGRFRFNHNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJRMEVzU1VGQlNUdFJRVU5tUkN4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzFGQlEzSkNUeXhOUVVGTkxFVkJRVVVzU1VGQlNTeERRVUZEUVR0UFFVTmtPMGxCUTBnN1JVRkJRenRGUVVGQk8wRkJRVUVzUlVGbWEwTlNMRk5CUVZNN1FVRkJPVU5KTzBGQlowSkRMRWxCUlZsVExIVkNRVUYzUWp0RlFVRkJPMFZCUVVFN1JVRkRia003U1VGQlFUdEpRVUZCTERCQ1FVTlJMSFZDUVVGMVFpeEZRVUZGTEhsQ1FVRjVRaXhGUVVGRkxFZEJRVWM3UlVGREwwUTdSVUZCUXp0QlFVRkJMRVZCU0RCRFJDeGxRVUZsTzBGQlFUVkVVanRCUVVsRExFbEJSVmxWTERKQ1FVRTBRanRGUVVGQk8wVkJRVUU3UlVGRGRrTXNjVU5CUVZsaUxFOUJRV1U3U1VGQlFUdEpRVUZCTERCQ1FVTnVRa0VzVDBGQlR5eEZRVUZGTERaQ1FVRTJRaXhGUVVGRkxFZEJRVWM3UlVGRGJrUTdSVUZCUXp0QlFVRkJMRVZCU0RoRFZ5eGxRVUZsTzBGQlFXaEZVanRCUVVsRExFbEJSVmxYTERoQ1FVRXJRanRGUVVGQk8wVkJRVUU3UlVGRk1VTXNkME5CUVZsa0xFOUJRV1VzUlVGQmQwUTdTVUZCUVR0SlFVRkJMRWxCUVhSRVpTdzRSVUZCYTBRc1NVRkJTVHRKUVVGQk8wbEJRMnBHTERSQ1FVRk5aaXhQUVVGUExFVkJRVVVzWjBOQlFXZERMRVZCUVVVc1IwRkJSenRKUVVaMFJDeGpRVUZQTEVkQlFUSkRMRWxCUVVrN1NVRkhjRVFzVDBGQlMyVXNUMEZCVHl4SFFVRkhRU3hQUVVGUE8wbEJRVUU3UlVGRGVFSTdSVUZCUXp0SlFVRkJPMGxCUVVFc1QwRkZSQ3hyUWtGQlRUdE5RVU5LTEU5QlFVODdVVUZEVEdRc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlEwRXNTVUZCU1R0UlFVTm1SQ3hQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZEUVN4UFFVRlBPMUZCUTNKQ1R5eE5RVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRRU3hOUVVGTk8xRkJRMjVDVVN4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFUdFBRVU5tTzBsQlEwZzdSVUZCUXp0RlFVRkJPMEZCUVVFc1JVRmthVVJLTEdWQlFXVTdRVUZCYmtWU08wRkJaVU1zU1VGRldXRXNkVUpCUVhkQ08wVkJRVUU3UlVGQlFUdEZRVU51UXl4cFEwRkJXV2hDTEU5QlFXVXNSVUZCUlU4c1RVRkJZenRKUVVGQk8wbEJRVUVzTUVKQlEyNURVQ3hQUVVGUExFVkJRVVVzZVVKQlFYbENMRVZCUVVWUExFMUJRVTA3UlVGRGJFUTdSVUZCUXp0QlFVRkJMRVZCU0RCRFNTeGxRVUZsTzBGQlFUVkVVaUlzSW01aGJXVnpJanBiSWtGMWRHaEZjbkp2Y2lJc0ltMWxjM05oWjJVaUxDSnVZVzFsSWl3aVJYSnliM0lpTENKbGVIQnZjblJ6SWl3aWFYTkJkWFJvUlhKeWIzSWlMQ0psY25KdmNpSXNJa0YxZEdoQmNHbEZjbkp2Y2lJc0luTjBZWFIxY3lJc0ltbHpRWFYwYUVGd2FVVnljbTl5SWl3aVFYVjBhRlZ1YTI1dmQyNUZjbkp2Y2lJc0ltOXlhV2RwYm1Gc1JYSnliM0lpTENKRGRYTjBiMjFCZFhSb1JYSnliM0lpTENKQmRYUm9VMlZ6YzJsdmJrMXBjM05wYm1kRmNuSnZjaUlzSWtGMWRHaEpiblpoYkdsa1EzSmxaR1Z1ZEdsaGJITkZjbkp2Y2lJc0lrRjFkR2hKYlhCc2FXTnBkRWR5WVc1MFVtVmthWEpsWTNSRmNuSnZjaUlzSW1SbGRHRnBiSE1pTENKQmRYUm9VbVYwY25saFlteGxSbVYwWTJoRmNuSnZjaUpkTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk5emNtTXZiR2xpTDJWeWNtOXljeTUwY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNlcyNTFiR3hkZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxudmFyIF9fYXdhaXRlciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX19yZXN0ID0gdm9pZCAwICYmICh2b2lkIDApLl9fcmVzdCB8fCBmdW5jdGlvbiAocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuX25vUmVzb2x2ZUpzb25SZXNwb25zZSA9IGV4cG9ydHMuX2dlbmVyYXRlTGlua1Jlc3BvbnNlID0gZXhwb3J0cy5fc3NvUmVzcG9uc2UgPSBleHBvcnRzLl91c2VyUmVzcG9uc2UgPSBleHBvcnRzLl9zZXNzaW9uUmVzcG9uc2UgPSBleHBvcnRzLl9yZXF1ZXN0ID0gdm9pZCAwO1xudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgX2dldEVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIF9nZXRFcnJvck1lc3NhZ2UoZXJyKSB7XG4gIHJldHVybiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbn07XG52YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgcmVqZWN0KSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIE5FVFdPUktfRVJST1JfQ09ERVM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgTkVUV09SS19FUlJPUl9DT0RFUyA9IFs1MDIsIDUwMywgNTA0XTtcbiAgICAgICAgICBpZiAoISgwLCBoZWxwZXJzXzEubG9va3NMaWtlRmV0Y2hSZXNwb25zZSkoZXJyb3IpKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IGVycm9yc18xLkF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChORVRXT1JLX0VSUk9SX0NPREVTLmluY2x1ZGVzKGVycm9yLnN0YXR1cykpIHtcbiAgICAgICAgICAgIC8vIHN0YXR1cyBpbiA1MDAuLi41OTkgcmFuZ2UgLSBzZXJ2ZXIgaGFkIGFuIGVycm9yLCByZXF1ZXN0IG1pZ2h0IGJlIHJldHJ5ZWQuXG4gICAgICAgICAgICByZWplY3QobmV3IGVycm9yc18xLkF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvci5zdGF0dXMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZ290IGEgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIgdGhhdCBpcyBub3QgaW4gdGhlIDUwMC4uLjU5OSByYW5nZSAtIHNob3VsZCBub3QgcmV0cnlcbiAgICAgICAgICAgIGVycm9yLmpzb24oKS50aGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnNfMS5BdXRoQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnIpLCBlcnJvci5zdGF0dXMgfHwgNTAwKSk7XG4gICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBhIHZhbGlkIGpzb24gcmVzcG9uc2VcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnNfMS5BdXRoVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xufTtcbnZhciBfZ2V0UmVxdWVzdFBhcmFtcyA9IGZ1bmN0aW9uIF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkge1xuICB2YXIgcGFyYW1zID0ge1xuICAgIG1ldGhvZDogbWV0aG9kLFxuICAgIGhlYWRlcnM6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycykgfHwge31cbiAgfTtcbiAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIHBhcmFtcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnXG4gIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuZnVuY3Rpb24gX3JlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgdmFyIGhlYWRlcnMsIHFzLCBxdWVyeVN0cmluZywgZGF0YTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmp3dCkge1xuICAgICAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gXCJCZWFyZXIgXCIuY29uY2F0KG9wdGlvbnMuand0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbykge1xuICAgICAgICAgICAgcXNbJ3JlZGlyZWN0X3RvJ10gPSBvcHRpb25zLnJlZGlyZWN0VG87XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gT2JqZWN0LmtleXMocXMpLmxlbmd0aCA/ICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXMocXMpLnRvU3RyaW5nKCkgOiAnJztcbiAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsICsgcXVlcnlTdHJpbmcsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBub1Jlc29sdmVKc29uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvblxuICAgICAgICAgIH0sIHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBkYXRhID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy54Zm9ybSkgPyBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueGZvcm0oZGF0YSkgOiB7XG4gICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xufVxuZXhwb3J0cy5fcmVxdWVzdCA9IF9yZXF1ZXN0O1xuZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmZXRjaGVyKHVybCwgX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0Lm9rKSB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qc29uKCk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycm9yLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIF9zZXNzaW9uUmVzcG9uc2UoZGF0YSkge1xuICB2YXIgX2E7XG4gIHZhciBzZXNzaW9uID0gbnVsbDtcbiAgaWYgKGhhc1Nlc3Npb24oZGF0YSkpIHtcbiAgICBzZXNzaW9uID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgc2Vzc2lvbi5leHBpcmVzX2F0ID0gKDAsIGhlbHBlcnNfMS5leHBpcmVzQXQpKGRhdGEuZXhwaXJlc19pbik7XG4gIH1cbiAgdmFyIHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gIHJldHVybiB7XG4gICAgZGF0YToge1xuICAgICAgc2Vzc2lvbjogc2Vzc2lvbixcbiAgICAgIHVzZXI6IHVzZXJcbiAgICB9LFxuICAgIGVycm9yOiBudWxsXG4gIH07XG59XG5leHBvcnRzLl9zZXNzaW9uUmVzcG9uc2UgPSBfc2Vzc2lvblJlc3BvbnNlO1xuZnVuY3Rpb24gX3VzZXJSZXNwb25zZShkYXRhKSB7XG4gIHZhciBfYTtcbiAgdmFyIHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gIHJldHVybiB7XG4gICAgZGF0YToge1xuICAgICAgdXNlcjogdXNlclxuICAgIH0sXG4gICAgZXJyb3I6IG51bGxcbiAgfTtcbn1cbmV4cG9ydHMuX3VzZXJSZXNwb25zZSA9IF91c2VyUmVzcG9uc2U7XG5mdW5jdGlvbiBfc3NvUmVzcG9uc2UoZGF0YSkge1xuICByZXR1cm4ge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgZXJyb3I6IG51bGxcbiAgfTtcbn1cbmV4cG9ydHMuX3Nzb1Jlc3BvbnNlID0gX3Nzb1Jlc3BvbnNlO1xuZnVuY3Rpb24gX2dlbmVyYXRlTGlua1Jlc3BvbnNlKGRhdGEpIHtcbiAgdmFyIGFjdGlvbl9saW5rID0gZGF0YS5hY3Rpb25fbGluayxcbiAgICBlbWFpbF9vdHAgPSBkYXRhLmVtYWlsX290cCxcbiAgICBoYXNoZWRfdG9rZW4gPSBkYXRhLmhhc2hlZF90b2tlbixcbiAgICByZWRpcmVjdF90byA9IGRhdGEucmVkaXJlY3RfdG8sXG4gICAgdmVyaWZpY2F0aW9uX3R5cGUgPSBkYXRhLnZlcmlmaWNhdGlvbl90eXBlLFxuICAgIHJlc3QgPSBfX3Jlc3QoZGF0YSwgW1wiYWN0aW9uX2xpbmtcIiwgXCJlbWFpbF9vdHBcIiwgXCJoYXNoZWRfdG9rZW5cIiwgXCJyZWRpcmVjdF90b1wiLCBcInZlcmlmaWNhdGlvbl90eXBlXCJdKTtcbiAgdmFyIHByb3BlcnRpZXMgPSB7XG4gICAgYWN0aW9uX2xpbms6IGFjdGlvbl9saW5rLFxuICAgIGVtYWlsX290cDogZW1haWxfb3RwLFxuICAgIGhhc2hlZF90b2tlbjogaGFzaGVkX3Rva2VuLFxuICAgIHJlZGlyZWN0X3RvOiByZWRpcmVjdF90byxcbiAgICB2ZXJpZmljYXRpb25fdHlwZTogdmVyaWZpY2F0aW9uX3R5cGVcbiAgfTtcbiAgdmFyIHVzZXIgPSBPYmplY3QuYXNzaWduKHt9LCByZXN0KTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiB7XG4gICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgdXNlcjogdXNlclxuICAgIH0sXG4gICAgZXJyb3I6IG51bGxcbiAgfTtcbn1cbmV4cG9ydHMuX2dlbmVyYXRlTGlua1Jlc3BvbnNlID0gX2dlbmVyYXRlTGlua1Jlc3BvbnNlO1xuZnVuY3Rpb24gX25vUmVzb2x2ZUpzb25SZXNwb25zZShkYXRhKSB7XG4gIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy5fbm9SZXNvbHZlSnNvblJlc3BvbnNlID0gX25vUmVzb2x2ZUpzb25SZXNwb25zZTtcbi8qKlxuICogaGFzU2Vzc2lvbiBjaGVja3MgaWYgdGhlIHJlc3BvbnNlIG9iamVjdCBjb250YWlucyBhIHZhbGlkIHNlc3Npb25cbiAqIEBwYXJhbSBkYXRhIEEgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgc2Vzc2lvbiBpcyBpbiB0aGUgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gaGFzU2Vzc2lvbihkYXRhKSB7XG4gIHJldHVybiBkYXRhLmFjY2Vzc190b2tlbiAmJiBkYXRhLnJlZnJlc2hfdG9rZW4gJiYgZGF0YS5leHBpcmVzX2luO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenRCUVVGQk8wRkJVMEU3UVVGcFFrRXNTVUZCVFVFc1owSkJRV2RDTEVkQlFVY3NVMEZCYmtKQkxHZENRVUZuUWl4RFFVRkpReXhIUVVGUk8wVkJRVUVzVDBGRGFFTkJMRWRCUVVjc1EwRkJRME1zUjBGQlJ5eEpRVUZKUkN4SFFVRkhMRU5CUVVORkxFOUJRVThzU1VGQlNVWXNSMEZCUnl4RFFVRkRSeXhwUWtGQmFVSXNTVUZCU1Vnc1IwRkJSeXhEUVVGRFNTeExRVUZMTEVsQlFVbERMRWxCUVVrc1EwRkJRME1zVTBGQlV5eERRVUZEVGl4SFFVRkhMRU5CUVVNN1FVRkJRVHRCUVVWeVJpeEpRVUZOVHl4WFFVRlhMRWRCUVVjc1UwRkJaRUVzVjBGQlZ5eERRVUZWU0N4TFFVRmpMRVZCUVVWSkxFMUJRVGhDTzBWQlFVRXNUMEZCU1VNN1NVRkJRVHRKUVVGQk8wMUJRVUU3VVVGQlFUdFZRVU55UlVNc2JVSkJRVzFDTEVkQlFVY3NRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF6dFZRVU16UXl4SlFVRkpMRU5CUVVNc2IwTkJRWE5DTEVWQlFVTk9MRXRCUVVzc1EwRkJReXhGUVVGRk8xbEJRMnhEU1N4TlFVRk5MRU5CUVVNc1NVRkJTVWNzWjBOQlFYVkNMRU5CUVVOYUxHZENRVUZuUWl4RFFVRkRTeXhMUVVGTExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0WFFVTm9SU3hOUVVGTkxFbEJRVWxOTEcxQ1FVRnRRaXhEUVVGRFJTeFJRVUZSTEVOQlFVTlNMRXRCUVVzc1EwRkJRMU1zVFVGQlRTeERRVUZETEVWQlFVVTdXVUZEY2tRN1dVRkRRVXdzVFVGQlRTeERRVUZETEVsQlFVbEhMR2REUVVGMVFpeERRVUZEV2l4blFrRkJaMElzUTBGQlEwc3NTMEZCU3l4RFFVRkRMRVZCUVVWQkxFdEJRVXNzUTBGQlExTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1YwRkRNMFVzVFVGQlRUdFpRVU5NTzFsQlEwRlVMRXRCUVVzc1EwRkRSbFVzU1VGQlNTeEZRVUZGTEVOQlEwNURMRWxCUVVrc1EwRkJReXhWUVVGRFppeEhRVUZITEVWQlFVazdZMEZEV2xFc1RVRkJUU3hEUVVGRExFbEJRVWxITEhGQ1FVRlpMRU5CUVVOYUxHZENRVUZuUWl4RFFVRkRReXhIUVVGSExFTkJRVU1zUlVGQlJVa3NTMEZCU3l4RFFVRkRVeXhOUVVGTkxFbEJRVWtzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZEZEVVc1EwRkJReXhEUVVGRExGTkJRMGtzUTBGQlF5eFZRVUZEUnl4RFFVRkRMRVZCUVVrN1kwRkRXRHRqUVVOQlVpeE5RVUZOTEVOQlFVTXNTVUZCU1Vjc2VVSkJRV2RDTEVOQlFVTmFMR2RDUVVGblFpeERRVUZEYVVJc1EwRkJReXhEUVVGRExFVkJRVVZCTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNSRUxFTkJRVU1zUTBGQlF6czdVVUZEVER0UlFVRkJPMVZCUVVFN1RVRkJRVHRKUVVGQk8wVkJRVUVzUTBGRFJqdEJRVUZCTzBGQlJVUXNTVUZCVFVNc2FVSkJRV2xDTEVkQlFVY3NVMEZCY0VKQkxHbENRVUZwUWl4RFFVTnlRa01zVFVGQmVVSXNSVUZEZWtKRExFOUJRWE5DTEVWQlEzUkNReXhWUVVFMFFpeEZRVU0xUWtNc1NVRkJZU3hGUVVOWU8wVkJRMFlzU1VGQlRVTXNUVUZCVFN4SFFVRjVRanRKUVVGRlNpeE5RVUZOTEVWQlFVNUJMRTFCUVUwN1NVRkJSVXNzVDBGQlR5eEZRVUZGTEZGQlFVOHNZVUZCVUVvc1QwRkJUeXgxUWtGQlVFRXNUMEZCVHl4RFFVRkZTU3hQUVVGUExFdEJRVWs3UlVGQlJTeERRVUZGTzBWQlJXaEdMRWxCUVVsTUxFMUJRVTBzUzBGQlN5eExRVUZMTEVWQlFVVTdTVUZEY0VJc1QwRkJUMGtzVFVGQlRUczdSVUZIWmtFc1RVRkJUU3hEUVVGRFF5eFBRVUZQTzBsQlFVc3NZMEZCWXl4RlFVRkZPMFZCUVdkRExFZEJRVXRLTEU5QlFVOHNZVUZCVUVFc1QwRkJUeXgxUWtGQlVFRXNUMEZCVHl4RFFVRkZTU3hQUVVGUExFTkJRVVU3UlVGRE1VWkVMRTFCUVUwc1EwRkJRMFFzU1VGQlNTeEhRVUZIYUVJc1NVRkJTU3hEUVVGRFF5eFRRVUZUTEVOQlFVTmxMRWxCUVVrc1EwRkJRenRGUVVOc1F5eDFRMEZCV1VNc1RVRkJUU3hIUVVGTFJpeFZRVUZWTzBGQlEyNURMRU5CUVVNN1FVRmhSQ3hUUVVGelFra3NVVUZCVVN4RFFVTTFRa01zVDBGQll5eEZRVU5rVUN4TlFVRjVRaXhGUVVONlFsRXNSMEZCVnl4RlFVTllVQ3hQUVVFNFFqczdPenM3T3p0VlFVVjRRa2tzVDBGQlR5eHhRa0ZCVVVvc1QwRkJUeXhoUVVGUVFTeFBRVUZQTEhWQ1FVRlFRU3hQUVVGUExFTkJRVVZKTEU5QlFVOHNRMEZCUlR0VlFVTjJReXhKUVVGSlNpeFBRVUZQTEdGQlFWQkJMRTlCUVU4c2RVSkJRVkJCTEU5QlFVOHNRMEZCUlZFc1IwRkJSeXhGUVVGRk8xbEJRMmhDU2l4UFFVRlBMRU5CUVVNc1pVRkJaU3hEUVVGRExHOUNRVUZoU2l4UFFVRlBMRU5CUVVOUkxFZEJRVWNzUTBGQlJUczdWVUZGT1VORExFVkJRVVVzUjBGQlJ5eGhRVUZQTEdGQlFWQlVMRTlCUVU4c2RVSkJRVkJCTEU5QlFVOHNRMEZCUlZVc1MwRkJTeXh0UTBGQlNTeEZRVUZGTzFWQlF5OUNMRWxCUVVsV0xFOUJRVThzWVVGQlVFRXNUMEZCVHl4MVFrRkJVRUVzVDBGQlR5eERRVUZGVnl4VlFVRlZMRVZCUVVVN1dVRkRka0pHTEVWQlFVVXNRMEZCUXl4aFFVRmhMRU5CUVVNc1IwRkJSMVFzVDBGQlR5eERRVUZEVnl4VlFVRlZPenRWUVVWc1EwTXNWMEZCVnl4SFFVRkhReXhOUVVGTkxFTkJRVU5ETEVsQlFVa3NRMEZCUTB3c1JVRkJSU3hEUVVGRExFTkJRVU5OTEUxQlFVMHNSMEZCUnl4SFFVRkhMRWRCUVVjc1NVRkJTVU1zWlVGQlpTeERRVUZEVUN4RlFVRkZMRU5CUVVNc1EwRkJRMUVzVVVGQlVTeEZRVUZGTEVkQlFVY3NSVUZCUlR0VlFVRkJPMVZCUXpkRkxFOUJRVTFETEdOQlFXTXNRMEZETDBKYUxFOUJRVThzUlVGRFVGQXNUVUZCVFN4RlFVTk9VU3hIUVVGSExFZEJRVWRMTEZkQlFWY3NSVUZEYWtJN1dVRkJSVklzVDBGQlR5eEZRVUZRUVN4UFFVRlBPMWxCUVVWbExHRkJRV0VzUlVGQlJXNUNMRTlCUVU4c1lVRkJVRUVzVDBGQlR5eDFRa0ZCVUVFc1QwRkJUeXhEUVVGRmJVSTdWVUZCWVN4RFFVRkZMRVZCUTJ4RUxFVkJRVVVzUlVGRFJtNUNMRTlCUVU4c1lVRkJVRUVzVDBGQlR5eDFRa0ZCVUVFc1QwRkJUeXhEUVVGRlJTeEpRVUZKTEVOQlEyUTdVVUZCUVR0VlFWQkxhMElzU1VGQlNUdFZRVUZCTEd0RFFWRklMRkZCUVU4c1lVRkJVSEJDTEU5QlFVOHNkVUpCUVZCQkxFOUJRVThzUTBGQlJYRkNMRXRCUVVzc1NVRkJSM0pDTEU5QlFVOHNZVUZCVUVFc1QwRkJUeXgxUWtGQlVFRXNUMEZCVHl4RFFVRkZjVUlzUzBGQlN5eERRVUZEUkN4SlFVRkpMRU5CUVVNc1IwRkJSenRaUVVGRlFTeEpRVUZKTEc5Q1FVRlBRU3hKUVVGSkxFTkJRVVU3V1VGQlJXNURMRXRCUVVzc1JVRkJSVHRWUVVGSkxFTkJRVVU3VVVGQlFUdFJRVUZCTzFWQlFVRTdUVUZCUVR0SlFVRkJPMFZCUVVFN08wRkJka0p1Um5GRE8wRkJNRUpCTEZOQlFXVktMR05CUVdNc1EwRkRNMEphTEU5QlFXTXNSVUZEWkZBc1RVRkJlVUlzUlVGRGVrSlJMRWRCUVZjc1JVRkRXRkFzVDBGQmMwSXNSVUZEZEVKRExGVkJRVFJDTEVWQlF6VkNReXhKUVVGaE96czdPenMwUTBGRlRpeEpRVUZKY1VJc1QwRkJUeXhEUVVGRExGVkJRVU5ETEU5QlFVOHNSVUZCUlc1RExFMUJRVTBzUlVGQlNUdFpRVU55UTJsQ0xFOUJRVThzUTBGQlEwTXNSMEZCUnl4RlFVRkZWQ3hwUWtGQmFVSXNRMEZCUTBNc1RVRkJUU3hGUVVGRlF5eFBRVUZQTEVWQlFVVkRMRlZCUVZVc1JVRkJSVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZETDBST0xFbEJRVWtzUTBGQlF5eFZRVUZETmtJc1RVRkJUU3hGUVVGSk8yTkJRMllzU1VGQlNTeERRVUZEUVN4TlFVRk5MRU5CUVVORExFVkJRVVVzUlVGQlJTeE5RVUZOUkN4TlFVRk5PMk5CUXpWQ0xFbEJRVWw2UWl4UFFVRlBMR0ZCUVZCQkxFOUJRVThzZFVKQlFWQkJMRTlCUVU4c1EwRkJSVzFDTEdGQlFXRXNSVUZCUlN4UFFVRlBUU3hOUVVGTk8yTkJRM3BETEU5QlFVOUJMRTFCUVUwc1EwRkJRemxDTEVsQlFVa3NSVUZCUlR0WlFVTjBRaXhEUVVGRExFTkJRVU1zUTBGRFJFTXNTVUZCU1N4RFFVRkRMRlZCUVVOM1FpeEpRVUZKTzJOQlFVRXNUMEZCUzBrc1QwRkJUeXhEUVVGRFNpeEpRVUZKTEVOQlFVTTdXVUZCUVN4RlFVRkRMRk5CUTNoQ0xFTkJRVU1zVlVGQlEyNURMRXRCUVVzN1kwRkJRU3hQUVVGTFJ5eFhRVUZYTEVOQlFVTklMRXRCUVVzc1JVRkJSVWtzVFVGQlRTeERRVUZETzFsQlFVRXNSVUZCUXp0VlFVTnFSQ3hEUVVGRExFTkJRVU03VVVGQlFUdFJRVUZCTzFWQlFVRTdUVUZCUVR0SlFVRkJPMFZCUVVFc1EwRkRTRHM3UVVGRlJDeFRRVUZuUW5ORExHZENRVUZuUWl4RFFVRkRVQ3hKUVVGVE96dEZRVU40UXl4SlFVRkpVU3hQUVVGUExFZEJRVWNzU1VGQlNUdEZRVU5zUWl4SlFVRkpReXhWUVVGVkxFTkJRVU5VTEVsQlFVa3NRMEZCUXl4RlFVRkZPMGxCUTNCQ1VTeFBRVUZQTEhGQ1FVRlJVaXhKUVVGSkxFTkJRVVU3U1VGRGNrSlJMRTlCUVU4c1EwRkJRMFVzVlVGQlZTeEhRVUZITEhWQ1FVRlRMRVZCUVVOV0xFbEJRVWtzUTBGQlExY3NWVUZCVlN4RFFVRkRPenRGUVVWcVJDeEpRVUZOUXl4SlFVRkpMRWRCUVZNc1ZVRkJTU3hEUVVGRFFTeEpRVUZKTEcxRFFVRkxXaXhKUVVGaE8wVkJRemxETEU5QlFVODdTVUZCUlVFc1NVRkJTU3hGUVVGRk8wMUJRVVZSTEU5QlFVOHNSVUZCVUVFc1QwRkJUenROUVVGRlNTeEpRVUZKTEVWQlFVcEJPMGxCUVVrc1EwRkJSVHRKUVVGRkwwTXNTMEZCU3l4RlFVRkZPMFZCUVVrc1EwRkJSVHRCUVVOcVJEdEJRVkpCY1VNN1FVRlZRU3hUUVVGblFsY3NZVUZCWVN4RFFVRkRZaXhKUVVGVE96dEZRVU55UXl4SlFVRk5XU3hKUVVGSkxFZEJRVk1zVlVGQlNTeERRVUZEUVN4SlFVRkpMRzFEUVVGTFdpeEpRVUZoTzBWQlF6bERMRTlCUVU4N1NVRkJSVUVzU1VGQlNTeEZRVUZGTzAxQlFVVlpMRWxCUVVrc1JVRkJTa0U3U1VGQlNTeERRVUZGTzBsQlFVVXZReXhMUVVGTExFVkJRVVU3UlVGQlNTeERRVUZGTzBGQlEzaERPMEZCU0VGeFF6dEJRVXRCTEZOQlFXZENXU3haUVVGWkxFTkJRVU5rTEVsQlFWTTdSVUZEY0VNc1QwRkJUenRKUVVGRlFTeEpRVUZKTEVWQlFVcEJMRWxCUVVrN1NVRkJSVzVETEV0QlFVc3NSVUZCUlR0RlFVRkpMRU5CUVVVN1FVRkRPVUk3UVVGR1FYRkRPMEZCU1VFc1UwRkJaMEpoTEhGQ1FVRnhRaXhEUVVGRFppeEpRVUZUTzBWQlF6ZERMRWxCUVZGblFpeFhRVUZYTEVkQlFYVkZhRUlzU1VGQlNTeERRVUYwUm1kQ0xGZEJRVmM3U1VGQlJVTXNVMEZCVXl4SFFVRTBSR3BDTEVsQlFVa3NRMEZCZWtWcFFpeFRRVUZUTzBsQlFVVkRMRmxCUVZrc1IwRkJPRU5zUWl4SlFVRkpMRU5CUVRsRWEwSXNXVUZCV1R0SlFVRkZReXhYUVVGWExFZEJRV2xEYmtJc1NVRkJTU3hEUVVGb1JHMUNMRmRCUVZjN1NVRkJSVU1zYVVKQlFXbENMRWRCUVdOd1FpeEpRVUZKTEVOQlFXNURiMElzYVVKQlFXbENPMGxCUVV0RExFbEJRVWtzVlVGQlMzSkNMRWxCUVVrc1JVRkJlRVlzWjBaQlFXbEdMRU5CUVU4N1JVRkZPVVlzU1VGQlRYTkNMRlZCUVZVc1IwRkJNa0k3U1VGRGVrTk9MRmRCUVZjc1JVRkJXRUVzVjBGQlZ6dEpRVU5ZUXl4VFFVRlRMRVZCUVZSQkxGTkJRVk03U1VGRFZFTXNXVUZCV1N4RlFVRmFRU3haUVVGWk8wbEJRMXBETEZkQlFWY3NSVUZCV0VFc1YwRkJWenRKUVVOWVF5eHBRa0ZCYVVJc1JVRkJha0pCTzBkQlEwUTdSVUZGUkN4SlFVRk5VaXhKUVVGSkxIRkNRVUZqVXl4SlFVRkpMRU5CUVVVN1JVRkRPVUlzVDBGQlR6dEpRVU5NY2tJc1NVRkJTU3hGUVVGRk8wMUJRMHB6UWl4VlFVRlZMRVZCUVZaQkxGVkJRVlU3VFVGRFZsWXNTVUZCU1N4RlFVRktRVHRMUVVORU8wbEJRMFF2UXl4TFFVRkxMRVZCUVVVN1IwRkRVanRCUVVOSU8wRkJia0pCY1VNN1FVRnhRa0VzVTBGQlowSnhRaXh6UWtGQmMwSXNRMEZCUTNaQ0xFbEJRVk03UlVGRE9VTXNUMEZCVDBFc1NVRkJTVHRCUVVOaU8wRkJSa0ZGTzBGQlNVRTdPenM3TzBGQlMwRXNVMEZCVTA4c1ZVRkJWU3hEUVVGRFZDeEpRVUZUTzBWQlF6TkNMRTlCUVU5QkxFbEJRVWtzUTBGQlEzZENMRmxCUVZrc1NVRkJTWGhDTEVsQlFVa3NRMEZCUTNsQ0xHRkJRV0VzU1VGQlNYcENMRWxCUVVrc1EwRkJRMWNzVlVGQlZUdEJRVU51UlNJc0ltNWhiV1Z6SWpwYklsOW5aWFJGY25KdmNrMWxjM05oWjJVaUxDSmxjbklpTENKdGMyY2lMQ0p0WlhOellXZGxJaXdpWlhKeWIzSmZaR1Z6WTNKcGNIUnBiMjRpTENKbGNuSnZjaUlzSWtwVFQwNGlMQ0p6ZEhKcGJtZHBabmtpTENKb1lXNWtiR1ZGY25KdmNpSXNJbkpsYW1WamRDSXNJbDlmWVhkaGFYUmxjaUlzSWs1RlZGZFBVa3RmUlZKU1QxSmZRMDlFUlZNaUxDSmxjbkp2Y25OZk1TSXNJbWx1WTJ4MVpHVnpJaXdpYzNSaGRIVnpJaXdpYW5OdmJpSXNJblJvWlc0aUxDSmxJaXdpWDJkbGRGSmxjWFZsYzNSUVlYSmhiWE1pTENKdFpYUm9iMlFpTENKdmNIUnBiMjV6SWl3aWNHRnlZVzFsZEdWeWN5SXNJbUp2WkhraUxDSndZWEpoYlhNaUxDSm9aV0ZrWlhKeklpd2lYM0psY1hWbGMzUWlMQ0ptWlhSamFHVnlJaXdpZFhKc0lpd2lhbmQwSWl3aWNYTWlMQ0p4ZFdWeWVTSXNJbkpsWkdseVpXTjBWRzhpTENKeGRXVnllVk4wY21sdVp5SXNJazlpYW1WamRDSXNJbXRsZVhNaUxDSnNaVzVuZEdnaUxDSlZVa3hUWldGeVkyaFFZWEpoYlhNaUxDSjBiMU4wY21sdVp5SXNJbDlvWVc1a2JHVlNaWEYxWlhOMElpd2libTlTWlhOdmJIWmxTbk52YmlJc0ltUmhkR0VpTENKNFptOXliU0lzSW1WNGNHOXlkSE1pTENKUWNtOXRhWE5sSWl3aWNtVnpiMngyWlNJc0luSmxjM1ZzZENJc0ltOXJJaXdpWDNObGMzTnBiMjVTWlhOd2IyNXpaU0lzSW5ObGMzTnBiMjRpTENKb1lYTlRaWE56YVc5dUlpd2laWGh3YVhKbGMxOWhkQ0lzSW1WNGNHbHlaWE5mYVc0aUxDSjFjMlZ5SWl3aVgzVnpaWEpTWlhOd2IyNXpaU0lzSWw5emMyOVNaWE53YjI1elpTSXNJbDluWlc1bGNtRjBaVXhwYm10U1pYTndiMjV6WlNJc0ltRmpkR2x2Ymw5c2FXNXJJaXdpWlcxaGFXeGZiM1J3SWl3aWFHRnphR1ZrWDNSdmEyVnVJaXdpY21Wa2FYSmxZM1JmZEc4aUxDSjJaWEpwWm1sallYUnBiMjVmZEhsd1pTSXNJbkpsYzNRaUxDSndjbTl3WlhKMGFXVnpJaXdpWDI1dlVtVnpiMngyWlVwemIyNVNaWE53YjI1elpTSXNJbUZqWTJWemMxOTBiMnRsYmlJc0luSmxabkpsYzJoZmRHOXJaVzRpWFN3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dmMzSmpMMnhwWWk5bVpYUmphQzUwY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNlcyNTFiR3hkZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IFwidXNlIHN0cmljdFwiOyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG52YXIgX19jcmVhdGVCaW5kaW5nID0gdm9pZCAwICYmICh2b2lkIDApLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgZGVzYyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdlxuICB9KTtcbn0gOiBmdW5jdGlvbiAobywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWNvZGVKV1RQYXlsb2FkID0gZXhwb3J0cy5EZWZlcnJlZCA9IGV4cG9ydHMuZGVjb2RlQmFzZTY0VVJMID0gZXhwb3J0cy5yZW1vdmVJdGVtQXN5bmMgPSBleHBvcnRzLmdldEl0ZW1Bc3luYyA9IGV4cG9ydHMuc2V0SXRlbUFzeW5jID0gZXhwb3J0cy5sb29rc0xpa2VGZXRjaFJlc3BvbnNlID0gZXhwb3J0cy5yZXNvbHZlRmV0Y2ggPSBleHBvcnRzLmdldFBhcmFtZXRlckJ5TmFtZSA9IGV4cG9ydHMuaXNCcm93c2VyID0gZXhwb3J0cy51dWlkID0gZXhwb3J0cy5leHBpcmVzQXQgPSB2b2lkIDA7XG5mdW5jdGlvbiBleHBpcmVzQXQoZXhwaXJlc0luKSB7XG4gIHZhciB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCk7XG4gIHJldHVybiB0aW1lTm93ICsgZXhwaXJlc0luO1xufVxuZXhwb3J0cy5leHBpcmVzQXQgPSBleHBpcmVzQXQ7XG5mdW5jdGlvbiB1dWlkKCkge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgIHYgPSBjID09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4O1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59XG5leHBvcnRzLnV1aWQgPSB1dWlkO1xudmFyIGlzQnJvd3NlciA9IGZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJCeU5hbWUobmFtZSwgdXJsKSB7XG4gIHZhciBfYTtcbiAgaWYgKCF1cmwpIHVybCA9ICgoX2EgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSB8fCAnJztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtcXF1dL2csICdcXFxcJCYnKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnWz8mI10nICsgbmFtZSArICcoPShbXiYjXSopfCZ8I3wkKScpLFxuICAgIHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gIGlmICghcmVzdWx0cykgcmV0dXJuIG51bGw7XG4gIGlmICghcmVzdWx0c1syXSkgcmV0dXJuICcnO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMl0ucmVwbGFjZSgvXFwrL2csICcgJykpO1xufVxuZXhwb3J0cy5nZXRQYXJhbWV0ZXJCeU5hbWUgPSBnZXRQYXJhbWV0ZXJCeU5hbWU7XG52YXIgcmVzb2x2ZUZldGNoID0gZnVuY3Rpb24gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKSB7XG4gIHZhciBfZmV0Y2g7XG4gIGlmIChjdXN0b21GZXRjaCkge1xuICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfZmV0Y2ggPSBmdW5jdGlvbiBfZmV0Y2goKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBfeWllbGQkUHJvbWlzZSRyZXNvbHY7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9faW1wb3J0U3RhcihyZXF1aXJlKCdjcm9zcy1mZXRjaCcpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gKF95aWVsZCRQcm9taXNlJHJlc29sdiA9IF9jb250ZXh0LnNlbnQpLmZldGNoLmFwcGx5KF95aWVsZCRQcm9taXNlJHJlc29sdiwgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF9mZXRjaCA9IGZldGNoO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9mZXRjaC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuZXhwb3J0cy5yZXNvbHZlRmV0Y2ggPSByZXNvbHZlRmV0Y2g7XG52YXIgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSA9IGZ1bmN0aW9uIGxvb2tzTGlrZUZldGNoUmVzcG9uc2UobWF5YmVSZXNwb25zZSkge1xuICByZXR1cm4gX3R5cGVvZihtYXliZVJlc3BvbnNlKSA9PT0gJ29iamVjdCcgJiYgbWF5YmVSZXNwb25zZSAhPT0gbnVsbCAmJiAnc3RhdHVzJyBpbiBtYXliZVJlc3BvbnNlICYmICdvaycgaW4gbWF5YmVSZXNwb25zZSAmJiAnanNvbicgaW4gbWF5YmVSZXNwb25zZSAmJiB0eXBlb2YgbWF5YmVSZXNwb25zZS5qc29uID09PSAnZnVuY3Rpb24nO1xufTtcbmV4cG9ydHMubG9va3NMaWtlRmV0Y2hSZXNwb25zZSA9IGxvb2tzTGlrZUZldGNoUmVzcG9uc2U7XG4vLyBTdG9yYWdlIGhlbHBlcnNcbnZhciBzZXRJdGVtQXN5bmMgPSBmdW5jdGlvbiBzZXRJdGVtQXN5bmMoc3RvcmFnZSwga2V5LCBkYXRhKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgcmV0dXJuIHN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG59O1xuZXhwb3J0cy5zZXRJdGVtQXN5bmMgPSBzZXRJdGVtQXN5bmM7XG52YXIgZ2V0SXRlbUFzeW5jID0gZnVuY3Rpb24gZ2V0SXRlbUFzeW5jKHN0b3JhZ2UsIGtleSkge1xuICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICB2YXIgdmFsdWU7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICByZXR1cm4gc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB2YWx1ZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgX2NvbnRleHQzLnByZXYgPSA1O1xuICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gOTtcbiAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSg1KTtcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB2YWx1ZSk7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgbnVsbCwgW1s1LCA5XV0pO1xuICB9KSk7XG59O1xuZXhwb3J0cy5nZXRJdGVtQXN5bmMgPSBnZXRJdGVtQXN5bmM7XG52YXIgcmVtb3ZlSXRlbUFzeW5jID0gZnVuY3Rpb24gcmVtb3ZlSXRlbUFzeW5jKHN0b3JhZ2UsIGtleSkge1xuICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgIHJldHVybiBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQpO1xuICB9KSk7XG59O1xuZXhwb3J0cy5yZW1vdmVJdGVtQXN5bmMgPSByZW1vdmVJdGVtQXN5bmM7XG52YXIgZGVjb2RlQmFzZTY0VVJMID0gZnVuY3Rpb24gZGVjb2RlQmFzZTY0VVJMKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgLy8gYXRvYiBpcyBwcmVzZW50IGluIGFsbCBicm93c2VycyBhbmQgbm9kZWpzID49IDE2XG4gICAgLy8gYnV0IGlmIGl0IGlzIG5vdCBpdCB3aWxsIHRocm93IGEgUmVmZXJlbmNlRXJyb3IgaW4gd2hpY2ggY2FzZSB3ZSBjYW4gdHJ5IHRvIHVzZSBCdWZmZXJcbiAgICAvLyByZXBsYWNlIGFyZSBoZXJlIHRvIGNvbnZlcnQgdGhlIEJhc2U2NC1VUkwgaW50byBCYXNlNjQgd2hpY2ggaXMgd2hhdCBhdG9iIHN1cHBvcnRzXG4gICAgLy8gcmVwbGFjZSB3aXRoIC8vZyByZWdleCBhY3RzIGxpa2UgcmVwbGFjZUFsbFxuICAgIC8vIERlY29kaW5nIGJhc2U2NCB0byBVVEY4IHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzAxMDY1NTEvMTc2MjIwNDRcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGF0b2IodmFsdWUucmVwbGFjZSgvWy1dL2csICcrJykucmVwbGFjZSgvW19dL2csICcvJykpLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiAnJScgKyAoJzAwJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICB9KS5qb2luKCcnKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSB7XG4gICAgICAvLyBydW5uaW5nIG9uIG5vZGVqcyA8IDE2XG4gICAgICAvLyBCdWZmZXIgc3VwcG9ydHMgQmFzZTY0LVVSTCB0cmFuc3BhcmVudGx5XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn07XG5leHBvcnRzLmRlY29kZUJhc2U2NFVSTCA9IGRlY29kZUJhc2U2NFVSTDtcbi8qKlxuICogQSBkZWZlcnJlZCByZXByZXNlbnRzIHNvbWUgYXN5bmNocm9ub3VzIHdvcmsgdGhhdCBpcyBub3QgeWV0IGZpbmlzaGVkLCB3aGljaFxuICogbWF5IG9yIG1heSBub3QgY3VsbWluYXRlIGluIGEgdmFsdWUuXG4gKiBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbWlrZS1ub3J0aC90eXBlcy9ibG9iL21hc3Rlci9zcmMvYXN5bmMudHNcbiAqL1xudmFyIERlZmVycmVkID0gLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyhmdW5jdGlvbiBEZWZlcnJlZCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlZmVycmVkKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gIDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IERlZmVycmVkLnByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICA7XG4gICAgX3RoaXMucmVzb2x2ZSA9IHJlcztcbiAgICBfdGhpcy5yZWplY3QgPSByZWo7XG4gIH0pO1xufSk7XG5leHBvcnRzLkRlZmVycmVkID0gRGVmZXJyZWQ7XG5EZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlO1xuLy8gVGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg1NTIwMDMvaG93LXRvLWRlY29kZS1qd3QtdG9rZW4taW4tamF2YXNjcmlwdC13aXRob3V0LXVzaW5nLWEtbGlicmFyeVxuZnVuY3Rpb24gZGVjb2RlSldUUGF5bG9hZCh0b2tlbikge1xuICAvLyBSZWdleCBjaGVja3MgZm9yIGJhc2U2NHVybCBmb3JtYXRcbiAgdmFyIGJhc2U2NFVybFJlZ2V4ID0gL14oW2EtejAtOV8tXXs0fSkqKCR8W2EtejAtOV8tXXszfT0/JHxbYS16MC05Xy1dezJ9KD09KT8kKSQvaTtcbiAgdmFyIHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSldUIGlzIG5vdCB2YWxpZDogbm90IGEgSldUIHN0cnVjdHVyZScpO1xuICB9XG4gIGlmICghYmFzZTY0VXJsUmVnZXgudGVzdChwYXJ0c1sxXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBpcyBub3QgdmFsaWQ6IHBheWxvYWQgaXMgbm90IGluIGJhc2U2NHVybCBmb3JtYXQnKTtcbiAgfVxuICB2YXIgYmFzZTY0VXJsID0gcGFydHNbMV07XG4gIHJldHVybiBKU09OLnBhcnNlKCgwLCBleHBvcnRzLmRlY29kZUJhc2U2NFVSTCkoYmFzZTY0VXJsKSk7XG59XG5leHBvcnRzLmRlY29kZUpXVFBheWxvYWQgPSBkZWNvZGVKV1RQYXlsb2FkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3UVVGRlFTeFRRVUZuUWtFc1UwRkJVeXhEUVVGRFF5eFRRVUZwUWp0RlFVTjZReXhKUVVGTlF5eFBRVUZQTEVkQlFVZERMRWxCUVVrc1EwRkJRME1zUzBGQlN5eERRVUZEUXl4SlFVRkpMRU5CUVVORExFZEJRVWNzUlVGQlJTeEhRVUZITEVsQlFVa3NRMEZCUXp0RlFVTTNReXhQUVVGUFNpeFBRVUZQTEVkQlFVZEVMRk5CUVZNN1FVRkROVUk3UVVGSVFVMDdRVUZMUVN4VFFVRm5Ra01zU1VGQlNUdEZRVU5zUWl4UFFVRlBMSE5EUVVGelF5eERRVUZEUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhGUVVGRkxGVkJRVlZETEVOQlFVTTdTVUZEZUVVc1NVRkJUVU1zUTBGQlF5eEhRVUZKVWl4SlFVRkpMRU5CUVVOVExFMUJRVTBzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCU1N4RFFVRkRPMDFCUTJoRFF5eERRVUZETEVkQlFVZElMRU5CUVVNc1NVRkJTU3hIUVVGSExFZEJRVWRETEVOQlFVTXNSMEZCU1VFc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlNTeEhRVUZITzBsQlEzQkRMRTlCUVU5RkxFTkJRVU1zUTBGQlEwTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJRenRGUVVOMlFpeERRVUZETEVOQlFVTTdRVUZEU2p0QlFVNUJVRHRCUVZGUExFbEJRVTFSTEZOQlFWTXNSMEZCUnl4VFFVRmFRU3hUUVVGVE8wVkJRVUVzVDBGQlV5eFBRVUZQUXl4UlFVRlJMRXRCUVVzc1YwRkJWenRCUVVGQk8wRkJRV3BFVkN4cFFrRkJVenRCUVVWMFFpeFRRVUZuUWxVc2EwSkJRV3RDTEVOQlFVTkRMRWxCUVZrc1JVRkJSVU1zUjBGQldUczdSVUZETTBRc1NVRkJTU3hEUVVGRFFTeEhRVUZITEVWQlFVVkJMRWRCUVVjc1IwRkJSeXhoUVVGTkxHRkJRVTVETEUxQlFVMHNkVUpCUVU1QkxFMUJRVTBzUTBGQlJVTXNVVUZCVVN3d1EwRkJSVU1zU1VGQlNTeExRVUZKTEVWQlFVVTdSVUZETlVNN1JVRkRRVW9zU1VGQlNTeEhRVUZIUVN4SlFVRkpMRU5CUVVOVUxFOUJRVThzUTBGQlF5eFRRVUZUTEVWQlFVVXNUVUZCVFN4RFFVRkRPMFZCUTNSRExFbEJRVTFqTEV0QlFVc3NSMEZCUnl4SlFVRkpReXhOUVVGTkxFTkJRVU1zVDBGQlR5eEhRVUZIVGl4SlFVRkpMRWRCUVVjc2JVSkJRVzFDTEVOQlFVTTdTVUZETlVSUExFOUJRVThzUjBGQlIwWXNTMEZCU3l4RFFVRkRSeXhKUVVGSkxFTkJRVU5RTEVkQlFVY3NRMEZCUXp0RlFVTXpRaXhKUVVGSkxFTkJRVU5OTEU5QlFVOHNSVUZCUlN4UFFVRlBMRWxCUVVrN1JVRkRla0lzU1VGQlNTeERRVUZEUVN4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzVDBGQlR5eEZRVUZGTzBWQlF6RkNMRTlCUVU5RkxHdENRVUZyUWl4RFFVRkRSaXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTm9RaXhQUVVGUExFTkJRVU1zUzBGQlN5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPMEZCUXpORU8wRkJWRUZHTzBGQllVOHNTVUZCVFhGQ0xGbEJRVmtzUjBGQlJ5eFRRVUZtUVN4WlFVRlpMRU5CUVVsRExGZEJRVzFDTEVWQlFWYzdSVUZEZWtRc1NVRkJTVU1zVFVGQllUdEZRVU5xUWl4SlFVRkpSQ3hYUVVGWExFVkJRVVU3U1VGRFprTXNUVUZCVFN4SFFVRkhSQ3hYUVVGWE8wZEJRM0pDTEUxQlFVMHNTVUZCU1N4UFFVRlBSU3hMUVVGTExFdEJRVXNzVjBGQlZ5eEZRVUZGTzBsQlEzWkRSQ3hOUVVGTkxFZEJRVWM3VFVGQlFTeHJRMEZCVlVVc1NVRkJTVHRSUVVGS1FTeEpRVUZKTzAxQlFVRTdUVUZCUVN4UFFVRkpRenRSUVVGQk8xRkJRVUU3VlVGQlFUdFpRVUZCTzJOQlFVRTdZMEZCVVR0blFrRkJRU3cwUWtGQllTeGhRVUZoTzJOQlFVRXNSVUZCUXp0WlFVRkJPMk5CUVVFN1kwRkJiRU1zSzBOQlFXOURSaXhMUVVGTExEaENRVUZKUXl4SlFVRkpPMWxCUVVNN1kwRkJRVHRaUVVGQk8xbEJRVUU3WTBGQlFUdFZRVUZCTzFGQlFVRTdUVUZCUVR0SlFVRkJPMGRCUXk5RkxFMUJRVTA3U1VGRFRFWXNUVUZCVFN4SFFVRkhReXhMUVVGTE96dEZRVVZvUWl4UFFVRlBPMGxCUVVFc1QwRkJZVVFzVFVGQlRTeDVRa0ZCVXp0RlFVRkJPMEZCUTNKRExFTkJRVU03UVVGV1dYWkNMRzlDUVVGWk8wRkJXV3hDTEVsQlFVMHlRaXh6UWtGQmMwSXNSMEZCUnl4VFFVRjZRa0VzYzBKQlFYTkNMRU5CUVVsRExHRkJRWE5DTEVWQlFTdENPMFZCUXpGR0xFOUJRMFVzVVVGQlQwRXNZVUZCWVN4TlFVRkxMRkZCUVZFc1NVRkRha05CTEdGQlFXRXNTMEZCU3l4SlFVRkpMRWxCUTNSQ0xGRkJRVkVzU1VGQlNVRXNZVUZCWVN4SlFVTjZRaXhKUVVGSkxFbEJRVWxCTEdGQlFXRXNTVUZEY2tJc1RVRkJUU3hKUVVGSlFTeGhRVUZoTEVsQlEzWkNMRTlCUVZGQkxHRkJRWEZDTEVOQlFVTkRMRWxCUVVrc1MwRkJTeXhWUVVGVk8wRkJSWEpFTEVOQlFVTTdRVUZVV1RkQ0xEaENRVUZ6UWp0QlFWZHVRenRCUVVOUExFbEJRVTA0UWl4WlFVRlpMRWRCUVVjc1UwRkJaa0VzV1VGQldTeERRVU4yUWtNc1QwRkJlVUlzUlVGRGVrSkRMRWRCUVZjc1JVRkRXRU1zU1VGQlV6dEZRVUZCTEU5QlExRlFPMGxCUVVFN1RVRkJRVHRSUVVGQk8xVkJRVUU3VlVGRGFrSXNUMEZCVFVzc1QwRkJUeXhEUVVGRFJ5eFBRVUZQTEVOQlFVTkdMRWRCUVVjc1JVRkJSVWNzU1VGQlNTeERRVUZEUXl4VFFVRlRMRU5CUVVOSUxFbEJRVWtzUTBGQlF5eERRVUZETzFGQlFVRTdVVUZCUVR0VlFVRkJPMDFCUVVFN1NVRkJRVHRGUVVGQkxFTkJRMnBFTzBGQlFVRTdRVUZPV1dwRExHOUNRVUZaTzBGQlVXeENMRWxCUVUxeFF5eFpRVUZaTEVkQlFVY3NVMEZCWmtFc1dVRkJXU3hEUVVGVlRpeFBRVUY1UWl4RlFVRkZReXhIUVVGWE8wVkJRVUVzVDBGQmMwSk9PMGxCUVVFN1NVRkJRVHROUVVGQk8xRkJRVUU3VlVGQlFUdFZRVU12UlN4UFFVRk5TeXhQUVVGUExFTkJRVU5QTEU5QlFVOHNRMEZCUTA0c1IwRkJSeXhEUVVGRE8xRkJRVUU3VlVGQmJFTlBMRXRCUVVzN1ZVRkJRU3hKUVVWT1FTeExRVUZMTzFsQlFVRTdXVUZCUVR0VlFVRkJPMVZCUVVFc2EwTkJRMFFzU1VGQlNUdFJRVUZCTzFWQlFVRTdWVUZCUVN4clEwRkpTa29zU1VGQlNTeERRVUZEU3l4TFFVRkxMRU5CUVVORUxFdEJRVXNzUTBGQlF6dFJRVUZCTzFWQlFVRTdWVUZCUVR0VlFVRkJMR3REUVVWcVFrRXNTMEZCU3p0UlFVRkJPMUZCUVVFN1ZVRkJRVHROUVVGQk8wbEJRVUU3UlVGQlFTeERRVVZtTzBGQlFVRTdRVUZhV1haRExHOUNRVUZaTzBGQlkyeENMRWxCUVUxNVF5eGxRVUZsTEVkQlFVY3NVMEZCYkVKQkxHVkJRV1VzUTBGQlZWWXNUMEZCZVVJc1JVRkJSVU1zUjBGQlZ6dEZRVUZCTEU5QlFXMUNUanRKUVVGQk8wMUJRVUU3VVVGQlFUdFZRVUZCTzFWQlF6ZEdMRTlCUVUxTExFOUJRVThzUTBGQlExY3NWVUZCVlN4RFFVRkRWaXhIUVVGSExFTkJRVU03VVVGQlFUdFJRVUZCTzFWQlFVRTdUVUZCUVR0SlFVRkJPMFZCUVVFc1EwRkRPVUk3UVVGQlFUdEJRVVpaYUVNc2RVSkJRV1U3UVVGSmNrSXNTVUZCVFRKRExHVkJRV1VzUjBGQlJ5eFRRVUZzUWtFc1pVRkJaU3hEUVVGSlNpeExRVUZoTEVWQlFWazdSVUZEZGtRc1NVRkJTVHRKUVVOR08wbEJRMEU3U1VGRFFUdEpRVU5CTzBsQlEwRTdTVUZEUVN4UFFVRlBia0lzYTBKQlFXdENMRU5CUTNaQ2QwSXNTVUZCU1N4RFFVRkRUQ3hMUVVGTExFTkJRVU55UXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZEUVN4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlEyeEVNa01zUzBGQlN5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVTlVReXhIUVVGSExFTkJRVU1zVlVGQlF6TkRMRU5CUVVNN1RVRkJRU3hQUVVGTExFZEJRVWNzUjBGQlJ5eERRVUZETEVsQlFVa3NSMEZCUjBFc1EwRkJReXhEUVVGRE5FTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRGVFTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRmVVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRVUVzUlVGQlF5eERRVU5xUlVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVU5hTzBkQlEwWXNRMEZCUXl4UFFVRlBReXhEUVVGRExFVkJRVVU3U1VGRFZpeEpRVUZKUVN4RFFVRkRMRmxCUVZsRExHTkJRV01zUlVGQlJUdE5RVU12UWp0TlFVTkJPMDFCUTBFc1QwRkJUME1zVFVGQlRTeERRVUZEUXl4SlFVRkpMRU5CUVVOa0xFdEJRVXNzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUTJoRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTTdTMEZEZEVRc1RVRkJUVHROUVVOTUxFMUJRVTB5UXl4RFFVRkRPenM3UVVGSFlpeERRVUZETzBGQmRFSlpiRVFzZFVKQlFXVTdRVUYzUWpWQ096czdPenRCUVVGQkxFbEJTMkZ6UkN4UlFVRlJMRFpDUVZOdVFqdEZRVUZCTzBWQlFVRTdSVUZEUlR0RlFVTkJPMFZCUVVVc1NVRkJXU3hEUVVGRFF5eFBRVUZQTEVkQlFVY3NTVUZCU1VRc1VVRkJVU3hEUVVGRFJTeHJRa0ZCYTBJc1EwRkJReXhWUVVGRFF5eEhRVUZITEVWQlFVVkRMRWRCUVVjc1JVRkJTVHRKUVVOd1JUdEpRVU5CTzBsQlFVVXNTMEZCV1N4RFFVRkRReXhQUVVGUExFZEJRVWRHTEVkQlFVYzdTVUZGTVVJc1MwRkJXU3hEUVVGRFJ5eE5RVUZOTEVkQlFVZEdMRWRCUVVjN1JVRkROMElzUTBGQlF5eERRVUZETzBGQlEwb3NRMEZCUXp0QlFXcENTREZFTzBGQlEyZENjMFFzTWtKQlFXdENMRWRCUVhWQ1R5eFBRVUZQTzBGQmJVSm9SVHRCUVVOQkxGTkJRV2RDUXl4blFrRkJaMElzUTBGQlEwTXNTMEZCWVR0RlFVTTFRenRGUVVOQkxFbEJRVTFETEdOQlFXTXNSMEZCUnl3MlJFRkJOa1E3UlVGRmNFWXNTVUZCVFVNc1MwRkJTeXhIUVVGSFJpeExRVUZMTEVOQlFVTnNRaXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETzBWQlJUbENMRWxCUVVsdlFpeExRVUZMTEVOQlFVTkRMRTFCUVUwc1MwRkJTeXhEUVVGRExFVkJRVVU3U1VGRGRFSXNUVUZCVFN4SlFVRkpReXhMUVVGTExFTkJRVU1zZFVOQlFYVkRMRU5CUVVNN08wVkJSekZFTEVsQlFVa3NRMEZCUTBnc1kwRkJZeXhEUVVGRFNTeEpRVUZKTEVOQlFVTklMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTzBsQlEyeERMRTFCUVUwc1NVRkJTVVVzUzBGQlN5eERRVUZETEhORVFVRnpSQ3hEUVVGRE96dEZRVWQ2UlN4SlFVRk5SU3hUUVVGVExFZEJRVWRLTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1JVRkRNVUlzVDBGQlR6bENMRWxCUVVrc1EwRkJRMHNzUzBGQlN5eERRVUZETERKQ1FVRmxMRVZCUVVNMlFpeFRRVUZUTEVOQlFVTXNRMEZCUXp0QlFVTXZRenRCUVdoQ1FYSkZJaXdpYm1GdFpYTWlPbHNpWlhod2FYSmxjMEYwSWl3aVpYaHdhWEpsYzBsdUlpd2lkR2x0WlU1dmR5SXNJazFoZEdnaUxDSnliM1Z1WkNJc0lrUmhkR1VpTENKdWIzY2lMQ0psZUhCdmNuUnpJaXdpZFhWcFpDSXNJbkpsY0d4aFkyVWlMQ0pqSWl3aWNpSXNJbkpoYm1SdmJTSXNJbllpTENKMGIxTjBjbWx1WnlJc0ltbHpRbkp2ZDNObGNpSXNJbVJ2WTNWdFpXNTBJaXdpWjJWMFVHRnlZVzFsZEdWeVFubE9ZVzFsSWl3aWJtRnRaU0lzSW5WeWJDSXNJbmRwYm1SdmR5SXNJbXh2WTJGMGFXOXVJaXdpYUhKbFppSXNJbkpsWjJWNElpd2lVbVZuUlhod0lpd2ljbVZ6ZFd4MGN5SXNJbVY0WldNaUxDSmtaV052WkdWVlVrbERiMjF3YjI1bGJuUWlMQ0p5WlhOdmJIWmxSbVYwWTJnaUxDSmpkWE4wYjIxR1pYUmphQ0lzSWw5bVpYUmphQ0lzSW1abGRHTm9JaXdpWVhKbmN5SXNJbDlmWVhkaGFYUmxjaUlzSW14dmIydHpUR2xyWlVabGRHTm9VbVZ6Y0c5dWMyVWlMQ0p0WVhsaVpWSmxjM0J2Ym5ObElpd2lhbk52YmlJc0luTmxkRWwwWlcxQmMzbHVZeUlzSW5OMGIzSmhaMlVpTENKclpYa2lMQ0prWVhSaElpd2ljMlYwU1hSbGJTSXNJa3BUVDA0aUxDSnpkSEpwYm1kcFpua2lMQ0puWlhSSmRHVnRRWE41Ym1NaUxDSm5aWFJKZEdWdElpd2lkbUZzZFdVaUxDSndZWEp6WlNJc0luSmxiVzkyWlVsMFpXMUJjM2x1WXlJc0luSmxiVzkyWlVsMFpXMGlMQ0prWldOdlpHVkNZWE5sTmpSVlVrd2lMQ0poZEc5aUlpd2ljM0JzYVhRaUxDSnRZWEFpTENKamFHRnlRMjlrWlVGMElpd2ljMnhwWTJVaUxDSnFiMmx1SWl3aVpTSXNJbEpsWm1WeVpXNWpaVVZ5Y205eUlpd2lRblZtWm1WeUlpd2labkp2YlNJc0lrUmxabVZ5Y21Wa0lpd2ljSEp2YldselpTSXNJbkJ5YjIxcGMyVkRiMjV6ZEhKMVkzUnZjaUlzSW5KbGN5SXNJbkpsYWlJc0luSmxjMjlzZG1VaUxDSnlaV3BsWTNRaUxDSlFjbTl0YVhObElpd2laR1ZqYjJSbFNsZFVVR0Y1Ykc5aFpDSXNJblJ2YTJWdUlpd2lZbUZ6WlRZMFZYSnNVbVZuWlhnaUxDSndZWEowY3lJc0lteGxibWQwYUNJc0lrVnljbTl5SWl3aWRHVnpkQ0lzSW1KaGMyVTJORlZ5YkNKZExDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOXpjbU12YkdsaUwyaGxiSEJsY25NdWRITWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHR1ZFd4c1hYMD0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xudmFyIGxvY2FsU3RvcmFnZUFkYXB0ZXIgPSB7XG4gIGdldEl0ZW06IGZ1bmN0aW9uIGdldEl0ZW0oa2V5KSB7XG4gICAgaWYgKCEoMCwgaGVscGVyc18xLmlzQnJvd3NlcikoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gIH0sXG4gIHNldEl0ZW06IGZ1bmN0aW9uIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIGlmICghKDAsIGhlbHBlcnNfMS5pc0Jyb3dzZXIpKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgfSxcbiAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gcmVtb3ZlSXRlbShrZXkpIHtcbiAgICBpZiAoISgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgfVxufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbG9jYWxTdG9yYWdlQWRhcHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3UVVGQlFUdEJRVWRCTEVsQlFVMUJMRzFDUVVGdFFpeEhRVUZ4UWp0RlFVTTFRME1zVDBGQlR5eEZRVUZGTEdsQ1FVRkRReXhIUVVGSExFVkJRVWs3U1VGRFppeEpRVUZKTEVOQlFVTXNkVUpCUVZNc1IwRkJSU3hGUVVGRk8wMUJRMmhDTEU5QlFVOHNTVUZCU1RzN1NVRkhZaXhQUVVGUFF5eFZRVUZWTEVOQlFVTkRMRmxCUVZrc1EwRkJRMGdzVDBGQlR5eERRVUZEUXl4SFFVRkhMRU5CUVVNN1JVRkROME1zUTBGQlF6dEZRVU5FUnl4UFFVRlBMRVZCUVVVc2FVSkJRVU5JTEVkQlFVY3NSVUZCUlVrc1MwRkJTeXhGUVVGSk8wbEJRM1JDTEVsQlFVa3NRMEZCUXl4MVFrRkJVeXhIUVVGRkxFVkJRVVU3VFVGRGFFSTdPMGxCUjBaSUxGVkJRVlVzUTBGQlEwTXNXVUZCV1N4RFFVRkRReXhQUVVGUExFTkJRVU5JTEVkQlFVY3NSVUZCUlVrc1MwRkJTeXhEUVVGRE8wVkJRemRETEVOQlFVTTdSVUZEUkVNc1ZVRkJWU3hGUVVGRkxHOUNRVUZEVEN4SFFVRkhMRVZCUVVrN1NVRkRiRUlzU1VGQlNTeERRVUZETEhWQ1FVRlRMRWRCUVVVc1JVRkJSVHROUVVOb1FqczdTVUZIUmtNc1ZVRkJWU3hEUVVGRFF5eFpRVUZaTEVOQlFVTkhMRlZCUVZVc1EwRkJRMHdzUjBGQlJ5eERRVUZETzBWQlEzcERPME5CUTBRN1FVRkZSRTBzY1VKQlFXVlNMRzFDUVVGdFFpSXNJbTVoYldWeklqcGJJbXh2WTJGc1UzUnZjbUZuWlVGa1lYQjBaWElpTENKblpYUkpkR1Z0SWl3aWEyVjVJaXdpWjJ4dlltRnNWR2hwY3lJc0lteHZZMkZzVTNSdmNtRm5aU0lzSW5ObGRFbDBaVzBpTENKMllXeDFaU0lzSW5KbGJXOTJaVWwwWlcwaUxDSmxlSEJ2Y25SeklsMHNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5c2FXSXZiRzlqWVd3dGMzUnZjbUZuWlM1MGN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXMjUxYkd4ZGZRPT0iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucG9seWZpbGxHbG9iYWxUaGlzID0gdm9pZCAwO1xuLyoqXG4gKiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuICovXG5mdW5jdGlvbiBwb2x5ZmlsbEdsb2JhbFRoaXMoKSB7XG4gIGlmICgodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihnbG9iYWxUaGlzKSkgPT09ICdvYmplY3QnKSByZXR1cm47XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdfX21hZ2ljX18nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIG1hZ2ljJ1xuICAgIF9fbWFnaWNfXy5nbG9iYWxUaGlzID0gX19tYWdpY19fO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX21hZ2ljX187XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gZ2xvYmFscydcbiAgICAgIHNlbGYuZ2xvYmFsVGhpcyA9IHNlbGY7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLnBvbHlmaWxsR2xvYmFsVGhpcyA9IHBvbHlmaWxsR2xvYmFsVGhpcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3p0QlFVRkJPenM3UVVGSFFTeFRRVUZuUWtFc2EwSkJRV3RDTzBWQlEyaERMRWxCUVVrc1VVRkJUME1zVlVGQlZTeDVRMEZCVmtFc1ZVRkJWU3hQUVVGTExGRkJRVkVzUlVGQlJUdEZRVU53UXl4SlFVRkpPMGxCUTBaRExFMUJRVTBzUTBGQlEwTXNZMEZCWXl4RFFVRkRSQ3hOUVVGTkxFTkJRVU5GTEZOQlFWTXNSVUZCUlN4WFFVRlhMRVZCUVVVN1RVRkRia1JETEVkQlFVY3NSVUZCUlR0UlFVTklMRTlCUVU4c1NVRkJTVHROUVVOaUxFTkJRVU03VFVGRFJFTXNXVUZCV1N4RlFVRkZPMHRCUTJZc1EwRkJRenRKUVVOR08wbEJRMEZETEZOQlFWTXNRMEZCUTA0c1ZVRkJWU3hIUVVGSFRTeFRRVUZUTzBsQlEyaERPMGxCUTBFc1QwRkJUMHdzVFVGQlRTeERRVUZEUlN4VFFVRlRMRU5CUVVOSExGTkJRVk03UjBGRGJFTXNRMEZCUXl4UFFVRlBReXhEUVVGRExFVkJRVVU3U1VGRFZpeEpRVUZKTEU5QlFVOURMRWxCUVVrc1MwRkJTeXhYUVVGWExFVkJRVVU3VFVGREwwSTdUVUZEUVVFc1NVRkJTU3hEUVVGRFVpeFZRVUZWTEVkQlFVZFJMRWxCUVVrN096dEJRVWMxUWp0QlFXNUNRVU1pTENKdVlXMWxjeUk2V3lKd2IyeDVabWxzYkVkc2IySmhiRlJvYVhNaUxDSm5iRzlpWVd4VWFHbHpJaXdpVDJKcVpXTjBJaXdpWkdWbWFXNWxVSEp2Y0dWeWRIa2lMQ0p3Y205MGIzUjVjR1VpTENKblpYUWlMQ0pqYjI1bWFXZDFjbUZpYkdVaUxDSmZYMjFoWjJsalgxOGlMQ0psSWl3aWMyVnNaaUlzSW1WNGNHOXlkSE1pWFN3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dmMzSmpMMnhwWWk5d2IyeDVabWxzYkhNdWRITWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHR1ZFd4c1hYMD0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklpSXNJbTVoYldWeklqcGJYU3dpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHRkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2VzExOSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuLy8gR2VuZXJhdGVkIGJ5IGdlbnZlcnNpb24uXG5leHBvcnRzLnZlcnNpb24gPSAnMi42LjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPMEZCUVVFN1FVRkRZVUVzWlVGQlR5eEhRVUZITEU5QlFVOGlMQ0p1WVcxbGN5STZXeUpsZUhCdmNuUnpJbDBzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OXNhV0l2ZG1WeWMybHZiaTUwY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNlcyNTFiR3hkZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgX19hd2FpdGVyID0gdm9pZCAwICYmICh2b2lkIDApLl9fYXdhaXRlciB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIH1cbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBjcm9zc19mZXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcm9zcy1mZXRjaFwiKSk7XG52YXIgUG9zdGdyZXN0QnVpbGRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvc3RncmVzdEJ1aWxkZXIoYnVpbGRlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3N0Z3Jlc3RCdWlsZGVyKTtcbiAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuICAgIHRoaXMubWV0aG9kID0gYnVpbGRlci5tZXRob2Q7XG4gICAgdGhpcy51cmwgPSBidWlsZGVyLnVybDtcbiAgICB0aGlzLmhlYWRlcnMgPSBidWlsZGVyLmhlYWRlcnM7XG4gICAgdGhpcy5zY2hlbWEgPSBidWlsZGVyLnNjaGVtYTtcbiAgICB0aGlzLmJvZHkgPSBidWlsZGVyLmJvZHk7XG4gICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBidWlsZGVyLnNob3VsZFRocm93T25FcnJvcjtcbiAgICB0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsO1xuICAgIHRoaXMuYWxsb3dFbXB0eSA9IGJ1aWxkZXIuYWxsb3dFbXB0eTtcbiAgICBpZiAoYnVpbGRlci5mZXRjaCkge1xuICAgICAgdGhpcy5mZXRjaCA9IGJ1aWxkZXIuZmV0Y2g7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmZldGNoID0gY3Jvc3NfZmV0Y2hfMVtcImRlZmF1bHRcIl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZXJlJ3MgYW4gZXJyb3Igd2l0aCB0aGUgcXVlcnksIHRocm93T25FcnJvciB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBieVxuICAgKiB0aHJvd2luZyB0aGUgZXJyb3IgaW5zdGVhZCBvZiByZXR1cm5pbmcgaXQgYXMgcGFydCBvZiBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAqXG4gICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UtanMvaXNzdWVzLzkyfVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFBvc3RncmVzdEJ1aWxkZXIsIFt7XG4gICAga2V5OiBcInRocm93T25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aHJvd09uRXJyb3IoKSB7XG4gICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGhlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgLy8gaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNzd2l0Y2hpbmctc2NoZW1hc1xuICAgICAgaWYgKHRoaXMuc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2tpcFxuICAgICAgfSBlbHNlIGlmIChbJ0dFVCcsICdIRUFEJ10uaW5jbHVkZXModGhpcy5tZXRob2QpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0LVByb2ZpbGUnXSA9IHRoaXMuc2NoZW1hO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydDb250ZW50LVByb2ZpbGUnXSA9IHRoaXMuc2NoZW1hO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWV0aG9kICE9PSAnR0VUJyAmJiB0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICB9XG4gICAgICAvLyBOT1RFOiBJbnZva2Ugdy9vIGB0aGlzYCB0byBhdm9pZCBpbGxlZ2FsIGludm9jYXRpb24gZXJyb3IuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL3B1bGwvMjQ3XG4gICAgICB2YXIgX2ZldGNoID0gdGhpcy5mZXRjaDtcbiAgICAgIHZhciByZXMgPSBfZmV0Y2godGhpcy51cmwudG9TdHJpbmcoKSwge1xuICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSksXG4gICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWxcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIGVycm9yLCBkYXRhLCBjb3VudCwgc3RhdHVzLCBzdGF0dXNUZXh0LCBib2R5LCBjb3VudEhlYWRlciwgY29udGVudFJhbmdlLCBfYm9keSwgcG9zdGdyZXN0UmVzcG9uc2U7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSByZXMuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMubWV0aG9kICE9PSAnSEVBRCcpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBib2R5ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFByZWZlcjogcmV0dXJuPW1pbmltYWxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPT09ICd0ZXh0L2NzdicpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEgPSBib2R5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oZWFkZXJzWydBY2NlcHQnXSAmJiB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbit0ZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEgPSBib2R5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgY291bnRIZWFkZXIgPSAoX2EgPSB0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF0Y2goL2NvdW50PShleGFjdHxwbGFubmVkfGVzdGltYXRlZCkvKTtcbiAgICAgICAgICAgICAgICBjb250ZW50UmFuZ2UgPSAoX2IgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtcmFuZ2UnKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50SGVhZGVyICYmIGNvbnRlbnRSYW5nZSAmJiBjb250ZW50UmFuZ2UubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgY291bnQgPSBwYXJzZUludChjb250ZW50UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMudGV4dCgpO1xuICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgIF9ib2R5ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKF9ib2R5KTtcbiAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzI5NVxuICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpICYmIHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChfZCkge1xuICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMjk1XG4gICAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0ICYmIF9ib2R5ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnTm8gQ29udGVudCc7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfYm9keVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgdGhpcy5hbGxvd0VtcHR5ICYmICgoX2MgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuZGV0YWlscykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmluY2x1ZGVzKCdSZXN1bHRzIGNvbnRhaW4gMCByb3dzJykpKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBzdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoZXJyb3IgJiYgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgcG9zdGdyZXN0UmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBzdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHBvc3RncmVzdFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICByZXMgPSByZXNbXCJjYXRjaFwiXShmdW5jdGlvbiAoZmV0Y2hFcnJvcikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZldGNoRXJyb3I6IFwiLmNvbmNhdChmZXRjaEVycm9yLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICBkZXRhaWxzOiAnJyxcbiAgICAgICAgICAgICAgaGludDogJycsXG4gICAgICAgICAgICAgIGNvZGU6IGZldGNoRXJyb3IuY29kZSB8fCAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBjb3VudDogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUG9zdGdyZXN0QnVpbGRlcjtcbn0oKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9zdGdyZXN0QnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN1FVRkJRVHRCUVVGdlF5eEpRVWxPUVN4blFrRkJaMEk3UlVGaE5VTXNNRUpCUVZsRExFOUJRV2xETzBsQlFVRTdTVUZNYmtNc2RVSkJRV3RDTEVkQlFVY3NTMEZCU3p0SlFVMXNReXhKUVVGSkxFTkJRVU5ETEUxQlFVMHNSMEZCUjBRc1QwRkJUeXhEUVVGRFF5eE5RVUZOTzBsQlF6VkNMRWxCUVVrc1EwRkJRME1zUjBGQlJ5eEhRVUZIUml4UFFVRlBMRU5CUVVORkxFZEJRVWM3U1VGRGRFSXNTVUZCU1N4RFFVRkRReXhQUVVGUExFZEJRVWRJTEU5QlFVOHNRMEZCUTBjc1QwRkJUenRKUVVNNVFpeEpRVUZKTEVOQlFVTkRMRTFCUVUwc1IwRkJSMG9zVDBGQlR5eERRVUZEU1N4TlFVRk5PMGxCUXpWQ0xFbEJRVWtzUTBGQlEwTXNTVUZCU1N4SFFVRkhUQ3hQUVVGUExFTkJRVU5MTEVsQlFVazdTVUZEZUVJc1NVRkJTU3hEUVVGRFF5eHJRa0ZCYTBJc1IwRkJSMDRzVDBGQlR5eERRVUZEVFN4clFrRkJhMEk3U1VGRGNFUXNTVUZCU1N4RFFVRkRReXhOUVVGTkxFZEJRVWRRTEU5QlFVOHNRMEZCUTA4c1RVRkJUVHRKUVVNMVFpeEpRVUZKTEVOQlFVTkRMRlZCUVZVc1IwRkJSMUlzVDBGQlR5eERRVUZEVVN4VlFVRlZPMGxCUlhCRExFbEJRVWxTTEU5QlFVOHNRMEZCUTFNc1MwRkJTeXhGUVVGRk8wMUJRMnBDTEVsQlFVa3NRMEZCUTBFc1MwRkJTeXhIUVVGSFZDeFBRVUZQTEVOQlFVTlRMRXRCUVVzN1MwRkRNMElzVFVGQlRTeEpRVUZKTEU5QlFVOUJMRXRCUVVzc1MwRkJTeXhYUVVGWExFVkJRVVU3VFVGRGRrTXNTVUZCU1N4RFFVRkRRU3hMUVVGTExFZEJRVWRETEhkQ1FVRlZPMHRCUTNoQ0xFMUJRVTA3VFVGRFRDeEpRVUZKTEVOQlFVTkVMRXRCUVVzc1IwRkJSMEVzUzBGQlN6czdSVUZGZEVJN1JVRkZRVHM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlRVRXNkMEpCUVZrN1RVRkRWaXhKUVVGSkxFTkJRVU5JTEd0Q1FVRnJRaXhIUVVGSExFbEJRVWs3VFVGRE9VSXNUMEZCVHl4SlFVRkpPMGxCUTJJN1JVRkJRenRKUVVGQk8wbEJRVUVzVDBGRlJDeGpRVU5GU3l4WFFVZFJMRVZCUTFKRExGVkJRVzFHTzAxQlFVRTdUVUZGYmtZN1RVRkRRU3hKUVVGSkxFbEJRVWtzUTBGQlExSXNUVUZCVFN4TFFVRkxVeXhUUVVGVExFVkJRVVU3VVVGRE4wSTdUVUZCUVN4RFFVTkVMRTFCUVUwc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUTBNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlEySXNUVUZCVFN4RFFVRkRMRVZCUVVVN1VVRkRhRVFzU1VGQlNTeERRVUZEUlN4UFFVRlBMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVORExFMUJRVTA3VDBGRE4wTXNUVUZCVFR0UlFVTk1MRWxCUVVrc1EwRkJRMFFzVDBGQlR5eERRVUZETEdsQ1FVRnBRaXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZEUXl4TlFVRk5PenROUVVVdlF5eEpRVUZKTEVsQlFVa3NRMEZCUTBnc1RVRkJUU3hMUVVGTExFdEJRVXNzU1VGQlNTeEpRVUZKTEVOQlFVTkJMRTFCUVUwc1MwRkJTeXhOUVVGTkxFVkJRVVU3VVVGRGJrUXNTVUZCU1N4RFFVRkRSU3hQUVVGUExFTkJRVU1zWTBGQll5eERRVUZETEVkQlFVY3NhMEpCUVd0Q096dE5RVWR1UkR0TlFVTkJPMDFCUTBFc1NVRkJUVmtzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUTA0c1MwRkJTenROUVVONlFpeEpRVUZKVHl4SFFVRkhMRWRCUVVkRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTmlMRWRCUVVjc1EwRkJRMlVzVVVGQlVTeEZRVUZGTEVWQlFVVTdVVUZEY0VOb1FpeE5RVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRRU3hOUVVGTk8xRkJRMjVDUlN4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzFGQlEzSkNSU3hKUVVGSkxFVkJRVVZoTEVsQlFVa3NRMEZCUTBNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlEyUXNTVUZCU1N4RFFVRkRPMUZCUXk5Q1JTeE5RVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRRVHRQUVVOa0xFTkJRVU1zUTBGQlEyRXNTVUZCU1N4RFFVRkRMRlZCUVU5S0xFZEJRVWM3VVVGQlFTeFBRVUZKU3p0VlFVRkJPMVZCUVVFN1dVRkJRVHRqUVVGQk8yZENRVU5vUWtNc1MwRkJTeXhIUVVGSExFbEJRVWs3WjBKQlExcERMRWxCUVVrc1IwRkJSeXhKUVVGSk8yZENRVU5ZUXl4TFFVRkxMRWRCUVd0Q0xFbEJRVWs3WjBKQlF6TkNReXhOUVVGTkxFZEJRVWRVTEVkQlFVY3NRMEZCUTFNc1RVRkJUVHRuUWtGRGJrSkRMRlZCUVZVc1IwRkJSMVlzUjBGQlJ5eERRVUZEVlN4VlFVRlZPMmRDUVVGQkxFdEJSVE5DVml4SFFVRkhMRU5CUVVOWExFVkJRVVU3YTBKQlFVRTdhMEpCUVVFN1owSkJRVUU3WjBKQlFVRXNUVUZEU2l4SlFVRkpMRU5CUVVNeFFpeE5RVUZOTEV0QlFVc3NUVUZCVFR0clFrRkJRVHRyUWtGQlFUdG5Ra0ZCUVR0blFrRkJRVHRuUWtGRFdDeFBRVUZOWlN4SFFVRkhMRU5CUVVOWkxFbEJRVWtzUlVGQlJUdGpRVUZCTzJkQ1FVRjJRblpDTEVsQlFVazdaMEpCUTFZc1NVRkJTVUVzU1VGQlNTeExRVUZMTEVWQlFVVXNSVUZCUlR0clFrRkRaanRuUWtGQlFTeERRVU5FTEUxQlFVMHNTVUZCU1N4SlFVRkpMRU5CUVVOR0xFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4VlFVRlZMRVZCUVVVN2EwSkJRMmhFYjBJc1NVRkJTU3hIUVVGSGJFSXNTVUZCU1R0cFFrRkRXaXhOUVVGTkxFbEJRMHdzU1VGQlNTeERRVUZEUml4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRM1JDTEVsQlFVa3NRMEZCUTBFc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZEVnl4UlFVRlJMRU5CUVVNc2FVTkJRV2xETEVOQlFVTXNSVUZEYkVVN2EwSkJRMEZUTEVsQlFVa3NSMEZCUjJ4Q0xFbEJRVWs3YVVKQlExb3NUVUZCVFR0clFrRkRUR3RDTEVsQlFVa3NSMEZCUjB3c1NVRkJTU3hEUVVGRFZ5eExRVUZMTEVOQlFVTjRRaXhKUVVGSkxFTkJRVU03TzJOQlEzaENPMmRDUVVkSGVVSXNWMEZCVnl4SFFVRkhMRlZCUVVrc1EwRkJRek5DTEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc01FTkJRVVUwUWl4TFFVRkxMRU5CUVVNc2FVTkJRV2xETEVOQlFVTTdaMEpCUXpsRlF5eFpRVUZaTEVkQlFVY3NVMEZCUnl4RFFVRkROMElzVDBGQlR5eERRVUZET0VJc1IwRkJSeXhEUVVGRExHVkJRV1VzUTBGQlF5d3dRMEZCUlVNc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF6dG5Ra0ZEYWtVc1NVRkJTVW9zVjBGQlZ5eEpRVUZKUlN4WlFVRlpMRWxCUVVsQkxGbEJRVmtzUTBGQlEwY3NUVUZCVFN4SFFVRkhMRU5CUVVNc1JVRkJSVHRyUWtGRE1VUllMRXRCUVVzc1IwRkJSMWtzVVVGQlVTeERRVUZEU2l4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03TzJkQ1FVTnNRenRuUWtGQlFUdGpRVUZCTzJkQ1FVRkJPMmRDUVVWWkxFOUJRVTFvUWl4SFFVRkhMRU5CUVVOWkxFbEJRVWtzUlVGQlJUdGpRVUZCTzJkQ1FVRjJRblpDTEV0QlFVazdaMEpCUlZZc1NVRkJTVHRyUWtGRFJtbENMRXRCUVVzc1IwRkJSMG9zU1VGQlNTeERRVUZEVnl4TFFVRkxMRU5CUVVONFFpeExRVUZKTEVOQlFVTTdhMEpCUlhoQ08ydENRVU5CTEVsQlFVbG5ReXhMUVVGTExFTkJRVU5ETEU5QlFVOHNRMEZCUTJoQ0xFdEJRVXNzUTBGQlF5eEpRVUZKVGl4SFFVRkhMRU5CUVVOVExFMUJRVTBzUzBGQlN5eEhRVUZITEVWQlFVVTdiMEpCUXpsRFJpeEpRVUZKTEVkQlFVY3NSVUZCUlR0dlFrRkRWRVFzUzBGQlN5eEhRVUZITEVsQlFVazdiMEpCUTFwSExFMUJRVTBzUjBGQlJ5eEhRVUZITzI5Q1FVTmFReXhWUVVGVkxFZEJRVWNzU1VGQlNUczdhVUpCUlhCQ0xFTkJRVU1zVjBGQlRUdHJRa0ZEVGp0clFrRkRRU3hKUVVGSlZpeEhRVUZITEVOQlFVTlRMRTFCUVUwc1MwRkJTeXhIUVVGSExFbEJRVWx3UWl4TFFVRkpMRXRCUVVzc1JVRkJSU3hGUVVGRk8yOUNRVU55UTI5Q0xFMUJRVTBzUjBGQlJ5eEhRVUZITzI5Q1FVTmFReXhWUVVGVkxFZEJRVWNzV1VGQldUdHRRa0ZETVVJc1RVRkJUVHR2UWtGRFRFb3NTMEZCU3l4SFFVRkhPM05DUVVOT2FVSXNUMEZCVHl4RlFVRkZiRU03Y1VKQlExWTdPenRuUWtGSlRDeEpRVUZKYVVJc1MwRkJTeXhKUVVGSkxFbEJRVWtzUTBGQlEyUXNWVUZCVlN4TFFVRkpMRmRCUVVzc1lVRkJUR01zUzBGQlN5eDFRa0ZCVEVFc1MwRkJTeXhEUVVGRmEwSXNUMEZCVHl3d1EwRkJSVEZDTEZGQlFWRXNRMEZCUXl4M1FrRkJkMElzUTBGQlF5eEhRVUZGTzJ0Q1FVTnNSbEVzUzBGQlN5eEhRVUZITEVsQlFVazdhMEpCUTFwSExFMUJRVTBzUjBGQlJ5eEhRVUZITzJ0Q1FVTmFReXhWUVVGVkxFZEJRVWNzU1VGQlNUczdaMEpCUTJ4Q0xFMUJSVWRLTEV0QlFVc3NTVUZCU1N4SlFVRkpMRU5CUVVOb1FpeHJRa0ZCYTBJN2EwSkJRVUU3YTBKQlFVRTdaMEpCUVVFN1owSkJRVUVzVFVGRE5VSm5RaXhMUVVGTE8yTkJRVUU3WjBKQlNWUnRRaXhwUWtGQmFVSXNSMEZCUnp0clFrRkRlRUp1UWl4TFFVRkxMRVZCUVV4QkxFdEJRVXM3YTBKQlEweERMRWxCUVVrc1JVRkJTa0VzU1VGQlNUdHJRa0ZEU2tNc1MwRkJTeXhGUVVGTVFTeExRVUZMTzJ0Q1FVTk1ReXhOUVVGTkxFVkJRVTVCTEUxQlFVMDdhMEpCUTA1RExGVkJRVlVzUlVGQlZrRTdhVUpCUTBRN1owSkJRVUVzYVVOQlJVMWxMR2xDUVVGcFFqdGpRVUZCTzJOQlFVRTdaMEpCUVVFN1dVRkJRVHRWUVVGQk8xRkJRVUVzUTBGRGVrSTdUVUZCUVN4RlFVRkRPMDFCUTBZc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlEyNURMR3RDUVVGclFpeEZRVUZGTzFGQlF6VkNWU3hIUVVGSExFZEJRVWRCTEVkQlFVY3NVMEZCVFN4RFFVRkRMRlZCUVVNd1FpeFZRVUZWTzFWQlFVRXNUMEZCVFR0WlFVTXZRbkJDTEV0QlFVc3NSVUZCUlR0alFVTk1hVUlzVDBGQlR5eDNRa0ZCYVVKSExGVkJRVlVzUTBGQlEwZ3NUMEZCVHl4RFFVRkZPMk5CUXpWRFF5eFBRVUZQTEVWQlFVVXNSVUZCUlR0alFVTllSeXhKUVVGSkxFVkJRVVVzUlVGQlJUdGpRVU5TUXl4SlFVRkpMRVZCUVVWR0xGVkJRVlVzUTBGQlEwVXNTVUZCU1N4SlFVRkpPMkZCUXpGQ08xbEJRMFJ5UWl4SlFVRkpMRVZCUVVVc1NVRkJTVHRaUVVOV1F5eExRVUZMTEVWQlFVVXNTVUZCU1R0WlFVTllReXhOUVVGTkxFVkJRVVVzUTBGQlF6dFpRVU5VUXl4VlFVRlZMRVZCUVVVN1YwRkRZanRSUVVGQkxFTkJRVU1zUTBGQlF6czdUVUZIVEN4UFFVRlBWaXhIUVVGSExFTkJRVU5KTEVsQlFVa3NRMEZCUTFRc1YwRkJWeXhGUVVGRlF5eFZRVUZWTEVOQlFVTTdTVUZETVVNN1JVRkJRenRGUVVGQk8wRkJRVUU3UVVGcVMwaHBReUlzSW01aGJXVnpJanBiSWxCdmMzUm5jbVZ6ZEVKMWFXeGtaWElpTENKaWRXbHNaR1Z5SWl3aWJXVjBhRzlrSWl3aWRYSnNJaXdpYUdWaFpHVnljeUlzSW5OamFHVnRZU0lzSW1KdlpIa2lMQ0p6YUc5MWJHUlVhSEp2ZDA5dVJYSnliM0lpTENKemFXZHVZV3dpTENKaGJHeHZkMFZ0Y0hSNUlpd2labVYwWTJnaUxDSmpjbTl6YzE5bVpYUmphRjh4SWl3aWIyNW1kV3htYVd4c1pXUWlMQ0p2Ym5KbGFtVmpkR1ZrSWl3aWRXNWtaV1pwYm1Wa0lpd2lhVzVqYkhWa1pYTWlMQ0pmWm1WMFkyZ2lMQ0p5WlhNaUxDSjBiMU4wY21sdVp5SXNJa3BUVDA0aUxDSnpkSEpwYm1kcFpua2lMQ0owYUdWdUlpd2lYMTloZDJGcGRHVnlJaXdpWlhKeWIzSWlMQ0prWVhSaElpd2lZMjkxYm5RaUxDSnpkR0YwZFhNaUxDSnpkR0YwZFhOVVpYaDBJaXdpYjJzaUxDSjBaWGgwSWl3aWNHRnljMlVpTENKamIzVnVkRWhsWVdSbGNpSXNJbTFoZEdOb0lpd2lZMjl1ZEdWdWRGSmhibWRsSWl3aVoyVjBJaXdpYzNCc2FYUWlMQ0pzWlc1bmRHZ2lMQ0p3WVhKelpVbHVkQ0lzSWtGeWNtRjVJaXdpYVhOQmNuSmhlU0lzSW0xbGMzTmhaMlVpTENKa1pYUmhhV3h6SWl3aWNHOXpkR2R5WlhOMFVtVnpjRzl1YzJVaUxDSm1aWFJqYUVWeWNtOXlJaXdpYUdsdWRDSXNJbU52WkdVaUxDSmxlSEJ2Y25SeklsMHNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlRYjNOMFozSmxjM1JDZFdsc1pHVnlMblJ6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYmJuVnNiRjE5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IG51bGwgPT0gYXJyID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSBfaSkgeyB2YXIgX3MsIF9lLCBfeCwgX3IsIF9hcnIgPSBbXSwgX24gPSAhMCwgX2QgPSAhMTsgdHJ5IHsgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7IGlmIChPYmplY3QoX2kpICE9PSBfaSkgcmV0dXJuOyBfbiA9ICExOyB9IGVsc2UgZm9yICg7ICEoX24gPSAoX3MgPSBfeC5jYWxsKF9pKSkuZG9uZSkgJiYgKF9hcnIucHVzaChfcy52YWx1ZSksIF9hcnIubGVuZ3RoICE9PSBpKTsgX24gPSAhMCk7IH0gY2F0Y2ggKGVycikgeyBfZCA9ICEwLCBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBudWxsICE9IF9pW1wicmV0dXJuXCJdICYmIChfciA9IF9pW1wicmV0dXJuXCJdKCksIE9iamVjdChfcikgIT09IF9yKSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbnZhciBfX2ltcG9ydERlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJcIikpO1xudmFyIFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXCIpKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogUG9zdGdSRVNUIGNsaWVudC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGFiYXNlIC0gVHlwZXMgZm9yIHRoZSBzY2hlbWEgZnJvbSB0aGUgW3R5cGVcbiAqIGdlbmVyYXRvcl0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9yZWZlcmVuY2UvamF2YXNjcmlwdC9uZXh0L3R5cGVzY3JpcHQtc3VwcG9ydClcbiAqXG4gKiBAdHlwZVBhcmFtIFNjaGVtYU5hbWUgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvLiBNdXN0IGJlIGEgc3RyaW5nXG4gKiBsaXRlcmFsLCB0aGUgc2FtZSBvbmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gSWYgdGhlIHNjaGVtYSBpcyBub3RcbiAqIGBcInB1YmxpY1wiYCwgdGhpcyBtdXN0IGJlIHN1cHBsaWVkIG1hbnVhbGx5LlxuICovXG52YXIgUG9zdGdyZXN0Q2xpZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gVE9ETzogQWRkIGJhY2sgc2hvdWxkVGhyb3dPbkVycm9yIG9uY2Ugd2UgZmlndXJlIG91dCB0aGUgdHlwaW5nc1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBvc3RnUkVTVCBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgLSBVUkwgb2YgdGhlIFBvc3RnUkVTVCBlbmRwb2ludFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyAtIEN1c3RvbSBoZWFkZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnNjaGVtYSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG9cbiAgICogQHBhcmFtIG9wdGlvbnMuZmV0Y2ggLSBDdXN0b20gZmV0Y2hcbiAgICovXG4gIGZ1bmN0aW9uIFBvc3RncmVzdENsaWVudCh1cmwpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICBfcmVmJGhlYWRlcnMgPSBfcmVmLmhlYWRlcnMsXG4gICAgICBoZWFkZXJzID0gX3JlZiRoZWFkZXJzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkaGVhZGVycyxcbiAgICAgIHNjaGVtYSA9IF9yZWYuc2NoZW1hLFxuICAgICAgZmV0Y2ggPSBfcmVmLmZldGNoO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3N0Z3Jlc3RDbGllbnQpO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uc3RhbnRzXzEuREVGQVVMVF9IRUFERVJTKSwgaGVhZGVycyk7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgcXVlcnkgb24gYSB0YWJsZSBvciBhIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhQb3N0Z3Jlc3RDbGllbnQsIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShyZWxhdGlvbikge1xuICAgICAgdmFyIHVybCA9IG5ldyBVUkwoXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL1wiKS5jb25jYXQocmVsYXRpb24pKTtcbiAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzFbXCJkZWZhdWx0XCJdKHVybCwge1xuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpLFxuICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICBmZXRjaDogdGhpcy5mZXRjaFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcbiAgICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgICAqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJwY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBycGMoZm4pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICAgIF9yZWYyJGhlYWQgPSBfcmVmMi5oZWFkLFxuICAgICAgICBoZWFkID0gX3JlZjIkaGVhZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRoZWFkLFxuICAgICAgICBjb3VudCA9IF9yZWYyLmNvdW50O1xuICAgICAgdmFyIG1ldGhvZDtcbiAgICAgIHZhciB1cmwgPSBuZXcgVVJMKFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9ycGMvXCIpLmNvbmNhdChmbikpO1xuICAgICAgdmFyIGJvZHk7XG4gICAgICBpZiAoaGVhZCkge1xuICAgICAgICBtZXRob2QgPSAnSEVBRCc7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGFyZ3MpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgbmFtZSA9IF9yZWY0WzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfcmVmNFsxXTtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCBcIlwiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgYm9keSA9IGFyZ3M7XG4gICAgICB9XG4gICAgICB2YXIgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyk7XG4gICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgaGVhZGVyc1snUHJlZmVyJ10gPSBcImNvdW50PVwiLmNvbmNhdChjb3VudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMVtcImRlZmF1bHRcIl0oe1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQb3N0Z3Jlc3RDbGllbnQ7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBvc3RncmVzdENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenRCUVVGQk8wRkJRMEU3UVVGRlFUdEJRVWRCT3pzN096czdPenM3TzBGQlFVRXNTVUZWY1VKQkxHVkJRV1U3UlVGamJFTTdSVUZEUVRzN096czdPenM3TzBWQlUwRXNlVUpCUTBWRExFZEJRVmNzUlVGVFREdEpRVUZCTEN0RlFVRkdMRVZCUVVVN1RVRkJRU3h2UWtGUVNrTXNUMEZCVHp0TlFVRlFRU3hQUVVGUExEWkNRVUZITEVWQlFVVTdUVUZEV2tNc1RVRkJUU3hSUVVGT1FTeE5RVUZOTzAxQlEwNURMRXRCUVVzc1VVRkJURUVzUzBGQlN6dEpRVUZCTzBsQlQxQXNTVUZCU1N4RFFVRkRTQ3hIUVVGSExFZEJRVWRCTEVkQlFVYzdTVUZEWkN4SlFVRkpMRU5CUVVORExFOUJRVThzYlVOQlFWRkhMREpDUVVGbExFZEJRVXRJTEU5QlFVOHNRMEZCUlR0SlFVTnFSQ3hKUVVGSkxFTkJRVU5ETEUxQlFVMHNSMEZCUjBFc1RVRkJUVHRKUVVOd1FpeEpRVUZKTEVOQlFVTkRMRXRCUVVzc1IwRkJSMEVzUzBGQlN6dEZRVU53UWp0RlFWVkJPenM3T3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVV0QkxHTkJRVXRGTEZGQlFXZENPMDFCUTI1Q0xFbEJRVTFNTEVkQlFVY3NSMEZCUnl4SlFVRkpUU3hIUVVGSExGZEJRVWtzU1VGQlNTeERRVUZEVGl4SFFVRkhMR05CUVVsTExGRkJRVkVzUlVGQlJ6dE5RVU01UXl4UFFVRlBMRWxCUVVsRkxHdERRVUZ4UWl4RFFVRmpVQ3hIUVVGSExFVkJRVVU3VVVGRGFrUkRMRTlCUVU4c2IwSkJRVThzU1VGQlNTeERRVUZEUVN4UFFVRlBMRU5CUVVVN1VVRkROVUpETEUxQlFVMHNSVUZCUlN4SlFVRkpMRU5CUVVOQkxFMUJRVTA3VVVGRGJrSkRMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU5CTzA5QlEySXNRMEZCUXp0SlFVTktPMGxCUlVFN096czdPenM3T3pzN096czdPenM3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFYRkNRU3hoUVVsRlN5eEZRVUZuUWl4RlFWRldPMDFCUVVFc1NVRlFUa01zTWtWQlFUQkNMRVZCUVVVN1RVRkJRU3huUmtGUGVFSXNSVUZCUlR0UlFVRkJMRzFDUVV4S1F5eEpRVUZKTzFGQlFVcEJMRWxCUVVrc01rSkJRVWNzUzBGQlN6dFJRVU5hUXl4TFFVRkxMRk5CUVV4QkxFdEJRVXM3VFVGalVDeEpRVUZKUXl4TlFVRjFRanROUVVNelFpeEpRVUZOV2l4SFFVRkhMRWRCUVVjc1NVRkJTVTBzUjBGQlJ5eFhRVUZKTEVsQlFVa3NRMEZCUTA0c1IwRkJSeXhyUWtGQlVWRXNSVUZCUlN4RlFVRkhPMDFCUXpWRExFbEJRVWxMTEVsQlFYbENPMDFCUXpkQ0xFbEJRVWxJTEVsQlFVa3NSVUZCUlR0UlFVTlNSU3hOUVVGTkxFZEJRVWNzVFVGQlRUdFJRVU5tUlN4TlFVRk5MRU5CUVVORExFOUJRVThzUTBGQlEwNHNTVUZCU1N4RFFVRkRMRU5CUVVOUExFOUJRVThzUTBGQlF5eHBRa0ZCYTBJN1ZVRkJRVHRaUVVGb1FrTXNTVUZCU1R0WlFVRkZReXhMUVVGTE8xVkJRM2hEYkVJc1IwRkJSeXhEUVVGRGJVSXNXVUZCV1N4RFFVRkRReXhOUVVGTkxFTkJRVU5JTEVsQlFVa3NXVUZCUzBNc1MwRkJTeXhGUVVGSE8xRkJRek5ETEVOQlFVTXNRMEZCUXp0UFFVTklMRTFCUVUwN1VVRkRURTRzVFVGQlRTeEhRVUZITEUxQlFVMDdVVUZEWmtNc1NVRkJTU3hIUVVGSFNpeEpRVUZKT3p0TlFVZGlMRWxCUVUxU0xFOUJRVThzY1VKQlFWRXNTVUZCU1N4RFFVRkRRU3hQUVVGUExFTkJRVVU3VFVGRGJrTXNTVUZCU1ZVc1MwRkJTeXhGUVVGRk8xRkJRMVJXTEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc2JVSkJRVmxWTEV0QlFVc3NRMEZCUlRzN1RVRkhkRU1zVDBGQlR5eEpRVUZKVlN4dFEwRkJjMElzUTBGQlF6dFJRVU5vUTFRc1RVRkJUU3hGUVVGT1FTeE5RVUZOTzFGQlEwNWFMRWRCUVVjc1JVRkJTRUVzUjBGQlJ6dFJRVU5JUXl4UFFVRlBMRVZCUVZCQkxFOUJRVTg3VVVGRFVFTXNUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJRMEVzVFVGQlRUdFJRVU51UWxjc1NVRkJTU3hGUVVGS1FTeEpRVUZKTzFGQlEwcFdMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU5CTEV0QlFVczdVVUZEYWtKdFFpeFZRVUZWTEVWQlFVVTdUMEZEZDBNc1EwRkJRenRKUVVONlJEdEZRVUZETzBWQlFVRTdRVUZCUVR0QlFYUkpTRU1pTENKdVlXMWxjeUk2V3lKUWIzTjBaM0psYzNSRGJHbGxiblFpTENKMWNtd2lMQ0pvWldGa1pYSnpJaXdpYzJOb1pXMWhJaXdpWm1WMFkyZ2lMQ0pqYjI1emRHRnVkSE5mTVNJc0luSmxiR0YwYVc5dUlpd2lWVkpNSWl3aVVHOXpkR2R5WlhOMFVYVmxjbmxDZFdsc1pHVnlYekVpTENKbWJpSXNJbUZ5WjNNaUxDSm9aV0ZrSWl3aVkyOTFiblFpTENKdFpYUm9iMlFpTENKaWIyUjVJaXdpVDJKcVpXTjBJaXdpWlc1MGNtbGxjeUlzSW1admNrVmhZMmdpTENKdVlXMWxJaXdpZG1Gc2RXVWlMQ0p6WldGeVkyaFFZWEpoYlhNaUxDSmhjSEJsYm1RaUxDSlFiM04wWjNKbGMzUkdhV3gwWlhKQ2RXbHNaR1Z5WHpFaUxDSmhiR3h2ZDBWdGNIUjVJaXdpWlhod2IzSjBjeUpkTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlVHOXpkR2R5WlhOMFEyeHBaVzUwTG5SeklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJiblZzYkYxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBudWxsID09IGFyciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gX2kpIHsgdmFyIF9zLCBfZSwgX3gsIF9yLCBfYXJyID0gW10sIF9uID0gITAsIF9kID0gITE7IHRyeSB7IGlmIChfeCA9IChfaSA9IF9pLmNhbGwoYXJyKSkubmV4dCwgMCA9PT0gaSkgeyBpZiAoT2JqZWN0KF9pKSAhPT0gX2kpIHJldHVybjsgX24gPSAhMTsgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApOyB9IGNhdGNoIChlcnIpIHsgX2QgPSAhMCwgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgbnVsbCAhPSBfaVtcInJldHVyblwiXSAmJiAoX3IgPSBfaVtcInJldHVyblwiXSgpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxudmFyIF9faW1wb3J0RGVmYXVsdCA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXCIpKTtcbnZhciBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUG9zdGdyZXN0VHJhbnNmb3JtQnUpIHtcbiAgX2luaGVyaXRzKFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsIF9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUG9zdGdyZXN0RmlsdGVyQnVpbGRlcik7XG4gIGZ1bmN0aW9uIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoUG9zdGdyZXN0RmlsdGVyQnVpbGRlciwgW3tcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIFRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBvZiBgY29sdW1uYCBpcyBOVUxMLCB5b3Ugc2hvdWxkIHVzZSBgLmlzKClgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcShjb2x1bW4sIHZhbHVlKSB7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgXCJlcS5cIi5jb25jYXQodmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbm90IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJuZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVxKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcIm5lcS5cIi5jb25jYXQodmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJndFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBndChjb2x1bW4sIHZhbHVlKSB7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgXCJndC5cIi5jb25jYXQodmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJndGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3RlKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcImd0ZS5cIi5jb25jYXQodmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsdChjb2x1bW4sIHZhbHVlKSB7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgXCJsdC5cIi5jb25jYXQodmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbHRlKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcImx0ZS5cIi5jb25jYXQodmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImxpa2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlrZShjb2x1bW4sIHBhdHRlcm4pIHtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcImxpa2UuXCIuY29uY2F0KHBhdHRlcm4pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaWxpa2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWxpa2UoY29sdW1uLCBwYXR0ZXJuKSB7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgXCJpbGlrZS5cIi5jb25jYXQocGF0dGVybikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogRm9yIG5vbi1ib29sZWFuIGNvbHVtbnMsIHRoaXMgaXMgb25seSByZWxldmFudCBmb3IgY2hlY2tpbmcgaWYgdGhlIHZhbHVlIG9mXG4gICAgICogYGNvbHVtbmAgaXMgTlVMTCBieSBzZXR0aW5nIGB2YWx1ZWAgdG8gYG51bGxgLlxuICAgICAqXG4gICAgICogRm9yIGJvb2xlYW4gY29sdW1ucywgeW91IGNhbiBhbHNvIHNldCBgdmFsdWVgIHRvIGB0cnVlYCBvciBgZmFsc2VgIGFuZCBpdFxuICAgICAqIHdpbGwgYmVoYXZlIHRoZSBzYW1lIHdheSBhcyBgLmVxKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXMoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIFwiaXMuXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGluY2x1ZGVkIGluIHRoZSBgdmFsdWVzYCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIGFycmF5IHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luKGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgICB2YXIgY2xlYW5lZFZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgLy8gaGFuZGxlIHBvc3RncmVzdCByZXNlcnZlZCBjaGFyYWN0ZXJzXG4gICAgICAgIC8vIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi92Ny4wLjAvYXBpLmh0bWwjcmVzZXJ2ZWQtY2hhcmFjdGVyc1xuICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnICYmIG5ldyBSZWdFeHAoJ1ssKCldJykudGVzdChzKSkgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChzLCBcIlxcXCJcIik7ZWxzZSByZXR1cm4gXCJcIi5jb25jYXQocyk7XG4gICAgICB9KS5qb2luKCcsJyk7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgXCJpbi4oXCIuY29uY2F0KGNsZWFuZWRWYWx1ZXMsIFwiKVwiKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogYGNvbHVtbmAgY29udGFpbnMgZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjb250YWluc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250YWlucyhjb2x1bW4sIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyByYW5nZSB0eXBlcyBjYW4gYmUgaW5jbHVzaXZlICdbJywgJ10nIG9yIGV4Y2x1c2l2ZSAnKCcsICcpJyBzbyBqdXN0XG4gICAgICAgIC8vIGtlZXAgaXQgc2ltcGxlIGFuZCBhY2NlcHQgYSBzdHJpbmdcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIFwiY3MuXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIGFycmF5XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcImNzLntcIi5jb25jYXQodmFsdWUuam9pbignLCcpLCBcIn1cIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8ganNvblxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgXCJjcy5cIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYGNvbHVtbmAgaXMgY29udGFpbmVkIGJ5IGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGFpbmVkQnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbmVkQnkoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gcmFuZ2VcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIFwiY2QuXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIGFycmF5XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcImNkLntcIi5jb25jYXQodmFsdWUuam9pbignLCcpLCBcIn1cIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8ganNvblxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgXCJjZC5cIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgKiBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJhbmdlR3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZ2VHdChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgXCJzci5cIi5jb25jYXQocmFuZ2UpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgICAqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW5cbiAgICAgKiBgcmFuZ2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VHdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZ2VHdGUoY29sdW1uLCByYW5nZSkge1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIFwibnhsLlwiLmNvbmNhdChyYW5nZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAgICogYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyYW5nZUx0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmdlTHQoY29sdW1uLCByYW5nZSkge1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIFwic2wuXCIuY29uY2F0KHJhbmdlKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgKiBgY29sdW1uYCBpcyBlaXRoZXIgY29udGFpbmVkIGluIGByYW5nZWAgb3IgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluXG4gICAgICogYHJhbmdlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJhbmdlTHRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmdlTHRlKGNvbHVtbiwgcmFuZ2UpIHtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcIm54ci5cIi5jb25jYXQocmFuZ2UpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXNcbiAgICAgKiBtdXR1YWxseSBleGNsdXNpdmUgdG8gYHJhbmdlYCBhbmQgdGhlcmUgY2FuIGJlIG5vIGVsZW1lbnQgYmV0d2VlbiB0aGUgdHdvXG4gICAgICogcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VBZGphY2VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYW5nZUFkamFjZW50KGNvbHVtbiwgcmFuZ2UpIHtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcImFkai5cIi5jb25jYXQocmFuZ2UpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBhcnJheSBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogYGNvbHVtbmAgYW5kIGB2YWx1ZWAgaGF2ZSBhbiBlbGVtZW50IGluIGNvbW1vbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgYXJyYXkgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhcnJheSBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm92ZXJsYXBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJsYXBzKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIHJhbmdlXG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcIm92LlwiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIFwib3Yue1wiLmNvbmNhdCh2YWx1ZS5qb2luKCcsJyksIFwifVwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgdGV4dCBhbmQgdHN2ZWN0b3IgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogYGNvbHVtbmAgbWF0Y2hlcyB0aGUgcXVlcnkgc3RyaW5nIGluIGBxdWVyeWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHRleHQgb3IgdHN2ZWN0b3IgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0ZXh0IHRvIG1hdGNoIHdpdGhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBUaGUgdGV4dCBzZWFyY2ggY29uZmlndXJhdGlvbiB0byB1c2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50eXBlIC0gQ2hhbmdlIGhvdyB0aGUgYHF1ZXJ5YCB0ZXh0IGlzIGludGVycHJldGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFNlYXJjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0U2VhcmNoKGNvbHVtbiwgcXVlcnkpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgY29uZmlnID0gX3JlZi5jb25maWcsXG4gICAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG4gICAgICB2YXIgdHlwZVBhcnQgPSAnJztcbiAgICAgIGlmICh0eXBlID09PSAncGxhaW4nKSB7XG4gICAgICAgIHR5cGVQYXJ0ID0gJ3BsJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3BocmFzZScpIHtcbiAgICAgICAgdHlwZVBhcnQgPSAncGgnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnd2Vic2VhcmNoJykge1xuICAgICAgICB0eXBlUGFydCA9ICd3JztcbiAgICAgIH1cbiAgICAgIHZhciBjb25maWdQYXJ0ID0gY29uZmlnID09PSB1bmRlZmluZWQgPyAnJyA6IFwiKFwiLmNvbmNhdChjb25maWcsIFwiKVwiKTtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcIlwiLmNvbmNhdCh0eXBlUGFydCwgXCJmdHNcIikuY29uY2F0KGNvbmZpZ1BhcnQsIFwiLlwiKS5jb25jYXQocXVlcnkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZWFjaCBjb2x1bW4gaW4gYHF1ZXJ5YCBrZXlzIGlzIGVxdWFsIHRvIGl0c1xuICAgICAqIGFzc29jaWF0ZWQgdmFsdWUuIFNob3J0aGFuZCBmb3IgbXVsdGlwbGUgYC5lcSgpYHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgb2JqZWN0IHRvIGZpbHRlciB3aXRoLCB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIG1hcHBlZFxuICAgICAqIHRvIHRoZWlyIGZpbHRlciB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaChxdWVyeSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksXG4gICAgICAgICAgY29sdW1uID0gX3JlZjNbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfcmVmM1sxXTtcbiAgICAgICAgX3RoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcImVxLlwiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIGRvZXNuJ3Qgc2F0aXNmeSB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICAgKiBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBiZSBuZWdhdGVkIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmdcbiAgICAgKiBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm5vdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3QoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcIm5vdC5cIi5jb25jYXQob3BlcmF0b3IsIFwiLlwiKS5jb25jYXQodmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpbHRlcnMuXG4gICAgICpcbiAgICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgZmlsdGVyc2AgaXMgdXNlZCBhcy1pcyBhbmQgbmVlZHMgdG8gZm9sbG93IFtQb3N0Z1JFU1RcbiAgICAgKiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuICAgICAqIHRvIG1ha2Ugc3VyZSBpdCdzIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICAgKlxuICAgICAqIEl0J3MgY3VycmVudGx5IG5vdCBwb3NzaWJsZSB0byBkbyBhbiBgLm9yKClgIGZpbHRlciBhY3Jvc3MgbXVsdGlwbGUgdGFibGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byB1c2UsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICogQHBhcmFtIGZvcmVpZ25UYWJsZSAtIFNldCB0aGlzIHRvIGZpbHRlciBvbiBmb3JlaWduIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZVxuICAgICAqIGN1cnJlbnQgdGFibGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcihmaWx0ZXJzKSB7XG4gICAgICB2YXIgX3JlZjQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBmb3JlaWduVGFibGUgPSBfcmVmNC5mb3JlaWduVGFibGU7XG4gICAgICB2YXIga2V5ID0gZm9yZWlnblRhYmxlID8gXCJcIi5jb25jYXQoZm9yZWlnblRhYmxlLCBcIi5vclwiKSA6ICdvcic7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgXCIoXCIuY29uY2F0KGZpbHRlcnMsIFwiKVwiKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgdGhlIGZpbHRlci4gVGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggLSB5b3VcbiAgICAgKiBzaG91bGQgdXNlIHRoZSBzcGVjaWZpYyBmaWx0ZXIgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG4gICAgICogZm9sbG93IFtQb3N0Z1JFU1RcbiAgICAgKiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuICAgICAqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXIoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBcIlwiLmNvbmNhdChvcGVyYXRvciwgXCIuXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyO1xufShQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzFbXCJkZWZhdWx0XCJdKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdRVUZCUVR0QlFVRnRSU3hKUVRKQ09VTkJMSE5DUVVsdVFqdEZRVUZCTzBWQlFVRTdSVUZCUVR0SlFVRkJPMGxCUVVFN1JVRkJRVHRGUVVGQk8wbEJRVUU3U1VGQlFUdEpRVWRCT3pzN096czdPenRKUVZGQkxGbEJRVWRETEUxQlFXTXNSVUZCUlVNc1MwRkJZenROUVVNdlFpeEpRVUZKTEVOQlFVTkRMRWRCUVVjc1EwRkJRME1zV1VGQldTeERRVUZEUXl4TlFVRk5MRU5CUVVOS0xFMUJRVTBzWlVGQlVVTXNTMEZCU3l4RlFVRkhPMDFCUTI1RUxFOUJRVThzU1VGQlNUdEpRVU5pTzBsQlNVRTdPenM3T3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVUxQkxHRkJRVWxFTEUxQlFXTXNSVUZCUlVNc1MwRkJZenROUVVOb1F5eEpRVUZKTEVOQlFVTkRMRWRCUVVjc1EwRkJRME1zV1VGQldTeERRVUZEUXl4TlFVRk5MRU5CUVVOS0xFMUJRVTBzWjBKQlFWTkRMRXRCUVVzc1JVRkJSenROUVVOd1JDeFBRVUZQTEVsQlFVazdTVUZEWWp0SlFVbEJPenM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGTlFTeFpRVUZIUkN4TlFVRmpMRVZCUVVWRExFdEJRV003VFVGREwwSXNTVUZCU1N4RFFVRkRReXhIUVVGSExFTkJRVU5ETEZsQlFWa3NRMEZCUTBNc1RVRkJUU3hEUVVGRFNpeE5RVUZOTEdWQlFWRkRMRXRCUVVzc1JVRkJSenROUVVOdVJDeFBRVUZQTEVsQlFVazdTVUZEWWp0SlFVbEJPenM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGTlFTeGhRVUZKUkN4TlFVRmpMRVZCUVVWRExFdEJRV003VFVGRGFFTXNTVUZCU1N4RFFVRkRReXhIUVVGSExFTkJRVU5ETEZsQlFWa3NRMEZCUTBNc1RVRkJUU3hEUVVGRFNpeE5RVUZOTEdkQ1FVRlRReXhMUVVGTExFVkJRVWM3VFVGRGNFUXNUMEZCVHl4SlFVRkpPMGxCUTJJN1NVRkpRVHM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlRVRXNXVUZCUjBRc1RVRkJZeXhGUVVGRlF5eExRVUZqTzAxQlF5OUNMRWxCUVVrc1EwRkJRME1zUjBGQlJ5eERRVUZEUXl4WlFVRlpMRU5CUVVORExFMUJRVTBzUTBGQlEwb3NUVUZCVFN4bFFVRlJReXhMUVVGTExFVkJRVWM3VFVGRGJrUXNUMEZCVHl4SlFVRkpPMGxCUTJJN1NVRkpRVHM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlRVRXNZVUZCU1VRc1RVRkJZeXhGUVVGRlF5eExRVUZqTzAxQlEyaERMRWxCUVVrc1EwRkJRME1zUjBGQlJ5eERRVUZEUXl4WlFVRlpMRU5CUVVORExFMUJRVTBzUTBGQlEwb3NUVUZCVFN4blFrRkJVME1zUzBGQlN5eEZRVUZITzAxQlEzQkVMRTlCUVU4c1NVRkJTVHRKUVVOaU8wbEJTVUU3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVMUJMR05CUVV0RUxFMUJRV01zUlVGQlJVc3NUMEZCWlR0TlFVTnNReXhKUVVGSkxFTkJRVU5JTEVkQlFVY3NRMEZCUTBNc1dVRkJXU3hEUVVGRFF5eE5RVUZOTEVOQlFVTktMRTFCUVUwc2FVSkJRVlZMTEU5QlFVOHNSVUZCUnp0TlFVTjJSQ3hQUVVGUExFbEJRVWs3U1VGRFlqdEpRVWxCT3pzN096czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRk5RU3hsUVVGTlRDeE5RVUZqTEVWQlFVVkxMRTlCUVdVN1RVRkRia01zU1VGQlNTeERRVUZEU0N4SFFVRkhMRU5CUVVORExGbEJRVmtzUTBGQlEwTXNUVUZCVFN4RFFVRkRTaXhOUVVGTkxHdENRVUZYU3l4UFFVRlBMRVZCUVVjN1RVRkRlRVFzVDBGQlR5eEpRVUZKTzBsQlEySTdTVUZQUVRzN096czdPenM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QldVRXNXVUZCUjB3c1RVRkJZeXhGUVVGRlF5eExRVUZ4UWp0TlFVTjBReXhKUVVGSkxFTkJRVU5ETEVkQlFVY3NRMEZCUTBNc1dVRkJXU3hEUVVGRFF5eE5RVUZOTEVOQlFVTktMRTFCUVUwc1pVRkJVVU1zUzBGQlN5eEZRVUZITzAxQlEyNUVMRTlCUVU4c1NVRkJTVHRKUVVOaU8wbEJTVUU3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVMUJMR0ZCUVVkRUxFMUJRV01zUlVGQlJVMHNUVUZCYVVJN1RVRkRiRU1zU1VGQlRVTXNZVUZCWVN4SFFVRkhSQ3hOUVVGTkxFTkJRM3BDUlN4SFFVRkhMRU5CUVVNc1ZVRkJRME1zUTBGQlF5eEZRVUZKTzFGQlExUTdVVUZEUVR0UlFVTkJMRWxCUVVrc1QwRkJUMEVzUTBGQlF5eExRVUZMTEZGQlFWRXNTVUZCU1N4SlFVRkpReXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTkRMRWxCUVVrc1EwRkJRMFlzUTBGQlF5eERRVUZETEVWQlFVVXNiVUpCUVZkQkxFTkJRVU1zVVVGQlJ5eExRVU53UlN4cFFrRkJWVUVzUTBGQlF6dE5RVU5zUWl4RFFVRkRMRU5CUVVNc1EwRkRSRWNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXp0TlFVTmFMRWxCUVVrc1EwRkJRMVlzUjBGQlJ5eERRVUZEUXl4WlFVRlpMRU5CUVVORExFMUJRVTBzUTBGQlEwb3NUVUZCVFN4blFrRkJVMDhzWVVGQllTeFBRVUZKTzAxQlF6ZEVMRTlCUVU4c1NVRkJTVHRKUVVOaU8wbEJUMEU3T3pzN096czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRlBRU3hyUWtGQlUxQXNUVUZCWXl4RlFVRkZReXhMUVVGdFJEdE5RVU14UlN4SlFVRkpMRTlCUVU5QkxFdEJRVXNzUzBGQlN5eFJRVUZSTEVWQlFVVTdVVUZETjBJN1VVRkRRVHRSUVVOQkxFbEJRVWtzUTBGQlEwTXNSMEZCUnl4RFFVRkRReXhaUVVGWkxFTkJRVU5ETEUxQlFVMHNRMEZCUTBvc1RVRkJUU3hsUVVGUlF5eExRVUZMTEVWQlFVYzdUMEZEY0VRc1RVRkJUU3hKUVVGSldTeExRVUZMTEVOQlFVTkRMRTlCUVU4c1EwRkJRMklzUzBGQlN5eERRVUZETEVWQlFVVTdVVUZETDBJN1VVRkRRU3hKUVVGSkxFTkJRVU5ETEVkQlFVY3NRMEZCUTBNc1dVRkJXU3hEUVVGRFF5eE5RVUZOTEVOQlFVTktMRTFCUVUwc1owSkJRVk5ETEV0QlFVc3NRMEZCUTFjc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZKTzA5QlEyaEZMRTFCUVUwN1VVRkRURHRSUVVOQkxFbEJRVWtzUTBGQlExWXNSMEZCUnl4RFFVRkRReXhaUVVGWkxFTkJRVU5ETEUxQlFVMHNRMEZCUTBvc1RVRkJUU3hsUVVGUlpTeEpRVUZKTEVOQlFVTkRMRk5CUVZNc1EwRkJRMllzUzBGQlN5eERRVUZETEVWQlFVYzdPMDFCUlhKRkxFOUJRVThzU1VGQlNUdEpRVU5pTzBsQlQwRTdPenM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGUFFTeHhRa0ZCV1VRc1RVRkJZeXhGUVVGRlF5eExRVUZ0UkR0TlFVTTNSU3hKUVVGSkxFOUJRVTlCTEV0QlFVc3NTMEZCU3l4UlFVRlJMRVZCUVVVN1VVRkROMEk3VVVGRFFTeEpRVUZKTEVOQlFVTkRMRWRCUVVjc1EwRkJRME1zV1VGQldTeERRVUZEUXl4TlFVRk5MRU5CUVVOS0xFMUJRVTBzWlVGQlVVTXNTMEZCU3l4RlFVRkhPMDlCUTNCRUxFMUJRVTBzU1VGQlNWa3NTMEZCU3l4RFFVRkRReXhQUVVGUExFTkJRVU5pTEV0QlFVc3NRMEZCUXl4RlFVRkZPMUZCUXk5Q08xRkJRMEVzU1VGQlNTeERRVUZEUXl4SFFVRkhMRU5CUVVORExGbEJRVmtzUTBGQlEwTXNUVUZCVFN4RFFVRkRTaXhOUVVGTkxHZENRVUZUUXl4TFFVRkxMRU5CUVVOWExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCU1R0UFFVTm9SU3hOUVVGTk8xRkJRMHc3VVVGRFFTeEpRVUZKTEVOQlFVTldMRWRCUVVjc1EwRkJRME1zV1VGQldTeERRVUZEUXl4TlFVRk5MRU5CUVVOS0xFMUJRVTBzWlVGQlVXVXNTVUZCU1N4RFFVRkRReXhUUVVGVExFTkJRVU5tTEV0QlFVc3NRMEZCUXl4RlFVRkhPenROUVVWeVJTeFBRVUZQTEVsQlFVazdTVUZEWWp0SlFVbEJPenM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlQwRXNhVUpCUVZGRUxFMUJRV01zUlVGQlJXbENMRXRCUVdFN1RVRkRia01zU1VGQlNTeERRVUZEWml4SFFVRkhMRU5CUVVORExGbEJRVmtzUTBGQlEwTXNUVUZCVFN4RFFVRkRTaXhOUVVGTkxHVkJRVkZwUWl4TFFVRkxMRVZCUVVjN1RVRkRia1FzVDBGQlR5eEpRVUZKTzBsQlEySTdTVUZKUVRzN096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZSUVN4clFrRkJVMnBDTEUxQlFXTXNSVUZCUldsQ0xFdEJRV0U3VFVGRGNFTXNTVUZCU1N4RFFVRkRaaXhIUVVGSExFTkJRVU5ETEZsQlFWa3NRMEZCUTBNc1RVRkJUU3hEUVVGRFNpeE5RVUZOTEdkQ1FVRlRhVUlzUzBGQlN5eEZRVUZITzAxQlEzQkVMRTlCUVU4c1NVRkJTVHRKUVVOaU8wbEJTVUU3T3pzN096czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRlBRU3hwUWtGQlVXcENMRTFCUVdNc1JVRkJSV2xDTEV0QlFXRTdUVUZEYmtNc1NVRkJTU3hEUVVGRFppeEhRVUZITEVOQlFVTkRMRmxCUVZrc1EwRkJRME1zVFVGQlRTeERRVUZEU2l4TlFVRk5MR1ZCUVZGcFFpeExRVUZMTEVWQlFVYzdUVUZEYmtRc1QwRkJUeXhKUVVGSk8wbEJRMkk3U1VGSlFUczdPenM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGUlFTeHJRa0ZCVTJwQ0xFMUJRV01zUlVGQlJXbENMRXRCUVdFN1RVRkRjRU1zU1VGQlNTeERRVUZEWml4SFFVRkhMRU5CUVVORExGbEJRVmtzUTBGQlEwTXNUVUZCVFN4RFFVRkRTaXhOUVVGTkxHZENRVUZUYVVJc1MwRkJTeXhGUVVGSE8wMUJRM0JFTEU5QlFVOHNTVUZCU1R0SlFVTmlPMGxCU1VFN096czdPenM3TzBWQlFVRTdTVUZCUVR0SlFVRkJMRTlCVVVFc2RVSkJRV05xUWl4TlFVRmpMRVZCUVVWcFFpeExRVUZoTzAxQlEzcERMRWxCUVVrc1EwRkJRMllzUjBGQlJ5eERRVUZEUXl4WlFVRlpMRU5CUVVORExFMUJRVTBzUTBGQlEwb3NUVUZCVFN4blFrRkJVMmxDTEV0QlFVc3NSVUZCUnp0TlFVTndSQ3hQUVVGUExFbEJRVWs3U1VGRFlqdEpRVTlCT3pzN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJUMEVzYTBKQlFWTnFRaXhOUVVGakxFVkJRVVZETEV0QlFYbENPMDFCUTJoRUxFbEJRVWtzVDBGQlQwRXNTMEZCU3l4TFFVRkxMRkZCUVZFc1JVRkJSVHRSUVVNM1FqdFJRVU5CTEVsQlFVa3NRMEZCUTBNc1IwRkJSeXhEUVVGRFF5eFpRVUZaTEVOQlFVTkRMRTFCUVUwc1EwRkJRMG9zVFVGQlRTeGxRVUZSUXl4TFFVRkxMRVZCUVVjN1QwRkRjRVFzVFVGQlRUdFJRVU5NTzFGQlEwRXNTVUZCU1N4RFFVRkRReXhIUVVGSExFTkJRVU5ETEZsQlFWa3NRMEZCUTBNc1RVRkJUU3hEUVVGRFNpeE5RVUZOTEdkQ1FVRlRReXhMUVVGTExFTkJRVU5YTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJTVHM3VFVGRmFrVXNUMEZCVHl4SlFVRkpPMGxCUTJJN1NVRlpRVHM3T3pzN096czdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVlZCTEc5Q1FVTkZXaXhOUVVGakxFVkJRMlJyUWl4TFFVRmhMRVZCUTNORk8wMUJRVUVzSzBWQlFVWXNSVUZCUlR0UlFVRnFSa01zVFVGQlRTeFJRVUZPUVN4TlFVRk5PMUZCUVVWRExFbEJRVWtzVVVGQlNrRXNTVUZCU1R0TlFVVmtMRWxCUVVsRExGRkJRVkVzUjBGQlJ5eEZRVUZGTzAxQlEycENMRWxCUVVsRUxFbEJRVWtzUzBGQlN5eFBRVUZQTEVWQlFVVTdVVUZEY0VKRExGRkJRVkVzUjBGQlJ5eEpRVUZKTzA5QlEyaENMRTFCUVUwc1NVRkJTVVFzU1VGQlNTeExRVUZMTEZGQlFWRXNSVUZCUlR0UlFVTTFRa01zVVVGQlVTeEhRVUZITEVsQlFVazdUMEZEYUVJc1RVRkJUU3hKUVVGSlJDeEpRVUZKTEV0QlFVc3NWMEZCVnl4RlFVRkZPMUZCUXk5Q1F5eFJRVUZSTEVkQlFVY3NSMEZCUnpzN1RVRkZhRUlzU1VGQlRVTXNWVUZCVlN4SFFVRkhTQ3hOUVVGTkxFdEJRVXRKTEZOQlFWTXNSMEZCUnl4RlFVRkZMR05CUVU5S0xFMUJRVTBzVFVGQlJ6dE5RVU0xUkN4SlFVRkpMRU5CUVVOcVFpeEhRVUZITEVOQlFVTkRMRmxCUVZrc1EwRkJRME1zVFVGQlRTeERRVUZEU2l4TlFVRk5MRmxCUVV0eFFpeFJRVUZSTEdkQ1FVRk5ReXhWUVVGVkxHTkJRVWxLTEV0QlFVc3NSVUZCUnp0TlFVTTFSU3hQUVVGUExFbEJRVWs3U1VGRFlqdEpRVWxCT3pzN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJUMEVzWlVGQlRVRXNTMEZCT0VJN1RVRkJRVHROUVVOc1EwMHNUVUZCVFN4RFFVRkRReXhQUVVGUExFTkJRVU5RTEV0QlFVc3NRMEZCUXl4RFFVRkRVU3hQUVVGUExFTkJRVU1zYVVKQlFXOUNPMUZCUVVFN1ZVRkJiRUl4UWl4TlFVRk5PMVZCUVVWRExFdEJRVXM3VVVGRE0wTXNTMEZCU1N4RFFVRkRReXhIUVVGSExFTkJRVU5ETEZsQlFWa3NRMEZCUTBNc1RVRkJUU3hEUVVGRFNpeE5RVUZOTEdWQlFWRkRMRXRCUVVzc1JVRkJSenROUVVOeVJDeERRVUZETEVOQlFVTTdUVUZEUml4UFFVRlBMRWxCUVVrN1NVRkRZanRKUVZGQk96czdPenM3T3pzN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJZVUVzWVVGQlNVUXNUVUZCWXl4RlFVRkZNa0lzVVVGQlowSXNSVUZCUlRGQ0xFdEJRV003VFVGRGJFUXNTVUZCU1N4RFFVRkRReXhIUVVGSExFTkJRVU5ETEZsQlFWa3NRMEZCUTBNc1RVRkJUU3hEUVVGRFNpeE5RVUZOTEdkQ1FVRlRNa0lzVVVGQlVTeGpRVUZKTVVJc1MwRkJTeXhGUVVGSE8wMUJRMmhGTEU5QlFVOHNTVUZCU1R0SlFVTmlPMGxCUlVFN096czdPenM3T3pzN096czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRmhRU3haUVVGSE1rSXNUMEZCWlN4RlFVRnJSRHROUVVGQkxHZEdRVUZHTEVWQlFVVTdVVUZCT1VORExGbEJRVmtzVTBGQldrRXNXVUZCV1R0TlFVTm9ReXhKUVVGTlF5eEhRVUZITEVkQlFVZEVMRmxCUVZrc1lVRkJUVUVzV1VGQldTeFhRVUZSTEVsQlFVazdUVUZEZEVRc1NVRkJTU3hEUVVGRE0wSXNSMEZCUnl4RFFVRkRReXhaUVVGWkxFTkJRVU5ETEUxQlFVMHNRMEZCUXpCQ0xFZEJRVWNzWVVGQlRVWXNUMEZCVHl4UFFVRkpPMDFCUTJwRUxFOUJRVThzU1VGQlNUdEpRVU5pTzBsQlVVRTdPenM3T3pzN096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZoUVN4blFrRkJUelZDTEUxQlFXTXNSVUZCUlRKQ0xGRkJRV2RDTEVWQlFVVXhRaXhMUVVGak8wMUJRM0pFTEVsQlFVa3NRMEZCUTBNc1IwRkJSeXhEUVVGRFF5eFpRVUZaTEVOQlFVTkRMRTFCUVUwc1EwRkJRMG9zVFVGQlRTeFpRVUZMTWtJc1VVRkJVU3hqUVVGSk1VSXNTMEZCU3l4RlFVRkhPMDFCUXpWRUxFOUJRVThzU1VGQlNUdEpRVU5pTzBWQlFVTTdSVUZCUVR0QlFVRkJMRVZCYkdGUE9FSXNjME5CUVRoRE8wRkJTbmhFUXlJc0ltNWhiV1Z6SWpwYklsQnZjM1JuY21WemRFWnBiSFJsY2tKMWFXeGtaWElpTENKamIyeDFiVzRpTENKMllXeDFaU0lzSW5WeWJDSXNJbk5sWVhKamFGQmhjbUZ0Y3lJc0ltRndjR1Z1WkNJc0luQmhkSFJsY200aUxDSjJZV3gxWlhNaUxDSmpiR1ZoYm1Wa1ZtRnNkV1Z6SWl3aWJXRndJaXdpY3lJc0lsSmxaMFY0Y0NJc0luUmxjM1FpTENKcWIybHVJaXdpUVhKeVlYa2lMQ0pwYzBGeWNtRjVJaXdpU2xOUFRpSXNJbk4wY21sdVoybG1lU0lzSW5KaGJtZGxJaXdpY1hWbGNua2lMQ0pqYjI1bWFXY2lMQ0owZVhCbElpd2lkSGx3WlZCaGNuUWlMQ0pqYjI1bWFXZFFZWEowSWl3aWRXNWtaV1pwYm1Wa0lpd2lUMkpxWldOMElpd2laVzUwY21sbGN5SXNJbVp2Y2tWaFkyZ2lMQ0p2Y0dWeVlYUnZjaUlzSW1acGJIUmxjbk1pTENKbWIzSmxhV2R1VkdGaWJHVWlMQ0pyWlhraUxDSlFiM04wWjNKbGMzUlVjbUZ1YzJadmNtMUNkV2xzWkdWeVh6RWlMQ0psZUhCdmNuUnpJbDBzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5UWIzTjBaM0psYzNSR2FXeDBaWEpDZFdsc1pHVnlMblJ6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYmJuVnNiRjE5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbnZhciBfX2ltcG9ydERlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG52YXIgUG9zdGdyZXN0UXVlcnlCdWlsZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9zdGdyZXN0UXVlcnlCdWlsZGVyKHVybCwgX3JlZikge1xuICAgIHZhciBfcmVmJGhlYWRlcnMgPSBfcmVmLmhlYWRlcnMsXG4gICAgICBoZWFkZXJzID0gX3JlZiRoZWFkZXJzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkaGVhZGVycyxcbiAgICAgIHNjaGVtYSA9IF9yZWYuc2NoZW1hLFxuICAgICAgZmV0Y2ggPSBfcmVmLmZldGNoO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIpO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgaW4gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAqXG4gICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICogaG9vZC5cbiAgICpcbiAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICpcbiAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgKiBudW1iZXJzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFBvc3RncmVzdFF1ZXJ5QnVpbGRlciwgW3tcbiAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdChjb2x1bW5zKSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBfcmVmMiRoZWFkID0gX3JlZjIuaGVhZCxcbiAgICAgICAgaGVhZCA9IF9yZWYyJGhlYWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkaGVhZCxcbiAgICAgICAgY291bnQgPSBfcmVmMi5jb3VudDtcbiAgICAgIHZhciBtZXRob2QgPSBoZWFkID8gJ0hFQUQnIDogJ0dFVCc7XG4gICAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZXMgZXhjZXB0IHdoZW4gcXVvdGVkXG4gICAgICB2YXIgcXVvdGVkID0gZmFsc2U7XG4gICAgICB2YXIgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyAhPT0gbnVsbCAmJiBjb2x1bW5zICE9PSB2b2lkIDAgPyBjb2x1bW5zIDogJyonKS5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSkuam9pbignJyk7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucyk7XG4gICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IFwiY291bnQ9XCIuY29uY2F0KGNvdW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xW1wiZGVmYXVsdFwiXSh7XG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW4gSU5TRVJUIGludG8gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBpbnNlcnRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICAgKiB3aXRoIGAuc2VsZWN0KClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gaW5zZXJ0LiBQYXNzIGFuIG9iamVjdCB0byBpbnNlcnQgYSBzaW5nbGUgcm93XG4gICAgICogb3IgYW4gYXJyYXkgdG8gaW5zZXJ0IG11bHRpcGxlIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCBpbnNlcnRlZCByb3dzLlxuICAgICAqXG4gICAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgICAqIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAgICogbnVtYmVycy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KHZhbHVlcykge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgY291bnQgPSBfcmVmMy5jb3VudDtcbiAgICAgIHZhciBtZXRob2QgPSAnUE9TVCc7XG4gICAgICB2YXIgcHJlZmVyc0hlYWRlcnMgPSBbXTtcbiAgICAgIHZhciBib2R5ID0gdmFsdWVzO1xuICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goXCJjb3VudD1cIi5jb25jYXQoY291bnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICAgIHByZWZlcnNIZWFkZXJzLnVuc2hpZnQodGhpcy5oZWFkZXJzWydQcmVmZXInXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddID0gcHJlZmVyc0hlYWRlcnMuam9pbignLCcpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICB2YXIgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgeCkge1xuICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KE9iamVjdC5rZXlzKHgpKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHVuaXF1ZUNvbHVtbnMgPSBfdG9Db25zdW1hYmxlQXJyYXkobmV3IFNldChjb2x1bW5zKSkubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoY29sdW1uLCBcIlxcXCJcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnY29sdW1ucycsIHVuaXF1ZUNvbHVtbnMuam9pbignLCcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzFbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIGFsbG93RW1wdHk6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBVUFNFUlQgb24gdGhlIHRhYmxlIG9yIHZpZXcuIERlcGVuZGluZyBvbiB0aGUgY29sdW1uKHMpIHBhc3NlZFxuICAgICAqIHRvIGBvbkNvbmZsaWN0YCwgYC51cHNlcnQoKWAgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHRoZSBlcXVpdmFsZW50IG9mXG4gICAgICogYC5pbnNlcnQoKWAgaWYgYSByb3cgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBgb25Db25mbGljdGAgY29sdW1ucyBkb2Vzbid0XG4gICAgICogZXhpc3QsIG9yIGlmIGl0IGRvZXMgZXhpc3QsIHBlcmZvcm0gYW4gYWx0ZXJuYXRpdmUgYWN0aW9uIGRlcGVuZGluZyBvblxuICAgICAqIGBpZ25vcmVEdXBsaWNhdGVzYC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHVwc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgICAqIHdpdGggYC5zZWxlY3QoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cHNlcnQgd2l0aC4gUGFzcyBhbiBvYmplY3QgdG8gdXBzZXJ0IGFcbiAgICAgKiBzaW5nbGUgcm93IG9yIGFuIGFycmF5IHRvIHVwc2VydCBtdWx0aXBsZSByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbkNvbmZsaWN0IC0gQ29tbWEtc2VwYXJhdGVkIFVOSVFVRSBjb2x1bW4ocykgdG8gc3BlY2lmeSBob3dcbiAgICAgKiBkdXBsaWNhdGUgcm93cyBhcmUgZGV0ZXJtaW5lZC4gVHdvIHJvd3MgYXJlIGR1cGxpY2F0ZXMgaWYgYWxsIHRoZVxuICAgICAqIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGFyZSBlcXVhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgLSBJZiBgdHJ1ZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBpZ25vcmVkLiBJZlxuICAgICAqIGBmYWxzZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBtZXJnZWQgd2l0aCBleGlzdGluZyByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwc2VydGVkIHJvd3MuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwc2VydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cHNlcnQodmFsdWVzKSB7XG4gICAgICB2YXIgX3JlZjQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBvbkNvbmZsaWN0ID0gX3JlZjQub25Db25mbGljdCxcbiAgICAgICAgX3JlZjQkaWdub3JlRHVwbGljYXRlID0gX3JlZjQuaWdub3JlRHVwbGljYXRlcyxcbiAgICAgICAgaWdub3JlRHVwbGljYXRlcyA9IF9yZWY0JGlnbm9yZUR1cGxpY2F0ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNCRpZ25vcmVEdXBsaWNhdGUsXG4gICAgICAgIGNvdW50ID0gX3JlZjQuY291bnQ7XG4gICAgICB2YXIgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgdmFyIHByZWZlcnNIZWFkZXJzID0gW1wicmVzb2x1dGlvbj1cIi5jb25jYXQoaWdub3JlRHVwbGljYXRlcyA/ICdpZ25vcmUnIDogJ21lcmdlJywgXCItZHVwbGljYXRlc1wiKV07XG4gICAgICBpZiAob25Db25mbGljdCAhPT0gdW5kZWZpbmVkKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdvbl9jb25mbGljdCcsIG9uQ29uZmxpY3QpO1xuICAgICAgdmFyIGJvZHkgPSB2YWx1ZXM7XG4gICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChcImNvdW50PVwiLmNvbmNhdChjb3VudCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgcHJlZmVyc0hlYWRlcnMudW5zaGlmdCh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJyk7XG4gICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMVtcImRlZmF1bHRcIl0oe1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgYWxsb3dFbXB0eTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHVwZGF0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gdXBkYXRlIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBfcmVmNSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIGNvdW50ID0gX3JlZjUuY291bnQ7XG4gICAgICB2YXIgbWV0aG9kID0gJ1BBVENIJztcbiAgICAgIHZhciBwcmVmZXJzSGVhZGVycyA9IFtdO1xuICAgICAgdmFyIGJvZHkgPSB2YWx1ZXM7XG4gICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChcImNvdW50PVwiLmNvbmNhdChjb3VudCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgcHJlZmVyc0hlYWRlcnMudW5zaGlmdCh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJyk7XG4gICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMVtcImRlZmF1bHRcIl0oe1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgYWxsb3dFbXB0eTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgREVMRVRFIG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgZGVsZXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcbiAgICAgKiB3aXRoIGAuc2VsZWN0KClgIGFmdGVyIGZpbHRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCBkZWxldGVkIHJvd3MuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKCkge1xuICAgICAgdmFyIF9yZWY2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgY291bnQgPSBfcmVmNi5jb3VudDtcbiAgICAgIHZhciBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgIHZhciBwcmVmZXJzSGVhZGVycyA9IFtdO1xuICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2goXCJjb3VudD1cIi5jb25jYXQoY291bnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICAgIHByZWZlcnNIZWFkZXJzLnVuc2hpZnQodGhpcy5oZWFkZXJzWydQcmVmZXInXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddID0gcHJlZmVyc0hlYWRlcnMuam9pbignLCcpO1xuICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzFbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIGFsbG93RW1wdHk6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjtcbn0oKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9zdGdyZXN0UXVlcnlCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096dEJRVU5CTzBGQlFUWkVMRWxCU1hoRFFTeHhRa0ZCY1VJN1JVRlZlRU1zSzBKQlEwVkRMRWRCUVZFc1VVRlRVRHRKUVVGQkxIZENRVkJEUXl4UFFVRlBPMDFCUVZCQkxFOUJRVThzTmtKQlFVY3NSVUZCUlR0TlFVTmFReXhOUVVGTkxGRkJRVTVCTEUxQlFVMDdUVUZEVGtNc1MwRkJTeXhSUVVGTVFTeExRVUZMTzBsQlFVRTdTVUZQVUN4SlFVRkpMRU5CUVVOSUxFZEJRVWNzUjBGQlIwRXNSMEZCUnp0SlFVTmtMRWxCUVVrc1EwRkJRME1zVDBGQlR5eEhRVUZIUVN4UFFVRlBPMGxCUTNSQ0xFbEJRVWtzUTBGQlEwTXNUVUZCVFN4SFFVRkhRU3hOUVVGTk8wbEJRM0JDTEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhIUVVGSFFTeExRVUZMTzBWQlEzQkNPMFZCUlVFN096czdPenM3T3pzN096czdPenM3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFYRkNRU3huUWtGRFJVTXNUMEZCWlN4RlFVOVVPMDFCUVVFc1owWkJRVVlzUlVGQlJUdFJRVUZCTEcxQ1FVeEtReXhKUVVGSk8xRkJRVXBCTEVsQlFVa3NNa0pCUVVjc1MwRkJTenRSUVVOYVF5eExRVUZMTEZOQlFVeEJMRXRCUVVzN1RVRk5VQ3hKUVVGTlF5eE5RVUZOTEVkQlFVZEdMRWxCUVVrc1IwRkJSeXhOUVVGTkxFZEJRVWNzUzBGQlN6dE5RVU53UXp0TlFVTkJMRWxCUVVsSExFMUJRVTBzUjBGQlJ5eExRVUZMTzAxQlEyeENMRWxCUVUxRExHTkJRV01zUjBGQlJ5eERRVUZEVEN4UFFVRlBMR0ZCUVZCQkxFOUJRVThzWTBGQlVFRXNUMEZCVHl4SFFVRkpMRWRCUVVjc1JVRkRia05OTEV0QlFVc3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkRWRU1zUjBGQlJ5eERRVUZETEZWQlFVTkRMRU5CUVVNc1JVRkJTVHRSUVVOVUxFbEJRVWtzU1VGQlNTeERRVUZEUXl4SlFVRkpMRU5CUVVORUxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTktMRTFCUVUwc1JVRkJSVHRWUVVNelFpeFBRVUZQTEVWQlFVVTdPMUZCUlZnc1NVRkJTVWtzUTBGQlF5eExRVUZMTEVkQlFVY3NSVUZCUlR0VlFVTmlTaXhOUVVGTkxFZEJRVWNzUTBGQlEwRXNUVUZCVFRzN1VVRkZiRUlzVDBGQlQwa3NRMEZCUXp0TlFVTldMRU5CUVVNc1EwRkJReXhEUVVORVJTeEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRPMDFCUTFnc1NVRkJTU3hEUVVGRFpDeEhRVUZITEVOQlFVTmxMRmxCUVZrc1EwRkJRME1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlZBc1kwRkJZeXhEUVVGRE8wMUJRMjVFTEVsQlFVbElMRXRCUVVzc1JVRkJSVHRSUVVOVUxFbEJRVWtzUTBGQlEwd3NUMEZCVHl4RFFVRkRMRkZCUVZFc1EwRkJReXh0UWtGQldVc3NTMEZCU3l4RFFVRkZPenROUVVjelF5eFBRVUZQTEVsQlFVbFhMRzFEUVVGelFpeERRVUZETzFGQlEyaERWaXhOUVVGTkxFVkJRVTVCTEUxQlFVMDdVVUZEVGxBc1IwRkJSeXhGUVVGRkxFbEJRVWtzUTBGQlEwRXNSMEZCUnp0UlFVTmlReXhQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZEUVN4UFFVRlBPMUZCUTNKQ1F5eE5RVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRRU3hOUVVGTk8xRkJRMjVDUXl4TFFVRkxMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeExRVUZMTzFGQlEycENaU3hWUVVGVkxFVkJRVVU3VDBGRE1FSXNRMEZCUXp0SlFVTXpRenRKUVVWQk96czdPenM3T3pzN096czdPenM3T3pzN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJjMEpCTEdkQ1FVTkZReXhOUVVGdFFpeEZRVXRpTzAxQlFVRXNaMFpCUVVZc1JVRkJSVHRSUVVoS1lpeExRVUZMTEZOQlFVeEJMRXRCUVVzN1RVRkxVQ3hKUVVGTlF5eE5RVUZOTEVkQlFVY3NUVUZCVFR0TlFVVnlRaXhKUVVGTllTeGpRVUZqTEVkQlFVY3NSVUZCUlR0TlFVTjZRaXhKUVVGTlF5eEpRVUZKTEVkQlFVZEdMRTFCUVUwN1RVRkRia0lzU1VGQlNXSXNTMEZCU3l4RlFVRkZPMUZCUTFSakxHTkJRV01zUTBGQlEwVXNTVUZCU1N4cFFrRkJWV2hDTEV0QlFVc3NSVUZCUnpzN1RVRkZka01zU1VGQlNTeEpRVUZKTEVOQlFVTk1MRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUlVGQlJUdFJRVU14UW0xQ0xHTkJRV01zUTBGQlEwY3NUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJRM1JDTEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenM3VFVGRmFFUXNTVUZCU1N4RFFVRkRRU3hQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVZHRRaXhqUVVGakxFTkJRVU5PTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNN1RVRkZha1FzU1VGQlNWVXNTMEZCU3l4RFFVRkRReXhQUVVGUExFTkJRVU5PTEUxQlFVMHNRMEZCUXl4RlFVRkZPMUZCUTNwQ0xFbEJRVTFtTEU5QlFVOHNSMEZCUjJVc1RVRkJUU3hEUVVGRFR5eE5RVUZOTEVOQlFVTXNWVUZCUTBNc1IwRkJSeXhGUVVGRlF5eERRVUZETzFWQlFVRXNUMEZCUzBRc1IwRkJSeXhEUVVGRFJTeE5RVUZOTEVOQlFVTkRMRTFCUVUwc1EwRkJRME1zU1VGQlNTeERRVUZEU0N4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVGQkxFZEJRVVVzUlVGQll5eERRVUZETzFGQlEzSkdMRWxCUVVsNFFpeFBRVUZQTEVOQlFVTTBRaXhOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFWQlEzUkNMRWxCUVUxRExHRkJRV0VzUjBGQlJ5eHRRa0ZCU1N4SlFVRkpReXhIUVVGSExFTkJRVU01UWl4UFFVRlBMRU5CUVVNc1JVRkJSVThzUjBGQlJ5eERRVUZETEZWQlFVTjNRaXhOUVVGTk8xbEJRVUVzYlVKQlFWTkJMRTFCUVUwN1ZVRkJRU3hEUVVGSExFTkJRVU03VlVGRE1VVXNTVUZCU1N4RFFVRkRia01zUjBGQlJ5eERRVUZEWlN4WlFVRlpMRU5CUVVORExFZEJRVWNzUTBGQlF5eFRRVUZUTEVWQlFVVnBRaXhoUVVGaExFTkJRVU51UWl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03T3p0TlFVbHFSU3hQUVVGUExFbEJRVWxITEcxRFFVRnpRaXhEUVVGRE8xRkJRMmhEVml4TlFVRk5MRVZCUVU1QkxFMUJRVTA3VVVGRFRsQXNSMEZCUnl4RlFVRkZMRWxCUVVrc1EwRkJRMEVzUjBGQlJ6dFJRVU5pUXl4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzFGQlEzSkNReXhOUVVGTkxFVkJRVVVzU1VGQlNTeERRVUZEUVN4TlFVRk5PMUZCUTI1Q2JVSXNTVUZCU1N4RlFVRktRU3hKUVVGSk8xRkJRMHBzUWl4TFFVRkxMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeExRVUZMTzFGQlEycENaU3hWUVVGVkxFVkJRVVU3VDBGRE5rSXNRMEZCUXp0SlFVTTVRenRKUVVWQk96czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZwUTBFc1owSkJRMFZETEUxQlFXMUNMRVZCVTJJN1RVRkJRU3huUmtGQlJpeEZRVUZGTzFGQlVFcHBRaXhWUVVGVkxGTkJRVlpCTEZWQlFWVTdVVUZCUVN3NFFrRkRWa01zWjBKQlFXZENPMUZCUVdoQ1FTeG5Ra0ZCWjBJc2MwTkJRVWNzUzBGQlN6dFJRVU40UWk5Q0xFdEJRVXNzVTBGQlRFRXNTMEZCU3p0TlFVOVFMRWxCUVUxRExFMUJRVTBzUjBGQlJ5eE5RVUZOTzAxQlJYSkNMRWxCUVUxaExHTkJRV01zUjBGQlJ5eHpRa0ZCWldsQ0xHZENRVUZuUWl4SFFVRkhMRkZCUVZFc1IwRkJSeXhQUVVGUExHbENRVUZqTzAxQlJYcEdMRWxCUVVsRUxGVkJRVlVzUzBGQlMwVXNVMEZCVXl4RlFVRkZMRWxCUVVrc1EwRkJRM1JETEVkQlFVY3NRMEZCUTJVc1dVRkJXU3hEUVVGRFF5eEhRVUZITEVOQlFVTXNZVUZCWVN4RlFVRkZiMElzVlVGQlZTeERRVUZETzAxQlEyeEdMRWxCUVUxbUxFbEJRVWtzUjBGQlIwWXNUVUZCVFR0TlFVTnVRaXhKUVVGSllpeExRVUZMTEVWQlFVVTdVVUZEVkdNc1kwRkJZeXhEUVVGRFJTeEpRVUZKTEdsQ1FVRlZhRUlzUzBGQlN5eEZRVUZIT3p0TlFVVjJReXhKUVVGSkxFbEJRVWtzUTBGQlEwd3NUMEZCVHl4RFFVRkRMRkZCUVZFc1EwRkJReXhGUVVGRk8xRkJRekZDYlVJc1kwRkJZeXhEUVVGRFJ5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRkRUlzVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRPenROUVVWb1JDeEpRVUZKTEVOQlFVTkJMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlIyMUNMR05CUVdNc1EwRkJRMDRzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXp0TlFVVnFSQ3hQUVVGUExFbEJRVWxITEcxRFFVRnpRaXhEUVVGRE8xRkJRMmhEVml4TlFVRk5MRVZCUVU1QkxFMUJRVTA3VVVGRFRsQXNSMEZCUnl4RlFVRkZMRWxCUVVrc1EwRkJRMEVzUjBGQlJ6dFJRVU5pUXl4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzFGQlEzSkNReXhOUVVGTkxFVkJRVVVzU1VGQlNTeERRVUZEUVN4TlFVRk5PMUZCUTI1Q2JVSXNTVUZCU1N4RlFVRktRU3hKUVVGSk8xRkJRMHBzUWl4TFFVRkxMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeExRVUZMTzFGQlEycENaU3hWUVVGVkxFVkJRVVU3VDBGRE5rSXNRMEZCUXp0SlFVTTVRenRKUVVWQk96czdPenM3T3pzN096czdPenM3T3pzN096czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRnhRa0VzWjBKQlEwVkRMRTFCUVZjc1JVRkxURHROUVVGQkxHZEdRVUZHTEVWQlFVVTdVVUZJU21Jc1MwRkJTeXhUUVVGTVFTeExRVUZMTzAxQlMxQXNTVUZCVFVNc1RVRkJUU3hIUVVGSExFOUJRVTg3VFVGRGRFSXNTVUZCVFdFc1kwRkJZeXhIUVVGSExFVkJRVVU3VFVGRGVrSXNTVUZCVFVNc1NVRkJTU3hIUVVGSFJpeE5RVUZOTzAxQlEyNUNMRWxCUVVsaUxFdEJRVXNzUlVGQlJUdFJRVU5VWXl4alFVRmpMRU5CUVVORkxFbEJRVWtzYVVKQlFWVm9RaXhMUVVGTExFVkJRVWM3TzAxQlJYWkRMRWxCUVVrc1NVRkJTU3hEUVVGRFRDeFBRVUZQTEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVN1VVRkRNVUp0UWl4alFVRmpMRU5CUVVOSExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTjBRaXhQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdPMDFCUldoRUxFbEJRVWtzUTBGQlEwRXNUMEZCVHl4RFFVRkRMRkZCUVZFc1EwRkJReXhIUVVGSGJVSXNZMEZCWXl4RFFVRkRUaXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETzAxQlJXcEVMRTlCUVU4c1NVRkJTVWNzYlVOQlFYTkNMRU5CUVVNN1VVRkRhRU5XTEUxQlFVMHNSVUZCVGtFc1RVRkJUVHRSUVVOT1VDeEhRVUZITEVWQlFVVXNTVUZCU1N4RFFVRkRRU3hIUVVGSE8xRkJRMkpETEU5QlFVOHNSVUZCUlN4SlFVRkpMRU5CUVVOQkxFOUJRVTg3VVVGRGNrSkRMRTFCUVUwc1JVRkJSU3hKUVVGSkxFTkJRVU5CTEUxQlFVMDdVVUZEYmtKdFFpeEpRVUZKTEVWQlFVcEJMRWxCUVVrN1VVRkRTbXhDTEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVOQkxFdEJRVXM3VVVGRGFrSmxMRlZCUVZVc1JVRkJSVHRQUVVNMlFpeERRVUZETzBsQlF6bERPMGxCUlVFN096czdPenM3T3pzN096czdPenM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGdFFrRXNiVUpCU1UwN1RVRkJRU3huUmtGQlJpeEZRVUZGTzFGQlNFcGFMRXRCUVVzc1UwRkJURUVzUzBGQlN6dE5RVWxNTEVsQlFVMURMRTFCUVUwc1IwRkJSeXhSUVVGUk8wMUJRM1pDTEVsQlFVMWhMR05CUVdNc1IwRkJSeXhGUVVGRk8wMUJRM3BDTEVsQlFVbGtMRXRCUVVzc1JVRkJSVHRSUVVOVVl5eGpRVUZqTEVOQlFVTkZMRWxCUVVrc2FVSkJRVlZvUWl4TFFVRkxMRVZCUVVjN08wMUJSWFpETEVsQlFVa3NTVUZCU1N4RFFVRkRUQ3hQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVVTdVVUZETVVKdFFpeGpRVUZqTEVOQlFVTkhMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU4wUWl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03TzAxQlJXaEVMRWxCUVVrc1EwRkJRMEVzVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhiVUlzWTBGQll5eERRVUZEVGl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRE8wMUJSV3BFTEU5QlFVOHNTVUZCU1Vjc2JVTkJRWE5DTEVOQlFVTTdVVUZEYUVOV0xFMUJRVTBzUlVGQlRrRXNUVUZCVFR0UlFVTk9VQ3hIUVVGSExFVkJRVVVzU1VGQlNTeERRVUZEUVN4SFFVRkhPMUZCUTJKRExFOUJRVThzUlVGQlJTeEpRVUZKTEVOQlFVTkJMRTlCUVU4N1VVRkRja0pETEUxQlFVMHNSVUZCUlN4SlFVRkpMRU5CUVVOQkxFMUJRVTA3VVVGRGJrSkRMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU5CTEV0QlFVczdVVUZEYWtKbExGVkJRVlVzUlVGQlJUdFBRVU0yUWl4RFFVRkRPMGxCUXpsRE8wVkJRVU03UlVGQlFUdEJRVUZCTzBGQmVsUkljVUlpTENKdVlXMWxjeUk2V3lKUWIzTjBaM0psYzNSUmRXVnllVUoxYVd4a1pYSWlMQ0oxY213aUxDSm9aV0ZrWlhKeklpd2ljMk5vWlcxaElpd2labVYwWTJnaUxDSmpiMngxYlc1eklpd2lhR1ZoWkNJc0ltTnZkVzUwSWl3aWJXVjBhRzlrSWl3aWNYVnZkR1ZrSWl3aVkyeGxZVzVsWkVOdmJIVnRibk1pTENKemNHeHBkQ0lzSW0xaGNDSXNJbU1pTENKMFpYTjBJaXdpYW05cGJpSXNJbk5sWVhKamFGQmhjbUZ0Y3lJc0luTmxkQ0lzSWxCdmMzUm5jbVZ6ZEVacGJIUmxja0oxYVd4a1pYSmZNU0lzSW1Gc2JHOTNSVzF3ZEhraUxDSjJZV3gxWlhNaUxDSndjbVZtWlhKelNHVmhaR1Z5Y3lJc0ltSnZaSGtpTENKd2RYTm9JaXdpZFc1emFHbG1kQ0lzSWtGeWNtRjVJaXdpYVhOQmNuSmhlU0lzSW5KbFpIVmpaU0lzSW1Gall5SXNJbmdpTENKamIyNWpZWFFpTENKUFltcGxZM1FpTENKclpYbHpJaXdpYkdWdVozUm9JaXdpZFc1cGNYVmxRMjlzZFcxdWN5SXNJbE5sZENJc0ltTnZiSFZ0YmlJc0ltOXVRMjl1Wm14cFkzUWlMQ0pwWjI1dmNtVkVkWEJzYVdOaGRHVnpJaXdpZFc1a1pXWnBibVZrSWl3aVpYaHdiM0owY3lKZExDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZVRzl6ZEdkeVpYTjBVWFZsY25sQ2RXbHNaR1Z5TG5SeklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJiblZzYkYxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdm9pZCAwICYmICh2b2lkIDApLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgUG9zdGdyZXN0QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEJ1aWxkZXJcIikpO1xudmFyIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Qb3N0Z3Jlc3RCdWlsZGVyXzEkZCkge1xuICBfaW5oZXJpdHMoUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciwgX1Bvc3RncmVzdEJ1aWxkZXJfMSRkKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyKTtcbiAgZnVuY3Rpb24gUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcik7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLCBbe1xuICAgIGtleTogXCJzZWxlY3RcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgU0VMRUNUIG9uIHRoZSBxdWVyeSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG4gICAgICogcmV0dXJuIG1vZGlmaWVkIHJvd3MuIEJ5IGNhbGxpbmcgdGhpcyBtZXRob2QsIG1vZGlmaWVkIHJvd3MgYXJlIHJldHVybmVkIGluXG4gICAgICogYGRhdGFgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbGVjdChjb2x1bW5zKSB7XG4gICAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZXMgZXhjZXB0IHdoZW4gcXVvdGVkXG4gICAgICB2YXIgcXVvdGVkID0gZmFsc2U7XG4gICAgICB2YXIgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyAhPT0gbnVsbCAmJiBjb2x1bW5zICE9PSB2b2lkIDAgPyBjb2x1bW5zIDogJyonKS5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSkuam9pbignJyk7XG4gICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucyk7XG4gICAgICBpZiAodGhpcy5oZWFkZXJzWydQcmVmZXInXSkge1xuICAgICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddICs9ICcsJztcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gKz0gJ3JldHVybj1yZXByZXNlbnRhdGlvbic7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3JkZXIgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY29sdW1uYC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyB0byBvcmRlciBieSBtdWx0aXBsZSBjb2x1bW5zLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcmRlciBmb3JlaWduIHRhYmxlcywgYnV0IGl0IGRvZXNuJ3QgYWZmZWN0IHRoZSBvcmRlcmluZyBvZiB0aGVcbiAgICAgKiBjdXJyZW50IHRhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gb3JkZXIgYnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc2NlbmRpbmcgLSBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5udWxsc0ZpcnN0IC0gSWYgYHRydWVgLCBgbnVsbGBzIGFwcGVhciBmaXJzdC4gSWYgYGZhbHNlYCxcbiAgICAgKiBgbnVsbGBzIGFwcGVhciBsYXN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIFNldCB0aGlzIHRvIG9yZGVyIGEgZm9yZWlnbiB0YWJsZSBieSBmb3JlaWduXG4gICAgICogY29sdW1uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9yZGVyKGNvbHVtbikge1xuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBfcmVmJGFzY2VuZGluZyA9IF9yZWYuYXNjZW5kaW5nLFxuICAgICAgICBhc2NlbmRpbmcgPSBfcmVmJGFzY2VuZGluZyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkYXNjZW5kaW5nLFxuICAgICAgICBudWxsc0ZpcnN0ID0gX3JlZi5udWxsc0ZpcnN0LFxuICAgICAgICBmb3JlaWduVGFibGUgPSBfcmVmLmZvcmVpZ25UYWJsZTtcbiAgICAgIHZhciBrZXkgPSBmb3JlaWduVGFibGUgPyBcIlwiLmNvbmNhdChmb3JlaWduVGFibGUsIFwiLm9yZGVyXCIpIDogJ29yZGVyJztcbiAgICAgIHZhciBleGlzdGluZ09yZGVyID0gdGhpcy51cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpO1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIFwiXCIuY29uY2F0KGV4aXN0aW5nT3JkZXIgPyBcIlwiLmNvbmNhdChleGlzdGluZ09yZGVyLCBcIixcIikgOiAnJykuY29uY2F0KGNvbHVtbiwgXCIuXCIpLmNvbmNhdChhc2NlbmRpbmcgPyAnYXNjJyA6ICdkZXNjJykuY29uY2F0KG51bGxzRmlyc3QgPT09IHVuZGVmaW5lZCA/ICcnIDogbnVsbHNGaXJzdCA/ICcubnVsbHNmaXJzdCcgOiAnLm51bGxzbGFzdCcpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb3VudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY291bnQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byByZXR1cm5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIGZvcmVpZ24gdGFibGVzXG4gICAgICogaW5zdGVhZCBvZiB0aGUgY3VycmVudCB0YWJsZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImxpbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbWl0KGNvdW50KSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBmb3JlaWduVGFibGUgPSBfcmVmMi5mb3JlaWduVGFibGU7XG4gICAgICB2YXIga2V5ID0gdHlwZW9mIGZvcmVpZ25UYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnbGltaXQnIDogXCJcIi5jb25jYXQoZm9yZWlnblRhYmxlLCBcIi5saW1pdFwiKTtcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBcIlwiLmNvbmNhdChjb3VudCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgYGZyb21gIGFuZCBgdG9gIGluY2x1c2l2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb20gLSBUaGUgc3RhcnRpbmcgaW5kZXggZnJvbSB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIHRvIC0gVGhlIGxhc3QgaW5kZXggdG8gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgZm9yZWlnbiB0YWJsZXNcbiAgICAgKiBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHRhYmxlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICAgIGZvcmVpZ25UYWJsZSA9IF9yZWYzLmZvcmVpZ25UYWJsZTtcbiAgICAgIHZhciBrZXlPZmZzZXQgPSB0eXBlb2YgZm9yZWlnblRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdvZmZzZXQnIDogXCJcIi5jb25jYXQoZm9yZWlnblRhYmxlLCBcIi5vZmZzZXRcIik7XG4gICAgICB2YXIga2V5TGltaXQgPSB0eXBlb2YgZm9yZWlnblRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdsaW1pdCcgOiBcIlwiLmNvbmNhdChmb3JlaWduVGFibGUsIFwiLmxpbWl0XCIpO1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlPZmZzZXQsIFwiXCIuY29uY2F0KGZyb20pKTtcbiAgICAgIC8vIFJhbmdlIGlzIGluY2x1c2l2ZSwgc28gYWRkIDFcbiAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5TGltaXQsIFwiXCIuY29uY2F0KHRvIC0gZnJvbSArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIEFib3J0U2lnbmFsIGZvciB0aGUgZmV0Y2ggcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYWwgLSBUaGUgQWJvcnRTaWduYWwgdG8gdXNlIGZvciB0aGUgZmV0Y2ggcmVxdWVzdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFib3J0U2lnbmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0U2lnbmFsKHNpZ25hbCkge1xuICAgICAgdGhpcy5zaWduYWwgPSBzaWduYWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgICAqXG4gICAgICogUXVlcnkgcmVzdWx0IG11c3QgYmUgb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZSB0aGlzXG4gICAgICogcmV0dXJucyBhbiBlcnJvci5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaW5nbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2luZ2xlKCkge1xuICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIHplcm8gb3Igb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZVxuICAgICAqIHRoaXMgcmV0dXJucyBhbiBlcnJvci5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJtYXliZVNpbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXliZVNpbmdsZSgpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uJztcbiAgICAgIHRoaXMuYWxsb3dFbXB0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHN0cmluZyBpbiBDU1YgZm9ybWF0LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNzdlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjc3YoKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ3RleHQvY3N2JztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYGRhdGFgIGFzIGFuIG9iamVjdCBpbiBbR2VvSlNPTl0oaHR0cHM6Ly9nZW9qc29uLm9yZykgZm9ybWF0LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdlb2pzb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VvanNvbigpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vZ2VvK2pzb24nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgdGhlIEVYUExBSU4gcGxhbiBmb3IgdGhlIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbmFseXplIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgd2lsbCBiZSBleGVjdXRlZCBhbmQgdGhlXG4gICAgICogYWN0dWFsIHJ1biB0aW1lIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnZlcmJvc2UgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSBpZGVudGlmaWVyIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiBhbmQgYGRhdGFgIHdpbGwgaW5jbHVkZSB0aGUgb3V0cHV0IGNvbHVtbnMgb2YgdGhlIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zZXR0aW5ncyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBjb25maWd1cmF0aW9uXG4gICAgICogcGFyYW1ldGVycyB0aGF0IGFmZmVjdCBxdWVyeSBwbGFubmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYnVmZmVycyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBidWZmZXIgdXNhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLndhbCAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBXQUwgcmVjb3JkIGdlbmVyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgY2FuIGJlIGBcInRleHRcImAgKGRlZmF1bHQpXG4gICAgICogb3IgYFwianNvblwiYFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImV4cGxhaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhwbGFpbigpIHtcbiAgICAgIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWY0JGFuYWx5emUgPSBfcmVmNC5hbmFseXplLFxuICAgICAgICBhbmFseXplID0gX3JlZjQkYW5hbHl6ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNCRhbmFseXplLFxuICAgICAgICBfcmVmNCR2ZXJib3NlID0gX3JlZjQudmVyYm9zZSxcbiAgICAgICAgdmVyYm9zZSA9IF9yZWY0JHZlcmJvc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjQkdmVyYm9zZSxcbiAgICAgICAgX3JlZjQkc2V0dGluZ3MgPSBfcmVmNC5zZXR0aW5ncyxcbiAgICAgICAgc2V0dGluZ3MgPSBfcmVmNCRzZXR0aW5ncyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNCRzZXR0aW5ncyxcbiAgICAgICAgX3JlZjQkYnVmZmVycyA9IF9yZWY0LmJ1ZmZlcnMsXG4gICAgICAgIGJ1ZmZlcnMgPSBfcmVmNCRidWZmZXJzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY0JGJ1ZmZlcnMsXG4gICAgICAgIF9yZWY0JHdhbCA9IF9yZWY0LndhbCxcbiAgICAgICAgd2FsID0gX3JlZjQkd2FsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY0JHdhbCxcbiAgICAgICAgX3JlZjQkZm9ybWF0ID0gX3JlZjQuZm9ybWF0LFxuICAgICAgICBmb3JtYXQgPSBfcmVmNCRmb3JtYXQgPT09IHZvaWQgMCA/ICd0ZXh0JyA6IF9yZWY0JGZvcm1hdDtcbiAgICAgIHZhciBvcHRpb25zID0gW2FuYWx5emUgPyAnYW5hbHl6ZScgOiBudWxsLCB2ZXJib3NlID8gJ3ZlcmJvc2UnIDogbnVsbCwgc2V0dGluZ3MgPyAnc2V0dGluZ3MnIDogbnVsbCwgYnVmZmVycyA/ICdidWZmZXJzJyA6IG51bGwsIHdhbCA/ICd3YWwnIDogbnVsbF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ3wnKTtcbiAgICAgIC8vIEFuIEFjY2VwdCBoZWFkZXIgY2FuIGNhcnJ5IG11bHRpcGxlIG1lZGlhIHR5cGVzIGJ1dCBwb3N0Z3Jlc3QtanMgYWx3YXlzIHNlbmRzIG9uZVxuICAgICAgdmFyIGZvck1lZGlhdHlwZSA9IHRoaXMuaGVhZGVyc1snQWNjZXB0J107XG4gICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gXCJhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbitcIi5jb25jYXQoZm9ybWF0LCBcIjsgZm9yPVxcXCJcIikuY29uY2F0KGZvck1lZGlhdHlwZSwgXCJcXFwiOyBvcHRpb25zPVwiKS5jb25jYXQob3B0aW9ucywgXCI7XCIpO1xuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2pzb24nKSByZXR1cm4gdGhpcztlbHNlIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb2xsYmFjayB0aGUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBgZGF0YWAgd2lsbCBzdGlsbCBiZSByZXR1cm5lZCwgYnV0IHRoZSBxdWVyeSBpcyBub3QgY29tbWl0dGVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJvbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvbGxiYWNrKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCgoX2EgPSB0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSArPSAnLHR4PXJvbGxiYWNrJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSAndHg9cm9sbGJhY2snO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJldHVybnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV0dXJucygpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjtcbn0oUG9zdGdyZXN0QnVpbGRlcl8xW1wiZGVmYXVsdFwiXSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN1FVRkJRVHRCUVVGcFJDeEpRVk0xUWtFc2VVSkJTVzVDTzBWQlFVRTdSVUZCUVR0RlFVRkJPMGxCUVVFN1NVRkJRVHRGUVVGQk8wVkJRVUU3U1VGQlFUdEpRVUZCTzBsQlEwRTdPenM3T3pzN096dEpRVk5CTEdkQ1FVTkZReXhQUVVGbE8wMUJSV1k3VFVGRFFTeEpRVUZKUXl4TlFVRk5MRWRCUVVjc1MwRkJTenROUVVOc1FpeEpRVUZOUXl4alFVRmpMRWRCUVVjc1EwRkJRMFlzVDBGQlR5eGhRVUZRUVN4UFFVRlBMR05CUVZCQkxFOUJRVThzUjBGQlNTeEhRVUZITEVWQlEyNURSeXhMUVVGTExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlExUkRMRWRCUVVjc1EwRkJReXhWUVVGRFF5eERRVUZETEVWQlFVazdVVUZEVkN4SlFVRkpMRWxCUVVrc1EwRkJRME1zU1VGQlNTeERRVUZEUkN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRFNpeE5RVUZOTEVWQlFVVTdWVUZETTBJc1QwRkJUeXhGUVVGRk96dFJRVVZZTEVsQlFVbEpMRU5CUVVNc1MwRkJTeXhIUVVGSExFVkJRVVU3VlVGRFlrb3NUVUZCVFN4SFFVRkhMRU5CUVVOQkxFMUJRVTA3TzFGQlJXeENMRTlCUVU5SkxFTkJRVU03VFVGRFZpeERRVUZETEVOQlFVTXNRMEZEUkVVc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF6dE5RVU5ZTEVsQlFVa3NRMEZCUTBNc1IwRkJSeXhEUVVGRFF5eFpRVUZaTEVOQlFVTkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFVkJRVVZTTEdOQlFXTXNRMEZCUXp0TlFVTnVSQ3hKUVVGSkxFbEJRVWtzUTBGQlExTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1EwRkJReXhGUVVGRk8xRkJRekZDTEVsQlFVa3NRMEZCUTBFc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVkQlFVYzdPMDFCUlM5Q0xFbEJRVWtzUTBGQlEwRXNUMEZCVHl4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxIVkNRVUYxUWp0TlFVTnFSQ3hQUVVGUExFbEJRVzlGTzBsQlF6ZEZPMGxCVlVFN096czdPenM3T3pzN096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZuUWtFc1pVRkRSVU1zVFVGQll5eEZRVXM0UkR0TlFVRkJMQ3RGUVVGR0xFVkJRVVU3VVVGQlFTeHpRa0ZJTVVWRExGTkJRVk03VVVGQlZFRXNVMEZCVXl3clFrRkJSeXhKUVVGSk8xRkJRMmhDUXl4VlFVRlZMRkZCUVZaQkxGVkJRVlU3VVVGRFZrTXNXVUZCV1N4UlFVRmFRU3haUVVGWk8wMUJSMlFzU1VGQlRVTXNSMEZCUnl4SFFVRkhSQ3haUVVGWkxHRkJRVTFCTEZsQlFWa3NZMEZCVnl4UFFVRlBPMDFCUXpWRUxFbEJRVTFGTEdGQlFXRXNSMEZCUnl4SlFVRkpMRU5CUVVOVUxFZEJRVWNzUTBGQlEwTXNXVUZCV1N4RFFVRkRVeXhIUVVGSExFTkJRVU5HTEVkQlFVY3NRMEZCUXp0TlFVVndSQ3hKUVVGSkxFTkJRVU5TTEVkQlFVY3NRMEZCUTBNc1dVRkJXU3hEUVVGRFF5eEhRVUZITEVOQlEzWkNUU3hIUVVGSExGbEJRMEZETEdGQlFXRXNZVUZCVFVFc1lVRkJZU3hUUVVGTkxFVkJRVVVzVTBGQlIwd3NUVUZCVFN4alFVRkpReXhUUVVGVExFZEJRVWNzUzBGQlN5eEhRVUZITEUxQlFVMHNVMEZEYUVaRExGVkJRVlVzUzBGQlMwc3NVMEZCVXl4SFFVRkhMRVZCUVVVc1IwRkJSMHdzVlVGQlZTeEhRVUZITEdGQlFXRXNSMEZCUnl4WlFVTXZSQ3hGUVVORU8wMUJRMFFzVDBGQlR5eEpRVUZKTzBsQlEySTdTVUZGUVRzN096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZSUVN4bFFVRk5UU3hMUVVGaExFVkJRV3RFTzAxQlFVRXNaMFpCUVVZc1JVRkJSVHRSUVVFNVEwd3NXVUZCV1N4VFFVRmFRU3haUVVGWk8wMUJRMnBETEVsQlFVMURMRWRCUVVjc1IwRkJSeXhQUVVGUFJDeFpRVUZaTEV0QlFVc3NWMEZCVnl4SFFVRkhMRTlCUVU4c1lVRkJUVUVzV1VGQldTeFhRVUZSTzAxQlEyNUdMRWxCUVVrc1EwRkJRMUFzUjBGQlJ5eERRVUZEUXl4WlFVRlpMRU5CUVVORExFZEJRVWNzUTBGQlEwMHNSMEZCUnl4WlFVRkxTU3hMUVVGTExFVkJRVWM3VFVGRE1VTXNUMEZCVHl4SlFVRkpPMGxCUTJJN1NVRkZRVHM3T3pzN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJVMEVzWlVGQlRVTXNTVUZCV1N4RlFVRkZReXhGUVVGVkxFVkJRV3RFTzAxQlFVRXNaMFpCUVVZc1JVRkJSVHRSUVVFNVExQXNXVUZCV1N4VFFVRmFRU3haUVVGWk8wMUJRelZETEVsQlFVMVJMRk5CUVZNc1IwRkJSeXhQUVVGUFVpeFpRVUZaTEV0QlFVc3NWMEZCVnl4SFFVRkhMRkZCUVZFc1lVRkJUVUVzV1VGQldTeFpRVUZUTzAxQlF6TkdMRWxCUVUxVExGRkJRVkVzUjBGQlJ5eFBRVUZQVkN4WlFVRlpMRXRCUVVzc1YwRkJWeXhIUVVGSExFOUJRVThzWVVGQlRVRXNXVUZCV1N4WFFVRlJPMDFCUTNoR0xFbEJRVWtzUTBGQlExQXNSMEZCUnl4RFFVRkRReXhaUVVGWkxFTkJRVU5ETEVkQlFVY3NRMEZCUTJFc1UwRkJVeXhaUVVGTFJpeEpRVUZKTEVWQlFVYzdUVUZETDBNN1RVRkRRU3hKUVVGSkxFTkJRVU5pTEVkQlFVY3NRMEZCUTBNc1dVRkJXU3hEUVVGRFF5eEhRVUZITEVOQlFVTmpMRkZCUVZFc1dVRkJTMFlzUlVGQlJTeEhRVUZIUkN4SlFVRkpMRWRCUVVjc1EwRkJReXhGUVVGSE8wMUJRM1pFTEU5QlFVOHNTVUZCU1R0SlFVTmlPMGxCUlVFN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJTMEVzY1VKQlFWbEpMRTFCUVcxQ08wMUJRemRDTEVsQlFVa3NRMEZCUTBFc1RVRkJUU3hIUVVGSFFTeE5RVUZOTzAxQlEzQkNMRTlCUVU4c1NVRkJTVHRKUVVOaU8wbEJSVUU3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVMUJMR3RDUVVGTk8wMUJRMG9zU1VGQlNTeERRVUZEWkN4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzYlVOQlFXMURPMDFCUXpWRUxFOUJRVThzU1VGQmIwUTdTVUZETjBRN1NVRkZRVHM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlRVRXNkVUpCUVZjN1RVRkRWQ3hKUVVGSkxFTkJRVU5CTEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXh0UTBGQmJVTTdUVUZETlVRc1NVRkJTU3hEUVVGRFpTeFZRVUZWTEVkQlFVY3NTVUZCU1R0TlFVTjBRaXhQUVVGUExFbEJRWGxFTzBsQlEyeEZPMGxCUlVFN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVZEJMR1ZCUVVjN1RVRkRSQ3hKUVVGSkxFTkJRVU5tTEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhWUVVGVk8wMUJRMjVETEU5QlFVOHNTVUZCYjBRN1NVRkROMFE3U1VGRlFUczdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJSMEVzYlVKQlFVODdUVUZEVEN4SlFVRkpMRU5CUVVOQkxFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4elFrRkJjMEk3VFVGREwwTXNUMEZCVHl4SlFVRnhSVHRKUVVNNVJUdEpRVVZCT3pzN096czdPenM3T3pzN096czdPenM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGeFFrRXNiVUpCWTAwN1RVRkJRU3huUmtGQlJpeEZRVUZGTzFGQlFVRXNjMEpCWWtwblFpeFBRVUZQTzFGQlFWQkJMRTlCUVU4c09FSkJRVWNzUzBGQlN6dFJRVUZCTEhOQ1FVTm1ReXhQUVVGUE8xRkJRVkJCTEU5QlFVOHNPRUpCUVVjc1MwRkJTenRSUVVGQkxIVkNRVU5tUXl4UlFVRlJPMUZCUVZKQkxGRkJRVkVzSzBKQlFVY3NTMEZCU3p0UlFVRkJMSE5DUVVOb1FrTXNUMEZCVHp0UlFVRlFRU3hQUVVGUExEaENRVUZITEV0QlFVczdVVUZCUVN4clFrRkRaa01zUjBGQlJ6dFJRVUZJUVN4SFFVRkhMREJDUVVGSExFdEJRVXM3VVVGQlFTeHhRa0ZEV0VNc1RVRkJUVHRSUVVGT1FTeE5RVUZOTERaQ1FVRkhMRTFCUVUwN1RVRlhaaXhKUVVGTlF5eFBRVUZQTEVkQlFVY3NRMEZEWkU0c1QwRkJUeXhIUVVGSExGTkJRVk1zUjBGQlJ5eEpRVUZKTEVWQlF6RkNReXhQUVVGUExFZEJRVWNzVTBGQlV5eEhRVUZITEVsQlFVa3NSVUZETVVKRExGRkJRVkVzUjBGQlJ5eFZRVUZWTEVkQlFVY3NTVUZCU1N4RlFVTTFRa01zVDBGQlR5eEhRVUZITEZOQlFWTXNSMEZCUnl4SlFVRkpMRVZCUXpGQ1F5eEhRVUZITEVkQlFVY3NTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkRia0lzUTBGRFJVY3NUVUZCVFN4RFFVRkRReXhQUVVGUExFTkJRVU1zUTBGRFpqVkNMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU03VFVGRFdqdE5RVU5CTEVsQlFVMDJRaXhaUVVGWkxFZEJRVWNzU1VGQlNTeERRVUZEZWtJc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF6dE5RVU16UXl4SlFVRkpMRU5CUVVOQkxFOUJRVThzUTBGRFZpeFJRVUZSTEVOQlExUXNkME5CUVdsRGNVSXNUVUZCVFN4eFFrRkJWVWtzV1VGQldTeDVRa0ZCWTBnc1QwRkJUeXhOUVVGSE8wMUJRM1JHTEVsQlFVbEVMRTFCUVUwc1MwRkJTeXhOUVVGTkxFVkJRVVVzVDBGQlR5eEpRVUVyUkN4TlFVTjRSaXhQUVVGUExFbEJRVzlFTzBsQlEyeEZPMGxCUlVFN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJTMEVzYjBKQlFWRTdPMDFCUTA0c1NVRkJTU3hEUVVGRExGVkJRVWtzUTBGQlEzSkNMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zYlVOQlFVa3NSVUZCUlN4RlFVRkZNRUlzU1VGQlNTeEZRVUZGTEVOQlFVTkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFVkJRVVU3VVVGRGNFUXNTVUZCU1N4RFFVRkRNMElzVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMR05CUVdNN1QwRkRla01zVFVGQlRUdFJRVU5NTEVsQlFVa3NRMEZCUTBFc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEdGQlFXRTdPMDFCUlhoRExFOUJRVThzU1VGQlNUdEpRVU5pTzBsQlJVRTdPenM3TzBWQlFVRTdTVUZCUVR0SlFVRkJMRTlCUzBFc2JVSkJRVTg3VFVGRFRDeFBRVUZQTEVsQlFXOUZPMGxCUXpkRk8wVkJRVU03UlVGQlFUdEJRVUZCTEVWQk4wOVBORUlzTmtKQlFYZENPMEZCU214RFF5SXNJbTVoYldWeklqcGJJbEJ2YzNSbmNtVnpkRlJ5WVc1elptOXliVUoxYVd4a1pYSWlMQ0pqYjJ4MWJXNXpJaXdpY1hWdmRHVmtJaXdpWTJ4bFlXNWxaRU52YkhWdGJuTWlMQ0p6Y0d4cGRDSXNJbTFoY0NJc0ltTWlMQ0owWlhOMElpd2lhbTlwYmlJc0luVnliQ0lzSW5ObFlYSmphRkJoY21GdGN5SXNJbk5sZENJc0ltaGxZV1JsY25NaUxDSmpiMngxYlc0aUxDSmhjMk5sYm1ScGJtY2lMQ0p1ZFd4c2MwWnBjbk4wSWl3aVptOXlaV2xuYmxSaFlteGxJaXdpYTJWNUlpd2laWGhwYzNScGJtZFBjbVJsY2lJc0ltZGxkQ0lzSW5WdVpHVm1hVzVsWkNJc0ltTnZkVzUwSWl3aVpuSnZiU0lzSW5Sdklpd2lhMlY1VDJabWMyVjBJaXdpYTJWNVRHbHRhWFFpTENKemFXZHVZV3dpTENKaGJHeHZkMFZ0Y0hSNUlpd2lZVzVoYkhsNlpTSXNJblpsY21KdmMyVWlMQ0p6WlhSMGFXNW5jeUlzSW1KMVptWmxjbk1pTENKM1lXd2lMQ0ptYjNKdFlYUWlMQ0p2Y0hScGIyNXpJaXdpWm1sc2RHVnlJaXdpUW05dmJHVmhiaUlzSW1admNrMWxaR2xoZEhsd1pTSXNJblJ5YVcwaUxDSnNaVzVuZEdnaUxDSlFiM04wWjNKbGMzUkNkV2xzWkdWeVh6RWlMQ0psZUhCdmNuUnpJbDBzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5UWIzTjBaM0psYzNSVWNtRnVjMlp2Y20xQ2RXbHNaR1Z5TG5SeklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJiblZzYkYxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ERUZBVUxUX0hFQURFUlMgPSB2b2lkIDA7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMuREVGQVVMVF9IRUFERVJTID0ge1xuICAnWC1DbGllbnQtSW5mbyc6IFwicG9zdGdyZXN0LWpzL1wiLmNvbmNhdCh2ZXJzaW9uXzEudmVyc2lvbilcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN08wRkJRVUU3UVVGRFlVRXNkVUpCUVdVc1IwRkJSenRGUVVGRkxHVkJRV1VzZVVKQlFXdENReXhwUWtGQlR6dEJRVUZGTEVOQlFVVWlMQ0p1WVcxbGN5STZXeUpsZUhCdmNuUnpJaXdpZG1WeWMybHZibDh4SWwwc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWpiMjV6ZEdGdWRITXVkSE1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2x0dWRXeHNYWDA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUG9zdGdyZXN0QnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0RmlsdGVyQnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0UXVlcnlCdWlsZGVyID0gZXhwb3J0cy5Qb3N0Z3Jlc3RDbGllbnQgPSB2b2lkIDA7XG52YXIgUG9zdGdyZXN0Q2xpZW50XzEgPSByZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RDbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb3N0Z3Jlc3RDbGllbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX19pbXBvcnREZWZhdWx0KFBvc3RncmVzdENsaWVudF8xKVtcImRlZmF1bHRcIl07XG4gIH1cbn0pO1xudmFyIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vUG9zdGdyZXN0UXVlcnlCdWlsZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9zdGdyZXN0UXVlcnlCdWlsZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJfMSlbXCJkZWZhdWx0XCJdO1xuICB9XG59KTtcbnZhciBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfX2ltcG9ydERlZmF1bHQoUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xKVtcImRlZmF1bHRcIl07XG4gIH1cbn0pO1xudmFyIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEpW1wiZGVmYXVsdFwiXTtcbiAgfVxufSk7XG52YXIgUG9zdGdyZXN0QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vUG9zdGdyZXN0QnVpbGRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBvc3RncmVzdEJ1aWxkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX19pbXBvcnREZWZhdWx0KFBvc3RncmVzdEJ1aWxkZXJfMSlbXCJkZWZhdWx0XCJdO1xuICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdRVUZCUVR0QlFVRlRRVHRGUVVGQlF6dEZRVUZCUXp0SlFVRkJMRzlFUVVGUE8wVkJRVUU3UVVGQlFUdEJRVU5vUWp0QlFVRlRSanRGUVVGQlF6dEZRVUZCUXp0SlFVRkJMREJFUVVGUE8wVkJRVUU3UVVGQlFUdEJRVU5vUWp0QlFVRlRSanRGUVVGQlF6dEZRVUZCUXp0SlFVRkJMREpFUVVGUE8wVkJRVUU3UVVGQlFUdEJRVU5vUWp0QlFVRlRSanRGUVVGQlF6dEZRVUZCUXp0SlFVRkJMRGhFUVVGUE8wVkJRVUU3UVVGQlFUdEJRVU5vUWp0QlFVRlRSanRGUVVGQlF6dEZRVUZCUXp0SlFVRkJMSEZFUVVGUE8wVkJRVUU3UVVGQlFTSXNJbTVoYldWeklqcGJJazlpYW1WamRDSXNJbVZ1ZFcxbGNtRmliR1VpTENKblpYUWlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJsdVpHVjRMblJ6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYmJuVnNiRjE5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSAnMS4xLjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPMEZCUVdGQkxHVkJRVThzUjBGQlJ5SXNJbTVoYldWeklqcGJJbVY0Y0c5eWRITWlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDNabGNuTnBiMjR1ZEhNaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sdHVkV3hzWFgwPSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgX19jcmVhdGVCaW5kaW5nID0gdm9pZCAwICYmICh2b2lkIDApLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgZGVzYyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdlxuICB9KTtcbn0gOiBmdW5jdGlvbiAobywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdm9pZCAwICYmICh2b2lkIDApLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMgPSBleHBvcnRzLlJFQUxUSU1FX0xJU1RFTl9UWVBFUyA9IGV4cG9ydHMuUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9saWIvY29uc3RhbnRzXCIpO1xudmFyIHB1c2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9saWIvcHVzaFwiKSk7XG52YXIgdGltZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdGltZXJcIikpO1xudmFyIFJlYWx0aW1lUHJlc2VuY2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9SZWFsdGltZVByZXNlbmNlXCIpKTtcbnZhciBUcmFuc2Zvcm1lcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbGliL3RyYW5zZm9ybWVyc1wiKSk7XG52YXIgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQ7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UKSB7XG4gIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiQUxMXCJdID0gXCIqXCI7XG4gIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiSU5TRVJUXCJdID0gXCJJTlNFUlRcIjtcbiAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJVUERBVEVcIl0gPSBcIlVQREFURVwiO1xuICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG59KShSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCA9IGV4cG9ydHMuUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgfHwgKGV4cG9ydHMuUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSB7fSkpO1xudmFyIFJFQUxUSU1FX0xJU1RFTl9UWVBFUztcbihmdW5jdGlvbiAoUkVBTFRJTUVfTElTVEVOX1RZUEVTKSB7XG4gIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIkJST0FEQ0FTVFwiXSA9IFwiYnJvYWRjYXN0XCI7XG4gIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlBSRVNFTkNFXCJdID0gXCJwcmVzZW5jZVwiO1xuICBSRUFMVElNRV9MSVNURU5fVFlQRVNbXCJQT1NUR1JFU19DSEFOR0VTXCJdID0gXCJwb3N0Z3Jlc19jaGFuZ2VzXCI7XG59KShSRUFMVElNRV9MSVNURU5fVFlQRVMgPSBleHBvcnRzLlJFQUxUSU1FX0xJU1RFTl9UWVBFUyB8fCAoZXhwb3J0cy5SRUFMVElNRV9MSVNURU5fVFlQRVMgPSB7fSkpO1xudmFyIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMpIHtcbiAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIlNVQlNDUklCRURcIl0gPSBcIlNVQlNDUklCRURcIjtcbiAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIlRJTUVEX09VVFwiXSA9IFwiVElNRURfT1VUXCI7XG4gIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDTE9TRURcIl0gPSBcIkNMT1NFRFwiO1xuICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiQ0hBTk5FTF9FUlJPUlwiXSA9IFwiQ0hBTk5FTF9FUlJPUlwiO1xufSkoUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyA9IGV4cG9ydHMuUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyB8fCAoZXhwb3J0cy5SRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTID0ge30pKTtcbi8qKiBBIGNoYW5uZWwgaXMgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIG9mIFJlYWx0aW1lXG4gKiBhbmQgbmFycm93cyB0aGUgc2NvcGUgb2YgZGF0YSBmbG93IHRvIHN1YnNjcmliZWQgY2xpZW50cy5cbiAqIFlvdSBjYW4gdGhpbmsgb2YgYSBjaGFubmVsIGFzIGEgY2hhdHJvb20gd2hlcmUgcGFydGljaXBhbnRzIGFyZSBhYmxlIHRvIHNlZSB3aG8ncyBvbmxpbmVcbiAqIGFuZCBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzLlxuICoqL1xudmFyIFJlYWx0aW1lQ2hhbm5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlYWx0aW1lQ2hhbm5lbCggLyoqIFRvcGljIG5hbWUgY2FuIGJlIGFueSBzdHJpbmcuICovXG4gIHRvcGljKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBjb25maWc6IHt9XG4gICAgfTtcbiAgICB2YXIgc29ja2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWx0aW1lQ2hhbm5lbCk7XG4gICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB0aGlzLnN0YXRlID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgIHRoaXMuam9pbmVkT25jZSA9IGZhbHNlO1xuICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgIHRoaXMucGFyYW1zLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYnJvYWRjYXN0OiB7XG4gICAgICAgIGFjazogZmFsc2UsXG4gICAgICAgIHNlbGY6IGZhbHNlXG4gICAgICB9LFxuICAgICAgcHJlc2VuY2U6IHtcbiAgICAgICAga2V5OiAnJ1xuICAgICAgfVxuICAgIH0sIHBhcmFtcy5jb25maWcpO1xuICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXQ7XG4gICAgdGhpcy5qb2luUHVzaCA9IG5ldyBwdXNoXzFbXCJkZWZhdWx0XCJdKHRoaXMsIGNvbnN0YW50c18xLkNIQU5ORUxfRVZFTlRTLmpvaW4sIHRoaXMucGFyYW1zLCB0aGlzLnRpbWVvdXQpO1xuICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgdGltZXJfMVtcImRlZmF1bHRcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9yZWpvaW5VbnRpbENvbm5lY3RlZCgpO1xuICAgIH0sIHRoaXMuc29ja2V0LnJlY29ubmVjdEFmdGVyTXMpO1xuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgnb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zdGF0ZSA9IGNvbnN0YW50c18xLkNIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICAgIF90aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICBfdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKHB1c2hFdmVudCkge1xuICAgICAgICByZXR1cm4gcHVzaEV2ZW50LnNlbmQoKTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgIH0pO1xuICAgIHRoaXMuX29uQ2xvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgIF90aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBcImNsb3NlIFwiLmNvbmNhdChfdGhpcy50b3BpYywgXCIgXCIpLmNvbmNhdChfdGhpcy5fam9pblJlZigpKSk7XG4gICAgICBfdGhpcy5zdGF0ZSA9IGNvbnN0YW50c18xLkNIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgIF90aGlzLnNvY2tldC5fcmVtb3ZlKF90aGlzKTtcbiAgICB9KTtcbiAgICB0aGlzLl9vbkVycm9yKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChfdGhpcy5faXNMZWF2aW5nKCkgfHwgX3RoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIFwiZXJyb3IgXCIuY29uY2F0KF90aGlzLnRvcGljKSwgcmVhc29uKTtcbiAgICAgIF90aGlzLnN0YXRlID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgIF90aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH0pO1xuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgndGltZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMuX2lzSm9pbmluZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBcInRpbWVvdXQgXCIuY29uY2F0KF90aGlzLnRvcGljKSwgX3RoaXMuam9pblB1c2gudGltZW91dCk7XG4gICAgICBfdGhpcy5zdGF0ZSA9IGNvbnN0YW50c18xLkNIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICBfdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICB9KTtcbiAgICB0aGlzLl9vbihjb25zdGFudHNfMS5DSEFOTkVMX0VWRU5UUy5yZXBseSwge30sIGZ1bmN0aW9uIChwYXlsb2FkLCByZWYpIHtcbiAgICAgIF90aGlzLl90cmlnZ2VyKF90aGlzLl9yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKTtcbiAgICB9KTtcbiAgICB0aGlzLnByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2VfMVtcImRlZmF1bHRcIl0odGhpcyk7XG4gIH1cbiAgLyoqIFN1YnNjcmliZSByZWdpc3RlcnMgeW91ciBjbGllbnQgd2l0aCB0aGUgc2VydmVyICovXG4gIF9jcmVhdGVDbGFzcyhSZWFsdGltZUNoYW5uZWwsIFt7XG4gICAga2V5OiBcInN1YnNjcmliZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudGltZW91dDtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAodGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICAgIHRocm93IFwidHJpZWQgdG8gc3Vic2NyaWJlIG11bHRpcGxlIHRpbWVzLiAnc3Vic2NyaWJlJyBjYW4gb25seSBiZSBjYWxsZWQgYSBzaW5nbGUgdGltZSBwZXIgY2hhbm5lbCBpbnN0YW5jZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90aGlzJHBhcmFtcyRjb25maWcgPSB0aGlzLnBhcmFtcy5jb25maWcsXG4gICAgICAgICAgYnJvYWRjYXN0ID0gX3RoaXMkcGFyYW1zJGNvbmZpZy5icm9hZGNhc3QsXG4gICAgICAgICAgcHJlc2VuY2UgPSBfdGhpcyRwYXJhbXMkY29uZmlnLnByZXNlbmNlO1xuICAgICAgICB0aGlzLl9vbkVycm9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKCdDSEFOTkVMX0VSUk9SJywgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbkNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soJ0NMT1NFRCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGFjY2Vzc1Rva2VuUGF5bG9hZCA9IHt9O1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgIGJyb2FkY2FzdDogYnJvYWRjYXN0LFxuICAgICAgICAgIHByZXNlbmNlOiBwcmVzZW5jZSxcbiAgICAgICAgICBwb3N0Z3Jlc19jaGFuZ2VzOiAoX2IgPSAoX2EgPSB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByLmZpbHRlcjtcbiAgICAgICAgICB9KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgYWNjZXNzVG9rZW5QYXlsb2FkLmFjY2Vzc190b2tlbiA9IHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlSm9pblBheWxvYWQoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgfSwgYWNjZXNzVG9rZW5QYXlsb2FkKSk7XG4gICAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Jlam9pbih0aW1lb3V0KTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCdvaycsIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgIHZhciBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlcnMgPSBfcmVmMi5wb3N0Z3Jlc19jaGFuZ2VzO1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBfdGhpczIuc29ja2V0LmFjY2Vzc1Rva2VuICYmIF90aGlzMi5zb2NrZXQuc2V0QXV0aChfdGhpczIuc29ja2V0LmFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICBpZiAoc2VydmVyUG9zdGdyZXNGaWx0ZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCdTVUJTQ1JJQkVEJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID0gX3RoaXMyLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXM7XG4gICAgICAgICAgICB2YXIgYmluZGluZ3NMZW4gPSAoX2EgPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID09PSBudWxsIHx8IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsaWVudFBvc3RncmVzQmluZGluZ3MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgdmFyIG5ld1Bvc3RncmVzQmluZGluZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluZGluZ3NMZW47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY2xpZW50UG9zdGdyZXNCaW5kaW5nID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nc1tpXTtcbiAgICAgICAgICAgICAgdmFyIF9jbGllbnRQb3N0Z3Jlc0JpbmRpbiA9IGNsaWVudFBvc3RncmVzQmluZGluZy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgZXZlbnQgPSBfY2xpZW50UG9zdGdyZXNCaW5kaW4uZXZlbnQsXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gX2NsaWVudFBvc3RncmVzQmluZGluLnNjaGVtYSxcbiAgICAgICAgICAgICAgICB0YWJsZSA9IF9jbGllbnRQb3N0Z3Jlc0JpbmRpbi50YWJsZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBfY2xpZW50UG9zdGdyZXNCaW5kaW4uZmlsdGVyO1xuICAgICAgICAgICAgICB2YXIgc2VydmVyUG9zdGdyZXNGaWx0ZXIgPSBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlcnMgJiYgc2VydmVyUG9zdGdyZXNGaWx0ZXJzW2ldO1xuICAgICAgICAgICAgICBpZiAoc2VydmVyUG9zdGdyZXNGaWx0ZXIgJiYgc2VydmVyUG9zdGdyZXNGaWx0ZXIuZXZlbnQgPT09IGV2ZW50ICYmIHNlcnZlclBvc3RncmVzRmlsdGVyLnNjaGVtYSA9PT0gc2NoZW1hICYmIHNlcnZlclBvc3RncmVzRmlsdGVyLnRhYmxlID09PSB0YWJsZSAmJiBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5maWx0ZXIgPT09IGZpbHRlcikge1xuICAgICAgICAgICAgICAgIG5ld1Bvc3RncmVzQmluZGluZ3MucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNsaWVudFBvc3RncmVzQmluZGluZyksIHtcbiAgICAgICAgICAgICAgICAgIGlkOiBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5pZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygnQ0hBTk5FTF9FUlJPUicsIG5ldyBFcnJvcignbWlzbWF0Y2ggYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCBiaW5kaW5ncyBmb3IgcG9zdGdyZXMgY2hhbmdlcycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzMi5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzID0gbmV3UG9zdGdyZXNCaW5kaW5ncztcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCdTVUJTQ1JJQkVEJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9KS5yZWNlaXZlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCdDSEFOTkVMX0VSUk9SJywgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KE9iamVjdC52YWx1ZXMoZXJyb3IpLmpvaW4oJywgJykgfHwgJ2Vycm9yJykpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pLnJlY2VpdmUoJ3RpbWVvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soJ1RJTUVEX09VVCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlc2VuY2VTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVzZW5jZVN0YXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2Uuc3RhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWNrKHBheWxvYWQpIHtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgICAgICBldmVudDogJ3RyYWNrJyxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICAgICAgICAgIH0sIG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVudHJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50cmFjaygpIHtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgICAgICBldmVudDogJ3VudHJhY2snXG4gICAgICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb24odHlwZSwgZmlsdGVyLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZChwYXlsb2FkKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdmFyIHB1c2ggPSBfdGhpczMuX3B1c2gocGF5bG9hZC50eXBlLCBwYXlsb2FkLCBvcHRzLnRpbWVvdXQgfHwgX3RoaXMzLnRpbWVvdXQpO1xuICAgICAgICBpZiAocHVzaC5yYXRlTGltaXRlZCkge1xuICAgICAgICAgIHJlc29sdmUoJ3JhdGUgbGltaXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdicm9hZGNhc3QnICYmICEoKF9jID0gKF9iID0gKF9hID0gX3RoaXMzLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJyb2FkY2FzdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjaykpIHtcbiAgICAgICAgICByZXNvbHZlKCdvaycpO1xuICAgICAgICB9XG4gICAgICAgIHB1c2gucmVjZWl2ZSgnb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoJ29rJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoJ3RpbWVkIG91dCcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVKb2luUGF5bG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVKb2luUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICB0aGlzLmpvaW5QdXNoLnVwZGF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZCBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyLlxuICAgICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rcy5cbiAgICAgKlxuICAgICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBhIGByZWNlaXZlYCBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgICAqIGNoYW5uZWwudW5zdWJzY3JpYmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5zdWJzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnRpbWVvdXQ7XG4gICAgICB0aGlzLnN0YXRlID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMubGVhdmluZztcbiAgICAgIHZhciBvbkNsb3NlID0gZnVuY3Rpb24gb25DbG9zZSgpIHtcbiAgICAgICAgX3RoaXM0LnNvY2tldC5sb2coJ2NoYW5uZWwnLCBcImxlYXZlIFwiLmNvbmNhdChfdGhpczQudG9waWMpKTtcbiAgICAgICAgX3RoaXM0Ll90cmlnZ2VyKGNvbnN0YW50c18xLkNIQU5ORUxfRVZFTlRTLmNsb3NlLCAnbGVhdmUnLCBfdGhpczQuX2pvaW5SZWYoKSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgLy8gRGVzdHJveSBqb2luUHVzaCB0byBhdm9pZCBjb25uZWN0aW9uIHRpbWVvdXRzIGR1cmluZyB1bnNjcmlwdGlvbiBwaGFzZVxuICAgICAgdGhpcy5qb2luUHVzaC5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIGxlYXZlUHVzaCA9IG5ldyBwdXNoXzFbXCJkZWZhdWx0XCJdKF90aGlzNCwgY29uc3RhbnRzXzEuQ0hBTk5FTF9FVkVOVFMubGVhdmUsIHt9LCB0aW1lb3V0KTtcbiAgICAgICAgbGVhdmVQdXNoLnJlY2VpdmUoJ29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICByZXNvbHZlKCdvaycpO1xuICAgICAgICB9KS5yZWNlaXZlKCd0aW1lb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICByZXNvbHZlKCd0aW1lZCBvdXQnKTtcbiAgICAgICAgfSkucmVjZWl2ZSgnZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZSgnZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxlYXZlUHVzaC5zZW5kKCk7XG4gICAgICAgIGlmICghX3RoaXM0Ll9jYW5QdXNoKCkpIHtcbiAgICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcignb2snLCB7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3B1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3B1c2goZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgIHZhciB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLnRpbWVvdXQ7XG4gICAgICBpZiAoIXRoaXMuam9pbmVkT25jZSkge1xuICAgICAgICB0aHJvdyBcInRyaWVkIHRvIHB1c2ggJ1wiLmNvbmNhdChldmVudCwgXCInIHRvICdcIikuY29uY2F0KHRoaXMudG9waWMsIFwiJyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuc3Vic2NyaWJlKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHB1c2hFdmVudCA9IG5ldyBwdXNoXzFbXCJkZWZhdWx0XCJdKHRoaXMsIGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0KTtcbiAgICAgIGlmICh0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgcHVzaEV2ZW50LnNlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdXNoRXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgICAqXG4gICAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZyBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NZXNzYWdlKF9ldmVudCwgcGF5bG9hZCwgX3JlZikge1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaXNNZW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzTWVtYmVyKHRvcGljKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3BpYyA9PT0gdG9waWM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgfSwge1xuICAgIGtleTogXCJfam9pblJlZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfam9pblJlZigpIHtcbiAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcIl90cmlnZ2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmlnZ2VyKHR5cGUsIHBheWxvYWQsIHJlZikge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdmFyIHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgIHZhciBfY29uc3RhbnRzXzEkQ0hBTk5FTF8gPSBjb25zdGFudHNfMS5DSEFOTkVMX0VWRU5UUyxcbiAgICAgICAgY2xvc2UgPSBfY29uc3RhbnRzXzEkQ0hBTk5FTF8uY2xvc2UsXG4gICAgICAgIGVycm9yID0gX2NvbnN0YW50c18xJENIQU5ORUxfLmVycm9yLFxuICAgICAgICBsZWF2ZSA9IF9jb25zdGFudHNfMSRDSEFOTkVMXy5sZWF2ZSxcbiAgICAgICAgam9pbiA9IF9jb25zdGFudHNfMSRDSEFOTkVMXy5qb2luO1xuICAgICAgdmFyIGV2ZW50cyA9IFtjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luXTtcbiAgICAgIGlmIChyZWYgJiYgZXZlbnRzLmluZGV4T2YodHlwZUxvd2VyKSA+PSAwICYmIHJlZiAhPT0gdGhpcy5fam9pblJlZigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYW5kbGVkUGF5bG9hZCA9IHRoaXMuX29uTWVzc2FnZSh0eXBlTG93ZXIsIHBheWxvYWQsIHJlZik7XG4gICAgICBpZiAocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgICAgdGhyb3cgJ2NoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZCc7XG4gICAgICB9XG4gICAgICBpZiAoWydpbnNlcnQnLCAndXBkYXRlJywgJ2RlbGV0ZSddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgICAgKF9hID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKGZ1bmN0aW9uIChiaW5kKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgcmV0dXJuICgoX2EgPSBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2ZW50KSA9PT0gJyonIHx8ICgoX2MgPSAoX2IgPSBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV2ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09IHR5cGVMb3dlcjtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChiaW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKF9iID0gdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZmlsdGVyKGZ1bmN0aW9uIChiaW5kKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgaWYgKFsnYnJvYWRjYXN0JywgJ3ByZXNlbmNlJywgJ3Bvc3RncmVzX2NoYW5nZXMnXS5pbmNsdWRlcyh0eXBlTG93ZXIpKSB7XG4gICAgICAgICAgICBpZiAoJ2lkJyBpbiBiaW5kKSB7XG4gICAgICAgICAgICAgIHZhciBiaW5kSWQgPSBiaW5kLmlkO1xuICAgICAgICAgICAgICB2YXIgYmluZEV2ZW50ID0gKF9hID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmVudDtcbiAgICAgICAgICAgICAgcmV0dXJuIGJpbmRJZCAmJiAoKF9iID0gcGF5bG9hZC5pZHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhiaW5kSWQpKSAmJiAoYmluZEV2ZW50ID09PSAnKicgfHwgKGJpbmRFdmVudCA9PT0gbnVsbCB8fCBiaW5kRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpbmRFdmVudC50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gKChfYyA9IHBheWxvYWQuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9iaW5kRXZlbnQgPSAoX2UgPSAoX2QgPSBiaW5kID09PSBudWxsIHx8IGJpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZXZlbnQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gX2JpbmRFdmVudCA9PT0gJyonIHx8IF9iaW5kRXZlbnQgPT09ICgoX2YgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQuZXZlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmQudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0eXBlTG93ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGJpbmQpIHtcbiAgICAgICAgICBpZiAoX3R5cGVvZihoYW5kbGVkUGF5bG9hZCkgPT09ICdvYmplY3QnICYmICdpZHMnIGluIGhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgcG9zdGdyZXNDaGFuZ2VzID0gaGFuZGxlZFBheWxvYWQuZGF0YTtcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSBwb3N0Z3Jlc0NoYW5nZXMuc2NoZW1hLFxuICAgICAgICAgICAgICB0YWJsZSA9IHBvc3RncmVzQ2hhbmdlcy50YWJsZSxcbiAgICAgICAgICAgICAgY29tbWl0X3RpbWVzdGFtcCA9IHBvc3RncmVzQ2hhbmdlcy5jb21taXRfdGltZXN0YW1wLFxuICAgICAgICAgICAgICBfdHlwZSA9IHBvc3RncmVzQ2hhbmdlcy50eXBlLFxuICAgICAgICAgICAgICBlcnJvcnMgPSBwb3N0Z3Jlc0NoYW5nZXMuZXJyb3JzO1xuICAgICAgICAgICAgdmFyIGVucmljaGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgY29tbWl0X3RpbWVzdGFtcDogY29tbWl0X3RpbWVzdGFtcCxcbiAgICAgICAgICAgICAgZXZlbnRUeXBlOiBfdHlwZSxcbiAgICAgICAgICAgICAgXCJuZXdcIjoge30sXG4gICAgICAgICAgICAgIG9sZDoge30sXG4gICAgICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaGFuZGxlZFBheWxvYWQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVucmljaGVkUGF5bG9hZCksIF90aGlzNS5fZ2V0UGF5bG9hZFJlY29yZHMocG9zdGdyZXNDaGFuZ2VzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzQ2xvc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0Nsb3NlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBjb25zdGFudHNfMS5DSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaXNKb2luZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzSm9pbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IGNvbnN0YW50c18xLkNIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9pc0pvaW5pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzSm9pbmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBjb25zdGFudHNfMS5DSEFOTkVMX1NUQVRFUy5qb2luaW5nO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzTGVhdmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNMZWF2aW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IGNvbnN0YW50c18xLkNIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVwbHlFdmVudE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgcmV0dXJuIFwiY2hhbl9yZXBseV9cIi5jb25jYXQocmVmKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9vblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb24odHlwZSwgZmlsdGVyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgIHZhciBiaW5kaW5nID0ge1xuICAgICAgICB0eXBlOiB0eXBlTG93ZXIsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXS5wdXNoKGJpbmRpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gW2JpbmRpbmddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgfSwge1xuICAgIGtleTogXCJfb2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vZmYodHlwZSwgZmlsdGVyKSB7XG4gICAgICB2YXIgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLmZpbHRlcihmdW5jdGlvbiAoYmluZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAhKCgoX2EgPSBiaW5kLnR5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gdHlwZUxvd2VyICYmIFJlYWx0aW1lQ2hhbm5lbC5pc0VxdWFsKGJpbmQuZmlsdGVyLCBmaWx0ZXIpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVqb2luVW50aWxDb25uZWN0ZWRcIixcbiAgICB2YWx1ZTogLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIF9yZWpvaW5VbnRpbENvbm5lY3RlZCgpIHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLl9yZWpvaW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgY2xvc2VzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX29uKGNvbnN0YW50c18xLkNIQU5ORUxfRVZFTlRTLmNsb3NlLCB7fSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhbm5lbCBlbmNvdW50ZXJlcyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9vbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9vbihjb25zdGFudHNfMS5DSEFOTkVMX0VWRU5UUy5lcnJvciwge30sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBjaGFubmVsIGhhcyBiZWVuIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jYW5QdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYW5QdXNoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5faXNKb2luZWQoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9yZWpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlam9pbigpIHtcbiAgICAgIHZhciB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnRpbWVvdXQ7XG4gICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQuX2xlYXZlT3BlblRvcGljKHRoaXMudG9waWMpO1xuICAgICAgdGhpcy5zdGF0ZSA9IGNvbnN0YW50c18xLkNIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgICB0aGlzLmpvaW5QdXNoLnJlc2VuZCh0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRQYXlsb2FkUmVjb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UGF5bG9hZFJlY29yZHMocGF5bG9hZCkge1xuICAgICAgdmFyIHJlY29yZHMgPSB7XG4gICAgICAgIFwibmV3XCI6IHt9LFxuICAgICAgICBvbGQ6IHt9XG4gICAgICB9O1xuICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ0lOU0VSVCcgfHwgcGF5bG9hZC50eXBlID09PSAnVVBEQVRFJykge1xuICAgICAgICByZWNvcmRzW1wibmV3XCJdID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKHBheWxvYWQuY29sdW1ucywgcGF5bG9hZC5yZWNvcmQpO1xuICAgICAgfVxuICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ1VQREFURScgfHwgcGF5bG9hZC50eXBlID09PSAnREVMRVRFJykge1xuICAgICAgICByZWNvcmRzLm9sZCA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQub2xkX3JlY29yZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjb3JkcztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJpc0VxdWFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRXF1YWwob2JqMSwgb2JqMikge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGsgaW4gb2JqMSkge1xuICAgICAgICBpZiAob2JqMVtrXSAhPT0gb2JqMltrXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZWFsdGltZUNoYW5uZWw7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJlYWx0aW1lQ2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenRCUVVGQk8wRkJRMEU3UVVGRlFUdEJRVU5CTzBGQlRVRTdRVUV3UkVFc1NVRkJXVUVzYzBOQlMxZzdRVUZNUkN4WFFVRlpRU3h6UTBGQmMwTTdSVUZEYUVSQkxHMUVRVUZUTzBWQlExUkJMREpFUVVGcFFqdEZRVU5xUWtFc01rUkJRV2xDTzBWQlEycENRU3d5UkVGQmFVSTdRVUZEYmtJc1EwRkJReXhGUVV4WFFTeHpRMEZCYzBNc1IwRkJkRU5ETERoRFFVRnpReXhMUVVGMFEwRXNPRU5CUVhORE8wRkJUMnhFTEVsQlFWbERMSEZDUVVsWU8wRkJTa1FzVjBGQldVRXNjVUpCUVhGQ08wVkJReTlDUVN4blJFRkJkVUk3UlVGRGRrSkJMRGhEUVVGeFFqdEZRVU55UWtFc09FUkJRWEZETzBGQlEzWkRMRU5CUVVNc1JVRktWMEVzY1VKQlFYRkNMRWRCUVhKQ1JDdzJRa0ZCY1VJc1MwRkJja0pCTERaQ1FVRnhRanRCUVUxcVF5eEpRVUZaUlN4NVFrRkxXRHRCUVV4RUxGZEJRVmxCTEhsQ1FVRjVRanRGUVVOdVEwRXNjMFJCUVhsQ08wVkJRM3BDUVN4dlJFRkJkVUk3UlVGRGRrSkJMRGhEUVVGcFFqdEZRVU5xUWtFc05FUkJRU3RDTzBGQlEycERMRU5CUVVNc1JVRk1WMEVzZVVKQlFYbENMRWRCUVhwQ1JpeHBRMEZCZVVJc1MwRkJla0pCTEdsRFFVRjVRanRCUVU5eVF6czdPenM3UVVGQlFTeEpRVXR4UWtjc1pVRkJaVHRGUVdsQ2JFTXNNRUpCUTBVN1JVRkRUME1zUzBGQllTeEZRVVZUTzBsQlFVRTdTVUZCUVN4SlFVUjBRa01zTmtWQlFXbERPMDFCUVVWRExFMUJRVTBzUlVGQlJUdEpRVUZGTEVOQlFVVTdTVUZCUVN4SlFVTXZRME1zVFVGQmMwSTdTVUZCUVR0SlFVWjBRaXhWUVVGTExFZEJRVXhJTEV0QlFVczdTVUZEVEN4WFFVRk5MRWRCUVU1RExFMUJRVTA3U1VGRFRpeFhRVUZOTEVkQlFVNUZMRTFCUVUwN1NVRndRbVlzWVVGQlVTeEhRVTlLTEVWQlFVVTdTVUZGVGl4VlFVRkxMRWRCUVVkRExEQkNRVUZqTEVOQlFVTkRMRTFCUVUwN1NVRkROMElzWlVGQlZTeEhRVUZITEV0QlFVczdTVUZIYkVJc1pVRkJWU3hIUVVGWExFVkJRVVU3U1VGVGNrSXNTVUZCU1N4RFFVRkRTaXhOUVVGTkxFTkJRVU5ETEUxQlFVMHNhVUpCUTJJN1RVRkRSRWtzVTBGQlV5eEZRVUZGTzFGQlFVVkRMRWRCUVVjc1JVRkJSU3hMUVVGTE8xRkJRVVZETEVsQlFVa3NSVUZCUlR0TlFVRkxMRU5CUVVVN1RVRkRkRU5ETEZGQlFWRXNSVUZCUlR0UlFVRkZReXhIUVVGSExFVkJRVVU3VFVGQlJUdExRVU53UWl4RlFVTkZWQ3hOUVVGTkxFTkJRVU5ETEUxQlFVMHNRMEZEYWtJN1NVRkRSQ3hKUVVGSkxFTkJRVU5UTEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVOU0xFMUJRVTBzUTBGQlExRXNUMEZCVHp0SlFVTnNReXhKUVVGSkxFTkJRVU5ETEZGQlFWRXNSMEZCUnl4SlFVRkpReXhwUWtGQlNTeERRVU4wUWl4SlFVRkpMRVZCUTBwVUxEQkNRVUZqTEVOQlFVTlZMRWxCUVVrc1JVRkRia0lzU1VGQlNTeERRVUZEWWl4TlFVRk5MRVZCUTFnc1NVRkJTU3hEUVVGRFZTeFBRVUZQTEVOQlEySTdTVUZEUkN4SlFVRkpMRU5CUVVOSkxGZEJRVmNzUjBGQlJ5eEpRVUZKUXl4clFrRkJTeXhEUVVNeFFqdE5RVUZCTEU5QlFVMHNTMEZCU1N4RFFVRkRReXh4UWtGQmNVSXNSVUZCUlR0SlFVRkJMRWRCUTJ4RExFbEJRVWtzUTBGQlEyUXNUVUZCVFN4RFFVRkRaU3huUWtGQlowSXNRMEZETjBJN1NVRkRSQ3hKUVVGSkxFTkJRVU5PTEZGQlFWRXNRMEZCUTA4c1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeFpRVUZMTzAxQlF5OUNMRXRCUVVrc1EwRkJRME1zUzBGQlN5eEhRVUZIYUVJc01FSkJRV01zUTBGQlEybENMRTFCUVUwN1RVRkRiRU1zUzBGQlNTeERRVUZEVGl4WFFVRlhMRU5CUVVOUExFdEJRVXNzUlVGQlJUdE5RVU40UWl4TFFVRkpMRU5CUVVORExGVkJRVlVzUTBGQlEwTXNUMEZCVHl4RFFVRkRMRlZCUVVORExGTkJRV1U3VVVGQlFTeFBRVUZMUVN4VFFVRlRMRU5CUVVORExFbEJRVWtzUlVGQlJUdE5RVUZCTEVWQlFVTTdUVUZET1VRc1MwRkJTU3hEUVVGRFNDeFZRVUZWTEVkQlFVY3NSVUZCUlR0SlFVTjBRaXhEUVVGRExFTkJRVU03U1VGRFJpeEpRVUZKTEVOQlFVTkpMRkZCUVZFc1EwRkJReXhaUVVGTE8wMUJRMnBDTEV0QlFVa3NRMEZCUTFvc1YwRkJWeXhEUVVGRFR5eExRVUZMTEVWQlFVVTdUVUZEZUVJc1MwRkJTU3hEUVVGRGJrSXNUVUZCVFN4RFFVRkRlVUlzUjBGQlJ5eERRVUZETEZOQlFWTXNhMEpCUVZjc1MwRkJTU3hEUVVGRE5VSXNTMEZCU3l4alFVRkpMRXRCUVVrc1EwRkJRelpDTEZGQlFWRXNSVUZCUlN4RlFVRkhPMDFCUTNCRkxFdEJRVWtzUTBGQlExUXNTMEZCU3l4SFFVRkhhRUlzTUVKQlFXTXNRMEZCUTBNc1RVRkJUVHROUVVOc1F5eExRVUZKTEVOQlFVTkdMRTFCUVUwc1EwRkJRekpDTEU5QlFVOHNRMEZCUXl4TFFVRkpMRU5CUVVNN1NVRkRNMElzUTBGQlF5eERRVUZETzBsQlEwWXNTVUZCU1N4RFFVRkRReXhSUVVGUkxFTkJRVU1zVlVGQlEwTXNUVUZCWXl4RlFVRkpPMDFCUXk5Q0xFbEJRVWtzUzBGQlNTeERRVUZEUXl4VlFVRlZMRVZCUVVVc1NVRkJTU3hMUVVGSkxFTkJRVU5ETEZOQlFWTXNSVUZCUlN4RlFVRkZPMUZCUTNwRE96dE5RVVZHTEV0QlFVa3NRMEZCUXk5Q0xFMUJRVTBzUTBGQlEzbENMRWRCUVVjc1EwRkJReXhUUVVGVExHdENRVUZYTEV0QlFVa3NRMEZCUXpWQ0xFdEJRVXNzUjBGQlNXZERMRTFCUVUwc1EwRkJRenROUVVONlJDeExRVUZKTEVOQlFVTmFMRXRCUVVzc1IwRkJSMmhDTERCQ1FVRmpMRU5CUVVNclFpeFBRVUZQTzAxQlEyNURMRXRCUVVrc1EwRkJRM0JDTEZkQlFWY3NRMEZCUTNGQ0xHVkJRV1VzUlVGQlJUdEpRVU53UXl4RFFVRkRMRU5CUVVNN1NVRkRSaXhKUVVGSkxFTkJRVU40UWl4UlFVRlJMRU5CUVVOUExFOUJRVThzUTBGQlF5eFRRVUZUTEVWQlFVVXNXVUZCU3p0TlFVTndReXhKUVVGSkxFTkJRVU1zUzBGQlNTeERRVUZEYTBJc1ZVRkJWU3hGUVVGRkxFVkJRVVU3VVVGRGRFSTdPMDFCUlVZc1MwRkJTU3hEUVVGRGJFTXNUVUZCVFN4RFFVRkRlVUlzUjBGQlJ5eERRVUZETEZOQlFWTXNiMEpCUVdFc1MwRkJTU3hEUVVGRE5VSXNTMEZCU3l4SFFVRkpMRXRCUVVrc1EwRkJRMWtzVVVGQlVTeERRVUZEUkN4UFFVRlBMRU5CUVVNN1RVRkRNVVVzUzBGQlNTeERRVUZEVXl4TFFVRkxMRWRCUVVkb1Fpd3dRa0ZCWXl4RFFVRkRLMElzVDBGQlR6dE5RVU51UXl4TFFVRkpMRU5CUVVOd1FpeFhRVUZYTEVOQlFVTnhRaXhsUVVGbExFVkJRVVU3U1VGRGNFTXNRMEZCUXl4RFFVRkRPMGxCUTBZc1NVRkJTU3hEUVVGRFJTeEhRVUZITEVOQlFVTnNReXd3UWtGQll5eERRVUZEYlVNc1MwRkJTeXhGUVVGRkxFVkJRVVVzUlVGQlJTeFZRVUZEUXl4UFFVRlpMRVZCUVVWRExFZEJRVmNzUlVGQlNUdE5RVU12UkN4TFFVRkpMRU5CUVVORExGRkJRVkVzUTBGQlF5eExRVUZKTEVOQlFVTkRMR1ZCUVdVc1EwRkJRMFlzUjBGQlJ5eERRVUZETEVWQlFVVkVMRTlCUVU4c1EwRkJRenRKUVVOdVJDeERRVUZETEVOQlFVTTdTVUZGUml4SlFVRkpMRU5CUVVNdlFpeFJRVUZSTEVkQlFVY3NTVUZCU1cxRExEWkNRVUZuUWl4RFFVRkRMRWxCUVVrc1EwRkJRenRGUVVNMVF6dEZRVVZCTzBWQlFVRTdTVUZCUVR0SlFVRkJMRTlCUTBFc2JVSkJRMFZETEZGQlFYZEZMRVZCUTJ4RU8wMUJRVUU3VFVGQlFTeEpRVUYwUW14RExFOUJRVThzZFVWQlFVY3NTVUZCU1N4RFFVRkRRU3hQUVVGUE96dE5RVVYwUWl4SlFVRkpMRWxCUVVrc1EwRkJRMjFETEZWQlFWVXNSVUZCUlR0UlFVTnVRanRQUVVORUxFMUJRVTA3VVVGRFRDd3dRa0ZGU1N4SlFVRkpMRU5CUVVNM1F5eE5RVUZOTEVOQlJHSkRMRTFCUVUwN1ZVRkJTVWtzVTBGQlV5eDFRa0ZCVkVFc1UwRkJVenRWUVVGRlJ5eFJRVUZSTEhWQ1FVRlNRU3hSUVVGUk8xRkJSUzlDTEVsQlFVa3NRMEZCUTNOQ0xGRkJRVkVzUTBGQlF5eFZRVUZEWjBJc1EwRkJVVHRWUVVGQkxFOUJRVXRHTEZGQlFWRXNTVUZCU1VFc1VVRkJVU3hEUVVGRExHVkJRV1VzUlVGQlJVVXNRMEZCUXl4RFFVRkRPMUZCUVVFc1JVRkJRenRSUVVOeVJTeEpRVUZKTEVOQlFVTndRaXhSUVVGUkxFTkJRVU03VlVGQlFTeFBRVUZOYTBJc1VVRkJVU3hKUVVGSlFTeFJRVUZSTEVOQlFVTXNVVUZCVVN4RFFVRkRPMUZCUVVFc1JVRkJRenRSUVVWdVJDeEpRVUZOUnl4clFrRkJhMElzUjBGQk9FSXNSVUZCUlR0UlFVTjRSQ3hKUVVGTk9VTXNUVUZCVFN4SFFVRkhPMVZCUTJKSkxGTkJRVk1zUlVGQlZFRXNVMEZCVXp0VlFVTlVSeXhSUVVGUkxFVkJRVkpCTEZGQlFWRTdWVUZEVW5kRExHZENRVUZuUWl4RlFVTmtMR2RDUVVGSkxFTkJRVU5ETEZGQlFWRXNRMEZCUTBRc1owSkJRV2RDTERCRFFVRkZSU3hIUVVGSExFTkJRVU1zVlVGQlEwTXNRMEZCUXp0WlFVRkJMRTlCUVV0QkxFTkJRVU1zUTBGQlEwTXNUVUZCVFR0VlFVRkJMRVZCUVVNc2JVTkJRVWs3VTBGRE0wUTdVVUZGUkN4SlFVRkpMRWxCUVVrc1EwRkJRMnhFTEUxQlFVMHNRMEZCUTIxRUxGZEJRVmNzUlVGQlJUdFZRVU16UWs0c2EwSkJRV3RDTEVOQlFVTlBMRmxCUVZrc1IwRkJSeXhKUVVGSkxFTkJRVU53UkN4TlFVRk5MRU5CUVVOdFJDeFhRVUZYT3p0UlFVY3pSQ3hKUVVGSkxFTkJRVU5GTEdsQ1FVRnBRaXhsUVVGTk8xVkJRVVYwUkN4TlFVRk5MRVZCUVU1Qk8xRkJRVTBzUTBGQlJTeEZRVUZMT0VNc2EwSkJRV3RDTEVWQlFVYzdVVUZGYUVVc1NVRkJTU3hEUVVGRFJpeFZRVUZWTEVkQlFVY3NTVUZCU1R0UlFVTjBRaXhKUVVGSkxFTkJRVU5YTEU5QlFVOHNRMEZCUXpsRExFOUJRVThzUTBGQlF6dFJRVVZ5UWl4SlFVRkpMRU5CUVVORExGRkJRVkVzUTBGRFZrOHNUMEZCVHl4RFFVTk9MRWxCUVVrc1JVRkRTaXhwUWtGVlN6dFZRVUZCTEVsQlZHVjFReXh4UWtGQmNVSXNVMEZCZGtOVUxHZENRVUZuUWpzN1ZVRlZhRUlzVFVGQlNTeERRVUZET1VNc1RVRkJUU3hEUVVGRGJVUXNWMEZCVnl4SlFVTnlRaXhOUVVGSkxFTkJRVU51UkN4TlFVRk5MRU5CUVVOM1JDeFBRVUZQTEVOQlFVTXNUVUZCU1N4RFFVRkRlRVFzVFVGQlRTeERRVUZEYlVRc1YwRkJWeXhEUVVGRE8xVkJSVGxETEVsQlFVbEpMSEZDUVVGeFFpeExRVUZMUlN4VFFVRlRMRVZCUVVVN1dVRkRka05tTEZGQlFWRXNTVUZCU1VFc1VVRkJVU3hEUVVGRExGbEJRVmtzUTBGQlF6dFpRVU5zUXp0WFFVTkVMRTFCUVUwN1dVRkRUQ3hKUVVGTlowSXNjMEpCUVhOQ0xFZEJRVWNzVFVGQlNTeERRVUZEV0N4UlFVRlJMRU5CUVVORUxHZENRVUZuUWp0WlFVTTNSQ3hKUVVGTllTeFhRVUZYTEVkQlFVY3NORUpCUVhOQ0xHRkJRWFJDUkN4elFrRkJjMElzZFVKQlFYUkNRU3h6UWtGQmMwSXNRMEZCUlVVc1RVRkJUU3h0UTBGQlNTeERRVUZETzFsQlEzWkVMRWxCUVUxRExHMUNRVUZ0UWl4SFFVRkhMRVZCUVVVN1dVRkZPVUlzUzBGQlN5eEpRVUZKUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRlFTeERRVUZETEVkQlFVZElMRmRCUVZjc1JVRkJSVWNzUTBGQlF5eEZRVUZGTEVWQlFVVTdZMEZEY0VNc1NVRkJUVU1zY1VKQlFYRkNMRWRCUVVkTUxITkNRVUZ6UWl4RFFVRkRTU3hEUVVGRExFTkJRVU03WTBGRGRrUXNORUpCUlVsRExIRkNRVUZ4UWl4RFFVUjJRbUlzVFVGQlRUdG5Ra0ZCU1dNc1MwRkJTeXg1UWtGQlRFRXNTMEZCU3p0blFrRkJSVU1zVFVGQlRTeDVRa0ZCVGtFc1RVRkJUVHRuUWtGQlJVTXNTMEZCU3l4NVFrRkJURUVzUzBGQlN6dG5Ra0ZCUldoQ0xFMUJRVTBzZVVKQlFVNUJMRTFCUVUwN1kwRkZlRU1zU1VGQlRXbENMRzlDUVVGdlFpeEhRVU40UWxvc2NVSkJRWEZDTEVsQlFVbEJMSEZDUVVGeFFpeERRVUZEVHl4RFFVRkRMRU5CUVVNN1kwRkZia1FzU1VGRFJVc3NiMEpCUVc5Q0xFbEJRM0JDUVN4dlFrRkJiMElzUTBGQlEwZ3NTMEZCU3l4TFFVRkxRU3hMUVVGTExFbEJRM0JEUnl4dlFrRkJiMElzUTBGQlEwWXNUVUZCVFN4TFFVRkxRU3hOUVVGTkxFbEJRM1JEUlN4dlFrRkJiMElzUTBGQlEwUXNTMEZCU3l4TFFVRkxRU3hMUVVGTExFbEJRM0JEUXl4dlFrRkJiMElzUTBGQlEycENMRTFCUVUwc1MwRkJTMEVzVFVGQlRTeEZRVU4wUXp0blFrRkRRVmNzYlVKQlFXMUNMRU5CUVVOUExFbEJRVWtzYVVOQlEyNUNUQ3h4UWtGQmNVSTdhMEpCUTNoQ1RTeEZRVUZGTEVWQlFVVkdMRzlDUVVGdlFpeERRVUZEUlR0blFrRkJSU3hIUVVNelFqdGxRVU5JTEUxQlFVMDdaMEpCUTB3c1RVRkJTU3hEUVVGRFF5eFhRVUZYTEVWQlFVVTdaMEpCUTJ4Q05VSXNVVUZCVVN4SlFVTk9RU3hSUVVGUkxFTkJRMDRzWlVGQlpTeEZRVU5tTEVsQlFVazJRaXhMUVVGTExFTkJRMUFzYTBWQlFXdEZMRU5CUTI1RkxFTkJRMFk3WjBKQlEwZzdPenRaUVVsS0xFMUJRVWtzUTBGQlEzaENMRkZCUVZFc1EwRkJRMFFzWjBKQlFXZENMRWRCUVVkbExHMUNRVUZ0UWp0WlFVVndSRzVDTEZGQlFWRXNTVUZCU1VFc1VVRkJVU3hEUVVGRExGbEJRVmtzUTBGQlF6dFpRVU5zUXpzN1VVRkZTaXhEUVVGRExFTkJRMFlzUTBGRFFURkNMRTlCUVU4c1EwRkJReXhQUVVGUExFVkJRVVVzVlVGQlEzZEVMRXRCUVRaQ0xFVkJRVWs3VlVGRGJFUTVRaXhSUVVGUkxFbEJRMDVCTEZGQlFWRXNRMEZEVGl4bFFVRmxMRVZCUTJZc1NVRkJTVFpDTEV0QlFVc3NRMEZEVUVVc1NVRkJTU3hEUVVGRFF5eFRRVUZUTEVOQlFVTkRMRTFCUVUwc1EwRkJRME1zVFVGQlRTeERRVUZEU2l4TFFVRkxMRU5CUVVNc1EwRkJRemRFTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hQUVVGUExFTkJRVU1zUTBGRE0wUXNRMEZEUmp0VlFVTklPMUZCUTBZc1EwRkJReXhEUVVGRExFTkJRMFJMTEU5QlFVOHNRMEZCUXl4VFFVRlRMRVZCUVVVc1dVRkJTenRWUVVOMlFqQkNMRkZCUVZFc1NVRkJTVUVzVVVGQlVTeERRVUZETEZkQlFWY3NRMEZCUXp0VlFVTnFRenRSUVVOR0xFTkJRVU1zUTBGQlF6czdUVUZIVGl4UFFVRlBMRWxCUVVrN1NVRkRZanRGUVVGRE8wbEJRVUU3U1VGQlFTeFBRVVZFTEhsQ1FVRmhPMDFCUTFnc1QwRkJUeXhKUVVGSkxFTkJRVU53UXl4UlFVRlJMRU5CUVVOWExFdEJRVXM3U1VGRE5VSTdSVUZCUXp0SlFVRkJPMGxCUVVFc1QwRkZTeXhsUVVOS2IwSXNUMEZCSzBJc1JVRkRSVHROUVVGQkxFbEJRV3BEZDBNc01rVkJRU3RDTEVWQlFVVTdPenM3T3p0alFVVXhRaXhQUVVGTkxFbEJRVWtzUTBGQlEzUkVMRWxCUVVrc1EwRkRjRUk3WjBKQlEwVjFSQ3hKUVVGSkxFVkJRVVVzVlVGQlZUdG5Ra0ZEYUVKa0xFdEJRVXNzUlVGQlJTeFBRVUZQTzJkQ1FVTmtNMElzVDBGQlR5eEZRVUZRUVR0bFFVTkVMRVZCUTBSM1F5eEpRVUZKTEVOQlFVTnlSU3hQUVVGUExFbEJRVWtzU1VGQlNTeERRVUZEUVN4UFFVRlBMRU5CUXpkQ08xbEJRVUU3WTBGQlFUdFpRVUZCTzFsQlFVRTdZMEZCUVR0VlFVRkJPMUZCUVVFN1RVRkJRU3hEUVVOR096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVVkxMRzFDUVVNMlFqdE5RVUZCTEVsQlFXcERjVVVzTWtWQlFTdENMRVZCUVVVN096czdPenRqUVVVeFFpeFBRVUZOTEVsQlFVa3NRMEZCUTNSRUxFbEJRVWtzUTBGRGNFSTdaMEpCUTBWMVJDeEpRVUZKTEVWQlFVVXNWVUZCVlR0blFrRkRhRUprTEV0QlFVc3NSVUZCUlR0bFFVTlNMRVZCUTBSaExFbEJRVWtzUTBGRFREdFpRVUZCTzJOQlFVRTdXVUZCUVR0WlFVRkJPMk5CUVVFN1ZVRkJRVHRSUVVGQk8wMUJRVUVzUTBGRFJqczdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRXJRMFFzV1VGRFJVTXNTVUZCWjBNc1JVRkRhRU0xUWl4TlFVRm5SQ3hGUVVOb1JGSXNVVUZCWjBNN1RVRkZhRU1zVDBGQlR5eEpRVUZKTEVOQlFVTlFMRWRCUVVjc1EwRkJRekpETEVsQlFVa3NSVUZCUlRWQ0xFMUJRVTBzUlVGQlJWSXNVVUZCVVN4RFFVRkRPMGxCUTNwRE8wVkJRVU03U1VGQlFUdEpRVUZCTEU5QlJVUXNZMEZEUlV3c1QwRkJOa01zUlVGRFdqdE5RVUZCTzAxQlFVRXNTVUZCYWtOM1F5d3lSVUZCSzBJc1JVRkJSVHROUVVWcVF5eFBRVUZQTEVsQlFVbEZMRTlCUVU4c1EwRkJReXhWUVVGRFF5eFBRVUZQTEVWQlFVazdPMUZCUXpkQ0xFbEJRVTFhTEVsQlFVa3NSMEZCUnl4TlFVRkpMRU5CUVVOaExFdEJRVXNzUTBGRGNrSTFReXhQUVVGUExFTkJRVU41UXl4SlFVRkpMRVZCUTFwNlF5eFBRVUZQTEVWQlExQjNReXhKUVVGSkxFTkJRVU55UlN4UFFVRlBMRWxCUVVrc1RVRkJTU3hEUVVGRFFTeFBRVUZQTEVOQlF6ZENPMUZCUlVRc1NVRkJTVFJFTEVsQlFVa3NRMEZCUTJNc1YwRkJWeXhGUVVGRk8xVkJRM0JDUml4UFFVRlBMRU5CUVVNc1kwRkJZeXhEUVVGRE96dFJRVWQ2UWl4SlFVTkZNME1zVDBGQlR5eERRVUZEZVVNc1NVRkJTU3hMUVVGTExGZEJRVmNzU1VGRE5VSXNSVUZCUXl4M1FrRkJTU3hEUVVGRGFFWXNUVUZCVFN3d1EwRkJSVU1zVFVGQlRTd3dRMEZCUlVrc1UwRkJVeXd3UTBGQlJVTXNSMEZCUnl4SFFVTndRenRWUVVOQk5FVXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJRenM3VVVGSFpsb3NTVUZCU1N4RFFVRkRjRVFzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZCUlR0VlFVRkJMRTlCUVUxblJTeFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUVVFc1JVRkJRenRSUVVOMlExb3NTVUZCU1N4RFFVRkRjRVFzVDBGQlR5eERRVUZETEZOQlFWTXNSVUZCUlR0VlFVRkJMRTlCUVUxblJTeFBRVUZQTEVOQlFVTXNWMEZCVnl4RFFVRkRPMUZCUVVFc1JVRkJRenROUVVOeVJDeERRVUZETEVOQlFVTTdTVUZEU2p0RlFVRkRPMGxCUVVFN1NVRkJRU3hQUVVWRUxESkNRVUZyUWpORExFOUJRU3RDTzAxQlF5OURMRWxCUVVrc1EwRkJRelZDTEZGQlFWRXNRMEZCUXpCRkxHRkJRV0VzUTBGQlF6bERMRTlCUVU4c1EwRkJRenRKUVVOMFF6dEpRVVZCT3pzN096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZUUVN4MVFrRkJhME03VFVGQlFUdE5RVUZCTEVsQlFYUkNOMElzVDBGQlR5eDFSVUZCUnl4SlFVRkpMRU5CUVVOQkxFOUJRVTg3VFVGRGFFTXNTVUZCU1N4RFFVRkRVeXhMUVVGTExFZEJRVWRvUWl3d1FrRkJZeXhEUVVGRGJVWXNUMEZCVHp0TlFVTnVReXhKUVVGTlF5eFBRVUZQTEVkQlFVY3NVMEZCVmtFc1QwRkJUeXhIUVVGUk8xRkJRMjVDTEUxQlFVa3NRMEZCUTNKR0xFMUJRVTBzUTBGQlEzbENMRWRCUVVjc1EwRkJReXhUUVVGVExHdENRVUZYTEUxQlFVa3NRMEZCUXpWQ0xFdEJRVXNzUlVGQlJ6dFJRVU5xUkN4TlFVRkpMRU5CUVVNd1F5eFJRVUZSTEVOQlFVTjBReXd3UWtGQll5eERRVUZEY1VZc1MwRkJTeXhGUVVGRkxFOUJRVThzUlVGQlJTeE5RVUZKTEVOQlFVTTFSQ3hSUVVGUkxFVkJRVVVzUTBGQlF6dE5RVU12UkN4RFFVRkRPMDFCUlVRc1NVRkJTU3hEUVVGRFpDeFhRVUZYTEVOQlFVTlBMRXRCUVVzc1JVRkJSVHROUVVONFFqdE5RVU5CTEVsQlFVa3NRMEZCUTFZc1VVRkJVU3hEUVVGRE9FVXNUMEZCVHl4RlFVRkZPMDFCUlhaQ0xFOUJRVThzU1VGQlNWSXNUMEZCVHl4RFFVRkRMRlZCUVVORExFOUJRVThzUlVGQlNUdFJRVU0zUWl4SlFVRk5VU3hUUVVGVExFZEJRVWNzU1VGQlNUbEZMR2xDUVVGSkxFTkJRVU1zVFVGQlNTeEZRVUZGVkN3d1FrRkJZeXhEUVVGRGQwWXNTMEZCU3l4RlFVRkZMRVZCUVVVc1JVRkJSV3BHTEU5QlFVOHNRMEZCUXp0UlFVVnVSV2RHTEZOQlFWTXNRMEZEVG5oRkxFOUJRVThzUTBGQlF5eEpRVUZKTEVWQlFVVXNXVUZCU3p0VlFVTnNRbkZGTEU5QlFVOHNSVUZCUlR0VlFVTlVUQ3hQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETzFGQlEyWXNRMEZCUXl4RFFVRkRMRU5CUTBSb1JTeFBRVUZQTEVOQlFVTXNVMEZCVXl4RlFVRkZMRmxCUVVzN1ZVRkRka0p4UlN4UFFVRlBMRVZCUVVVN1ZVRkRWRXdzVDBGQlR5eERRVUZETEZkQlFWY3NRMEZCUXp0UlFVTjBRaXhEUVVGRExFTkJRVU1zUTBGRFJHaEZMRTlCUVU4c1EwRkJReXhQUVVGUExFVkJRVVVzV1VGQlN6dFZRVU55UW1kRkxFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTTdVVUZEYkVJc1EwRkJReXhEUVVGRE8xRkJSVXBSTEZOQlFWTXNRMEZCUTJwRkxFbEJRVWtzUlVGQlJUdFJRVVZvUWl4SlFVRkpMRU5CUVVNc1RVRkJTU3hEUVVGRGJVVXNVVUZCVVN4RlFVRkZMRVZCUVVVN1ZVRkRjRUpHTEZOQlFWTXNRMEZCUTBjc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeEZRVUZGTEVOQlFVTTdPMDFCUlM5Q0xFTkJRVU1zUTBGQlF6dEpRVU5LTzBsQlJVRTdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkRRU3hsUVVORk0wSXNTMEZCWVN4RlFVTmlNMElzVDBGQkswSXNSVUZEVkR0TlFVRkJMRWxCUVhSQ04wSXNUMEZCVHl4MVJVRkJSeXhKUVVGSkxFTkJRVU5CTEU5QlFVODdUVUZGZEVJc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlEyMURMRlZCUVZVc1JVRkJSVHRSUVVOd1Fpd3JRa0ZCZDBKeFFpeExRVUZMTEcxQ1FVRlRMRWxCUVVrc1EwRkJRMjVGTEV0QlFVczdPMDFCUld4RUxFbEJRVWw1UWl4VFFVRlRMRWRCUVVjc1NVRkJTVm9zYVVKQlFVa3NRMEZCUXl4SlFVRkpMRVZCUVVWelJDeExRVUZMTEVWQlFVVXpRaXhQUVVGUExFVkJRVVUzUWl4UFFVRlBMRU5CUVVNN1RVRkRka1FzU1VGQlNTeEpRVUZKTEVOQlFVTnJSaXhSUVVGUkxFVkJRVVVzUlVGQlJUdFJRVU51UW5CRkxGTkJRVk1zUTBGQlEwTXNTVUZCU1N4RlFVRkZPMDlCUTJwQ0xFMUJRVTA3VVVGRFRFUXNVMEZCVXl4RFFVRkRjMFVzV1VGQldTeEZRVUZGTzFGQlEzaENMRWxCUVVrc1EwRkJRM2hGTEZWQlFWVXNRMEZCUTJkRUxFbEJRVWtzUTBGQlF6bERMRk5CUVZNc1EwRkJRenM3VFVGSGFrTXNUMEZCVDBFc1UwRkJVenRKUVVOc1FqdEpRVVZCT3pzN096czdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVkZCTEc5Q1FVRlhkVVVzVFVGQll5eEZRVUZGZUVRc1QwRkJXU3hGUVVGRmVVUXNTVUZCWVR0TlFVTndSQ3hQUVVGUGVrUXNUMEZCVHp0SlFVTm9RanRKUVVWQk8wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlEwRXNiVUpCUVZWNFF5eExRVUZoTzAxQlEzSkNMRTlCUVU4c1NVRkJTU3hEUVVGRFFTeExRVUZMTEV0QlFVdEJMRXRCUVVzN1NVRkROMEk3U1VGRlFUdEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVTkJMRzlDUVVGUk8wMUJRMDRzVDBGQlR5eEpRVUZKTEVOQlFVTlpMRkZCUVZFc1EwRkJRelpDTEVkQlFVYzdTVUZETVVJN1NVRkZRVHRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVU5CTEd0Q1FVRlRkME1zU1VGQldTeEZRVUZGZWtNc1QwRkJZU3hGUVVGRlF5eEhRVUZaTzAxQlFVRTdPMDFCUTJoRUxFbEJRVTE1UkN4VFFVRlRMRWRCUVVkcVFpeEpRVUZKTEVOQlFVTnJRaXhwUWtGQmFVSXNSVUZCUlR0TlFVTXhReXcwUWtGQmMwTXZSaXd3UWtGQll6dFJRVUUxUTNGR0xFdEJRVXNzZVVKQlFVeEJMRXRCUVVzN1VVRkJSV1FzUzBGQlN5eDVRa0ZCVEVFc1MwRkJTenRSUVVGRmFVSXNTMEZCU3l4NVFrRkJURUVzUzBGQlN6dFJRVUZGT1VVc1NVRkJTU3g1UWtGQlNrRXNTVUZCU1R0TlFVTnFReXhKUVVGTmMwWXNUVUZCVFN4SFFVRmhMRU5CUVVOWUxFdEJRVXNzUlVGQlJXUXNTMEZCU3l4RlFVRkZhVUlzUzBGQlN5eEZRVUZGT1VVc1NVRkJTU3hEUVVGRE8wMUJRM0JFTEVsQlFVa3lRaXhIUVVGSExFbEJRVWt5UkN4TlFVRk5MRU5CUVVORExFOUJRVThzUTBGQlEwZ3NVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSmVrUXNSMEZCUnl4TFFVRkxMRWxCUVVrc1EwRkJRMW9zVVVGQlVTeEZRVUZGTEVWQlFVVTdVVUZEY0VVN08wMUJSVVlzU1VGQlNYbEZMR05CUVdNc1IwRkJSeXhKUVVGSkxFTkJRVU5ETEZWQlFWVXNRMEZCUTB3c1UwRkJVeXhGUVVGRk1VUXNUMEZCVHl4RlFVRkZReXhIUVVGSExFTkJRVU03VFVGRE4wUXNTVUZCU1VRc1QwRkJUeXhKUVVGSkxFTkJRVU00UkN4alFVRmpMRVZCUVVVN1VVRkRPVUlzVFVGQlRTdzJSVUZCTmtVN08wMUJSM0pHTEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1VVRkJVU3hGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZEUlN4UlFVRlJMRU5CUVVOT0xGTkJRVk1zUTBGQlF5eEZRVUZGTzFGQlEzUkVMRlZCUVVrc1EwRkJRMmhFTEZGQlFWRXNRMEZCUTBRc1owSkJRV2RDTERCRFFVTXhRa2tzVFVGQlRTeERRVUZETEZWQlFVTnZSQ3hKUVVGSkxFVkJRVWs3TzFWQlEyaENMRTlCUTBVc1YwRkJTU3hEUVVGRGNFUXNUVUZCVFN3d1EwRkJSV01zUzBGQlN5eE5RVUZMTEVkQlFVY3NTVUZETVVJc2FVSkJRVWtzUTBGQlEyUXNUVUZCVFN3d1EwRkJSV01zUzBGQlN5d3dRMEZCUldkRExHbENRVUZwUWl4RlFVRkZMRTFCUVV0RUxGTkJRVk03VVVGRmVrUXNRMEZCUXl4RlFVTkJMME1zUjBGQlJ5eERRVUZETEZWQlFVTnpSQ3hKUVVGSk8xVkJRVUVzVDBGQlMwRXNTVUZCU1N4RFFVRkROVVFzVVVGQlVTeERRVUZEZVVRc1kwRkJZeXhGUVVGRk4wUXNSMEZCUnl4RFFVRkRPMUZCUVVFc1JVRkJRenRQUVVOeVJDeE5RVUZOTzFGQlEwd3NWVUZCU1N4RFFVRkRVeXhSUVVGUkxFTkJRVU5uUkN4VFFVRlRMRU5CUVVNc01FTkJRM0JDTjBNc1RVRkJUU3hEUVVGRExGVkJRVU52UkN4SlFVRkpMRVZCUVVrN08xVkJRMmhDTEVsQlEwVXNRMEZCUXl4WFFVRlhMRVZCUVVVc1ZVRkJWU3hGUVVGRkxHdENRVUZyUWl4RFFVRkRMRU5CUVVORUxGRkJRVkVzUTBGQlEwNHNVMEZCVXl4RFFVRkRMRVZCUTJwRk8xbEJRMEVzU1VGQlNTeEpRVUZKTEVsQlFVbFBMRWxCUVVrc1JVRkJSVHRqUVVOb1FpeEpRVUZOUXl4TlFVRk5MRWRCUVVkRUxFbEJRVWtzUTBGQlEycERMRVZCUVVVN1kwRkRkRUlzU1VGQlRXMURMRk5CUVZNc1IwRkJSeXhWUVVGSkxFTkJRVU4wUkN4TlFVRk5MREJEUVVGRll5eExRVUZMTzJOQlEzQkRMRTlCUTBWMVF5eE5RVUZOTEV0QlEwNHNZVUZCVHl4RFFVRkRSU3hIUVVGSExEQkRRVUZGU2l4UlFVRlJMRU5CUVVORkxFMUJRVTBzUTBGQlF5eE5RVU0xUWtNc1UwRkJVeXhMUVVGTExFZEJRVWNzU1VGRGFFSXNWVUZCVXl4aFFVRlVRU3hUUVVGVExIVkNRVUZVUVN4VFFVRlRMRU5CUVVWU0xHbENRVUZwUWl4RlFVRkZMRTlCUXpWQ0xHRkJRVThzUTBGQlExVXNTVUZCU1N3d1EwRkJSVFZDTEVsQlFVa3NRMEZCUTJ0Q0xHbENRVUZwUWl4RlFVRkZMRVZCUVVNN1lVRkZPVU1zVFVGQlRUdGpRVU5NTEVsQlFVMVJMRlZCUVZNc1IwRkJSeXhuUWtGQlNTeGhRVUZLUml4SlFVRkpMSFZDUVVGS1FTeEpRVUZKTEVOQlFVVndSQ3hOUVVGTkxEQkRRVUZGWXl4TFFVRkxMREJEUVVGRlowTXNhVUpCUVdsQ0xFVkJRVVU3WTBGRE1VUXNUMEZEUlZFc1ZVRkJVeXhMUVVGTExFZEJRVWNzU1VGRGFrSkJMRlZCUVZNc1RVRkJTeXhoUVVGUExHRkJRVkJ1UlN4UFFVRlBMSFZDUVVGUVFTeFBRVUZQTEVOQlFVVXlRaXhMUVVGTExEQkRRVUZGWjBNc2FVSkJRV2xDTEVWQlFVVTdPMWRCUjNSRUxFMUJRVTA3V1VGRFRDeFBRVUZQVFN4SlFVRkpMRU5CUVVONFFpeEpRVUZKTEVOQlFVTnJRaXhwUWtGQmFVSXNSVUZCUlN4TFFVRkxSQ3hUUVVGVE96dFJRVVYwUkN4RFFVRkRMRVZCUTBFdlF5eEhRVUZITEVOQlFVTXNWVUZCUTNORUxFbEJRVWtzUlVGQlNUdFZRVU5hTEVsQlFVa3NVVUZCVDBnc1kwRkJZeXhOUVVGTExGRkJRVkVzU1VGQlNTeExRVUZMTEVsQlFVbEJMR05CUVdNc1JVRkJSVHRaUVVOcVJTeEpRVUZOVVN4bFFVRmxMRWRCUVVkU0xHTkJRV01zUTBGQlEwOHNTVUZCU1R0WlFVTXpReXhKUVVGUmVrTXNUVUZCVFN4SFFVTmFNRU1zWlVGQlpTeERRVVJVTVVNc1RVRkJUVHRqUVVGRlF5eExRVUZMTEVkQlEyNUNlVU1zWlVGQlpTeERRVVJFZWtNc1MwRkJTenRqUVVGRk1FTXNaMEpCUVdkQ0xFZEJRM0pEUkN4bFFVRmxMRU5CUkUxRExHZENRVUZuUWp0alFVRkZPVUlzUzBGQlNTeEhRVU16UXpaQ0xHVkJRV1VzUTBGRWQwSTNRaXhKUVVGSk8yTkJRVVVyUWl4TlFVRk5MRWRCUTI1RVJpeGxRVUZsTEVOQlJEaENSU3hOUVVGTk8xbEJSWEpFTEVsQlFVMURMR1ZCUVdVc1IwRkJSenRqUVVOMFFqZERMRTFCUVUwc1JVRkJSVUVzVFVGQlRUdGpRVU5rUXl4TFFVRkxMRVZCUVVWQkxFdEJRVXM3WTBGRFdqQkRMR2RDUVVGblFpeEZRVUZGUVN4blFrRkJaMEk3WTBGRGJFTkhMRk5CUVZNc1JVRkJSV3BETEV0QlFVazdZMEZEWml4UFFVRkxMRVZCUVVVN1kwRkRVR3RETEVkQlFVY3NSVUZCUlN4RlFVRkZPMk5CUTFCSUxFMUJRVTBzUlVGQlJVRTdZVUZEVkR0WlFVTkVWaXhqUVVGakxHMURRVU5VVnl4bFFVRmxMRWRCUTJZc1RVRkJTU3hEUVVGRFJ5eHJRa0ZCYTBJc1EwRkJRMDRzWlVGQlpTeERRVUZETEVOQlF6VkRPenRWUVVWSVRDeEpRVUZKTEVOQlFVTTFSQ3hSUVVGUkxFTkJRVU41UkN4alFVRmpMRVZCUVVVM1JDeEhRVUZITEVOQlFVTTdVVUZEY0VNc1EwRkJReXhEUVVGRE96dEpRVVZTTzBsQlJVRTdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkRRU3h4UWtGQlV6dE5RVU5RTEU5QlFVOHNTVUZCU1N4RFFVRkRja0lzUzBGQlN5eExRVUZMYUVJc01FSkJRV01zUTBGQlEwTXNUVUZCVFR0SlFVTTNRenRKUVVWQk8wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlEwRXNjVUpCUVZNN1RVRkRVQ3hQUVVGUExFbEJRVWtzUTBGQlEyVXNTMEZCU3l4TFFVRkxhRUlzTUVKQlFXTXNRMEZCUTJsQ0xFMUJRVTA3U1VGRE4wTTdTVUZGUVR0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVVOQkxITkNRVUZWTzAxQlExSXNUMEZCVHl4SlFVRkpMRU5CUVVORUxFdEJRVXNzUzBGQlMyaENMREJDUVVGakxFTkJRVU5wU0N4UFFVRlBPMGxCUXpsRE8wbEJSVUU3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZEUVN4elFrRkJWVHROUVVOU0xFOUJRVThzU1VGQlNTeERRVUZEYWtjc1MwRkJTeXhMUVVGTGFFSXNNRUpCUVdNc1EwRkJRMjFHTEU5QlFVODdTVUZET1VNN1NVRkZRVHRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVU5CTEhsQ1FVRm5RamxETEVkQlFWYzdUVUZEZWtJc05FSkJRWEZDUVN4SFFVRkhPMGxCUXpGQ08wbEJSVUU3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZEUVN4aFFVRkpkME1zU1VGQldTeEZRVUZGTlVJc1RVRkJPRUlzUlVGQlJWSXNVVUZCYTBJN1RVRkRiRVVzU1VGQlRYRkVMRk5CUVZNc1IwRkJSMnBDTEVsQlFVa3NRMEZCUTJ0Q0xHbENRVUZwUWl4RlFVRkZPMDFCUlRGRExFbEJRVTF0UWl4UFFVRlBMRWRCUVVjN1VVRkRaSEpETEVsQlFVa3NSVUZCUldsQ0xGTkJRVk03VVVGRFpqZERMRTFCUVUwc1JVRkJSVUVzVFVGQlRUdFJRVU5rVWl4UlFVRlJMRVZCUVVWQk8wOUJRMWc3VFVGRlJDeEpRVUZKTEVsQlFVa3NRMEZCUTBzc1VVRkJVU3hEUVVGRFowUXNVMEZCVXl4RFFVRkRMRVZCUVVVN1VVRkROVUlzU1VGQlNTeERRVUZEYUVRc1VVRkJVU3hEUVVGRFowUXNVMEZCVXl4RFFVRkRMRU5CUVVNelFpeEpRVUZKTEVOQlFVTXJReXhQUVVGUExFTkJRVU03VDBGRGRrTXNUVUZCVFR0UlFVTk1MRWxCUVVrc1EwRkJRM0JGTEZGQlFWRXNRMEZCUTJkRUxGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTnZRaXhQUVVGUExFTkJRVU03TzAxQlIzUkRMRTlCUVU4c1NVRkJTVHRKUVVOaU8wbEJSVUU3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZEUVN4alFVRkxja01zU1VGQldTeEZRVUZGTlVJc1RVRkJPRUk3VFVGREwwTXNTVUZCVFRaRExGTkJRVk1zUjBGQlIycENMRWxCUVVrc1EwRkJRMnRDTEdsQ1FVRnBRaXhGUVVGRk8wMUJSVEZETEVsQlFVa3NRMEZCUTJwRUxGRkJRVkVzUTBGQlEyZEVMRk5CUVZNc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlEyaEVMRkZCUVZFc1EwRkJRMmRFTEZOQlFWTXNRMEZCUXl4RFFVRkROME1zVFVGQlRTeERRVUZETEZWQlFVTnZSQ3hKUVVGSkxFVkJRVWs3TzFGQlEyeEZMRTlCUVU4c1JVRkRUQ3hYUVVGSkxFTkJRVU40UWl4SlFVRkpMREJEUVVGRmEwSXNhVUpCUVdsQ0xFVkJRVVVzVFVGQlMwUXNVMEZCVXl4SlFVTTFRMjVITEdWQlFXVXNRMEZCUTNkSUxFOUJRVThzUTBGQlEyUXNTVUZCU1N4RFFVRkRjRVFzVFVGQlRTeEZRVUZGUVN4TlFVRk5MRU5CUVVNc1EwRkROME03VFVGRFNDeERRVUZETEVOQlFVTTdUVUZEUml4UFFVRlBMRWxCUVVrN1NVRkRZanRKUVVWQk8wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QmEwSkJPMGxCUTFFc2FVTkJRWEZDTzAxQlF6TkNMRWxCUVVrc1EwRkJRM1JETEZkQlFWY3NRMEZCUTNGQ0xHVkJRV1VzUlVGQlJUdE5RVU5zUXl4SlFVRkpMRWxCUVVrc1EwRkJRMnBETEUxQlFVMHNRMEZCUTNGSUxGZEJRVmNzUlVGQlJTeEZRVUZGTzFGQlF6ZENMRWxCUVVrc1EwRkJReTlFTEU5QlFVOHNSVUZCUlRzN1NVRkZiRUk3U1VGRlFUczdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZMVVN4clFrRkJVMW9zVVVGQmEwSTdUVUZEYWtNc1NVRkJTU3hEUVVGRFVDeEhRVUZITEVOQlFVTnNReXd3UWtGQll5eERRVUZEY1VZc1MwRkJTeXhGUVVGRkxFVkJRVVVzUlVGQlJUVkRMRkZCUVZFc1EwRkJRenRKUVVNNVF6dEpRVVZCT3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVdFJMR3RDUVVGVFFTeFJRVUZyUWp0TlFVTnFReXhKUVVGSkxFTkJRVU5RTEVkQlFVY3NRMEZCUTJ4RExEQkNRVUZqTEVOQlFVTjFSU3hMUVVGTExFVkJRVVVzUlVGQlJTeEZRVUZGTEZWQlFVTXpReXhOUVVGak8xRkJRVUVzVDBGQlMyRXNVVUZCVVN4RFFVRkRZaXhOUVVGTkxFTkJRVU03VFVGQlFTeEZRVUZETzBsQlF6RkZPMGxCUlVFN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJTMUVzYjBKQlFWRTdUVUZEWkN4UFFVRlBMRWxCUVVrc1EwRkJRemRDTEUxQlFVMHNRMEZCUTNGSUxGZEJRVmNzUlVGQlJTeEpRVUZKTEVsQlFVa3NRMEZCUTBNc1UwRkJVeXhGUVVGRk8wbEJRM1JFTzBsQlJVRTdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkRVU3h0UWtGQk9FSTdUVUZCUVN4SlFVRjBRamxITEU5QlFVOHNkVVZCUVVjc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzAxQlEzQkRMRWxCUVVrc1NVRkJTU3hEUVVGRGMwSXNWVUZCVlN4RlFVRkZMRVZCUVVVN1VVRkRja0k3TzAxQlJVWXNTVUZCU1N4RFFVRkRPVUlzVFVGQlRTeERRVUZEZFVnc1pVRkJaU3hEUVVGRExFbEJRVWtzUTBGQlF6RklMRXRCUVVzc1EwRkJRenROUVVOMlF5eEpRVUZKTEVOQlFVTnZRaXhMUVVGTExFZEJRVWRvUWl3d1FrRkJZeXhEUVVGRGFVZ3NUMEZCVHp0TlFVTnVReXhKUVVGSkxFTkJRVU42Unl4UlFVRlJMRU5CUVVNclJ5eE5RVUZOTEVOQlFVTm9TQ3hQUVVGUExFTkJRVU03U1VGREwwSTdTVUZGUVR0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVVOUkxEUkNRVUZ0UWpaQ0xFOUJRVms3VFVGRGNrTXNTVUZCVFc5R0xFOUJRVThzUjBGQlJ6dFJRVU5rTEU5QlFVc3NSVUZCUlR0UlFVTlFWQ3hIUVVGSExFVkJRVVU3VDBGRFRqdE5RVVZFTEVsQlFVa3pSU3hQUVVGUExFTkJRVU41UXl4SlFVRkpMRXRCUVVzc1VVRkJVU3hKUVVGSmVrTXNUMEZCVHl4RFFVRkRlVU1zU1VGQlNTeExRVUZMTEZGQlFWRXNSVUZCUlR0UlFVTXhSREpETEU5QlFVOHNUMEZCU1N4SFFVRkhReXhaUVVGWkxFTkJRVU5ETEdsQ1FVRnBRaXhEUVVNeFEzUkdMRTlCUVU4c1EwRkJRM1ZHTEU5QlFVOHNSVUZEWm5aR0xFOUJRVThzUTBGQlEzZEdMRTFCUVUwc1EwRkRaanM3VFVGSFNDeEpRVUZKZUVZc1QwRkJUeXhEUVVGRGVVTXNTVUZCU1N4TFFVRkxMRkZCUVZFc1NVRkJTWHBETEU5QlFVOHNRMEZCUTNsRExFbEJRVWtzUzBGQlN5eFJRVUZSTEVWQlFVVTdVVUZETVVReVF5eFBRVUZQTEVOQlFVTlVMRWRCUVVjc1IwRkJSMVVzV1VGQldTeERRVUZEUXl4cFFrRkJhVUlzUTBGRE1VTjBSaXhQUVVGUExFTkJRVU4xUml4UFFVRlBMRVZCUTJaMlJpeFBRVUZQTEVOQlFVTjVSaXhWUVVGVkxFTkJRMjVDT3p0TlFVZElMRTlCUVU5TUxFOUJRVTg3U1VGRGFFSTdSVUZCUXp0SlFVRkJPMGxCUVVFc1QwRndSazhzYVVKQlEwNU5MRWxCUVN0Q0xFVkJReTlDUXl4SlFVRXJRanROUVVVdlFpeEpRVUZKY2tRc1RVRkJUU3hEUVVGRGMwUXNTVUZCU1N4RFFVRkRSaXhKUVVGSkxFTkJRVU1zUTBGQlEyNUZMRTFCUVUwc1MwRkJTMlVzVFVGQlRTeERRVUZEYzBRc1NVRkJTU3hEUVVGRFJDeEpRVUZKTEVOQlFVTXNRMEZCUTNCRkxFMUJRVTBzUlVGQlJUdFJRVU42UkN4UFFVRlBMRXRCUVVzN08wMUJSMlFzUzBGQlN5eEpRVUZOYzBVc1EwRkJReXhKUVVGSlNDeEpRVUZKTEVWQlFVVTdVVUZEY0VJc1NVRkJTVUVzU1VGQlNTeERRVUZEUnl4RFFVRkRMRU5CUVVNc1MwRkJTMFlzU1VGQlNTeERRVUZEUlN4RFFVRkRMRU5CUVVNc1JVRkJSVHRWUVVOMlFpeFBRVUZQTEV0QlFVczdPenROUVVsb1FpeFBRVUZQTEVsQlFVazdTVUZEWWp0RlFVRkRPMFZCUVVFN1FVRkJRVHRCUVhob1FraDZTU0lzSW01aGJXVnpJanBiSWxKRlFVeFVTVTFGWDFCUFUxUkhVa1ZUWDBOSVFVNUhSVk5mVEVsVFZFVk9YMFZXUlU1VUlpd2laWGh3YjNKMGN5SXNJbEpGUVV4VVNVMUZYMHhKVTFSRlRsOVVXVkJGVXlJc0lsSkZRVXhVU1UxRlgxTlZRbE5EVWtsQ1JWOVRWRUZVUlZNaUxDSlNaV0ZzZEdsdFpVTm9ZVzV1Wld3aUxDSjBiM0JwWXlJc0luQmhjbUZ0Y3lJc0ltTnZibVpwWnlJc0luTnZZMnRsZENJc0ltTnZibk4wWVc1MGMxOHhJaXdpWTJ4dmMyVmtJaXdpWW5KdllXUmpZWE4wSWl3aVlXTnJJaXdpYzJWc1ppSXNJbkJ5WlhObGJtTmxJaXdpYTJWNUlpd2lkR2x0Wlc5MWRDSXNJbXB2YVc1UWRYTm9JaXdpY0hWemFGOHhJaXdpYW05cGJpSXNJbkpsYW05cGJsUnBiV1Z5SWl3aWRHbHRaWEpmTVNJc0lsOXlaV3B2YVc1VmJuUnBiRU52Ym01bFkzUmxaQ0lzSW5KbFkyOXVibVZqZEVGbWRHVnlUWE1pTENKeVpXTmxhWFpsSWl3aWMzUmhkR1VpTENKcWIybHVaV1FpTENKeVpYTmxkQ0lzSW5CMWMyaENkV1ptWlhJaUxDSm1iM0pGWVdOb0lpd2ljSFZ6YUVWMlpXNTBJaXdpYzJWdVpDSXNJbDl2YmtOc2IzTmxJaXdpYkc5bklpd2lYMnB2YVc1U1pXWWlMQ0pmY21WdGIzWmxJaXdpWDI5dVJYSnliM0lpTENKeVpXRnpiMjRpTENKZmFYTk1aV0YyYVc1bklpd2lYMmx6UTJ4dmMyVmtJaXdpWlhKeWIzSmxaQ0lzSW5OamFHVmtkV3hsVkdsdFpXOTFkQ0lzSWw5cGMwcHZhVzVwYm1jaUxDSmZiMjRpTENKeVpYQnNlU0lzSW5CaGVXeHZZV1FpTENKeVpXWWlMQ0pmZEhKcFoyZGxjaUlzSWw5eVpYQnNlVVYyWlc1MFRtRnRaU0lzSWxKbFlXeDBhVzFsVUhKbGMyVnVZMlZmTVNJc0ltTmhiR3hpWVdOcklpd2lhbTlwYm1Wa1QyNWpaU0lzSW1VaUxDSmhZMk5sYzNOVWIydGxibEJoZVd4dllXUWlMQ0p3YjNOMFozSmxjMTlqYUdGdVoyVnpJaXdpWW1sdVpHbHVaM01pTENKdFlYQWlMQ0p5SWl3aVptbHNkR1Z5SWl3aVlXTmpaWE56Vkc5clpXNGlMQ0poWTJObGMzTmZkRzlyWlc0aUxDSjFjR1JoZEdWS2IybHVVR0Y1Ykc5aFpDSXNJbDl5WldwdmFXNGlMQ0p6WlhKMlpYSlFiM04wWjNKbGMwWnBiSFJsY25NaUxDSnpaWFJCZFhSb0lpd2lkVzVrWldacGJtVmtJaXdpWTJ4cFpXNTBVRzl6ZEdkeVpYTkNhVzVrYVc1bmN5SXNJbUpwYm1ScGJtZHpUR1Z1SWl3aWJHVnVaM1JvSWl3aWJtVjNVRzl6ZEdkeVpYTkNhVzVrYVc1bmN5SXNJbWtpTENKamJHbGxiblJRYjNOMFozSmxjMEpwYm1ScGJtY2lMQ0psZG1WdWRDSXNJbk5qYUdWdFlTSXNJblJoWW14bElpd2ljMlZ5ZG1WeVVHOXpkR2R5WlhOR2FXeDBaWElpTENKd2RYTm9JaXdpYVdRaUxDSjFibk4xWW5OamNtbGlaU0lzSWtWeWNtOXlJaXdpWlhKeWIzSWlMQ0pLVTA5T0lpd2ljM1J5YVc1bmFXWjVJaXdpVDJKcVpXTjBJaXdpZG1Gc2RXVnpJaXdpYjNCMGN5SXNJblI1Y0dVaUxDSlFjbTl0YVhObElpd2ljbVZ6YjJ4MlpTSXNJbDl3ZFhOb0lpd2ljbUYwWlV4cGJXbDBaV1FpTENKMWNHUmhkR1ZRWVhsc2IyRmtJaXdpYkdWaGRtbHVaeUlzSW05dVEyeHZjMlVpTENKamJHOXpaU0lzSW1SbGMzUnliM2tpTENKc1pXRjJaVkIxYzJnaUxDSnNaV0YyWlNJc0lsOWpZVzVRZFhOb0lpd2lkSEpwWjJkbGNpSXNJbk4wWVhKMFZHbHRaVzkxZENJc0lsOWxkbVZ1ZENJc0lsOXlaV1lpTENKMGVYQmxURzkzWlhJaUxDSjBiMHh2WTJGc1pVeHZkMlZ5UTJGelpTSXNJbVYyWlc1MGN5SXNJbWx1WkdWNFQyWWlMQ0pvWVc1a2JHVmtVR0Y1Ykc5aFpDSXNJbDl2YmsxbGMzTmhaMlVpTENKcGJtTnNkV1JsY3lJc0ltSnBibVFpTENKaWFXNWtTV1FpTENKaWFXNWtSWFpsYm5RaUxDSnBaSE1pTENKa1lYUmhJaXdpY0c5emRHZHlaWE5EYUdGdVoyVnpJaXdpWTI5dGJXbDBYM1JwYldWemRHRnRjQ0lzSW1WeWNtOXljeUlzSW1WdWNtbGphR1ZrVUdGNWJHOWhaQ0lzSW1WMlpXNTBWSGx3WlNJc0ltOXNaQ0lzSWw5blpYUlFZWGxzYjJGa1VtVmpiM0prY3lJc0ltcHZhVzVwYm1jaUxDSmlhVzVrYVc1bklpd2lhWE5GY1hWaGJDSXNJbWx6UTI5dWJtVmpkR1ZrSWl3aVgybHpTbTlwYm1Wa0lpd2lYMnhsWVhabFQzQmxibFJ2Y0dsaklpd2ljbVZ6Wlc1a0lpd2ljbVZqYjNKa2N5SXNJbFJ5WVc1elptOXliV1Z5Y3lJc0ltTnZiblpsY25SRGFHRnVaMlZFWVhSaElpd2lZMjlzZFcxdWN5SXNJbkpsWTI5eVpDSXNJbTlzWkY5eVpXTnZjbVFpTENKdlltb3hJaXdpYjJKcU1pSXNJbXRsZVhNaUxDSnJJbDBzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5U1pXRnNkR2x0WlVOb1lXNXVaV3d1ZEhNaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sdHVkV3hzWFgwPSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgX19hd2FpdGVyID0gdm9pZCAwICYmICh2b2lkIDApLl9fYXdhaXRlciB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIH1cbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciB3ZWJzb2NrZXRfMSA9IHJlcXVpcmUoXCJ3ZWJzb2NrZXRcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9saWIvY29uc3RhbnRzXCIpO1xudmFyIHRpbWVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGliL3RpbWVyXCIpKTtcbnZhciBzZXJpYWxpemVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGliL3NlcmlhbGl6ZXJcIikpO1xudmFyIFJlYWx0aW1lQ2hhbm5lbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1JlYWx0aW1lQ2hhbm5lbFwiKSk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbnZhciBSZWFsdGltZUNsaWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gZW5kUG9pbnQgVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCIsIFwid3NzOi8vZXhhbXBsZS5jb21cIiwgXCIvc29ja2V0XCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zcG9ydCBUaGUgV2Vic29ja2V0IFRyYW5zcG9ydCwgZm9yIGV4YW1wbGUgV2ViU29ja2V0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAgICogQHBhcmFtIG9wdGlvbnMucGFyYW1zIFRoZSBvcHRpb25hbCBwYXJhbXMgdG8gcGFzcyB3aGVuIGNvbm5lY3RpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgVGhlIG9wdGlvbmFsIGhlYWRlcnMgdG8gcGFzcyB3aGVuIGNvbm5lY3RpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXMgVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMubG9nZ2VyIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6IGxvZ2dlcjogKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgKiBAcGFyYW0gb3B0aW9ucy5lbmNvZGUgVGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBvdXRnb2luZyBtZXNzYWdlcy4gRGVmYXVsdHMgdG8gSlNPTjogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICogQHBhcmFtIG9wdGlvbnMuZGVjb2RlIFRoZSBmdW5jdGlvbiB0byBkZWNvZGUgaW5jb21pbmcgbWVzc2FnZXMuIERlZmF1bHRzIHRvIFNlcmlhbGl6ZXIncyBkZWNvZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMgaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjIHJlY29ubmVjdCBpbnRlcnZhbC4gRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mZi5cbiAgICovXG4gIGZ1bmN0aW9uIFJlYWx0aW1lQ2xpZW50KGVuZFBvaW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhbHRpbWVDbGllbnQpO1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICB0aGlzLmNoYW5uZWxzID0gW107XG4gICAgdGhpcy5lbmRQb2ludCA9ICcnO1xuICAgIHRoaXMuaGVhZGVycyA9IGNvbnN0YW50c18xLkRFRkFVTFRfSEVBREVSUztcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgIHRoaXMudGltZW91dCA9IGNvbnN0YW50c18xLkRFRkFVTFRfVElNRU9VVDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHdlYnNvY2tldF8xLnczY3dlYnNvY2tldDtcbiAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSAzMDAwMDtcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgdGhpcy5yZWYgPSAwO1xuICAgIHRoaXMubG9nZ2VyID0gbm9vcDtcbiAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBzZXJpYWxpemVyXzFbXCJkZWZhdWx0XCJdKCk7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHtcbiAgICAgIG9wZW46IFtdLFxuICAgICAgY2xvc2U6IFtdLFxuICAgICAgZXJyb3I6IFtdLFxuICAgICAgbWVzc2FnZTogW11cbiAgICB9O1xuICAgIHRoaXMuZXZlbnRzUGVyU2Vjb25kTGltaXRNcyA9IDEwMDtcbiAgICB0aGlzLmluVGhyb3R0bGUgPSBmYWxzZTtcbiAgICB0aGlzLmVuZFBvaW50ID0gXCJcIi5jb25jYXQoZW5kUG9pbnQsIFwiL1wiKS5jb25jYXQoY29uc3RhbnRzXzEuVFJBTlNQT1JUUy53ZWJzb2NrZXQpO1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycykgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dCkgdGhpcy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9nZ2VyKSB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyO1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNwb3J0KSB0aGlzLnRyYW5zcG9ydCA9IG9wdGlvbnMudHJhbnNwb3J0O1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcykgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zO1xuICAgIHZhciBldmVudHNQZXJTZWNvbmQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZlbnRzUGVyU2Vjb25kO1xuICAgIGlmIChldmVudHNQZXJTZWNvbmQpIHRoaXMuZXZlbnRzUGVyU2Vjb25kTGltaXRNcyA9IE1hdGguZmxvb3IoMTAwMCAvIGV2ZW50c1BlclNlY29uZCk7XG4gICAgdGhpcy5yZWNvbm5lY3RBZnRlck1zID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWNvbm5lY3RBZnRlck1zKSA/IG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNcyA6IGZ1bmN0aW9uICh0cmllcykge1xuICAgICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMDtcbiAgICB9O1xuICAgIHRoaXMuZW5jb2RlID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbmNvZGUpID8gb3B0aW9ucy5lbmNvZGUgOiBmdW5jdGlvbiAocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgfTtcbiAgICB0aGlzLmRlY29kZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVjb2RlKSA/IG9wdGlvbnMuZGVjb2RlIDogdGhpcy5zZXJpYWxpemVyLmRlY29kZS5iaW5kKHRoaXMuc2VyaWFsaXplcik7XG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyB0aW1lcl8xW1wiZGVmYXVsdFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRoZSBzb2NrZXQsIHVubGVzcyBhbHJlYWR5IGNvbm5lY3RlZC5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhSZWFsdGltZUNsaWVudCwgW3tcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLl9lbmRQb2ludFVSTCgpLCBbXSwgbnVsbCwgdGhpcy5oZWFkZXJzKTtcbiAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB0aGlzLmNvbm4ub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX29uQ29ubk9wZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9vbkNvbm5FcnJvcihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9vbkNvbm5NZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9vbkNvbm5DbG9zZShldmVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZSBBIG51bWVyaWMgc3RhdHVzIGNvZGUgdG8gc2VuZCBvbiBkaXNjb25uZWN0LlxuICAgICAqIEBwYXJhbSByZWFzb24gQSBjdXN0b20gcmVhc29uIGZvciB0aGUgZGlzY29ubmVjdC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXNjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoY29kZSwgcmVhc29uKSB7XG4gICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZnVuY3Rpb24gKCkge307IC8vIG5vb3BcbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uICE9PSBudWxsICYmIHJlYXNvbiAhPT0gdm9pZCAwID8gcmVhc29uIDogJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubiA9IG51bGw7XG4gICAgICAgIC8vIHJlbW92ZSBvcGVuIGhhbmRsZXNcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENoYW5uZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYW5uZWxzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHJldHVybiBjaGFubmVsLnVuc3Vic2NyaWJlKCkudGhlbihmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgIGlmIChfdGhpczMuY2hhbm5lbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgX3RoaXMzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUFsbENoYW5uZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUFsbENoYW5uZWxzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5jaGFubmVscy5tYXAoZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgX3RoaXM0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIHRoZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogRm9yIGN1c3RvbWl6ZWQgbG9nZ2luZywgYHRoaXMubG9nZ2VyYCBjYW4gYmUgb3ZlcnJpZGVuLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2coa2luZCwgbXNnLCBkYXRhKSB7XG4gICAgICB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzb2NrZXQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29ubmVjdGlvblN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgIGNhc2UgY29uc3RhbnRzXzEuU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nOlxuICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5DT05ORUNUSU9OX1NUQVRFLkNvbm5lY3Rpbmc7XG4gICAgICAgIGNhc2UgY29uc3RhbnRzXzEuU09DS0VUX1NUQVRFUy5vcGVuOlxuICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5DT05ORUNUSU9OX1NUQVRFLk9wZW47XG4gICAgICAgIGNhc2UgY29uc3RhbnRzXzEuU09DS0VUX1NUQVRFUy5jbG9zaW5nOlxuICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5DT05ORUNUSU9OX1NUQVRFLkNsb3Npbmc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLkNPTk5FQ1RJT05fU1RBVEUuQ2xvc2VkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1bnMgYHRydWVgIGlzIHRoZSBjb25uZWN0aW9uIGlzIG9wZW4uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDb25uZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNDb25uZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gY29uc3RhbnRzXzEuQ09OTkVDVElPTl9TVEFURS5PcGVuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGFubmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5uZWwodG9waWMpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgICAgY29uZmlnOiB7fVxuICAgICAgfTtcbiAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW4gPSBuZXcgUmVhbHRpbWVDaGFubmVsXzFbXCJkZWZhdWx0XCJdKFwicmVhbHRpbWU6XCIuY29uY2F0KHRvcGljKSwgcGFyYW1zLCB0aGlzKTtcbiAgICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKTtcbiAgICAgIHJldHVybiBjaGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoIG91dCBhIG1lc3NhZ2UgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc29ja2V0IGlzIG5vdCBjb25uZWN0ZWQsIHRoZSBtZXNzYWdlIGdldHMgZW5xdWV1ZWQgd2l0aGluIGEgbG9jYWwgYnVmZmVyLCBhbmQgc2VudCBvdXQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgbmV4dCBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2goZGF0YSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgdG9waWMgPSBkYXRhLnRvcGljLFxuICAgICAgICBldmVudCA9IGRhdGEuZXZlbnQsXG4gICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQsXG4gICAgICAgIHJlZiA9IGRhdGEucmVmO1xuICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICAgIF90aGlzNS5lbmNvZGUoZGF0YSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSBfdGhpczUuY29ubikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmQocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coJ3B1c2gnLCBcIlwiLmNvbmNhdCh0b3BpYywgXCIgXCIpLmNvbmNhdChldmVudCwgXCIgKFwiKS5jb25jYXQocmVmLCBcIilcIiksIHBheWxvYWQpO1xuICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICBpZiAoWydicm9hZGNhc3QnLCAncHJlc2VuY2UnLCAncG9zdGdyZXNfY2hhbmdlcyddLmluY2x1ZGVzKGV2ZW50KSkge1xuICAgICAgICAgIHZhciBpc1Rocm90dGxlZCA9IHRoaXMuX3Rocm90dGxlKGNhbGxiYWNrKSgpO1xuICAgICAgICAgIGlmIChpc1Rocm90dGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuICdyYXRlIGxpbWl0ZWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEpXVCBhY2Nlc3MgdG9rZW4gdXNlZCBmb3IgY2hhbm5lbCBzdWJzY3JpcHRpb24gYXV0aG9yaXphdGlvbiBhbmQgUmVhbHRpbWUgUkxTLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIEEgSldUIHN0cmluZy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRBdXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF1dGgodG9rZW4pIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB0b2tlbjtcbiAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICB0b2tlbiAmJiBjaGFubmVsLnVwZGF0ZUpvaW5QYXlsb2FkKHtcbiAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbm5lbC5qb2luZWRPbmNlICYmIGNoYW5uZWwuX2lzSm9pbmVkKCkpIHtcbiAgICAgICAgICBjaGFubmVsLl9wdXNoKGNvbnN0YW50c18xLkNIQU5ORUxfRVZFTlRTLmFjY2Vzc190b2tlbiwge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlUmVmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlUmVmKCkge1xuICAgICAgdmFyIG5ld1JlZiA9IHRoaXMucmVmICsgMTtcbiAgICAgIGlmIChuZXdSZWYgPT09IHRoaXMucmVmKSB7XG4gICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVmID0gbmV3UmVmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gY2hhbm5lbHMgd2l0aCB0aGUgc3BlY2lmaWVkIHRvcGljLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xlYXZlT3BlblRvcGljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sZWF2ZU9wZW5Ub3BpYyh0b3BpYykge1xuICAgICAgdmFyIGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMudG9waWMgPT09IHRvcGljICYmIChjLl9pc0pvaW5lZCgpIHx8IGMuX2lzSm9pbmluZygpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGR1cENoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIFwibGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXFxcIlwiLmNvbmNhdCh0b3BpYywgXCJcXFwiXCIpKTtcbiAgICAgICAgZHVwQ2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3Vic2NyaXB0aW9uIGZyb20gdGhlIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIEFuIG9wZW4gc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlKGNoYW5uZWwpIHtcbiAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5fam9pblJlZigpICE9PSBjaGFubmVsLl9qb2luUmVmKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZW5kUG9pbnRVUkxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VuZFBvaW50VVJMKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcywge1xuICAgICAgICB2c246IGNvbnN0YW50c18xLlZTTlxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uQ29ubk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICB0aGlzLmRlY29kZShyYXdNZXNzYWdlLmRhdGEsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIHRvcGljID0gbXNnLnRvcGljLFxuICAgICAgICAgIGV2ZW50ID0gbXNnLmV2ZW50LFxuICAgICAgICAgIHBheWxvYWQgPSBtc2cucGF5bG9hZCxcbiAgICAgICAgICByZWYgPSBtc2cucmVmO1xuICAgICAgICBpZiAocmVmICYmIHJlZiA9PT0gX3RoaXM2LnBlbmRpbmdIZWFydGJlYXRSZWYgfHwgZXZlbnQgPT09IChwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQudHlwZSkpIHtcbiAgICAgICAgICBfdGhpczYucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXM2LmxvZygncmVjZWl2ZScsIFwiXCIuY29uY2F0KHBheWxvYWQuc3RhdHVzIHx8ICcnLCBcIiBcIikuY29uY2F0KHRvcGljLCBcIiBcIikuY29uY2F0KGV2ZW50LCBcIiBcIikuY29uY2F0KHJlZiAmJiAnKCcgKyByZWYgKyAnKScgfHwgJycpLCBwYXlsb2FkKTtcbiAgICAgICAgX3RoaXM2LmNoYW5uZWxzLmZpbHRlcihmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgIHJldHVybiBjaGFubmVsLl9pc01lbWJlcih0b3BpYyk7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICByZXR1cm4gY2hhbm5lbC5fdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzNi5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG1zZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgfSwge1xuICAgIGtleTogXCJfb25Db25uT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Db25uT3BlbigpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIFwiY29ubmVjdGVkIHRvIFwiLmNvbmNhdCh0aGlzLl9lbmRQb2ludFVSTCgpKSk7XG4gICAgICB0aGlzLl9mbHVzaFNlbmRCdWZmZXIoKTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKTtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczcuX3NlbmRIZWFydGJlYXQoKTtcbiAgICAgIH0sIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9vbkNvbm5DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Db25uQ2xvc2UoZXZlbnQpIHtcbiAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCAnY2xvc2UnLCBldmVudCk7XG4gICAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKCk7XG4gICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyICYmIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lcik7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgfSwge1xuICAgIGtleTogXCJfb25Db25uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ29ubkVycm9yKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKCk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcIl90cmlnZ2VyQ2hhbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBjaGFubmVsLl90cmlnZ2VyKGNvbnN0YW50c18xLkNIQU5ORUxfRVZFTlRTLmVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZFBhcmFtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kUGFyYW1zKHVybCwgcGFyYW1zKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gJyYnIDogJz8nO1xuICAgICAgdmFyIHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHVybCkuY29uY2F0KHByZWZpeCkuY29uY2F0KHF1ZXJ5KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9mbHVzaFNlbmRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZsdXNoU2VuZEJ1ZmZlcigpIHtcbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZW5kSGVhcnRiZWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZW5kSGVhcnRiZWF0KCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgJ2hlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uJyk7XG4gICAgICAgIChfYSA9IHRoaXMuY29ubikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKGNvbnN0YW50c18xLldTX0NMT1NFX05PUk1BTCwgJ2hlYXJiZWF0IHRpbWVvdXQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5fbWFrZVJlZigpO1xuICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgdG9waWM6ICdwaG9lbml4JyxcbiAgICAgICAgZXZlbnQ6ICdoZWFydGJlYXQnLFxuICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWZcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRBdXRoKHRoaXMuYWNjZXNzVG9rZW4pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Rocm90dGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvdHRsZShjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgICB2YXIgZXZlbnRzUGVyU2Vjb25kTGltaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuZXZlbnRzUGVyU2Vjb25kTGltaXRNcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczguaW5UaHJvdHRsZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIF90aGlzOC5pblRocm90dGxlID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM4LmluVGhyb3R0bGUgPSBmYWxzZTtcbiAgICAgICAgfSwgZXZlbnRzUGVyU2Vjb25kTGltaXQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUmVhbHRpbWVDbGllbnQ7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJlYWx0aW1lQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3UVVGQlFUdEJRVU5CTzBGQlZVRTdRVUZEUVR0QlFVTkJPMEZCZDBKQkxFbEJRVTFCTEVsQlFVa3NSMEZCUnl4VFFVRlFRU3hKUVVGSkxFZEJRVkVzUTBGQlJTeERRVUZETzBGQlFVRXNTVUZGUVVNc1kwRkJZenRGUVd0RGFrTTdPenM3T3pzN096czdPenM3TzBWQlkwRXNkMEpCUVZsRExGRkJRV2RDTEVWQlFVVkRMRTlCUVN0Q08wbEJRVUU3U1VGQlFUczdTVUV2UXpkRUxHZENRVUZYTEVkQlFXdENMRWxCUVVrN1NVRkRha01zWVVGQlVTeEhRVUZ6UWl4RlFVRkZPMGxCUTJoRExHRkJRVkVzUjBGQlZ5eEZRVUZGTzBsQlEzSkNMRmxCUVU4c1IwRkJLMEpETERKQ1FVRmxPMGxCUTNKRUxGZEJRVTBzUjBGQkswSXNSVUZCUlR0SlFVTjJReXhaUVVGUExFZEJRVmRCTERKQ1FVRmxPMGxCUTJwRExHTkJRVk1zUjBGQlVVTXNkMEpCUVZrN1NVRkROMElzZDBKQlFXMUNMRWRCUVZjc1MwRkJTenRKUVVOdVF5eHRRa0ZCWXl4SFFVRXJRME1zVTBGQlV6dEpRVU4wUlN4M1FrRkJiVUlzUjBGQmEwSXNTVUZCU1R0SlFVTjZReXhSUVVGSExFZEJRVmNzUTBGQlF6dEpRVVZtTEZkQlFVMHNSMEZCWVU0c1NVRkJTVHRKUVVsMlFpeFRRVUZKTEVkQlFYRkNMRWxCUVVrN1NVRkROMElzWlVGQlZTeEhRVUZsTEVWQlFVVTdTVUZETTBJc1pVRkJWU3hIUVVGbExFbEJRVWxQTEhWQ1FVRlZMRVZCUVVVN1NVRkRla01zZVVKQlFXOUNMRWRCUzJoQ08wMUJRMFpETEVsQlFVa3NSVUZCUlN4RlFVRkZPMDFCUTFKRExFdEJRVXNzUlVGQlJTeEZRVUZGTzAxQlExUkRMRXRCUVVzc1JVRkJSU3hGUVVGRk8wMUJRMVJETEU5QlFVOHNSVUZCUlR0TFFVTldPMGxCUTBRc01rSkJRWE5DTEVkQlFWY3NSMEZCUnp0SlFVTndReXhsUVVGVkxFZEJRVmtzUzBGQlN6dEpRV2xDZWtJc1NVRkJTU3hEUVVGRFZDeFJRVUZSTEdGQlFVMUJMRkZCUVZFc1kwRkJTVVVzYzBKQlFWVXNRMEZCUTFFc1UwRkJVeXhEUVVGRk8wbEJSWEpFTEVsQlFVbFVMRTlCUVU4c1lVRkJVRUVzVDBGQlR5eDFRa0ZCVUVFc1QwRkJUeXhEUVVGRlZTeE5RVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRRU3hOUVVGTkxFZEJRVWRXTEU5QlFVOHNRMEZCUTFVc1RVRkJUVHRKUVVOcVJDeEpRVUZKVml4UFFVRlBMR0ZCUVZCQkxFOUJRVThzZFVKQlFWQkJMRTlCUVU4c1EwRkJSVmNzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTBFc1QwRkJUeXh0UTBGQlVTeEpRVUZKTEVOQlFVTkJMRTlCUVU4c1IwRkJTMWdzVDBGQlR5eERRVUZEVnl4UFFVRlBMRU5CUVVVN1NVRkROVVVzU1VGQlNWZ3NUMEZCVHl4aFFVRlFRU3hQUVVGUExIVkNRVUZRUVN4UFFVRlBMRU5CUVVWWkxFOUJRVThzUlVGQlJTeEpRVUZKTEVOQlFVTkJMRTlCUVU4c1IwRkJSMW9zVDBGQlR5eERRVUZEV1N4UFFVRlBPMGxCUTNCRUxFbEJRVWxhTEU5QlFVOHNZVUZCVUVFc1QwRkJUeXgxUWtGQlVFRXNUMEZCVHl4RFFVRkZZU3hOUVVGTkxFVkJRVVVzU1VGQlNTeERRVUZEUVN4TlFVRk5MRWRCUVVkaUxFOUJRVThzUTBGQlEyRXNUVUZCVFR0SlFVTnFSQ3hKUVVGSllpeFBRVUZQTEdGQlFWQkJMRTlCUVU4c2RVSkJRVkJCTEU5QlFVOHNRMEZCUldNc1UwRkJVeXhGUVVGRkxFbEJRVWtzUTBGQlEwRXNVMEZCVXl4SFFVRkhaQ3hQUVVGUExFTkJRVU5qTEZOQlFWTTdTVUZETVVRc1NVRkJTV1FzVDBGQlR5eGhRVUZRUVN4UFFVRlBMSFZDUVVGUVFTeFBRVUZQTEVOQlFVVmxMRzFDUVVGdFFpeEZRVU01UWl4SlFVRkpMRU5CUVVOQkxHMUNRVUZ0UWl4SFFVRkhaaXhQUVVGUExFTkJRVU5sTEcxQ1FVRnRRanRKUVVWNFJDeEpRVUZOUXl4bFFVRmxMRWRCUVVjc1lVRkJUeXhoUVVGUWFFSXNUMEZCVHl4MVFrRkJVRUVzVDBGQlR5eERRVUZGVlN4TlFVRk5MREJEUVVGRlRTeGxRVUZsTzBsQlEzaEVMRWxCUVVsQkxHVkJRV1VzUlVGRGFrSXNTVUZCU1N4RFFVRkRReXh6UWtGQmMwSXNSMEZCUjBNc1NVRkJTU3hEUVVGRFF5eExRVUZMTEVOQlFVTXNTVUZCU1N4SFFVRkhTQ3hsUVVGbExFTkJRVU03U1VGRmJFVXNTVUZCU1N4RFFVRkRTU3huUWtGQlowSXNSMEZCUnl4UlFVRlBMR0ZCUVZCd1FpeFBRVUZQTEhWQ1FVRlFRU3hQUVVGUExFTkJRVVZ2UWl4blFrRkJaMElzU1VGRE4wTndRaXhQUVVGUExFTkJRVU52UWl4blFrRkJaMElzUjBGRGVFSXNWVUZCUTBNc1MwRkJZU3hGUVVGSk8wMUJRMmhDTEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNRMEZCUTBFc1MwRkJTeXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVczdTVUZEZEVRc1EwRkJRenRKUVVOTUxFbEJRVWtzUTBGQlEwTXNUVUZCVFN4SFFVRkhMRkZCUVU4c1lVRkJVSFJDTEU5QlFVOHNkVUpCUVZCQkxFOUJRVThzUTBGQlJYTkNMRTFCUVUwc1NVRkRla0owUWl4UFFVRlBMRU5CUVVOelFpeE5RVUZOTEVkQlEyUXNWVUZCUTBNc1QwRkJZU3hGUVVGRlF5eFJRVUZyUWl4RlFVRkpPMDFCUTNCRExFOUJRVTlCTEZGQlFWRXNRMEZCUTBNc1NVRkJTU3hEUVVGRFF5eFRRVUZUTEVOQlFVTklMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRekZETEVOQlFVTTdTVUZEVEN4SlFVRkpMRU5CUVVOSkxFMUJRVTBzUjBGQlJ5eFJRVUZQTEdGQlFWQXpRaXhQUVVGUExIVkNRVUZRUVN4UFFVRlBMRU5CUVVVeVFpeE5RVUZOTEVsQlEzcENNMElzVDBGQlR5eERRVUZETWtJc1RVRkJUU3hIUVVOa0xFbEJRVWtzUTBGQlEwTXNWVUZCVlN4RFFVRkRSQ3hOUVVGTkxFTkJRVU5GTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVORUxGVkJRVlVzUTBGQlF6dEpRVU5vUkN4SlFVRkpMRU5CUVVORkxHTkJRV01zUjBGQlJ5eEpRVUZKUXl4clFrRkJTeXhEUVVGRE8wMUJRVUVzVDBGQlYwTTdVVUZCUVR0VlFVRkJPMWxCUVVFN1kwRkRla01zU1VGQlNTeERRVUZEUXl4VlFVRlZMRVZCUVVVN1kwRkRha0lzU1VGQlNTeERRVUZEUXl4UFFVRlBMRVZCUVVVN1dVRkJRVHRaUVVGQk8yTkJRVUU3VlVGQlFUdFJRVUZCTzAxQlFVRXNRMEZEWmp0SlFVRkJMRWRCUVVVc1NVRkJTU3hEUVVGRFpDeG5Ra0ZCWjBJc1EwRkJRenRGUVVNelFqdEZRVVZCT3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGSFFTeHRRa0ZCVHp0TlFVRkJPMDFCUTB3c1NVRkJTU3hKUVVGSkxFTkJRVU5sTEVsQlFVa3NSVUZCUlR0UlFVTmlPenROUVVkR0xFbEJRVWtzUTBGQlEwRXNTVUZCU1N4SFFVRkhMRWxCUVVrc1NVRkJTU3hEUVVGRGNrSXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJRM05DTEZsQlFWa3NSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZEZWtJc1QwRkJUeXhEUVVGRE8wMUJSVE5GTEVsQlFVa3NTVUZCU1N4RFFVRkRkMElzU1VGQlNTeEZRVUZGTzFGQlEySXNTVUZCU1N4RFFVRkRRU3hKUVVGSkxFTkJRVU5GTEZWQlFWVXNSMEZCUnl4aFFVRmhPMUZCUTNCRExFbEJRVWtzUTBGQlEwWXNTVUZCU1N4RFFVRkRSeXhOUVVGTkxFZEJRVWM3VlVGQlFTeFBRVUZOTEUxQlFVa3NRMEZCUTBNc1YwRkJWeXhGUVVGRk8xRkJRVUU3VVVGRE0wTXNTVUZCU1N4RFFVRkRTaXhKUVVGSkxFTkJRVU5MTEU5QlFVOHNSMEZCUnl4VlFVRkRha01zUzBGQlN6dFZRVUZCTEU5QlFVc3NUVUZCU1N4RFFVRkRhME1zV1VGQldTeERRVUZEYkVNc1MwRkJiVUlzUTBGQlF6dFJRVUZCTzFGQlEzSkZMRWxCUVVrc1EwRkJRelJDTEVsQlFVa3NRMEZCUTA4c1UwRkJVeXhIUVVGSExGVkJRVU5ETEV0QlFVczdWVUZCUVN4UFFVRkxMRTFCUVVrc1EwRkJRME1zWTBGQll5eERRVUZEUkN4TFFVRkxMRU5CUVVNN1VVRkJRVHRSUVVNelJDeEpRVUZKTEVOQlFVTlNMRWxCUVVrc1EwRkJRMVVzVDBGQlR5eEhRVUZITEZWQlFVTkdMRXRCUVVzN1ZVRkJRU3hQUVVGTExFMUJRVWtzUTBGQlEwY3NXVUZCV1N4RFFVRkRTQ3hMUVVGTExFTkJRVU03VVVGQlFUczdTVUZGTTBRN1NVRkZRVHM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlRVRXNiMEpCUVZkSkxFbEJRV0VzUlVGQlJVTXNUVUZCWlR0TlFVTjJReXhKUVVGSkxFbEJRVWtzUTBGQlEySXNTVUZCU1N4RlFVRkZPMUZCUTJJc1NVRkJTU3hEUVVGRFFTeEpRVUZKTEVOQlFVTlZMRTlCUVU4c1IwRkJSeXhoUVVGaExFTkJRVU1zUlVGQlF6dFJRVU51UXl4SlFVRkpSU3hKUVVGSkxFVkJRVVU3VlVGRFVpeEpRVUZKTEVOQlFVTmFMRWxCUVVrc1EwRkJRemRDTEV0QlFVc3NRMEZCUTNsRExFbEJRVWtzUlVGQlJVTXNUVUZCVFN4aFFVRk9RU3hOUVVGTkxHTkJRVTVCTEUxQlFVMHNSMEZCU1N4RlFVRkZMRU5CUVVNN1UwRkRjRU1zVFVGQlRUdFZRVU5NTEVsQlFVa3NRMEZCUTJJc1NVRkJTU3hEUVVGRE4wSXNTMEZCU3l4RlFVRkZPenRSUVVWdVFpeEpRVUZKTEVOQlFVTTJRaXhKUVVGSkxFZEJRVWNzU1VGQlNUdFJRVU5vUWp0UlFVTkJMRWxCUVVrc1EwRkJRMk1zWTBGQll5eEpRVUZKUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hEUVVGRFJDeGpRVUZqTEVOQlFVTTdVVUZEZWtRc1NVRkJTU3hEUVVGRGJrSXNZMEZCWXl4RFFVRkRjVUlzUzBGQlN5eEZRVUZGT3p0SlFVVXZRanRGUVVGRE8wbEJRVUU3U1VGQlFTeFBRVVZFTEhWQ1FVRlhPMDFCUTFRc1QwRkJUeXhKUVVGSkxFTkJRVU5ETEZGQlFWRTdTVUZEZEVJN1JVRkJRenRKUVVGQk8wbEJRVUVzVDBGRlJDeDFRa0ZEUlVNc1QwRkJkMEk3VFVGQlFUdE5RVVY0UWl4UFFVRlBRU3hQUVVGUExFTkJRVU5ETEZkQlFWY3NSVUZCUlN4RFFVRkRReXhKUVVGSkxFTkJRVU1zVlVGQlEwTXNUVUZCVFN4RlFVRkpPMUZCUXpORExFbEJRVWtzVFVGQlNTeERRVUZEU2l4UlFVRlJMRU5CUVVOTExFMUJRVTBzUzBGQlN5eERRVUZETEVWQlFVVTdWVUZET1VJc1RVRkJTU3hEUVVGRGVFSXNWVUZCVlN4RlFVRkZPenRSUVVWdVFpeFBRVUZQZFVJc1RVRkJUVHROUVVObUxFTkJRVU1zUTBGQlF6dEpRVU5LTzBWQlFVTTdTVUZCUVR0SlFVRkJMRTlCUlVRc05rSkJRV2xDTzAxQlFVRTdUVUZEWml4UFFVRlBSU3hQUVVGUExFTkJRVU5ETEVkQlFVY3NRMEZEYUVJc1NVRkJTU3hEUVVGRFVDeFJRVUZSTEVOQlFVTlJMRWRCUVVjc1EwRkJReXhWUVVGRFVDeFBRVUZQTzFGQlFVRXNUMEZCUzBFc1QwRkJUeXhEUVVGRFF5eFhRVUZYTEVWQlFVVTdUVUZCUVN4RlFVRkRMRU5CUTNSRUxFTkJRVU5ETEVsQlFVa3NRMEZCUXl4VlFVRkRUU3hOUVVGTkxFVkJRVWs3VVVGRGFFSXNUVUZCU1N4RFFVRkROVUlzVlVGQlZTeEZRVUZGTzFGQlEycENMRTlCUVU4MFFpeE5RVUZOTzAxQlEyWXNRMEZCUXl4RFFVRkRPMGxCUTBvN1NVRkZRVHM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGTFFTeGhRVUZKUXl4SlFVRlpMRVZCUVVWRExFZEJRVmNzUlVGQlJVTXNTVUZCVlR0TlFVTjJReXhKUVVGSkxFTkJRVU51UkN4TlFVRk5MRU5CUVVOcFJDeEpRVUZKTEVWQlFVVkRMRWRCUVVjc1JVRkJSVU1zU1VGQlNTeERRVUZETzBsQlF6bENPMGxCUlVFN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVZEJMREpDUVVGbE8wMUJRMklzVVVGQlVTeEpRVUZKTEVOQlFVTTNRaXhKUVVGSkxFbEJRVWtzU1VGQlNTeERRVUZEUVN4SlFVRkpMRU5CUVVNNFFpeFZRVUZWTzFGQlEzWkRMRXRCUVV0b1JTeDVRa0ZCWVN4RFFVRkRhVVVzVlVGQlZUdFZRVU16UWl4UFFVRlBha1VzTkVKQlFXZENMRU5CUVVOclJTeFZRVUZWTzFGQlEzQkRMRXRCUVV0c1JTeDVRa0ZCWVN4RFFVRkRTU3hKUVVGSk8xVkJRM0pDTEU5QlFVOUtMRFJDUVVGblFpeERRVUZEYlVVc1NVRkJTVHRSUVVNNVFpeExRVUZMYmtVc2VVSkJRV0VzUTBGQlEyOUZMRTlCUVU4N1ZVRkRlRUlzVDBGQlQzQkZMRFJDUVVGblFpeERRVUZEY1VVc1QwRkJUenRSUVVOcVF6dFZRVU5GTEU5QlFVOXlSU3cwUWtGQlowSXNRMEZCUTNORkxFMUJRVTA3VFVGQlFUdEpRVVZ3UXp0SlFVVkJPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZIUVN4MVFrRkJWenROUVVOVUxFOUJRVThzU1VGQlNTeERRVUZEUXl4bFFVRmxMRVZCUVVVc1MwRkJTM1pGTERSQ1FVRm5RaXhEUVVGRGJVVXNTVUZCU1R0SlFVTjZSRHRGUVVGRE8wbEJRVUU3U1VGQlFTeFBRVVZFTEdsQ1FVTkZTeXhMUVVGaExFVkJRMnRETzAxQlFVRXNTVUZCTDBNdlJDdzJSVUZCYVVNN1VVRkJSV2RGTEUxQlFVMHNSVUZCUlR0TlFVRkZMRU5CUVVVN1RVRkZMME1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUTBNc1YwRkJWeXhGUVVGRkxFVkJRVVU3VVVGRGRrSXNTVUZCU1N4RFFVRkRla01zVDBGQlR5eEZRVUZGT3p0TlFVZG9RaXhKUVVGTk1FTXNTVUZCU1N4SFFVRkhMRWxCUVVsRExEUkNRVUZsTEc5Q1FVRmhTaXhMUVVGTExFZEJRVWt2UkN4TlFVRk5MRVZCUVVVc1NVRkJTU3hEUVVGRE8wMUJRMjVGTEVsQlFVa3NRMEZCUXpCRExGRkJRVkVzUTBGQlF6QkNMRWxCUVVrc1EwRkJRMFlzU1VGQlNTeERRVUZETzAxQlEzaENMRTlCUVU5QkxFbEJRVWs3U1VGRFlqdEpRVVZCT3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVdEJMR05CUVV0YUxFbEJRWEZDTzAxQlFVRTdUVUZEZUVJc1NVRkJVVk1zUzBGQlN5eEhRVUV3UWxRc1NVRkJTU3hEUVVGdVExTXNTMEZCU3p0UlFVRkZPVUlzUzBGQlN5eEhRVUZ0UW5GQ0xFbEJRVWtzUTBGQk5VSnlRaXhMUVVGTE8xRkJRVVZ3UWl4UFFVRlBMRWRCUVZWNVF5eEpRVUZKTEVOQlFYSkNla01zVDBGQlR6dFJRVUZGZDBRc1IwRkJSeXhIUVVGTFppeEpRVUZKTEVOQlFWcGxMRWRCUVVjN1RVRkRiRU1zU1VGQlNYWkVMRkZCUVZFc1IwRkJSeXhUUVVGWVFTeFJRVUZSTEVkQlFWRTdVVUZEYkVJc1RVRkJTU3hEUVVGRFJpeE5RVUZOTEVOQlFVTXdReXhKUVVGSkxFVkJRVVVzVlVGQlEyZENMRTFCUVZjc1JVRkJTVHM3VlVGRGFFTXNXVUZCU1N4RFFVRkROME1zU1VGQlNTd3dRMEZCUlRoRExFbEJRVWtzUTBGQlEwUXNUVUZCVFN4RFFVRkRPMUZCUTNwQ0xFTkJRVU1zUTBGQlF6dE5RVU5LTEVOQlFVTTdUVUZEUkN4SlFVRkpMRU5CUVVORkxFZEJRVWNzUTBGQlF5eE5RVUZOTEZsQlFVdFVMRXRCUVVzc1kwRkJTVGxDTEV0QlFVc3NaVUZCUzI5RExFZEJRVWNzVVVGQlMzaEVMRTlCUVU4c1EwRkJRenROUVVOMlJDeEpRVUZKTEVsQlFVa3NRMEZCUTI5RUxGZEJRVmNzUlVGQlJTeEZRVUZGTzFGQlEzUkNMRWxCUVVrc1EwRkJReXhYUVVGWExFVkJRVVVzVlVGQlZTeEZRVUZGTEd0Q1FVRnJRaXhEUVVGRExFTkJRVU5STEZGQlFWRXNRMEZCUTNoRExFdEJRVXNzUTBGQlF5eEZRVUZGTzFWQlEycEZMRWxCUVUxNVF5eFhRVUZYTEVkQlFVY3NTVUZCU1N4RFFVRkRReXhUUVVGVExFTkJRVU0zUkN4UlFVRlJMRU5CUVVNc1JVRkJSVHRWUVVNNVF5eEpRVUZKTkVRc1YwRkJWeXhGUVVGRk8xbEJRMllzVDBGQlR5eGpRVUZqT3p0VFFVVjRRaXhOUVVGTk8xVkJRMHcxUkN4UlFVRlJMRVZCUVVVN08wOUJSV0lzVFVGQlRUdFJRVU5NTEVsQlFVa3NRMEZCUXpoRUxGVkJRVlVzUTBGQlExSXNTVUZCU1N4RFFVRkRkRVFzVVVGQlVTeERRVUZET3p0SlFVVnNRenRKUVVWQk96czdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVXRCTEdsQ1FVRlJLMFFzUzBGQmIwSTdUVUZETVVJc1NVRkJTU3hEUVVGRFF5eFhRVUZYTEVkQlFVZEVMRXRCUVVzN1RVRkZlRUlzU1VGQlNTeERRVUZEYmtNc1VVRkJVU3hEUVVGRGNVTXNUMEZCVHl4RFFVRkRMRlZCUVVOd1F5eFBRVUZQTEVWQlFVazdVVUZEYUVOclF5eExRVUZMTEVsQlFVbHNReXhQUVVGUExFTkJRVU54UXl4cFFrRkJhVUlzUTBGQlF6dFZRVUZGUXl4WlFVRlpMRVZCUVVWS08xRkJRVXNzUTBGQlJTeERRVUZETzFGQlJUTkVMRWxCUVVsc1F5eFBRVUZQTEVOQlFVTjFReXhWUVVGVkxFbEJRVWwyUXl4UFFVRlBMRU5CUVVOM1F5eFRRVUZUTEVWQlFVVXNSVUZCUlR0VlFVTTNRM2hETEU5QlFVOHNRMEZCUTNsRExFdEJRVXNzUTBGQlF6ZEdMREJDUVVGakxFTkJRVU13Uml4WlFVRlpMRVZCUVVVN1dVRkJSVUVzV1VGQldTeEZRVUZGU2p0VlFVRkxMRU5CUVVVc1EwRkJRenM3VFVGRmRrVXNRMEZCUXl4RFFVRkRPMGxCUTBvN1NVRkZRVHM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGTFFTeHZRa0ZCVVR0TlFVTk9MRWxCUVVsUkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTm9RaXhIUVVGSExFZEJRVWNzUTBGQlF6dE5RVU42UWl4SlFVRkpaMElzVFVGQlRTeExRVUZMTEVsQlFVa3NRMEZCUTJoQ0xFZEJRVWNzUlVGQlJUdFJRVU4yUWl4SlFVRkpMRU5CUVVOQkxFZEJRVWNzUjBGQlJ5eERRVUZETzA5QlEySXNUVUZCVFR0UlFVTk1MRWxCUVVrc1EwRkJRMEVzUjBGQlJ5eEhRVUZIWjBJc1RVRkJUVHM3VFVGSGJrSXNUMEZCVHl4SlFVRkpMRU5CUVVOb1FpeEhRVUZITEVOQlFVTnBRaXhSUVVGUkxFVkJRVVU3U1VGRE5VSTdTVUZGUVRzN096czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkxRU3g1UWtGQlowSjJRaXhMUVVGaE8wMUJRek5DTEVsQlFVbDNRaXhWUVVGVkxFZEJRVWNzU1VGQlNTeERRVUZETjBNc1VVRkJVU3hEUVVGRE9FTXNTVUZCU1N4RFFVTnFReXhWUVVGRFF5eERRVUZETzFGQlFVRXNUMEZCUzBFc1EwRkJReXhEUVVGRE1VSXNTMEZCU3l4TFFVRkxRU3hMUVVGTExFdEJRVXN3UWl4RFFVRkRMRU5CUVVOT0xGTkJRVk1zUlVGQlJTeEpRVUZKVFN4RFFVRkRMRU5CUVVORExGVkJRVlVzUlVGQlJTeERRVUZETzAxQlFVRXNSVUZET1VRN1RVRkRSQ3hKUVVGSlNDeFZRVUZWTEVWQlFVVTdVVUZEWkN4SlFVRkpMRU5CUVVObUxFZEJRVWNzUTBGQlF5eFhRVUZYTEhORFFVRTRRbFFzUzBGQlN5eFJRVUZKTzFGQlF6TkVkMElzVlVGQlZTeERRVUZETTBNc1YwRkJWeXhGUVVGRk96dEpRVVUxUWp0SlFVVkJPenM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlQwRXNhVUpCUVZGRUxFOUJRWGRDTzAxQlF6bENMRWxCUVVrc1EwRkJRMFFzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUTBFc1VVRkJVU3hEUVVGRGFVUXNUVUZCVFN4RFFVTnNReXhWUVVGRFJpeERRVUZyUWp0UlFVRkJMRTlCUVV0QkxFTkJRVU1zUTBGQlEwY3NVVUZCVVN4RlFVRkZMRXRCUVV0cVJDeFBRVUZQTEVOQlFVTnBSQ3hSUVVGUkxFVkJRVVU3VFVGQlFTeEZRVU0xUkR0SlFVTklPMGxCUlVFN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJTMUVzZDBKQlFWazdUVUZEYkVJc1QwRkJUeXhKUVVGSkxFTkJRVU5ETEdGQlFXRXNRMEZEZGtJc1NVRkJTU3hEUVVGRGVFY3NVVUZCVVN4RlFVTmllVWNzVFVGQlRTeERRVUZEUXl4TlFVRk5MRU5CUVVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUTBGQlF5OUdMRTFCUVUwc1JVRkJSVHRSUVVGRlowY3NSMEZCUnl4RlFVRkZla2M3VFVGQlJ5eERRVUZGTEVOQlFVTXNRMEZETjBNN1NVRkRTRHRKUVVWQk8wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlExRXNkMEpCUVdVd1J5eFZRVUY1UWp0TlFVRkJPMDFCUXpsRExFbEJRVWtzUTBGQlEyaEdMRTFCUVUwc1EwRkJRMmRHTEZWQlFWVXNRMEZCUXpORExFbEJRVWtzUlVGQlJTeFZRVUZEUkN4SFFVRnZRaXhGUVVGSk8xRkJRM0JFTEVsQlFVMVZMRXRCUVVzc1IwRkJNRUpXTEVkQlFVY3NRMEZCYkVOVkxFdEJRVXM3VlVGQlJUbENMRXRCUVVzc1IwRkJiVUp2UWl4SFFVRkhMRU5CUVROQ2NFSXNTMEZCU3p0VlFVRkZjRUlzVDBGQlR5eEhRVUZWZDBNc1IwRkJSeXhEUVVGd1FuaERMRTlCUVU4N1ZVRkJSWGRFTEVkQlFVY3NSMEZCUzJoQ0xFZEJRVWNzUTBGQldHZENMRWRCUVVjN1VVRkZhRU1zU1VGRFIwRXNSMEZCUnl4SlFVRkpRU3hIUVVGSExFdEJRVXNzVFVGQlNTeERRVUZETmtJc2JVSkJRVzFDTEVsQlEzaERha1VzUzBGQlN5eE5RVUZMY0VJc1QwRkJUeXhoUVVGUVFTeFBRVUZQTEhWQ1FVRlFRU3hQUVVGUExFTkJRVVZ6Uml4SlFVRkpMRWRCUTNaQ08xVkJRMEVzVFVGQlNTeERRVUZEUkN4dFFrRkJiVUlzUjBGQlJ5eEpRVUZKT3p0UlFVZHFReXhOUVVGSkxFTkJRVU14UWl4SFFVRkhMRU5CUTA0c1UwRkJVeXhaUVVOT00wUXNUMEZCVHl4RFFVRkRhVU1zVFVGQlRTeEpRVUZKTEVWQlFVVXNZMEZCU1dsQ0xFdEJRVXNzWTBGQlNUbENMRXRCUVVzc1kwRkRkRU52UXl4SFFVRkhMRWxCUVVrc1IwRkJSeXhIUVVGSFFTeEhRVUZITEVkQlFVY3NSMEZCUnl4SlFVRkxMRVZCUXpsQ0xFZEJRMEY0UkN4UFFVRlBMRU5CUTFJN1VVRkRSQ3hOUVVGSkxFTkJRVU0yUWl4UlFVRlJMRU5CUTFacFJDeE5RVUZOTEVOQlFVTXNWVUZCUTJoRUxFOUJRWGRDTzFWQlFVRXNUMEZCUzBFc1QwRkJUeXhEUVVGRGVVUXNVMEZCVXl4RFFVRkRja01zUzBGQlN5eERRVUZETzFGQlFVRXNSVUZCUXl4RFFVTTVSR2RDTEU5QlFVOHNRMEZCUXl4VlFVRkRjRU1zVDBGQmQwSTdWVUZCUVN4UFFVTm9RMEVzVDBGQlR5eERRVUZETUVRc1VVRkJVU3hEUVVGRGNFVXNTMEZCU3l4RlFVRkZjRUlzVDBGQlR5eEZRVUZGZDBRc1IwRkJSeXhEUVVGRE8xRkJRVUVzUlVGRGRFTTdVVUZEU0N4TlFVRkpMRU5CUVVOcFF5eHZRa0ZCYjBJc1EwRkJRM2hITEU5QlFVOHNRMEZCUTJsR0xFOUJRVThzUTBGQlF5eFZRVUZEYWtVc1VVRkJVVHRWUVVGQkxFOUJRVXRCTEZGQlFWRXNRMEZCUTNWRExFZEJRVWNzUTBGQlF6dFJRVUZCTEVWQlFVTTdUVUZEZUVVc1EwRkJReXhEUVVGRE8wbEJRMG83U1VGRlFUdEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVTlJMSFZDUVVGWE8wMUJRVUU3VFVGRGFrSXNTVUZCU1N4RFFVRkRiVUlzUjBGQlJ5eERRVUZETEZkQlFWY3NlVUpCUVd0Q0xFbEJRVWtzUTBGQlF6bERMRmxCUVZrc1JVRkJSU3hGUVVGSE8wMUJRelZFTEVsQlFVa3NRMEZCUXpaRkxHZENRVUZuUWl4RlFVRkZPMDFCUTNaQ0xFbEJRVWtzUTBGQlEyNUdMR05CUVdNc1EwRkJRM0ZDTEV0QlFVc3NSVUZCUlR0TlFVTXpRaXhKUVVGSkxFTkJRVU5HTEdOQlFXTXNTVUZCU1VNc1lVRkJZU3hEUVVGRExFbEJRVWtzUTBGQlEwUXNZMEZCWXl4RFFVRkRPMDFCUTNwRUxFbEJRVWtzUTBGQlEwRXNZMEZCWXl4SFFVRkhhVVVzVjBGQlZ5eERRVU12UWp0UlFVRkJMRTlCUVUwc1RVRkJTU3hEUVVGRFF5eGpRVUZqTEVWQlFVVTdUVUZCUVN4SFFVTXpRaXhKUVVGSkxFTkJRVU53Unl4dFFrRkJiVUlzUTBGRGVrSTdUVUZEUkN4SlFVRkpMRU5CUVVOcFJ5eHZRa0ZCYjBJc1EwRkJRek5ITEVsQlFVa3NRMEZCUTI5R0xFOUJRVThzUTBGQlF5eFZRVUZEYWtVc1VVRkJVVHRSUVVGQkxFOUJRVXRCTEZGQlFWRXNSVUZCUlR0TlFVRkJMRVZCUVVVN1NVRkRia1U3U1VGRlFUdEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVTlJMSE5DUVVGaGJVSXNTMEZCVlR0TlFVTTNRaXhKUVVGSkxFTkJRVU4xUXl4SFFVRkhMRU5CUVVNc1YwRkJWeXhGUVVGRkxFOUJRVThzUlVGQlJYWkRMRXRCUVVzc1EwRkJRenROUVVOeVF5eEpRVUZKTEVOQlFVTjVSU3hwUWtGQmFVSXNSVUZCUlR0TlFVTjRRaXhKUVVGSkxFTkJRVU51UlN4alFVRmpMRWxCUVVsRExHRkJRV0VzUTBGQlF5eEpRVUZKTEVOQlFVTkVMR05CUVdNc1EwRkJRenROUVVONlJDeEpRVUZKTEVOQlFVTnVRaXhqUVVGakxFTkJRVU4xUml4bFFVRmxMRVZCUVVVN1RVRkRja01zU1VGQlNTeERRVUZEVEN4dlFrRkJiMElzUTBGQlF6RkhMRXRCUVVzc1EwRkJRMjFHTEU5QlFVOHNRMEZCUXl4VlFVRkRha1VzVVVGQlVUdFJRVUZCTEU5QlFVdEJMRkZCUVZFc1EwRkJRMjFDTEV0QlFVc3NRMEZCUXp0TlFVRkJMRVZCUVVNN1NVRkRlRVU3U1VGRlFUdEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVTlJMSE5DUVVGaGNFTXNTMEZCYVVJN1RVRkRjRU1zU1VGQlNTeERRVUZETWtVc1IwRkJSeXhEUVVGRExGZEJRVmNzUlVGQlJUTkZMRXRCUVVzc1EwRkJRME1zVDBGQlR5eERRVUZETzAxQlEzQkRMRWxCUVVrc1EwRkJRelJITEdsQ1FVRnBRaXhGUVVGRk8wMUJRM2hDTEVsQlFVa3NRMEZCUTBvc2IwSkJRVzlDTEVOQlFVTjZSeXhMUVVGTExFTkJRVU5yUml4UFFVRlBMRU5CUVVNc1ZVRkJRMnBGTEZGQlFWRTdVVUZCUVN4UFFVRkxRU3hSUVVGUkxFTkJRVU5xUWl4TFFVRkxMRU5CUVVNN1RVRkJRU3hGUVVGRE8wbEJRM2hGTzBsQlJVRTdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkRVU3cyUWtGQmFVSTdUVUZEZGtJc1NVRkJTU3hEUVVGRE5rTXNVVUZCVVN4RFFVRkRjVU1zVDBGQlR5eERRVUZETEZWQlFVTndReXhQUVVGM1FqdFJRVUZCTEU5QlF6ZERRU3hQUVVGUExFTkJRVU13UkN4UlFVRlJMRU5CUVVNNVJ5d3dRa0ZCWXl4RFFVRkRUU3hMUVVGTExFTkJRVU03VFVGQlFTeEZRVU4yUXp0SlFVTklPMGxCUlVFN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGRFVTeDFRa0ZEVGl0SExFZEJRVmNzUlVGRFdEVkhMRTFCUVdsRE8wMUJSV3BETEVsQlFVazRSaXhOUVVGTkxFTkJRVU5sTEVsQlFVa3NRMEZCUXpkSExFMUJRVTBzUTBGQlF5eERRVUZESzBNc1RVRkJUU3hMUVVGTExFTkJRVU1zUlVGQlJUdFJRVU53UXl4UFFVRlBOa1FzUjBGQlJ6czdUVUZGV2l4SlFVRk5SU3hOUVVGTkxFZEJRVWRHTEVkQlFVY3NRMEZCUTBjc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4SFFVRkhPMDFCUXpGRExFbEJRVTFETEV0QlFVc3NSMEZCUnl4SlFVRkpReXhsUVVGbExFTkJRVU5xU0N4TlFVRk5MRU5CUVVNN1RVRkZla01zYVVKQlFWVTBSeXhIUVVGSExGTkJRVWRGTEUxQlFVMHNVMEZCUjBVc1MwRkJTenRKUVVOb1F6dEpRVVZCTzBWQlFVRTdTVUZCUVR0SlFVRkJMRTlCUTFFc05FSkJRV2RDTzAxQlEzUkNMRWxCUVVrc1NVRkJTU3hEUVVGREwwTXNWMEZCVnl4RlFVRkZMRWxCUVVrc1NVRkJTU3hEUVVGRFZ5eFZRVUZWTEVOQlFVTTNRaXhOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFGQlEzQkVMRWxCUVVrc1EwRkJRelpDTEZWQlFWVXNRMEZCUTBjc1QwRkJUeXhEUVVGRExGVkJRVU5xUlN4UlFVRlJPMVZCUVVFc1QwRkJTMEVzVVVGQlVTeEZRVUZGTzFGQlFVRXNSVUZCUXp0UlFVTnFSQ3hKUVVGSkxFTkJRVU00UkN4VlFVRlZMRWRCUVVjc1JVRkJSVHM3U1VGRmVFSTdTVUZEUVR0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVVOUkxEQkNRVUZqT3p0TlFVTndRaXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZEV0N4WFFVRlhMRVZCUVVVc1JVRkJSVHRSUVVOMlFqczdUVUZGUml4SlFVRkpMRWxCUVVrc1EwRkJRMmxETEcxQ1FVRnRRaXhGUVVGRk8xRkJRelZDTEVsQlFVa3NRMEZCUTBFc2JVSkJRVzFDTEVkQlFVY3NTVUZCU1R0UlFVTXZRaXhKUVVGSkxFTkJRVU14UWl4SFFVRkhMRU5CUTA0c1YwRkJWeXhGUVVOWUxEQkVRVUV3UkN4RFFVTXpSRHRSUVVORUxGVkJRVWtzUTBGQlF5OURMRWxCUVVrc01FTkJRVVUzUWl4TFFVRkxMRU5CUVVOTUxESkNRVUZsTEVWQlFVVXNhMEpCUVd0Q0xFTkJRVU03VVVGRGNrUTdPMDFCUlVZc1NVRkJTU3hEUVVGRE1rY3NiVUpCUVcxQ0xFZEJRVWNzU1VGQlNTeERRVUZEWjBJc1VVRkJVU3hGUVVGRk8wMUJRekZETEVsQlFVa3NRMEZCUXpsRExFbEJRVWtzUTBGQlF6dFJRVU5TVEN4TFFVRkxMRVZCUVVVc1UwRkJVenRSUVVOb1FqbENMRXRCUVVzc1JVRkJSU3hYUVVGWE8xRkJRMnhDY0VJc1QwRkJUeXhGUVVGRkxFVkJRVVU3VVVGRFdIZEVMRWRCUVVjc1JVRkJSU3hKUVVGSkxFTkJRVU0yUWp0UFFVTllMRU5CUVVNN1RVRkRSaXhKUVVGSkxFTkJRVU5wUWl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRGNrTXNWMEZCVnl4RFFVRkRPMGxCUTJoRE8wbEJSVUU3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZEVVN4dFFrRkRUbWhGTEZGQlFXdENMRVZCUTNkRE8wMUJRVUU3VFVGQlFTeEpRVUV4UkhOSExESkdRVUVyUWl4SlFVRkpMRU5CUVVNM1J5eHpRa0ZCYzBJN1RVRkZNVVFzVDBGQlR5eFpRVUZMTzFGQlExWXNTVUZCU1N4TlFVRkpMRU5CUVVNNFJ5eFZRVUZWTEVWQlFVVXNUMEZCVHl4SlFVRkpPMUZCUTJoRGRrY3NVVUZCVVN4RlFVRkZPMUZCUTFZc1RVRkJTU3hEUVVGRGRVY3NWVUZCVlN4SFFVRkhMRWxCUVVrN1VVRkRkRUpETEZWQlFWVXNRMEZCUXl4WlFVRkxPMVZCUTJRc1RVRkJTU3hEUVVGRFJDeFZRVUZWTEVkQlFVY3NTMEZCU3p0UlFVTjZRaXhEUVVGRExFVkJRVVZFTEc5Q1FVRnZRaXhEUVVGRE8xRkJRM2hDTEU5QlFVOHNTMEZCU3p0TlFVTmtMRU5CUVVNN1NVRkRTRHRGUVVGRE8wVkJRVUU3UVVGQlFUdEJRVGxhU0VjaUxDSnVZVzFsY3lJNld5SnViMjl3SWl3aVVtVmhiSFJwYldWRGJHbGxiblFpTENKbGJtUlFiMmx1ZENJc0ltOXdkR2x2Ym5NaUxDSmpiMjV6ZEdGdWRITmZNU0lzSW5kbFluTnZZMnRsZEY4eElpd2lkVzVrWldacGJtVmtJaXdpYzJWeWFXRnNhWHBsY2w4eElpd2liM0JsYmlJc0ltTnNiM05sSWl3aVpYSnliM0lpTENKdFpYTnpZV2RsSWl3aWQyVmljMjlqYTJWMElpd2ljR0Z5WVcxeklpd2lhR1ZoWkdWeWN5SXNJblJwYldWdmRYUWlMQ0pzYjJkblpYSWlMQ0owY21GdWMzQnZjblFpTENKb1pXRnlkR0psWVhSSmJuUmxjblpoYkUxeklpd2laWFpsYm5SelVHVnlVMlZqYjI1a0lpd2laWFpsYm5SelVHVnlVMlZqYjI1a1RHbHRhWFJOY3lJc0lrMWhkR2dpTENKbWJHOXZjaUlzSW5KbFkyOXVibVZqZEVGbWRHVnlUWE1pTENKMGNtbGxjeUlzSW1WdVkyOWtaU0lzSW5CaGVXeHZZV1FpTENKallXeHNZbUZqYXlJc0lrcFRUMDRpTENKemRISnBibWRwWm5raUxDSmtaV052WkdVaUxDSnpaWEpwWVd4cGVtVnlJaXdpWW1sdVpDSXNJbkpsWTI5dWJtVmpkRlJwYldWeUlpd2lkR2x0WlhKZk1TSXNJbDlmWVhkaGFYUmxjaUlzSW1ScGMyTnZibTVsWTNRaUxDSmpiMjV1WldOMElpd2lZMjl1YmlJc0lsOWxibVJRYjJsdWRGVlNUQ0lzSW1KcGJtRnllVlI1Y0dVaUxDSnZibTl3Wlc0aUxDSmZiMjVEYjI1dVQzQmxiaUlzSW05dVpYSnliM0lpTENKZmIyNURiMjV1UlhKeWIzSWlMQ0p2Ym0xbGMzTmhaMlVpTENKbGRtVnVkQ0lzSWw5dmJrTnZibTVOWlhOellXZGxJaXdpYjI1amJHOXpaU0lzSWw5dmJrTnZibTVEYkc5elpTSXNJbU52WkdVaUxDSnlaV0Z6YjI0aUxDSm9aV0Z5ZEdKbFlYUlVhVzFsY2lJc0ltTnNaV0Z5U1c1MFpYSjJZV3dpTENKeVpYTmxkQ0lzSW1Ob1lXNXVaV3h6SWl3aVkyaGhibTVsYkNJc0luVnVjM1ZpYzJOeWFXSmxJaXdpZEdobGJpSXNJbk4wWVhSMWN5SXNJbXhsYm1kMGFDSXNJbEJ5YjIxcGMyVWlMQ0poYkd3aUxDSnRZWEFpTENKMllXeDFaWE1pTENKcmFXNWtJaXdpYlhObklpd2laR0YwWVNJc0luSmxZV1I1VTNSaGRHVWlMQ0pqYjI1dVpXTjBhVzVuSWl3aVEyOXVibVZqZEdsdVp5SXNJazl3Wlc0aUxDSmpiRzl6YVc1bklpd2lRMnh2YzJsdVp5SXNJa05zYjNObFpDSXNJbU52Ym01bFkzUnBiMjVUZEdGMFpTSXNJblJ2Y0dsaklpd2lZMjl1Wm1sbklpd2lhWE5EYjI1dVpXTjBaV1FpTENKamFHRnVJaXdpVW1WaGJIUnBiV1ZEYUdGdWJtVnNYekVpTENKd2RYTm9JaXdpY21WbUlpd2ljbVZ6ZFd4MElpd2ljMlZ1WkNJc0lteHZaeUlzSW1sdVkyeDFaR1Z6SWl3aWFYTlVhSEp2ZEhSc1pXUWlMQ0pmZEdoeWIzUjBiR1VpTENKelpXNWtRblZtWm1WeUlpd2lkRzlyWlc0aUxDSmhZMk5sYzNOVWIydGxiaUlzSW1admNrVmhZMmdpTENKMWNHUmhkR1ZLYjJsdVVHRjViRzloWkNJc0ltRmpZMlZ6YzE5MGIydGxiaUlzSW1wdmFXNWxaRTl1WTJVaUxDSmZhWE5LYjJsdVpXUWlMQ0pmY0hWemFDSXNJbTVsZDFKbFppSXNJblJ2VTNSeWFXNW5JaXdpWkhWd1EyaGhibTVsYkNJc0ltWnBibVFpTENKaklpd2lYMmx6U205cGJtbHVaeUlzSW1acGJIUmxjaUlzSWw5cWIybHVVbVZtSWl3aVgyRndjR1Z1WkZCaGNtRnRjeUlzSWs5aWFtVmpkQ0lzSW1GemMybG5iaUlzSW5aemJpSXNJbkpoZDAxbGMzTmhaMlVpTENKd1pXNWthVzVuU0dWaGNuUmlaV0YwVW1WbUlpd2lkSGx3WlNJc0lsOXBjMDFsYldKbGNpSXNJbDkwY21sbloyVnlJaXdpYzNSaGRHVkRhR0Z1WjJWRFlXeHNZbUZqYTNNaUxDSmZabXgxYzJoVFpXNWtRblZtWm1WeUlpd2ljMlYwU1c1MFpYSjJZV3dpTENKZmMyVnVaRWhsWVhKMFltVmhkQ0lzSWw5MGNtbG5aMlZ5UTJoaGJrVnljbTl5SWl3aWMyTm9aV1IxYkdWVWFXMWxiM1YwSWl3aWRYSnNJaXdpYTJWNWN5SXNJbkJ5WldacGVDSXNJbTFoZEdOb0lpd2ljWFZsY25raUxDSlZVa3hUWldGeVkyaFFZWEpoYlhNaUxDSmZiV0ZyWlZKbFppSXNJbk5sZEVGMWRHZ2lMQ0psZG1WdWRITlFaWEpUWldOdmJtUk1hVzFwZENJc0ltbHVWR2h5YjNSMGJHVWlMQ0p6WlhSVWFXMWxiM1YwSWl3aVpYaHdiM0owY3lKZExDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZVbVZoYkhScGJXVkRiR2xsYm5RdWRITWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHR1ZFd4c1hYMD0iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgVGhpcyBmaWxlIGRyYXdzIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9hc3NldHMvanMvcGhvZW5peC9wcmVzZW5jZS5qc1xuICBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9MSUNFTlNFLm1kXG4qL1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IHZvaWQgMDtcbnZhciBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTKSB7XG4gIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJTWU5DXCJdID0gXCJzeW5jXCI7XG4gIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJKT0lOXCJdID0gXCJqb2luXCI7XG4gIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJMRUFWRVwiXSA9IFwibGVhdmVcIjtcbn0pKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgPSBleHBvcnRzLlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgfHwgKGV4cG9ydHMuUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IHt9KSk7XG52YXIgUmVhbHRpbWVQcmVzZW5jZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgUHJlc2VuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIFJlYWx0aW1lQ2hhbm5lbFxuICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBvcHRpb25zLFxuICAgKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogJ3N0YXRlJywgZGlmZjogJ2RpZmYnfX1gXG4gICAqL1xuICBmdW5jdGlvbiBSZWFsdGltZVByZXNlbmNlKGNoYW5uZWwsIG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFsdGltZVByZXNlbmNlKTtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgIHRoaXMuam9pblJlZiA9IG51bGw7XG4gICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICBvbkpvaW46IGZ1bmN0aW9uIG9uSm9pbigpIHt9LFxuICAgICAgb25MZWF2ZTogZnVuY3Rpb24gb25MZWF2ZSgpIHt9LFxuICAgICAgb25TeW5jOiBmdW5jdGlvbiBvblN5bmMoKSB7fVxuICAgIH07XG4gICAgdmFyIGV2ZW50cyA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZXZlbnRzKSB8fCB7XG4gICAgICBzdGF0ZTogJ3ByZXNlbmNlX3N0YXRlJyxcbiAgICAgIGRpZmY6ICdwcmVzZW5jZV9kaWZmJ1xuICAgIH07XG4gICAgdGhpcy5jaGFubmVsLl9vbihldmVudHMuc3RhdGUsIHt9LCBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgIHZhciBfdGhpcyRjYWxsZXIgPSBfdGhpcy5jYWxsZXIsXG4gICAgICAgIG9uSm9pbiA9IF90aGlzJGNhbGxlci5vbkpvaW4sXG4gICAgICAgIG9uTGVhdmUgPSBfdGhpcyRjYWxsZXIub25MZWF2ZSxcbiAgICAgICAgb25TeW5jID0gX3RoaXMkY2FsbGVyLm9uU3luYztcbiAgICAgIF90aGlzLmpvaW5SZWYgPSBfdGhpcy5jaGFubmVsLl9qb2luUmVmKCk7XG4gICAgICBfdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY1N0YXRlKF90aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgIF90aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICAgIF90aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZihfdGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgICBvblN5bmMoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5kaWZmLCB7fSwgZnVuY3Rpb24gKGRpZmYpIHtcbiAgICAgIHZhciBfdGhpcyRjYWxsZXIyID0gX3RoaXMuY2FsbGVyLFxuICAgICAgICBvbkpvaW4gPSBfdGhpcyRjYWxsZXIyLm9uSm9pbixcbiAgICAgICAgb25MZWF2ZSA9IF90aGlzJGNhbGxlcjIub25MZWF2ZSxcbiAgICAgICAgb25TeW5jID0gX3RoaXMkY2FsbGVyMi5vblN5bmM7XG4gICAgICBpZiAoX3RoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpIHtcbiAgICAgICAgX3RoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYoX3RoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgIG9uU3luYygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub25Kb2luKGZ1bmN0aW9uIChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcykge1xuICAgICAgX3RoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgIGV2ZW50OiAnam9pbicsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBjdXJyZW50UHJlc2VuY2VzOiBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICBuZXdQcmVzZW5jZXM6IG5ld1ByZXNlbmNlc1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5vbkxlYXZlKGZ1bmN0aW9uIChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpIHtcbiAgICAgIF90aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICBldmVudDogJ2xlYXZlJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGN1cnJlbnRQcmVzZW5jZXM6IGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgIGxlZnRQcmVzZW5jZXM6IGxlZnRQcmVzZW5jZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMub25TeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICBldmVudDogJ3N5bmMnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBzeW5jIHRoZSBsaXN0IG9mIHByZXNlbmNlcyBvbiB0aGUgc2VydmVyIHdpdGggdGhlXG4gICAqIGNsaWVudCdzIHN0YXRlLlxuICAgKlxuICAgKiBBbiBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCB0b1xuICAgKiByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAqIGRpc2Nvbm5lY3RzIGFuZCByZWNvbm5lY3RzIHdpdGggdGhlIHNlcnZlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoUmVhbHRpbWVQcmVzZW5jZSwgW3tcbiAgICBrZXk6IFwib25Kb2luXCIsXG4gICAgdmFsdWU6IC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBvbkpvaW4oY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGVyLm9uSm9pbiA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25MZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxlYXZlKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxlci5vbkxlYXZlID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgfSwge1xuICAgIGtleTogXCJvblN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TeW5jKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcImluUGVuZGluZ1N5bmNTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpblBlbmRpbmdTeW5jU3RhdGUoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5fam9pblJlZigpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInN5bmNTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChjdXJyZW50U3RhdGUpO1xuICAgICAgdmFyIHRyYW5zZm9ybWVkU3RhdGUgPSB0aGlzLnRyYW5zZm9ybVN0YXRlKG5ld1N0YXRlKTtcbiAgICAgIHZhciBqb2lucyA9IHt9O1xuICAgICAgdmFyIGxlYXZlcyA9IHt9O1xuICAgICAgdGhpcy5tYXAoc3RhdGUsIGZ1bmN0aW9uIChrZXksIHByZXNlbmNlcykge1xuICAgICAgICBpZiAoIXRyYW5zZm9ybWVkU3RhdGVba2V5XSkge1xuICAgICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwKHRyYW5zZm9ybWVkU3RhdGUsIGZ1bmN0aW9uIChrZXksIG5ld1ByZXNlbmNlcykge1xuICAgICAgICB2YXIgY3VycmVudFByZXNlbmNlcyA9IHN0YXRlW2tleV07XG4gICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzKSB7XG4gICAgICAgICAgdmFyIG5ld1ByZXNlbmNlUmVmcyA9IG5ld1ByZXNlbmNlcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBtLnByZXNlbmNlX3JlZjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgY3VyUHJlc2VuY2VSZWZzID0gY3VycmVudFByZXNlbmNlcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBtLnByZXNlbmNlX3JlZjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgam9pbmVkUHJlc2VuY2VzID0gbmV3UHJlc2VuY2VzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1clByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGxlZnRQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1ByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGpvaW5lZFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBqb2luc1trZXldID0gam9pbmVkUHJlc2VuY2VzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVmdFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZWF2ZXNba2V5XSA9IGxlZnRQcmVzZW5jZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZXM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHtcbiAgICAgICAgam9pbnM6IGpvaW5zLFxuICAgICAgICBsZWF2ZXM6IGxlYXZlc1xuICAgICAgfSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZSBldmVudHMgZnJvbSB0aGVcbiAgICAgKiBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLlxuICAgICAqXG4gICAgICogTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYCBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZFxuICAgICAqIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGFcbiAgICAgKiBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzeW5jRGlmZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBfam9pbnMkbGVhdmVzID0ge1xuICAgICAgICAgIGpvaW5zOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYuam9pbnMpLFxuICAgICAgICAgIGxlYXZlczogdGhpcy50cmFuc2Zvcm1TdGF0ZShkaWZmLmxlYXZlcylcbiAgICAgICAgfSxcbiAgICAgICAgam9pbnMgPSBfam9pbnMkbGVhdmVzLmpvaW5zLFxuICAgICAgICBsZWF2ZXMgPSBfam9pbnMkbGVhdmVzLmxlYXZlcztcbiAgICAgIGlmICghb25Kb2luKSB7XG4gICAgICAgIG9uSm9pbiA9IGZ1bmN0aW9uIG9uSm9pbigpIHt9O1xuICAgICAgfVxuICAgICAgaWYgKCFvbkxlYXZlKSB7XG4gICAgICAgIG9uTGVhdmUgPSBmdW5jdGlvbiBvbkxlYXZlKCkge307XG4gICAgICB9XG4gICAgICB0aGlzLm1hcChqb2lucywgZnVuY3Rpb24gKGtleSwgbmV3UHJlc2VuY2VzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGN1cnJlbnRQcmVzZW5jZXMgPSAoX2EgPSBzdGF0ZVtrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgc3RhdGVba2V5XSA9IF90aGlzMi5jbG9uZURlZXAobmV3UHJlc2VuY2VzKTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBfc3RhdGUka2V5O1xuICAgICAgICAgIHZhciBqb2luZWRQcmVzZW5jZVJlZnMgPSBzdGF0ZVtrZXldLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ucHJlc2VuY2VfcmVmO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjdXJQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIGpvaW5lZFByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgKF9zdGF0ZSRrZXkgPSBzdGF0ZVtrZXldKS51bnNoaWZ0LmFwcGx5KF9zdGF0ZSRrZXksIF90b0NvbnN1bWFibGVBcnJheShjdXJQcmVzZW5jZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hcChsZWF2ZXMsIGZ1bmN0aW9uIChrZXksIGxlZnRQcmVzZW5jZXMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRQcmVzZW5jZXMgPSBzdGF0ZVtrZXldO1xuICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZXMpIHJldHVybjtcbiAgICAgICAgdmFyIHByZXNlbmNlUmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5wcmVzZW5jZV9yZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50UHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gcHJlc2VuY2VSZWZzVG9SZW1vdmUuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGVba2V5XSA9IGN1cnJlbnRQcmVzZW5jZXM7XG4gICAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBsZWZ0UHJlc2VuY2VzKTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMubGVuZ3RoID09PSAwKSBkZWxldGUgc3RhdGVba2V5XTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChvYmosIGZ1bmMpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBmdW5jKGtleSwgb2JqW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSAnbWV0YXMnIGtleVxuICAgICAqIENoYW5nZSAncGh4X3JlZicgdG8gJ3ByZXNlbmNlX3JlZidcbiAgICAgKiBSZW1vdmUgJ3BoeF9yZWYnIGFuZCAncGh4X3JlZl9wcmV2J1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm5zIHtcbiAgICAgKiAgYWJjMTIzOiBbXG4gICAgICogICAgeyBwcmVzZW5jZV9yZWY6ICcyJywgdXNlcl9pZDogMSB9LFxuICAgICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgICAqICBdXG4gICAgICogfVxuICAgICAqIFJlYWx0aW1lUHJlc2VuY2UudHJhbnNmb3JtU3RhdGUoe1xuICAgICAqICBhYmMxMjM6IHtcbiAgICAgKiAgICBtZXRhczogW1xuICAgICAqICAgICAgeyBwaHhfcmVmOiAnMicsIHBoeF9yZWZfcHJldjogJzEnIHVzZXJfaWQ6IDEgfSxcbiAgICAgKiAgICAgIHsgcGh4X3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICAgKiAgICBdXG4gICAgICogIH1cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5jbG9uZURlZXAoc3RhdGUpO1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0YXRlKS5yZWR1Y2UoZnVuY3Rpb24gKG5ld1N0YXRlLCBrZXkpIHtcbiAgICAgICAgdmFyIHByZXNlbmNlcyA9IHN0YXRlW2tleV07XG4gICAgICAgIGlmICgnbWV0YXMnIGluIHByZXNlbmNlcykge1xuICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXMubWV0YXMubWFwKGZ1bmN0aW9uIChwcmVzZW5jZSkge1xuICAgICAgICAgICAgcHJlc2VuY2VbJ3ByZXNlbmNlX3JlZiddID0gcHJlc2VuY2VbJ3BoeF9yZWYnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcmVzZW5jZVsncGh4X3JlZiddO1xuICAgICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmX3ByZXYnXTtcbiAgICAgICAgICAgIHJldHVybiBwcmVzZW5jZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gcHJlc2VuY2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsb25lRGVlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZURlZXAob2JqKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlYWx0aW1lUHJlc2VuY2U7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJlYWx0aW1lUHJlc2VuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFUczdPenRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUczdPenM3UVVGcFEwRXNTVUZCV1VFc0swSkJTVmc3UVVGS1JDeFhRVUZaUVN3clFrRkJLMEk3UlVGRGVrTkJMR2RFUVVGaE8wVkJRMkpCTEdkRVFVRmhPMFZCUTJKQkxHdEVRVUZsTzBGQlEycENMRU5CUVVNc1JVRktWMEVzSzBKQlFTdENMRWRCUVM5Q1F5eDFRMEZCSzBJc1MwRkJMMEpCTEhWRFFVRXJRanRCUVVreFF5eEpRWGRDYjBKRExHZENRVUZuUWp0RlFXTnVRenM3T3pzN096dEZRVTlCTERCQ1FVRnRRa01zVDBGQmQwSXNSVUZCUlVNc1NVRkJiVUk3U1VGQlFUdEpRVUZCTzBsQlFUZERMRmxCUVU4c1IwRkJVRVFzVDBGQlR6dEpRWEJDTVVJc1ZVRkJTeXhIUVVFd1FpeEZRVUZGTzBsQlEycERMR2xDUVVGWkxFZEJRWE5DTEVWQlFVVTdTVUZEY0VNc1dVRkJUeXhIUVVGclFpeEpRVUZKTzBsQlF6ZENMRmRCUVUwc1IwRkpSanROUVVOR1JTeE5RVUZOTEVWQlFVVXNhMEpCUVVzc1EwRkJSU3hEUVVGRE8wMUJRMmhDUXl4UFFVRlBMRVZCUVVVc2JVSkJRVXNzUTBGQlJTeERRVUZETzAxQlEycENReXhOUVVGTkxFVkJRVVVzYTBKQlFVc3NRMEZCUlR0TFFVTm9RanRKUVZWRExFbEJRVTFETEUxQlFVMHNSMEZCUnl4TFFVRkpMR0ZCUVVwS0xFbEJRVWtzZFVKQlFVcEJMRWxCUVVrc1EwRkJSVWtzVFVGQlRTeExRVUZKTzAxQlF6ZENReXhMUVVGTExFVkJRVVVzWjBKQlFXZENPMDFCUTNaQ1F5eEpRVUZKTEVWQlFVVTdTMEZEVUR0SlFVVkVMRWxCUVVrc1EwRkJRMUFzVDBGQlR5eERRVUZEVVN4SFFVRkhMRU5CUVVOSUxFMUJRVTBzUTBGQlEwTXNTMEZCU3l4RlFVRkZMRVZCUVVVc1JVRkJSU3hWUVVGRFJ5eFJRVUV3UWl4RlFVRkpPMDFCUTJoRkxHMUNRVUZ2UXl4TFFVRkpMRU5CUVVORExFMUJRVTA3VVVGQmRrTlNMRTFCUVUwc1owSkJRVTVCTEUxQlFVMDdVVUZCUlVNc1QwRkJUeXhuUWtGQlVFRXNUMEZCVHp0UlFVRkZReXhOUVVGTkxHZENRVUZPUVN4TlFVRk5PMDFCUlM5Q0xFdEJRVWtzUTBGQlEwOHNUMEZCVHl4SFFVRkhMRXRCUVVrc1EwRkJRMWdzVDBGQlR5eERRVUZEV1N4UlFVRlJMRVZCUVVVN1RVRkZkRU1zUzBGQlNTeERRVUZEVGl4TFFVRkxMRWRCUVVkUUxHZENRVUZuUWl4RFFVRkRZeXhUUVVGVExFTkJRM0pETEV0QlFVa3NRMEZCUTFBc1MwRkJTeXhGUVVOV1J5eFJRVUZSTEVWQlExSlFMRTFCUVUwc1JVRkRUa01zVDBGQlR5eERRVU5TTzAxQlJVUXNTMEZCU1N4RFFVRkRWeXhaUVVGWkxFTkJRVU5ETEU5QlFVOHNRMEZCUXl4VlFVRkRVaXhKUVVGSkxFVkJRVWs3VVVGRGFrTXNTMEZCU1N4RFFVRkRSQ3hMUVVGTExFZEJRVWRRTEdkQ1FVRm5RaXhEUVVGRGFVSXNVVUZCVVN4RFFVTndReXhMUVVGSkxFTkJRVU5XTEV0QlFVc3NSVUZEVmtNc1NVRkJTU3hGUVVOS1RDeE5RVUZOTEVWQlEwNURMRTlCUVU4c1EwRkRVanROUVVOSUxFTkJRVU1zUTBGQlF6dE5RVVZHTEV0QlFVa3NRMEZCUTFjc1dVRkJXU3hIUVVGSExFVkJRVVU3VFVGRmRFSldMRTFCUVUwc1JVRkJSVHRKUVVOV0xFTkJRVU1zUTBGQlF6dEpRVVZHTEVsQlFVa3NRMEZCUTBvc1QwRkJUeXhEUVVGRFVTeEhRVUZITEVOQlFVTklMRTFCUVUwc1EwRkJRMFVzU1VGQlNTeEZRVUZGTEVWQlFVVXNSVUZCUlN4VlFVRkRRU3hKUVVGeFFpeEZRVUZKTzAxQlF6RkVMRzlDUVVGdlF5eExRVUZKTEVOQlFVTkhMRTFCUVUwN1VVRkJka05TTEUxQlFVMHNhVUpCUVU1QkxFMUJRVTA3VVVGQlJVTXNUMEZCVHl4cFFrRkJVRUVzVDBGQlR6dFJRVUZGUXl4TlFVRk5MR2xDUVVGT1FTeE5RVUZOTzAxQlJTOUNMRWxCUVVrc1MwRkJTU3hEUVVGRFlTeHJRa0ZCYTBJc1JVRkJSU3hGUVVGRk8xRkJRemRDTEV0QlFVa3NRMEZCUTBnc1dVRkJXU3hEUVVGRFNTeEpRVUZKTEVOQlFVTllMRWxCUVVrc1EwRkJRenRQUVVNM1FpeE5RVUZOTzFGQlEwd3NTMEZCU1N4RFFVRkRSQ3hMUVVGTExFZEJRVWRRTEdkQ1FVRm5RaXhEUVVGRGFVSXNVVUZCVVN4RFFVTndReXhMUVVGSkxFTkJRVU5XTEV0QlFVc3NSVUZEVmtNc1NVRkJTU3hGUVVOS1RDeE5RVUZOTEVWQlEwNURMRTlCUVU4c1EwRkRVanRSUVVWRVF5eE5RVUZOTEVWQlFVVTdPMGxCUlZvc1EwRkJReXhEUVVGRE8wbEJSVVlzU1VGQlNTeERRVUZEUml4TlFVRk5MRU5CUVVNc1ZVRkJRMmxDTEVkQlFVY3NSVUZCUlVNc1owSkJRV2RDTEVWQlFVVkRMRmxCUVZrc1JVRkJTVHROUVVOc1JDeExRVUZKTEVOQlFVTnlRaXhQUVVGUExFTkJRVU56UWl4UlFVRlJMRU5CUVVNc1ZVRkJWU3hGUVVGRk8xRkJRMmhEUXl4TFFVRkxMRVZCUVVVc1RVRkJUVHRSUVVOaVNpeEhRVUZITEVWQlFVaEJMRWRCUVVjN1VVRkRTRU1zWjBKQlFXZENMRVZCUVdoQ1FTeG5Ra0ZCWjBJN1VVRkRhRUpETEZsQlFWa3NSVUZCV2tFN1QwRkRSQ3hEUVVGRE8wbEJRMG9zUTBGQlF5eERRVUZETzBsQlJVWXNTVUZCU1N4RFFVRkRiRUlzVDBGQlR5eERRVUZETEZWQlFVTm5RaXhIUVVGSExFVkJRVVZETEdkQ1FVRm5RaXhGUVVGRlNTeGhRVUZoTEVWQlFVazdUVUZEY0VRc1MwRkJTU3hEUVVGRGVFSXNUMEZCVHl4RFFVRkRjMElzVVVGQlVTeERRVUZETEZWQlFWVXNSVUZCUlR0UlFVTm9RME1zUzBGQlN5eEZRVUZGTEU5QlFVODdVVUZEWkVvc1IwRkJSeXhGUVVGSVFTeEhRVUZITzFGQlEwaERMR2RDUVVGblFpeEZRVUZvUWtFc1owSkJRV2RDTzFGQlEyaENTU3hoUVVGaExFVkJRV0pCTzA5QlEwUXNRMEZCUXp0SlFVTktMRU5CUVVNc1EwRkJRenRKUVVWR0xFbEJRVWtzUTBGQlEzQkNMRTFCUVUwc1EwRkJReXhaUVVGTE8wMUJRMllzUzBGQlNTeERRVUZEU2l4UFFVRlBMRU5CUVVOelFpeFJRVUZSTEVOQlFVTXNWVUZCVlN4RlFVRkZPMUZCUVVWRExFdEJRVXNzUlVGQlJUdE5RVUZOTEVOQlFVVXNRMEZCUXp0SlFVTjBSQ3hEUVVGRExFTkJRVU03UlVGRFNqdEZRVVZCT3pzN096czdPenM3TzBWQlFVRTdTVUZCUVR0SlFVRkJMRTlCTmt4Qk8wbEJRMUVzWjBKQlFVOUZMRkZCUVdkRE8wMUJRemRETEVsQlFVa3NRMEZCUTJZc1RVRkJUU3hEUVVGRFVpeE5RVUZOTEVkQlFVZDFRaXhSUVVGUk8wbEJReTlDTzBsQlJVRTdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkRVU3hwUWtGQlVVRXNVVUZCYVVNN1RVRkRMME1zU1VGQlNTeERRVUZEWml4TlFVRk5MRU5CUVVOUUxFOUJRVThzUjBGQlIzTkNMRkZCUVZFN1NVRkRhRU03U1VGRlFUdEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVTlJMR2RDUVVGUFFTeFJRVUZ2UWp0TlFVTnFReXhKUVVGSkxFTkJRVU5tTEUxQlFVMHNRMEZCUTA0c1RVRkJUU3hIUVVGSGNVSXNVVUZCVVR0SlFVTXZRanRKUVVWQk8wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlExRXNPRUpCUVd0Q08wMUJRM2hDTEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVOa0xFOUJRVThzU1VGQlNTeEpRVUZKTEVOQlFVTkJMRTlCUVU4c1MwRkJTeXhKUVVGSkxFTkJRVU5ZTEU5QlFVOHNRMEZCUTFrc1VVRkJVU3hGUVVGRk8wbEJRMnhGTzBWQlFVTTdTVUZCUVR0SlFVRkJMRTlCY2sxUExHMUNRVU5PWXl4WlFVRnRReXhGUVVOdVEycENMRkZCUVd0RUxFVkJRMnhFVUN4TlFVRTRRaXhGUVVNNVFrTXNUMEZCWjBNN1RVRkZhRU1zU1VGQlRVY3NTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkJRM0ZDTEZOQlFWTXNRMEZCUTBRc1dVRkJXU3hEUVVGRE8wMUJRekZETEVsQlFVMUZMR2RDUVVGblFpeEhRVUZITEVsQlFVa3NRMEZCUTBNc1kwRkJZeXhEUVVGRGNFSXNVVUZCVVN4RFFVRkRPMDFCUTNSRUxFbEJRVTF4UWl4TFFVRkxMRWRCUVRCQ0xFVkJRVVU3VFVGRGRrTXNTVUZCVFVNc1RVRkJUU3hIUVVFd1FpeEZRVUZGTzAxQlJYaERMRWxCUVVrc1EwRkJRME1zUjBGQlJ5eERRVUZETVVJc1MwRkJTeXhGUVVGRkxGVkJRVU5oTEVkQlFWY3NSVUZCUldNc1UwRkJjVUlzUlVGQlNUdFJRVU55UkN4SlFVRkpMRU5CUVVOTUxHZENRVUZuUWl4RFFVRkRWQ3hIUVVGSExFTkJRVU1zUlVGQlJUdFZRVU14UWxrc1RVRkJUU3hEUVVGRFdpeEhRVUZITEVOQlFVTXNSMEZCUjJNc1UwRkJVenM3VFVGRk0wSXNRMEZCUXl4RFFVRkRPMDFCUlVZc1NVRkJTU3hEUVVGRFJDeEhRVUZITEVOQlFVTktMR2RDUVVGblFpeEZRVUZGTEZWQlFVTlVMRWRCUVVjc1JVRkJSVVVzV1VGQmQwSXNSVUZCU1R0UlFVTXpSQ3hKUVVGTlJDeG5Ra0ZCWjBJc1IwRkJaV1FzUzBGQlN5eERRVUZEWVN4SFFVRkhMRU5CUVVNN1VVRkZMME1zU1VGQlNVTXNaMEpCUVdkQ0xFVkJRVVU3VlVGRGNFSXNTVUZCVFdNc1pVRkJaU3hIUVVGSFlpeFpRVUZaTEVOQlFVTlhMRWRCUVVjc1EwRkRkRU1zVlVGQlEwY3NRMEZCVnp0WlFVRkJMRTlCUVV0QkxFTkJRVU1zUTBGQlEwTXNXVUZCV1R0VlFVRkJMRVZCUTJoRE8xVkJRMFFzU1VGQlRVTXNaVUZCWlN4SFFVRkhha0lzWjBKQlFXZENMRU5CUVVOWkxFZEJRVWNzUTBGRE1VTXNWVUZCUTBjc1EwRkJWenRaUVVGQkxFOUJRVXRCTEVOQlFVTXNRMEZCUTBNc1dVRkJXVHRWUVVGQkxFVkJRMmhETzFWQlEwUXNTVUZCVFVVc1pVRkJaU3hIUVVGbGFrSXNXVUZCV1N4RFFVRkRhMElzVFVGQlRTeERRVU55UkN4VlFVRkRTaXhEUVVGWE8xbEJRVUVzVDBGQlMwVXNaVUZCWlN4RFFVRkRSeXhQUVVGUExFTkJRVU5NTEVOQlFVTXNRMEZCUTBNc1dVRkJXU3hEUVVGRExFZEJRVWNzUTBGQlF6dFZRVUZCTEVWQlF6ZEVPMVZCUTBRc1NVRkJUVm9zWVVGQllTeEhRVUZsU2l4blFrRkJaMElzUTBGQlEyMUNMRTFCUVUwc1EwRkRka1FzVlVGQlEwb3NRMEZCVnp0WlFVRkJMRTlCUVV0RUxHVkJRV1VzUTBGQlEwMHNUMEZCVHl4RFFVRkRUQ3hEUVVGRExFTkJRVU5ETEZsQlFWa3NRMEZCUXl4SFFVRkhMRU5CUVVNN1ZVRkJRU3hGUVVNM1JEdFZRVVZFTEVsQlFVbEZMR1ZCUVdVc1EwRkJRMGNzVFVGQlRTeEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTTVRbGdzUzBGQlN5eERRVUZEV0N4SFFVRkhMRU5CUVVNc1IwRkJSMjFDTEdWQlFXVTdPMVZCUnpsQ0xFbEJRVWxrTEdGQlFXRXNRMEZCUTJsQ0xFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZETlVKV0xFMUJRVTBzUTBGQlExb3NSMEZCUnl4RFFVRkRMRWRCUVVkTExHRkJRV0U3TzFOQlJUbENMRTFCUVUwN1ZVRkRURTBzUzBGQlN5eERRVUZEV0N4SFFVRkhMRU5CUVVNc1IwRkJSMFVzV1VGQldUczdUVUZGTjBJc1EwRkJReXhEUVVGRE8wMUJSVVlzVDBGQlR5eEpRVUZKTEVOQlFVTk1MRkZCUVZFc1EwRkJRMVlzUzBGQlN5eEZRVUZGTzFGQlFVVjNRaXhMUVVGTExFVkJRVXhCTEV0QlFVczdVVUZCUlVNc1RVRkJUU3hGUVVGT1FUdE5RVUZOTEVOQlFVVXNSVUZCUlRkQ0xFMUJRVTBzUlVGQlJVTXNUMEZCVHl4RFFVRkRPMGxCUTJwRk8wbEJSVUU3T3pzN096czdPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNUMEZWVVN4clFrRkRUa2NzUzBGQk5FSXNSVUZETlVKRExFbEJRVzlETEVWQlEzQkRUQ3hOUVVFNFFpeEZRVU01UWtNc1QwRkJaME03VFVGQlFUdE5RVVZvUXl4dlFrRkJNRUk3VlVGRGVFSXlRaXhMUVVGTExFVkJRVVVzU1VGQlNTeERRVUZEUkN4alFVRmpMRU5CUVVOMFFpeEpRVUZKTEVOQlFVTjFRaXhMUVVGTExFTkJRVU03VlVGRGRFTkRMRTFCUVUwc1JVRkJSU3hKUVVGSkxFTkJRVU5HTEdOQlFXTXNRMEZCUTNSQ0xFbEJRVWtzUTBGQlEzZENMRTFCUVUwN1UwRkRlRU03VVVGSVQwUXNTMEZCU3l4cFFrRkJURUVzUzBGQlN6dFJRVUZGUXl4TlFVRk5MR2xDUVVGT1FTeE5RVUZOTzAxQlMzSkNMRWxCUVVrc1EwRkJRemRDTEUxQlFVMHNSVUZCUlR0UlFVTllRU3hOUVVGTkxFZEJRVWNzYTBKQlFVc3NRMEZCUlN4RFFVRkRPenROUVVkdVFpeEpRVUZKTEVOQlFVTkRMRTlCUVU4c1JVRkJSVHRSUVVOYVFTeFBRVUZQTEVkQlFVY3NiVUpCUVVzc1EwRkJSU3hEUVVGRE96dE5RVWR3UWl4SlFVRkpMRU5CUVVNMlFpeEhRVUZITEVOQlFVTkdMRXRCUVVzc1JVRkJSU3hWUVVGRFdDeEhRVUZITEVWQlFVVkZMRmxCUVhkQ0xFVkJRVWs3TzFGQlEyaEVMRWxCUVUxRUxHZENRVUZuUWl4SFFVRmxMRmRCUVVzc1EwRkJRMFFzUjBGQlJ5eERRVUZETEcxRFFVRkpMRVZCUVVVN1VVRkRja1JpTEV0QlFVc3NRMEZCUTJFc1IwRkJSeXhEUVVGRExFZEJRVWNzVFVGQlNTeERRVUZEVVN4VFFVRlRMRU5CUVVOT0xGbEJRVmtzUTBGQlF6dFJRVVY2UXl4SlFVRkpSQ3huUWtGQlowSXNRMEZCUTNGQ0xFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVTdWVUZCUVR0VlFVTXZRaXhKUVVGTlF5eHJRa0ZCYTBJc1IwRkJSM0JETEV0QlFVc3NRMEZCUTJFc1IwRkJSeXhEUVVGRExFTkJRVU5oTEVkQlFVY3NRMEZEZGtNc1ZVRkJRMGNzUTBGQlZ6dFpRVUZCTEU5QlFVdEJMRU5CUVVNc1EwRkJRME1zV1VGQldUdFZRVUZCTEVWQlEyaERPMVZCUTBRc1NVRkJUVThzV1VGQldTeEhRVUZsZGtJc1owSkJRV2RDTEVOQlFVTnRRaXhOUVVGTkxFTkJRM1JFTEZWQlFVTktMRU5CUVZjN1dVRkJRU3hQUVVGTFR5eHJRa0ZCYTBJc1EwRkJRMFlzVDBGQlR5eERRVUZEVEN4RFFVRkRMRU5CUVVORExGbEJRVmtzUTBGQlF5eEhRVUZITEVOQlFVTTdWVUZCUVN4RlFVTm9SVHRWUVVWRUxHMUNRVUZMTEVOQlFVTnFRaXhIUVVGSExFTkJRVU1zUlVGQlEzbENMRTlCUVU4c2MwTkJRVWxFTEZsQlFWa3NSVUZCUXpzN1VVRkhja042UXl4TlFVRk5MRU5CUVVOcFFpeEhRVUZITEVWQlFVVkRMR2RDUVVGblFpeEZRVUZGUXl4WlFVRlpMRU5CUVVNN1RVRkROME1zUTBGQlF5eERRVUZETzAxQlJVWXNTVUZCU1N4RFFVRkRWeXhIUVVGSExFTkJRVU5FTEUxQlFVMHNSVUZCUlN4VlFVRkRXaXhIUVVGSExFVkJRVVZMTEdGQlFYbENMRVZCUVVrN1VVRkRiRVFzU1VGQlNVb3NaMEpCUVdkQ0xFZEJRV1ZrTEV0QlFVc3NRMEZCUTJFc1IwRkJSeXhEUVVGRE8xRkJSVGRETEVsQlFVa3NRMEZCUTBNc1owSkJRV2RDTEVWQlFVVTdVVUZGZGtJc1NVRkJUWGxDTEc5Q1FVRnZRaXhIUVVGSGNrSXNZVUZCWVN4RFFVRkRVU3hIUVVGSExFTkJRelZETEZWQlFVTkhMRU5CUVZjN1ZVRkJRU3hQUVVGTFFTeERRVUZETEVOQlFVTkRMRmxCUVZrN1VVRkJRU3hGUVVOb1F6dFJRVU5FYUVJc1owSkJRV2RDTEVkQlFVZEJMR2RDUVVGblFpeERRVUZEYlVJc1RVRkJUU3hEUVVONFF5eFZRVUZEU2l4RFFVRlhPMVZCUVVFc1QwRkJTMVVzYjBKQlFXOUNMRU5CUVVOTUxFOUJRVThzUTBGQlEwd3NRMEZCUXl4RFFVRkRReXhaUVVGWkxFTkJRVU1zUjBGQlJ5eERRVUZETzFGQlFVRXNSVUZEYkVVN1VVRkZSRGxDTEV0QlFVc3NRMEZCUTJFc1IwRkJSeXhEUVVGRExFZEJRVWRETEdkQ1FVRm5RanRSUVVVM1FtcENMRTlCUVU4c1EwRkJRMmRDTEVkQlFVY3NSVUZCUlVNc1owSkJRV2RDTEVWQlFVVkpMR0ZCUVdFc1EwRkJRenRSUVVVM1F5eEpRVUZKU2l4blFrRkJaMElzUTBGQlEzRkNMRTFCUVUwc1MwRkJTeXhEUVVGRExFVkJRVVVzVDBGQlQyNURMRXRCUVVzc1EwRkJRMkVzUjBGQlJ5eERRVUZETzAxQlEzUkVMRU5CUVVNc1EwRkJRenROUVVWR0xFOUJRVTlpTEV0QlFVczdTVUZEWkR0SlFVVkJPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJRMUVzWVVGRFRuZERMRWRCUVRCQ0xFVkJRekZDUXl4SlFVRjNRanROUVVWNFFpeFBRVUZQUXl4TlFVRk5MRU5CUVVORExHMUNRVUZ0UWl4RFFVRkRTQ3hIUVVGSExFTkJRVU1zUTBGQlEyUXNSMEZCUnl4RFFVRkRMRlZCUVVOaUxFZEJRVWM3VVVGQlFTeFBRVUZMTkVJc1NVRkJTU3hEUVVGRE5VSXNSMEZCUnl4RlFVRkZNa0lzUjBGQlJ5eERRVUZETTBJc1IwRkJSeXhEUVVGRExFTkJRVU03VFVGQlFTeEZRVUZETzBsQlF6RkZPMGxCUlVFN096czdPenM3T3pzN096czdPenM3T3pzN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJkVUpSTEhkQ1FVTk9ZaXhMUVVFclF6dE5RVVV2UTBFc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlEzRkNMRk5CUVZNc1EwRkJRM0pDTEV0QlFVc3NRMEZCUXp0TlFVVTNRaXhQUVVGUE1FTXNUVUZCVFN4RFFVRkRReXh0UWtGQmJVSXNRMEZCUXpORExFdEJRVXNzUTBGQlF5eERRVUZETkVNc1RVRkJUU3hEUVVGRExGVkJRVU42UXl4UlFVRlJMRVZCUVVWVkxFZEJRVWNzUlVGQlNUdFJRVU5vUlN4SlFVRk5ZeXhUUVVGVExFZEJRVWN6UWl4TFFVRkxMRU5CUVVOaExFZEJRVWNzUTBGQlF6dFJRVVUxUWl4SlFVRkpMRTlCUVU4c1NVRkJTV01zVTBGQlV5eEZRVUZGTzFWQlEzaENlRUlzVVVGQlVTeERRVUZEVlN4SFFVRkhMRU5CUVVNc1IwRkJSMk1zVTBGQlV5eERRVUZEYTBJc1MwRkJTeXhEUVVGRGJrSXNSMEZCUnl4RFFVRkRMRlZCUVVOdlFpeFJRVUZSTEVWQlFVazdXVUZETDBOQkxGRkJRVkVzUTBGQlF5eGpRVUZqTEVOQlFVTXNSMEZCUjBFc1VVRkJVU3hEUVVGRExGTkJRVk1zUTBGQlF6dFpRVVU1UXl4UFFVRlBRU3hSUVVGUkxFTkJRVU1zVTBGQlV5eERRVUZETzFsQlF6RkNMRTlCUVU5QkxGRkJRVkVzUTBGQlF5eGpRVUZqTEVOQlFVTTdXVUZGTDBJc1QwRkJUMEVzVVVGQlVUdFZRVU5xUWl4RFFVRkRMRU5CUVdVN1UwRkRha0lzVFVGQlRUdFZRVU5NTTBNc1VVRkJVU3hEUVVGRFZTeEhRVUZITEVOQlFVTXNSMEZCUjJNc1UwRkJVenM3VVVGSE0wSXNUMEZCVDNoQ0xGRkJRVkU3VFVGRGFrSXNRMEZCUXl4RlFVRkZMRVZCUVRKQ0xFTkJRVU03U1VGRGFrTTdTVUZGUVR0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVVOUkxHMUNRVUZwUW5GRExFZEJRVEpDTzAxQlEyeEVMRTlCUVU5UExFbEJRVWtzUTBGQlEwTXNTMEZCU3l4RFFVRkRSQ3hKUVVGSkxFTkJRVU5GTEZOQlFWTXNRMEZCUTFRc1IwRkJSeXhEUVVGRExFTkJRVU03U1VGRGVFTTdSVUZCUXp0RlFVRkJPMEZCUVVFN1FVRjRVa2hvUkNJc0ltNWhiV1Z6SWpwYklsSkZRVXhVU1UxRlgxQlNSVk5GVGtORlgweEpVMVJGVGw5RlZrVk9WRk1pTENKbGVIQnZjblJ6SWl3aVVtVmhiSFJwYldWUWNtVnpaVzVqWlNJc0ltTm9ZVzV1Wld3aUxDSnZjSFJ6SWl3aWIyNUtiMmx1SWl3aWIyNU1aV0YyWlNJc0ltOXVVM2x1WXlJc0ltVjJaVzUwY3lJc0luTjBZWFJsSWl3aVpHbG1aaUlzSWw5dmJpSXNJbTVsZDFOMFlYUmxJaXdpWTJGc2JHVnlJaXdpYW05cGJsSmxaaUlzSWw5cWIybHVVbVZtSWl3aWMzbHVZMU4wWVhSbElpd2ljR1Z1WkdsdVowUnBabVp6SWl3aVptOXlSV0ZqYUNJc0luTjVibU5FYVdabUlpd2lhVzVRWlc1a2FXNW5VM2x1WTFOMFlYUmxJaXdpY0hWemFDSXNJbXRsZVNJc0ltTjFjbkpsYm5SUWNtVnpaVzVqWlhNaUxDSnVaWGRRY21WelpXNWpaWE1pTENKZmRISnBaMmRsY2lJc0ltVjJaVzUwSWl3aWJHVm1kRkJ5WlhObGJtTmxjeUlzSW1OaGJHeGlZV05ySWl3aVkzVnljbVZ1ZEZOMFlYUmxJaXdpWTJ4dmJtVkVaV1Z3SWl3aWRISmhibk5tYjNKdFpXUlRkR0YwWlNJc0luUnlZVzV6Wm05eWJWTjBZWFJsSWl3aWFtOXBibk1pTENKc1pXRjJaWE1pTENKdFlYQWlMQ0p3Y21WelpXNWpaWE1pTENKdVpYZFFjbVZ6Wlc1alpWSmxabk1pTENKdElpd2ljSEpsYzJWdVkyVmZjbVZtSWl3aVkzVnlVSEpsYzJWdVkyVlNaV1p6SWl3aWFtOXBibVZrVUhKbGMyVnVZMlZ6SWl3aVptbHNkR1Z5SWl3aWFXNWtaWGhQWmlJc0lteGxibWQwYUNJc0ltcHZhVzVsWkZCeVpYTmxibU5sVW1WbWN5SXNJbU4xY2xCeVpYTmxibU5sY3lJc0luVnVjMmhwWm5RaUxDSndjbVZ6Wlc1alpWSmxabk5VYjFKbGJXOTJaU0lzSW05aWFpSXNJbVoxYm1NaUxDSlBZbXBsWTNRaUxDSm5aWFJQZDI1UWNtOXdaWEowZVU1aGJXVnpJaXdpY21Wa2RXTmxJaXdpYldWMFlYTWlMQ0p3Y21WelpXNWpaU0lzSWtwVFQwNGlMQ0p3WVhKelpTSXNJbk4wY21sdVoybG1lU0pkTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlVtVmhiSFJwYldWUWNtVnpaVzVqWlM1MGN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXMjUxYkd4ZGZRPT0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9fY3JlYXRlQmluZGluZyA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgIGRlc2MgPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdm9pZCAwICYmICh2b2lkIDApLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZcbiAgfSk7XG59IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gdm9pZCAwICYmICh2b2lkIDApLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyA9IGV4cG9ydHMuUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IGV4cG9ydHMuUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSBleHBvcnRzLlJFQUxUSU1FX0xJU1RFTl9UWVBFUyA9IGV4cG9ydHMuUmVhbHRpbWVDbGllbnQgPSBleHBvcnRzLlJlYWx0aW1lQ2hhbm5lbCA9IGV4cG9ydHMuUmVhbHRpbWVQcmVzZW5jZSA9IHZvaWQgMDtcbnZhciBSZWFsdGltZUNsaWVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1JlYWx0aW1lQ2xpZW50XCIpKTtcbmV4cG9ydHMuUmVhbHRpbWVDbGllbnQgPSBSZWFsdGltZUNsaWVudF8xW1wiZGVmYXVsdFwiXTtcbnZhciBSZWFsdGltZUNoYW5uZWxfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9SZWFsdGltZUNoYW5uZWxcIikpO1xuZXhwb3J0cy5SZWFsdGltZUNoYW5uZWwgPSBSZWFsdGltZUNoYW5uZWxfMVtcImRlZmF1bHRcIl07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSRUFMVElNRV9MSVNURU5fVFlQRVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gUmVhbHRpbWVDaGFubmVsXzEuUkVBTFRJTUVfTElTVEVOX1RZUEVTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIFJlYWx0aW1lQ2hhbm5lbF8xLlJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gUmVhbHRpbWVDaGFubmVsXzEuUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUztcbiAgfVxufSk7XG52YXIgUmVhbHRpbWVQcmVzZW5jZV8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL1JlYWx0aW1lUHJlc2VuY2VcIikpO1xuZXhwb3J0cy5SZWFsdGltZVByZXNlbmNlID0gUmVhbHRpbWVQcmVzZW5jZV8xW1wiZGVmYXVsdFwiXTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gUmVhbHRpbWVQcmVzZW5jZV8xLlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFM7XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPMEZCUVVFN1FVRTJRa1ZCTEhsQ1FUZENTME1zTWtKQlFXTTdRVUZMY2tJN1FVRnhRa1ZFTERCQ1FYSkNTMFVzTkVKQlFXVTdRVUZ2UTNCQ1F6dEZRVUZCUXp0RlFVRkJRenRKUVVGQkxFOUJOVUpCU0N4MVEwRkJjVUk3UlVGQlFUdEJRVUZCTzBGQk5rSnlRa003UlVGQlFVTTdSVUZCUVVNN1NVRkJRU3hQUVRWQ1FVZ3NkMFJCUVhORE8wVkJRVUU3UVVGQlFUdEJRVGhDZEVORE8wVkJRVUZETzBWQlFVRkRPMGxCUVVFc1QwRTNRa0ZJTERKRFFVRjVRanRGUVVGQk8wRkJRVUU3UVVGRk0wSTdRVUZSUlVZc01rSkJVa3ROTERaQ1FVRm5RanRCUVRCQ2NrSklPMFZCUVVGRE8wVkJRVUZETzBsQlFVRXNUMEYwUWtGRExHdEVRVUVyUWp0RlFVRkJPMEZCUVVFaUxDSnVZVzFsY3lJNld5SmxlSEJ2Y25Seklpd2lVbVZoYkhScGJXVkRiR2xsYm5SZk1TSXNJbEpsWVd4MGFXMWxRMmhoYm01bGJGOHhJaXdpVDJKcVpXTjBJaXdpWlc1MWJXVnlZV0pzWlNJc0ltZGxkQ0lzSWxKbFlXeDBhVzFsVUhKbGMyVnVZMlZmTVNKZExDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZhVzVrWlhndWRITWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHR1ZFd4c1hYMD0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ09OTkVDVElPTl9TVEFURSA9IGV4cG9ydHMuVFJBTlNQT1JUUyA9IGV4cG9ydHMuQ0hBTk5FTF9FVkVOVFMgPSBleHBvcnRzLkNIQU5ORUxfU1RBVEVTID0gZXhwb3J0cy5TT0NLRVRfU1RBVEVTID0gZXhwb3J0cy5XU19DTE9TRV9OT1JNQUwgPSBleHBvcnRzLkRFRkFVTFRfVElNRU9VVCA9IGV4cG9ydHMuVlNOID0gZXhwb3J0cy5ERUZBVUxUX0hFQURFUlMgPSB2b2lkIDA7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMuREVGQVVMVF9IRUFERVJTID0ge1xuICAnWC1DbGllbnQtSW5mbyc6IFwicmVhbHRpbWUtanMvXCIuY29uY2F0KHZlcnNpb25fMS52ZXJzaW9uKVxufTtcbmV4cG9ydHMuVlNOID0gJzEuMC4wJztcbmV4cG9ydHMuREVGQVVMVF9USU1FT1VUID0gMTAwMDA7XG5leHBvcnRzLldTX0NMT1NFX05PUk1BTCA9IDEwMDA7XG52YXIgU09DS0VUX1NUQVRFUztcbihmdW5jdGlvbiAoU09DS0VUX1NUQVRFUykge1xuICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjb25uZWN0aW5nXCJdID0gMF0gPSBcImNvbm5lY3RpbmdcIjtcbiAgU09DS0VUX1NUQVRFU1tTT0NLRVRfU1RBVEVTW1wib3BlblwiXSA9IDFdID0gXCJvcGVuXCI7XG4gIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNsb3NpbmdcIl0gPSAyXSA9IFwiY2xvc2luZ1wiO1xuICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjbG9zZWRcIl0gPSAzXSA9IFwiY2xvc2VkXCI7XG59KShTT0NLRVRfU1RBVEVTID0gZXhwb3J0cy5TT0NLRVRfU1RBVEVTIHx8IChleHBvcnRzLlNPQ0tFVF9TVEFURVMgPSB7fSkpO1xudmFyIENIQU5ORUxfU1RBVEVTO1xuKGZ1bmN0aW9uIChDSEFOTkVMX1NUQVRFUykge1xuICBDSEFOTkVMX1NUQVRFU1tcImNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG4gIENIQU5ORUxfU1RBVEVTW1wiZXJyb3JlZFwiXSA9IFwiZXJyb3JlZFwiO1xuICBDSEFOTkVMX1NUQVRFU1tcImpvaW5lZFwiXSA9IFwiam9pbmVkXCI7XG4gIENIQU5ORUxfU1RBVEVTW1wiam9pbmluZ1wiXSA9IFwiam9pbmluZ1wiO1xuICBDSEFOTkVMX1NUQVRFU1tcImxlYXZpbmdcIl0gPSBcImxlYXZpbmdcIjtcbn0pKENIQU5ORUxfU1RBVEVTID0gZXhwb3J0cy5DSEFOTkVMX1NUQVRFUyB8fCAoZXhwb3J0cy5DSEFOTkVMX1NUQVRFUyA9IHt9KSk7XG52YXIgQ0hBTk5FTF9FVkVOVFM7XG4oZnVuY3Rpb24gKENIQU5ORUxfRVZFTlRTKSB7XG4gIENIQU5ORUxfRVZFTlRTW1wiY2xvc2VcIl0gPSBcInBoeF9jbG9zZVwiO1xuICBDSEFOTkVMX0VWRU5UU1tcImVycm9yXCJdID0gXCJwaHhfZXJyb3JcIjtcbiAgQ0hBTk5FTF9FVkVOVFNbXCJqb2luXCJdID0gXCJwaHhfam9pblwiO1xuICBDSEFOTkVMX0VWRU5UU1tcInJlcGx5XCJdID0gXCJwaHhfcmVwbHlcIjtcbiAgQ0hBTk5FTF9FVkVOVFNbXCJsZWF2ZVwiXSA9IFwicGh4X2xlYXZlXCI7XG4gIENIQU5ORUxfRVZFTlRTW1wiYWNjZXNzX3Rva2VuXCJdID0gXCJhY2Nlc3NfdG9rZW5cIjtcbn0pKENIQU5ORUxfRVZFTlRTID0gZXhwb3J0cy5DSEFOTkVMX0VWRU5UUyB8fCAoZXhwb3J0cy5DSEFOTkVMX0VWRU5UUyA9IHt9KSk7XG52YXIgVFJBTlNQT1JUUztcbihmdW5jdGlvbiAoVFJBTlNQT1JUUykge1xuICBUUkFOU1BPUlRTW1wid2Vic29ja2V0XCJdID0gXCJ3ZWJzb2NrZXRcIjtcbn0pKFRSQU5TUE9SVFMgPSBleHBvcnRzLlRSQU5TUE9SVFMgfHwgKGV4cG9ydHMuVFJBTlNQT1JUUyA9IHt9KSk7XG52YXIgQ09OTkVDVElPTl9TVEFURTtcbihmdW5jdGlvbiAoQ09OTkVDVElPTl9TVEFURSkge1xuICBDT05ORUNUSU9OX1NUQVRFW1wiQ29ubmVjdGluZ1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICBDT05ORUNUSU9OX1NUQVRFW1wiT3BlblwiXSA9IFwib3BlblwiO1xuICBDT05ORUNUSU9OX1NUQVRFW1wiQ2xvc2luZ1wiXSA9IFwiY2xvc2luZ1wiO1xuICBDT05ORUNUSU9OX1NUQVRFW1wiQ2xvc2VkXCJdID0gXCJjbG9zZWRcIjtcbn0pKENPTk5FQ1RJT05fU1RBVEUgPSBleHBvcnRzLkNPTk5FQ1RJT05fU1RBVEUgfHwgKGV4cG9ydHMuQ09OTkVDVElPTl9TVEFURSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN08wRkJRVUU3UVVGRllVRXNkVUpCUVdVc1IwRkJSenRGUVVGRkxHVkJRV1VzZDBKQlFXbENReXhwUWtGQlR6dEJRVUZGTEVOQlFVVTdRVUZGTDBSRUxGZEJRVWNzUjBGQlZ5eFBRVUZQTzBGQlJYSkNRU3gxUWtGQlpTeEhRVUZITEV0QlFVczdRVUZGZGtKQkxIVkNRVUZsTEVkQlFVY3NTVUZCU1R0QlFVVnVReXhKUVVGWlJTeGhRVXRZTzBGQlRFUXNWMEZCV1VFc1lVRkJZVHRGUVVOMlFrRXNOa1JCUVdNN1JVRkRaRUVzYVVSQlFWRTdSVUZEVWtFc2RVUkJRVmM3UlVGRFdFRXNjVVJCUVZVN1FVRkRXaXhEUVVGRExFVkJURmRCTEdGQlFXRXNSMEZCWWtZc2NVSkJRV0VzUzBGQllrRXNjVUpCUVdFN1FVRlBla0lzU1VGQldVY3NZMEZOV0R0QlFVNUVMRmRCUVZsQkxHTkJRV003UlVGRGVFSkJMRzFEUVVGcFFqdEZRVU5xUWtFc2NVTkJRVzFDTzBWQlEyNUNRU3h0UTBGQmFVSTdSVUZEYWtKQkxIRkRRVUZ0UWp0RlFVTnVRa0VzY1VOQlFXMUNPMEZCUTNKQ0xFTkJRVU1zUlVGT1YwRXNZMEZCWXl4SFFVRmtTQ3h6UWtGQll5eExRVUZrUVN4elFrRkJZenRCUVZFeFFpeEpRVUZaU1N4alFVOVlPMEZCVUVRc1YwRkJXVUVzWTBGQll6dEZRVU40UWtFc2NVTkJRVzFDTzBWQlEyNUNRU3h4UTBGQmJVSTdSVUZEYmtKQkxHMURRVUZwUWp0RlFVTnFRa0VzY1VOQlFXMUNPMFZCUTI1Q1FTeHhRMEZCYlVJN1JVRkRia0pCTEN0RFFVRTJRanRCUVVNdlFpeERRVUZETEVWQlVGZEJMR05CUVdNc1IwRkJaRW9zYzBKQlFXTXNTMEZCWkVFc2MwSkJRV003UVVGVE1VSXNTVUZCV1Vzc1ZVRkZXRHRCUVVaRUxGZEJRVmxCTEZWQlFWVTdSVUZEY0VKQkxIRkRRVUYxUWp0QlFVTjZRaXhEUVVGRExFVkJSbGRCTEZWQlFWVXNSMEZCVmt3c2EwSkJRVlVzUzBGQlZrRXNhMEpCUVZVN1FVRkpkRUlzU1VGQldVMHNaMEpCUzFnN1FVRk1SQ3hYUVVGWlFTeG5Ra0ZCWjBJN1JVRkRNVUpCTERaRFFVRjVRanRGUVVONlFrRXNhVU5CUVdFN1JVRkRZa0VzZFVOQlFXMUNPMFZCUTI1Q1FTeHhRMEZCYVVJN1FVRkRia0lzUTBGQlF5eEZRVXhYUVN4blFrRkJaMElzUjBGQmFFSk9MSGRDUVVGblFpeExRVUZvUWtFc2QwSkJRV2RDSWl3aWJtRnRaWE1pT2xzaVpYaHdiM0owY3lJc0luWmxjbk5wYjI1Zk1TSXNJbE5QUTB0RlZGOVRWRUZVUlZNaUxDSkRTRUZPVGtWTVgxTlVRVlJGVXlJc0lrTklRVTVPUlV4ZlJWWkZUbFJUSWl3aVZGSkJUbE5RVDFKVVV5SXNJa05QVGs1RlExUkpUMDVmVTFSQlZFVWlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2YzNKakwyeHBZaTlqYjI1emRHRnVkSE11ZEhNaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sdHVkV3hzWFgwPSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vbGliL2NvbnN0YW50c1wiKTtcbnZhciBQdXNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gICAqXG4gICAqIEBwYXJhbSBjaGFubmVsIFRoZSBDaGFubmVsXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gICAqIEBwYXJhbSBwYXlsb2FkIFRoZSBwYXlsb2FkLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IDEyM31gXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBmdW5jdGlvbiBQdXNoKGNoYW5uZWwsIGV2ZW50KSB7XG4gICAgdmFyIHBheWxvYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBjb25zdGFudHNfMS5ERUZBVUxUX1RJTUVPVVQ7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1c2gpO1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlZiA9ICcnO1xuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbDtcbiAgICB0aGlzLnJlY0hvb2tzID0gW107XG4gICAgdGhpcy5yZWZFdmVudCA9IG51bGw7XG4gICAgdGhpcy5yYXRlTGltaXRlZCA9IGZhbHNlO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhQdXNoLCBbe1xuICAgIGtleTogXCJyZXNlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZW5kKHRpbWVvdXQpIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgIHRoaXMucmVmRXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgdGhpcy5zZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbmQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKCkge1xuICAgICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKCd0aW1lb3V0JykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFydFRpbWVvdXQoKTtcbiAgICAgIHRoaXMuc2VudCA9IHRydWU7XG4gICAgICB2YXIgc3RhdHVzID0gdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCxcbiAgICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5fam9pblJlZigpXG4gICAgICB9KTtcbiAgICAgIGlmIChzdGF0dXMgPT09ICdyYXRlIGxpbWl0ZWQnKSB7XG4gICAgICAgIHRoaXMucmF0ZUxpbWl0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQYXlsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBheWxvYWQocGF5bG9hZCkge1xuICAgICAgdGhpcy5wYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBheWxvYWQpLCBwYXlsb2FkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjZWl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNlaXZlKHN0YXR1cywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZChzdGF0dXMpKSB7XG4gICAgICAgIGNhbGxiYWNrKChfYSA9IHRoaXMucmVjZWl2ZWRSZXNwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWNIb29rcy5wdXNoKHtcbiAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRUaW1lb3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0VGltZW91dCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Ll9tYWtlUmVmKCk7XG4gICAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLl9yZXBseUV2ZW50TmFtZSh0aGlzLnJlZik7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhwYXlsb2FkKSB7XG4gICAgICAgIF90aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICBfdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgICAgICBfdGhpcy5yZWNlaXZlZFJlc3AgPSBwYXlsb2FkO1xuICAgICAgICBfdGhpcy5fbWF0Y2hSZWNlaXZlKHBheWxvYWQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY2hhbm5lbC5fb24odGhpcy5yZWZFdmVudCwge30sIGNhbGxiYWNrKTtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnRyaWdnZXIoJ3RpbWVvdXQnLCB7fSk7XG4gICAgICB9LCB0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmlnZ2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgaWYgKHRoaXMucmVmRXZlbnQpIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7XG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICByZXNwb25zZTogcmVzcG9uc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FuY2VsUmVmRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbmNlbFJlZkV2ZW50KCkge1xuICAgICAgaWYgKCF0aGlzLnJlZkV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hhbm5lbC5fb2ZmKHRoaXMucmVmRXZlbnQsIHt9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbmNlbFRpbWVvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbmNlbFRpbWVvdXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpO1xuICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9tYXRjaFJlY2VpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21hdGNoUmVjZWl2ZShfcmVmKSB7XG4gICAgICB2YXIgc3RhdHVzID0gX3JlZi5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlID0gX3JlZi5yZXNwb25zZTtcbiAgICAgIHRoaXMucmVjSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBoLnN0YXR1cyA9PT0gc3RhdHVzO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gaC5jYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhc1JlY2VpdmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYXNSZWNlaXZlZChzdGF0dXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1cztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFB1c2g7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFB1c2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3UVVGQlFUdEJRVUZyUkN4SlFVYzNRa0VzU1VGQlNUdEZRV1YyUWpzN096czdPenM3UlVGUlFTeGpRVU5UUXl4UFFVRjNRaXhGUVVONFFrTXNTMEZCWVN4RlFVVnZRanRKUVVGQkxFbEJSR3BEUXl3NFJVRkJhME1zUlVGQlJUdEpRVUZCTEVsQlEzQkRReXc0UlVGQmEwSkRMREpDUVVGbE8wbEJRVUU3U1VGSWFrTXNXVUZCVHl4SFFVRlFTaXhQUVVGUE8wbEJRMUFzVlVGQlN5eEhRVUZNUXl4TFFVRkxPMGxCUTB3c1dVRkJUeXhIUVVGUVF5eFBRVUZQTzBsQlExQXNXVUZCVHl4SFFVRlFReXhQUVVGUE8wbEJNVUpvUWl4VFFVRkpMRWRCUVZrc1MwRkJTenRKUVVOeVFpeHBRa0ZCV1N4SFFVRjFRa1VzVTBGQlV6dEpRVU0xUXl4UlFVRkhMRWRCUVZjc1JVRkJSVHRKUVVOb1FpeHBRa0ZCV1N4SFFVZEVMRWxCUVVrN1NVRkRaaXhoUVVGUkxFZEJSMFlzUlVGQlJUdEpRVU5TTEdGQlFWRXNSMEZCYTBJc1NVRkJTVHRKUVVNNVFpeG5Ra0ZCVnl4SFFVRlpMRXRCUVVzN1JVRmxla0k3UlVGQlF6dEpRVUZCTzBsQlFVRXNUMEZGU2l4blFrRkJUMFlzVDBGQlpUdE5RVU53UWl4SlFVRkpMRU5CUVVOQkxFOUJRVThzUjBGQlIwRXNUMEZCVHp0TlFVTjBRaXhKUVVGSkxFTkJRVU5ITEdWQlFXVXNSVUZCUlR0TlFVTjBRaXhKUVVGSkxFTkJRVU5ETEVkQlFVY3NSMEZCUnl4RlFVRkZPMDFCUTJJc1NVRkJTU3hEUVVGRFF5eFJRVUZSTEVkQlFVY3NTVUZCU1R0TlFVTndRaXhKUVVGSkxFTkJRVU5ETEZsQlFWa3NSMEZCUnl4SlFVRkpPMDFCUTNoQ0xFbEJRVWtzUTBGQlEwTXNTVUZCU1N4SFFVRkhMRXRCUVVzN1RVRkRha0lzU1VGQlNTeERRVUZEUXl4SlFVRkpMRVZCUVVVN1NVRkRZanRGUVVGRE8wbEJRVUU3U1VGQlFTeFBRVVZFTEdkQ1FVRkpPMDFCUTBZc1NVRkJTU3hKUVVGSkxFTkJRVU5ETEZsQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1JVRkJSVHRSUVVOb1F6czdUVUZGUml4SlFVRkpMRU5CUVVORExGbEJRVmtzUlVGQlJUdE5RVU51UWl4SlFVRkpMRU5CUVVOSUxFbEJRVWtzUjBGQlJ5eEpRVUZKTzAxQlEyaENMRWxCUVUxSkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTmtMRTlCUVU4c1EwRkJRMlVzVFVGQlRTeERRVUZEUXl4SlFVRkpMRU5CUVVNN1VVRkRkRU5ETEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVOcVFpeFBRVUZQTEVOQlFVTnBRaXhMUVVGTE8xRkJRM3BDYUVJc1MwRkJTeXhGUVVGRkxFbEJRVWtzUTBGQlEwRXNTMEZCU3p0UlFVTnFRa01zVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTBFc1QwRkJUenRSUVVOeVFrc3NSMEZCUnl4RlFVRkZMRWxCUVVrc1EwRkJRMEVzUjBGQlJ6dFJRVU5pVnl4UlFVRlJMRVZCUVVVc1NVRkJTU3hEUVVGRGJFSXNUMEZCVHl4RFFVRkRiVUlzVVVGQlVUdFBRVU5vUXl4RFFVRkRPMDFCUTBZc1NVRkJTVXdzVFVGQlRTeExRVUZMTEdOQlFXTXNSVUZCUlR0UlFVTTNRaXhKUVVGSkxFTkJRVU5OTEZkQlFWY3NSMEZCUnl4SlFVRkpPenRKUVVVelFqdEZRVUZETzBsQlFVRTdTVUZCUVN4UFFVVkVMSFZDUVVGamJFSXNUMEZCSzBJN1RVRkRNME1zU1VGQlNTeERRVUZEUVN4UFFVRlBMRzFEUVVGUkxFbEJRVWtzUTBGQlEwRXNUMEZCVHl4SFFVRkxRU3hQUVVGUExFTkJRVVU3U1VGRGFFUTdSVUZCUXp0SlFVRkJPMGxCUVVFc1QwRkZSQ3hwUWtGQlVWa3NUVUZCWXl4RlFVRkZUeXhSUVVGclFqczdUVUZEZUVNc1NVRkJTU3hKUVVGSkxFTkJRVU5VTEZsQlFWa3NRMEZCUTBVc1RVRkJUU3hEUVVGRExFVkJRVVU3VVVGRE4wSlBMRkZCUVZFc1EwRkJReXhWUVVGSkxFTkJRVU5hTEZsQlFWa3NNRU5CUVVWaExGRkJRVkVzUTBGQlF6czdUVUZIZGtNc1NVRkJTU3hEUVVGRFF5eFJRVUZSTEVOQlFVTlFMRWxCUVVrc1EwRkJRenRSUVVGRlJpeE5RVUZOTEVWQlFVNUJMRTFCUVUwN1VVRkJSVThzVVVGQlVTeEZRVUZTUVR0TlFVRlJMRU5CUVVVc1EwRkJRenROUVVONFF5eFBRVUZQTEVsQlFVazdTVUZEWWp0RlFVRkRPMGxCUVVFN1NVRkJRU3hQUVVWRUxIZENRVUZaTzAxQlFVRTdUVUZEVml4SlFVRkpMRWxCUVVrc1EwRkJRMGNzV1VGQldTeEZRVUZGTzFGQlEzSkNPenROUVVWR0xFbEJRVWtzUTBGQlEycENMRWRCUVVjc1IwRkJSeXhKUVVGSkxFTkJRVU5RTEU5QlFVOHNRMEZCUTJVc1RVRkJUU3hEUVVGRFZTeFJRVUZSTEVWQlFVVTdUVUZEZWtNc1NVRkJTU3hEUVVGRGFrSXNVVUZCVVN4SFFVRkhMRWxCUVVrc1EwRkJRMUlzVDBGQlR5eERRVUZETUVJc1pVRkJaU3hEUVVGRExFbEJRVWtzUTBGQlEyNUNMRWRCUVVjc1EwRkJRenROUVVWMFJDeEpRVUZOWXl4UlFVRlJMRWRCUVVjc1UwRkJXRUVzVVVGQlVTeERRVUZKYmtJc1QwRkJXU3hGUVVGSk8xRkJRMmhETEV0QlFVa3NRMEZCUTBrc1pVRkJaU3hGUVVGRk8xRkJRM1JDTEV0QlFVa3NRMEZCUTNGQ0xHTkJRV01zUlVGQlJUdFJRVU55UWl4TFFVRkpMRU5CUVVOc1FpeFpRVUZaTEVkQlFVZFFMRTlCUVU4N1VVRkRNMElzUzBGQlNTeERRVUZETUVJc1lVRkJZU3hEUVVGRE1VSXNUMEZCVHl4RFFVRkRPMDFCUXpkQ0xFTkJRVU03VFVGRlJDeEpRVUZKTEVOQlFVTkdMRTlCUVU4c1EwRkJRelpDTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVOeVFpeFJRVUZSTEVWQlFVVXNSVUZCUlN4RlFVRkZZU3hSUVVGUkxFTkJRVU03VFVGRk4wTXNTVUZCU1N4RFFVRkRSeXhaUVVGWkxFZEJRVkZOTEZWQlFWVXNRMEZCUXl4WlFVRkxPMUZCUTNaRExFdEJRVWtzUTBGQlEwTXNUMEZCVHl4RFFVRkRMRk5CUVZNc1JVRkJSU3hGUVVGRkxFTkJRVU03VFVGRE4wSXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJRelZDTEU5QlFVOHNRMEZCUXp0SlFVTnNRanRGUVVGRE8wbEJRVUU3U1VGQlFTeFBRVVZFTEdsQ1FVRlJWeXhOUVVGakxFVkJRVVZSTEZGQlFXRTdUVUZEYmtNc1NVRkJTU3hKUVVGSkxFTkJRVU5rTEZGQlFWRXNSVUZEWml4SlFVRkpMRU5CUVVOU0xFOUJRVThzUTBGQlEyZERMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU40UWl4UlFVRlJMRVZCUVVVN1VVRkJSVTBzVFVGQlRTeEZRVUZPUVN4TlFVRk5PMUZCUVVWUkxGRkJRVkVzUlVGQlVrRTdUVUZCVVN4RFFVRkZMRU5CUVVNN1NVRkRPVVE3UlVGQlF6dEpRVUZCTzBsQlFVRXNUMEZGUkN4dFFrRkJUenROUVVOTUxFbEJRVWtzUTBGQlEyaENMR1ZCUVdVc1JVRkJSVHROUVVOMFFpeEpRVUZKTEVOQlFVTnhRaXhqUVVGakxFVkJRVVU3U1VGRGRrSTdSVUZCUXp0SlFVRkJPMGxCUVVFc1QwRkZUeXd5UWtGQlpUdE5RVU55UWl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRGJrSXNVVUZCVVN4RlFVRkZPMUZCUTJ4Q096dE5RVWRHTEVsQlFVa3NRMEZCUTFJc1QwRkJUeXhEUVVGRGFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJRM3BDTEZGQlFWRXNSVUZCUlN4RlFVRkZMRU5CUVVNN1NVRkRkRU03UlVGQlF6dEpRVUZCTzBsQlFVRXNUMEZGVHl3d1FrRkJZenROUVVOd1FqQkNMRmxCUVZrc1EwRkJReXhKUVVGSkxFTkJRVU5XTEZsQlFWa3NRMEZCUXp0TlFVTXZRaXhKUVVGSkxFTkJRVU5CTEZsQlFWa3NSMEZCUjI1Q0xGTkJRVk03U1VGREwwSTdSVUZCUXp0SlFVRkJPMGxCUVVFc1QwRkZUeXcyUWtGTlVEdE5RVUZCTEVsQlRFTlRMRTFCUVUwc1VVRkJUa0VzVFVGQlRUdFJRVU5PVVN4UlFVRlJMRkZCUVZKQkxGRkJRVkU3VFVGTFVpeEpRVUZKTEVOQlFVTkRMRkZCUVZFc1EwRkRWbGtzVFVGQlRTeERRVUZETEZWQlFVTkRMRU5CUVVNN1VVRkJRU3hQUVVGTFFTeERRVUZETEVOQlFVTjBRaXhOUVVGTkxFdEJRVXRCTEUxQlFVMDdUVUZCUVN4RlFVRkRMRU5CUTJ4RGRVSXNUMEZCVHl4RFFVRkRMRlZCUVVORUxFTkJRVU03VVVGQlFTeFBRVUZMUVN4RFFVRkRMRU5CUVVObUxGRkJRVkVzUTBGQlEwTXNVVUZCVVN4RFFVRkRPMDFCUVVFc1JVRkJRenRKUVVONlF6dEZRVUZETzBsQlFVRTdTVUZCUVN4UFFVVlBMSE5DUVVGaFVpeE5RVUZqTzAxQlEycERMRTlCUVU4c1NVRkJTU3hEUVVGRFRDeFpRVUZaTEVsQlFVa3NTVUZCU1N4RFFVRkRRU3haUVVGWkxFTkJRVU5MTEUxQlFVMHNTMEZCUzBFc1RVRkJUVHRKUVVOcVJUdEZRVUZETzBWQlFVRTdRVUZCUVR0QlFXcEpTSGRDSWl3aWJtRnRaWE1pT2xzaVVIVnphQ0lzSW1Ob1lXNXVaV3dpTENKbGRtVnVkQ0lzSW5CaGVXeHZZV1FpTENKMGFXMWxiM1YwSWl3aVkyOXVjM1JoYm5Selh6RWlMQ0oxYm1SbFptbHVaV1FpTENKZlkyRnVZMlZzVW1WbVJYWmxiblFpTENKeVpXWWlMQ0p5WldaRmRtVnVkQ0lzSW5KbFkyVnBkbVZrVW1WemNDSXNJbk5sYm5RaUxDSnpaVzVrSWl3aVgyaGhjMUpsWTJWcGRtVmtJaXdpYzNSaGNuUlVhVzFsYjNWMElpd2ljM1JoZEhWeklpd2ljMjlqYTJWMElpd2ljSFZ6YUNJc0luUnZjR2xqSWl3aWFtOXBibDl5WldZaUxDSmZhbTlwYmxKbFppSXNJbkpoZEdWTWFXMXBkR1ZrSWl3aVkyRnNiR0poWTJzaUxDSnlaWE53YjI1elpTSXNJbkpsWTBodmIydHpJaXdpZEdsdFpXOTFkRlJwYldWeUlpd2lYMjFoYTJWU1pXWWlMQ0pmY21Wd2JIbEZkbVZ1ZEU1aGJXVWlMQ0pmWTJGdVkyVnNWR2x0Wlc5MWRDSXNJbDl0WVhSamFGSmxZMlZwZG1VaUxDSmZiMjRpTENKelpYUlVhVzFsYjNWMElpd2lkSEpwWjJkbGNpSXNJbDkwY21sbloyVnlJaXdpWDI5bVppSXNJbU5zWldGeVZHbHRaVzkxZENJc0ltWnBiSFJsY2lJc0ltZ2lMQ0ptYjNKRllXTm9JaXdpWlhod2IzSjBjeUpkTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk5emNtTXZiR2xpTDNCMWMyZ3VkSE1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2x0dWRXeHNYWDA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgZmlsZSBkcmF3cyBoZWF2aWx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9jb21taXQvY2YwOThlOWNmN2E0NGVlNjQ3OWQzMWQ5MTFhOTdkM2M3NDMwYzZmZVxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgU2VyaWFsaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNlcmlhbGl6ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlcmlhbGl6ZXIpO1xuICAgIHRoaXMuSEVBREVSX0xFTkdUSCA9IDE7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFNlcmlhbGl6ZXIsIFt7XG4gICAga2V5OiBcImRlY29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChyYXdQYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04ucGFyc2UocmF3UGF5bG9hZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmFyeURlY29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluYXJ5RGVjb2RlKGJ1ZmZlcikge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgIHZhciBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICByZXR1cm4gdGhpcy5fZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZWNvZGVCcm9hZGNhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgIHZhciB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgdmFyIGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMik7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMjtcbiAgICAgIHZhciB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgICAgdmFyIGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemU7XG4gICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWY6IG51bGwsXG4gICAgICAgIHRvcGljOiB0b3BpYyxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBwYXlsb2FkOiBkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2VyaWFsaXplcjtcbn0oKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdRVUZCUVR0QlFVTkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCT3pzN08wbEJSWEZDUVN4VlFVRlZPMFZCUVM5Q08wbEJRVUU3U1VGRFJTeHJRa0ZCWVN4SFFVRkhMRU5CUVVNN1JVRTBRMjVDTzBWQlFVTTdTVUZCUVR0SlFVRkJMRTlCTVVORExHZENRVUZQUXl4VlFVRm5ReXhGUVVGRlF5eFJRVUZyUWp0TlFVTjZSQ3hKUVVGSlJDeFZRVUZWTEVOQlFVTkZMRmRCUVZjc1MwRkJTME1zVjBGQlZ5eEZRVUZGTzFGQlF6RkRMRTlCUVU5R0xGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTkhMR0ZCUVdFc1EwRkJRMG9zVlVGQlZTeERRVUZETEVOQlFVTTdPMDFCUjJwRUxFbEJRVWtzVDBGQlQwRXNWVUZCVlN4TFFVRkxMRkZCUVZFc1JVRkJSVHRSUVVOc1F5eFBRVUZQUXl4UlFVRlJMRU5CUVVOSkxFbEJRVWtzUTBGQlEwTXNTMEZCU3l4RFFVRkRUaXhWUVVGVkxFTkJRVU1zUTBGQlF6czdUVUZIZWtNc1QwRkJUME1zVVVGQlVTeERRVUZETEVWQlFVVXNRMEZCUXp0SlFVTnlRanRGUVVGRE8wbEJRVUU3U1VGQlFTeFBRVVZQTEhWQ1FVRmpUU3hOUVVGdFFqdE5RVU4yUXl4SlFVRk5ReXhKUVVGSkxFZEJRVWNzU1VGQlNVTXNVVUZCVVN4RFFVRkRSaXhOUVVGTkxFTkJRVU03VFVGRGFrTXNTVUZCVFVjc1QwRkJUeXhIUVVGSExFbEJRVWxETEZkQlFWY3NSVUZCUlR0TlFVVnFReXhQUVVGUExFbEJRVWtzUTBGQlEwTXNaMEpCUVdkQ0xFTkJRVU5NTEUxQlFVMHNSVUZCUlVNc1NVRkJTU3hGUVVGRlJTeFBRVUZQTEVOQlFVTTdTVUZEY2tRN1JVRkJRenRKUVVGQk8wbEJRVUVzVDBGRlR5d3dRa0ZEVGtnc1RVRkJiVUlzUlVGRGJrSkRMRWxCUVdNc1JVRkRaRVVzVDBGQmIwSTdUVUZQY0VJc1NVRkJUVWNzVTBGQlV5eEhRVUZIVEN4SlFVRkpMRU5CUVVOTkxGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdUVUZEYkVNc1NVRkJUVU1zVTBGQlV5eEhRVUZIVUN4SlFVRkpMRU5CUVVOTkxGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdUVUZEYkVNc1NVRkJTVVVzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUTBNc1lVRkJZU3hIUVVGSExFTkJRVU03VFVGRGJrTXNTVUZCVFVNc1MwRkJTeXhIUVVGSFVpeFBRVUZQTEVOQlFVTlRMRTFCUVUwc1EwRkJRMW9zVFVGQlRTeERRVUZEWVN4TFFVRkxMRU5CUVVOS0xFMUJRVTBzUlVGQlJVRXNUVUZCVFN4SFFVRkhTQ3hUUVVGVExFTkJRVU1zUTBGQlF6dE5RVU4wUlVjc1RVRkJUU3hIUVVGSFFTeE5RVUZOTEVkQlFVZElMRk5CUVZNN1RVRkRNMElzU1VGQlRWRXNTMEZCU3l4SFFVRkhXQ3hQUVVGUExFTkJRVU5UTEUxQlFVMHNRMEZCUTFvc1RVRkJUU3hEUVVGRFlTeExRVUZMTEVOQlFVTktMRTFCUVUwc1JVRkJSVUVzVFVGQlRTeEhRVUZIUkN4VFFVRlRMRU5CUVVNc1EwRkJRenROUVVOMFJVTXNUVUZCVFN4SFFVRkhRU3hOUVVGTkxFZEJRVWRFTEZOQlFWTTdUVUZETTBJc1NVRkJUVThzU1VGQlNTeEhRVUZIYWtJc1NVRkJTU3hEUVVGRFF5eExRVUZMTEVOQlEzSkNTU3hQUVVGUExFTkJRVU5UTEUxQlFVMHNRMEZCUTFvc1RVRkJUU3hEUVVGRFlTeExRVUZMTEVOQlFVTktMRTFCUVUwc1JVRkJSVlFzVFVGQlRTeERRVUZEWjBJc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGRGVFUTdUVUZGUkN4UFFVRlBPMUZCUVVWRExFZEJRVWNzUlVGQlJTeEpRVUZKTzFGQlFVVk9MRXRCUVVzc1JVRkJSVUVzUzBGQlN6dFJRVUZGUnl4TFFVRkxMRVZCUVVWQkxFdEJRVXM3VVVGQlJVa3NUMEZCVHl4RlFVRkZTRHROUVVGSkxFTkJRVVU3U1VGRGFrVTdSVUZCUXp0RlFVRkJPMEZCUVVFN1FVRTFRMGhKSWl3aWJtRnRaWE1pT2xzaVUyVnlhV0ZzYVhwbGNpSXNJbkpoZDFCaGVXeHZZV1FpTENKallXeHNZbUZqYXlJc0ltTnZibk4wY25WamRHOXlJaXdpUVhKeVlYbENkV1ptWlhJaUxDSmZZbWx1WVhKNVJHVmpiMlJsSWl3aVNsTlBUaUlzSW5CaGNuTmxJaXdpWW5WbVptVnlJaXdpZG1sbGR5SXNJa1JoZEdGV2FXVjNJaXdpWkdWamIyUmxjaUlzSWxSbGVIUkVaV052WkdWeUlpd2lYMlJsWTI5a1pVSnliMkZrWTJGemRDSXNJblJ2Y0dsalUybDZaU0lzSW1kbGRGVnBiblE0SWl3aVpYWmxiblJUYVhwbElpd2liMlptYzJWMElpd2lTRVZCUkVWU1gweEZUa2RVU0NJc0luUnZjR2xqSWl3aVpHVmpiMlJsSWl3aWMyeHBZMlVpTENKbGRtVnVkQ0lzSW1SaGRHRWlMQ0ppZVhSbFRHVnVaM1JvSWl3aWNtVm1JaXdpY0dGNWJHOWhaQ0lzSW1WNGNHOXlkSE1pWFN3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dmMzSmpMMnhwWWk5elpYSnBZV3hwZW1WeUxuUnpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiYm5Wc2JGMTkiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybSBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogICAgfSlcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqL1xudmFyIFRpbWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZXIoY2FsbGJhY2ssIHRpbWVyQ2FsYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lcik7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjO1xuICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50cmllcyA9IDA7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhUaW1lciwgW3tcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnRyaWVzID0gMDtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICB9XG4gICAgLy8gQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgfSwge1xuICAgIGtleTogXCJzY2hlZHVsZVRpbWVvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NoZWR1bGVUaW1lb3V0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMudHJpZXMgPSBfdGhpcy50cmllcyArIDE7XG4gICAgICAgIF90aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGltZXI7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRpbWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN1FVRkJRVHM3T3pzN096czdPenM3TzBGQlFVRXNTVUZaY1VKQkxFdEJRVXM3UlVGSmVFSXNaVUZCYlVKRExGRkJRV3RDTEVWQlFWTkRMRk5CUVcxQ08wbEJRVUU3U1VGQk9VTXNZVUZCVVN4SFFVRlNSQ3hSUVVGUk8wbEJRVzFDTEdOQlFWTXNSMEZCVkVNc1UwRkJVenRKUVVoMlJDeFZRVUZMTEVkQlFYVkNReXhUUVVGVE8wbEJRM0pETEZWQlFVc3NSMEZCVnl4RFFVRkRPMGxCUjJZc1NVRkJTU3hEUVVGRFJpeFJRVUZSTEVkQlFVZEJMRkZCUVZFN1NVRkRlRUlzU1VGQlNTeERRVUZEUXl4VFFVRlRMRWRCUVVkQkxGTkJRVk03UlVGRE5VSTdSVUZCUXp0SlFVRkJPMGxCUVVFc1QwRkZSQ3hwUWtGQlN6dE5RVU5JTEVsQlFVa3NRMEZCUTBVc1MwRkJTeXhIUVVGSExFTkJRVU03VFVGRFpFTXNXVUZCV1N4RFFVRkRMRWxCUVVrc1EwRkJRME1zUzBGQlN5eERRVUZETzBsQlF6RkNPMGxCUlVFN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGRFFTd3lRa0ZCWlR0TlFVRkJPMDFCUTJKRUxGbEJRVmtzUTBGQlF5eEpRVUZKTEVOQlFVTkRMRXRCUVVzc1EwRkJRenROUVVWNFFpeEpRVUZKTEVOQlFVTkJMRXRCUVVzc1IwRkJVVU1zVlVGQlZTeERRVUZETEZsQlFVczdVVUZEYUVNc1MwRkJTU3hEUVVGRFNDeExRVUZMTEVkQlFVY3NTMEZCU1N4RFFVRkRRU3hMUVVGTExFZEJRVWNzUTBGQlF6dFJRVU16UWl4TFFVRkpMRU5CUVVOSUxGRkJRVkVzUlVGQlJUdE5RVU5xUWl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRFF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRSU3hMUVVGTExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEY0VNN1JVRkJRenRGUVVGQk8wRkJRVUU3UVVGMFFraEpJaXdpYm1GdFpYTWlPbHNpVkdsdFpYSWlMQ0pqWVd4c1ltRmpheUlzSW5ScGJXVnlRMkZzWXlJc0luVnVaR1ZtYVc1bFpDSXNJblJ5YVdWeklpd2lZMnhsWVhKVWFXMWxiM1YwSWl3aWRHbHRaWElpTENKelpYUlVhVzFsYjNWMElpd2laWGh3YjNKMGN5SmRMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTl6Y21NdmJHbGlMM1JwYldWeUxuUnpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiYm5Wc2JGMTkiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBIZWxwZXJzIHRvIGNvbnZlcnQgdGhlIGNoYW5nZSBQYXlsb2FkIGludG8gbmF0aXZlIEpTIHR5cGVzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy50b1RpbWVzdGFtcFN0cmluZyA9IGV4cG9ydHMudG9BcnJheSA9IGV4cG9ydHMudG9Kc29uID0gZXhwb3J0cy50b051bWJlciA9IGV4cG9ydHMudG9Cb29sZWFuID0gZXhwb3J0cy5jb252ZXJ0Q2VsbCA9IGV4cG9ydHMuY29udmVydENvbHVtbiA9IGV4cG9ydHMuY29udmVydENoYW5nZURhdGEgPSBleHBvcnRzLlBvc3RncmVzVHlwZXMgPSB2b2lkIDA7XG4vLyBBZGFwdGVkIGZyb20gZXBnc3FsIChzcmMvZXBnc3FsX2JpbmFyeS5lcmwpLCB0aGlzIG1vZHVsZSBsaWNlbnNlZCB1bmRlclxuLy8gMy1jbGF1c2UgQlNEIGZvdW5kIGhlcmU6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lcGdzcWwvZXBnc3FsL2RldmVsL0xJQ0VOU0VcbnZhciBQb3N0Z3Jlc1R5cGVzO1xuKGZ1bmN0aW9uIChQb3N0Z3Jlc1R5cGVzKSB7XG4gIFBvc3RncmVzVHlwZXNbXCJhYnN0aW1lXCJdID0gXCJhYnN0aW1lXCI7XG4gIFBvc3RncmVzVHlwZXNbXCJib29sXCJdID0gXCJib29sXCI7XG4gIFBvc3RncmVzVHlwZXNbXCJkYXRlXCJdID0gXCJkYXRlXCI7XG4gIFBvc3RncmVzVHlwZXNbXCJkYXRlcmFuZ2VcIl0gPSBcImRhdGVyYW5nZVwiO1xuICBQb3N0Z3Jlc1R5cGVzW1wiZmxvYXQ0XCJdID0gXCJmbG9hdDRcIjtcbiAgUG9zdGdyZXNUeXBlc1tcImZsb2F0OFwiXSA9IFwiZmxvYXQ4XCI7XG4gIFBvc3RncmVzVHlwZXNbXCJpbnQyXCJdID0gXCJpbnQyXCI7XG4gIFBvc3RncmVzVHlwZXNbXCJpbnQ0XCJdID0gXCJpbnQ0XCI7XG4gIFBvc3RncmVzVHlwZXNbXCJpbnQ0cmFuZ2VcIl0gPSBcImludDRyYW5nZVwiO1xuICBQb3N0Z3Jlc1R5cGVzW1wiaW50OFwiXSA9IFwiaW50OFwiO1xuICBQb3N0Z3Jlc1R5cGVzW1wiaW50OHJhbmdlXCJdID0gXCJpbnQ4cmFuZ2VcIjtcbiAgUG9zdGdyZXNUeXBlc1tcImpzb25cIl0gPSBcImpzb25cIjtcbiAgUG9zdGdyZXNUeXBlc1tcImpzb25iXCJdID0gXCJqc29uYlwiO1xuICBQb3N0Z3Jlc1R5cGVzW1wibW9uZXlcIl0gPSBcIm1vbmV5XCI7XG4gIFBvc3RncmVzVHlwZXNbXCJudW1lcmljXCJdID0gXCJudW1lcmljXCI7XG4gIFBvc3RncmVzVHlwZXNbXCJvaWRcIl0gPSBcIm9pZFwiO1xuICBQb3N0Z3Jlc1R5cGVzW1wicmVsdGltZVwiXSA9IFwicmVsdGltZVwiO1xuICBQb3N0Z3Jlc1R5cGVzW1widGV4dFwiXSA9IFwidGV4dFwiO1xuICBQb3N0Z3Jlc1R5cGVzW1widGltZVwiXSA9IFwidGltZVwiO1xuICBQb3N0Z3Jlc1R5cGVzW1widGltZXN0YW1wXCJdID0gXCJ0aW1lc3RhbXBcIjtcbiAgUG9zdGdyZXNUeXBlc1tcInRpbWVzdGFtcHR6XCJdID0gXCJ0aW1lc3RhbXB0elwiO1xuICBQb3N0Z3Jlc1R5cGVzW1widGltZXR6XCJdID0gXCJ0aW1ldHpcIjtcbiAgUG9zdGdyZXNUeXBlc1tcInRzcmFuZ2VcIl0gPSBcInRzcmFuZ2VcIjtcbiAgUG9zdGdyZXNUeXBlc1tcInRzdHpyYW5nZVwiXSA9IFwidHN0enJhbmdlXCI7XG59KShQb3N0Z3Jlc1R5cGVzID0gZXhwb3J0cy5Qb3N0Z3Jlc1R5cGVzIHx8IChleHBvcnRzLlBvc3RncmVzVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBjb2x1bW5zIGFuZCBhbiBvYmplY3Qgb2Ygc3RyaW5nIHZhbHVlcyB0aGVuIGNvbnZlcnRzIGVhY2ggc3RyaW5nIHZhbHVlXG4gKiB0byBpdHMgbWFwcGVkIHR5cGUuXG4gKlxuICogQHBhcmFtIHt7bmFtZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9W119IGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBtYXAgb2YgdmFyaW91cyBvcHRpb25zIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIG1hcHBlclxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5za2lwVHlwZXMgVGhlIGFycmF5IG9mIHR5cGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2hhbmdlRGF0YShbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiczMyd9LCB7fSlcbiAqIC8vPT57IGZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAzMyB9XG4gKi9cbnZhciBjb252ZXJ0Q2hhbmdlRGF0YSA9IGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VEYXRhKGNvbHVtbnMsIHJlY29yZCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBfYTtcbiAgdmFyIHNraXBUeXBlcyA9IChfYSA9IG9wdGlvbnMuc2tpcFR5cGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlY29yZCkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJlY19rZXkpIHtcbiAgICBhY2NbcmVjX2tleV0gPSAoMCwgZXhwb3J0cy5jb252ZXJ0Q29sdW1uKShyZWNfa2V5LCBjb2x1bW5zLCByZWNvcmQsIHNraXBUeXBlcyk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTtcbmV4cG9ydHMuY29udmVydENoYW5nZURhdGEgPSBjb252ZXJ0Q2hhbmdlRGF0YTtcbi8qKlxuICogQ29udmVydHMgdGhlIHZhbHVlIG9mIGFuIGluZGl2aWR1YWwgY29sdW1uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5OYW1lIFRoZSBjb2x1bW4gdGhhdCB5b3Ugd2FudCB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1ucyBBbGwgb2YgdGhlIGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQgVGhlIG1hcCBvZiBzdHJpbmcgdmFsdWVzXG4gKiBAcGFyYW0ge0FycmF5fSBza2lwVHlwZXMgQW4gYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICogQHJldHVybiB7b2JqZWN0fSBVc2VsZXNzIGluZm9ybWF0aW9uXG4gKlxuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFtdKVxuICogLy89PiAzM1xuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFsnaW50NCddKVxuICogLy89PiBcIjMzXCJcbiAqL1xudmFyIGNvbnZlcnRDb2x1bW4gPSBmdW5jdGlvbiBjb252ZXJ0Q29sdW1uKGNvbHVtbk5hbWUsIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKSB7XG4gIHZhciBjb2x1bW4gPSBjb2x1bW5zLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geC5uYW1lID09PSBjb2x1bW5OYW1lO1xuICB9KTtcbiAgdmFyIGNvbFR5cGUgPSBjb2x1bW4gPT09IG51bGwgfHwgY29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW4udHlwZTtcbiAgdmFyIHZhbHVlID0gcmVjb3JkW2NvbHVtbk5hbWVdO1xuICBpZiAoY29sVHlwZSAmJiAhc2tpcFR5cGVzLmluY2x1ZGVzKGNvbFR5cGUpKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmNvbnZlcnRDZWxsKShjb2xUeXBlLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG5vb3AodmFsdWUpO1xufTtcbmV4cG9ydHMuY29udmVydENvbHVtbiA9IGNvbnZlcnRDb2x1bW47XG4vKipcbiAqIElmIHRoZSB2YWx1ZSBvZiB0aGUgY2VsbCBpcyBgbnVsbGAsIHJldHVybnMgbnVsbC5cbiAqIE90aGVyd2lzZSBjb252ZXJ0cyB0aGUgc3RyaW5nIHZhbHVlIHRvIHRoZSBjb3JyZWN0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHBvc3RncmVzIGNvbHVtbiB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nVmFsdWUgVGhlIGNlbGwgdmFsdWVcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnYm9vbCcsICd0JylcbiAqIC8vPT4gdHJ1ZVxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2ludDgnLCAnMTAnKVxuICogLy89PiAxMFxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ19pbnQ0JywgJ3sxLDIsMyw0fScpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG52YXIgY29udmVydENlbGwgPSBmdW5jdGlvbiBjb252ZXJ0Q2VsbCh0eXBlLCB2YWx1ZSkge1xuICAvLyBpZiBkYXRhIHR5cGUgaXMgYW4gYXJyYXlcbiAgaWYgKHR5cGUuY2hhckF0KDApID09PSAnXycpIHtcbiAgICB2YXIgZGF0YVR5cGUgPSB0eXBlLnNsaWNlKDEsIHR5cGUubGVuZ3RoKTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMudG9BcnJheSkodmFsdWUsIGRhdGFUeXBlKTtcbiAgfVxuICAvLyBJZiBub3QgbnVsbCwgY29udmVydCB0byBjb3JyZWN0IHR5cGUuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5ib29sOlxuICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnRvQm9vbGVhbikodmFsdWUpO1xuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDQ6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0ODpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50MjpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NDpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50ODpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMubnVtZXJpYzpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMub2lkOlxuICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnRvTnVtYmVyKSh2YWx1ZSk7XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb246XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb25iOlxuICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnRvSnNvbikodmFsdWUpO1xuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXA6XG4gICAgICByZXR1cm4gKDAsIGV4cG9ydHMudG9UaW1lc3RhbXBTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBGb3JtYXQgdG8gYmUgY29uc2lzdGVudCB3aXRoIFBvc3RnUkVTVFxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5hYnN0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMuZGF0ZXJhbmdlOlxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0cmFuZ2U6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDhyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMubW9uZXk6XG4gICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnJlbHRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGV4dDpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXB0ejogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1ldHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudHNyYW5nZTpcbiAgICBjYXNlIFBvc3RncmVzVHlwZXMudHN0enJhbmdlOlxuICAgICAgcmV0dXJuIG5vb3AodmFsdWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciByZW1haW5pbmcgdHlwZXNcbiAgICAgIHJldHVybiBub29wKHZhbHVlKTtcbiAgfVxufTtcbmV4cG9ydHMuY29udmVydENlbGwgPSBjb252ZXJ0Q2VsbDtcbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIHRvQm9vbGVhbiA9IGZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSAndCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdmJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuZXhwb3J0cy50b0Jvb2xlYW4gPSB0b0Jvb2xlYW47XG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwYXJzZWRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0cy50b051bWJlciA9IHRvTnVtYmVyO1xudmFyIHRvSnNvbiA9IGZ1bmN0aW9uIHRvSnNvbih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiSlNPTiBwYXJzZSBlcnJvcjogXCIuY29uY2F0KGVycm9yKSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnRzLnRvSnNvbiA9IHRvSnNvbjtcbi8qKlxuICogQ29udmVydHMgYSBQb3N0Z3JlcyBBcnJheSBpbnRvIGEgbmF0aXZlIEpTIGFycmF5XG4gKlxuICogQGV4YW1wbGUgdG9BcnJheSgne30nLCAnaW50NCcpXG4gKiAvLz0+IFtdXG4gKiBAZXhhbXBsZSB0b0FycmF5KCd7XCJbMjAyMS0wMS0wMSwyMDIxLTEyLTMxKVwiLFwiKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl1cIn0nLCAnZGF0ZXJhbmdlJylcbiAqIC8vPT4gWydbMjAyMS0wMS0wMSwyMDIxLTEyLTMxKScsICcoMjAyMS0wMS0wMSwyMDIxLTEyLTMyXSddXG4gKiBAZXhhbXBsZSB0b0FycmF5KFsxLDIsMyw0XSwgJ2ludDQnKVxuICogLy89PiBbMSwyLDMsNF1cbiAqL1xudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBsYXN0SWR4ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgdmFyIGNsb3NlQnJhY2UgPSB2YWx1ZVtsYXN0SWR4XTtcbiAgdmFyIG9wZW5CcmFjZSA9IHZhbHVlWzBdO1xuICAvLyBDb25maXJtIHZhbHVlIGlzIGEgUG9zdGdyZXMgYXJyYXkgYnkgY2hlY2tpbmcgY3VybHkgYnJhY2tldHNcbiAgaWYgKG9wZW5CcmFjZSA9PT0gJ3snICYmIGNsb3NlQnJhY2UgPT09ICd9Jykge1xuICAgIHZhciBhcnI7XG4gICAgdmFyIHZhbFRyaW0gPSB2YWx1ZS5zbGljZSgxLCBsYXN0SWR4KTtcbiAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uIHRvIHNlcGFyYXRlIFBvc3RncmVzIGFycmF5IGRhdGFcbiAgICB0cnkge1xuICAgICAgYXJyID0gSlNPTi5wYXJzZSgnWycgKyB2YWxUcmltICsgJ10nKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAvLyBXQVJOSU5HOiBzcGxpdHRpbmcgb24gY29tbWEgZG9lcyBub3QgY292ZXIgYWxsIGVkZ2UgY2FzZXNcbiAgICAgIGFyciA9IHZhbFRyaW0gPyB2YWxUcmltLnNwbGl0KCcsJykgOiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmNvbnZlcnRDZWxsKSh0eXBlLCB2YWwpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuLyoqXG4gKiBGaXhlcyB0aW1lc3RhbXAgdG8gYmUgSVNPLTg2MDEuIFN3YXBzIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBkYXRlIGFuZCB0aW1lIGZvciBhICdUJ1xuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9zdXBhYmFzZS9pc3N1ZXMvMThcbiAqXG4gKiBAZXhhbXBsZSB0b1RpbWVzdGFtcFN0cmluZygnMjAxOS0wOS0xMCAwMDowMDowMCcpXG4gKiAvLz0+ICcyMDE5LTA5LTEwVDAwOjAwOjAwJ1xuICovXG52YXIgdG9UaW1lc3RhbXBTdHJpbmcgPSBmdW5jdGlvbiB0b1RpbWVzdGFtcFN0cmluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKCcgJywgJ1QnKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0cy50b1RpbWVzdGFtcFN0cmluZyA9IHRvVGltZXN0YW1wU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRVHM3T3pzN096dEJRVWxCTzBGQlEwRTdRVUZGUVN4SlFVRlpRU3hoUVhsQ1dEdEJRWHBDUkN4WFFVRlpRU3hoUVVGaE8wVkJRM1pDUVN4dlEwRkJiVUk3UlVGRGJrSkJMRGhDUVVGaE8wVkJRMkpCTERoQ1FVRmhPMFZCUTJKQkxIZERRVUYxUWp0RlFVTjJRa0VzYTBOQlFXbENPMFZCUTJwQ1FTeHJRMEZCYVVJN1JVRkRha0pCTERoQ1FVRmhPMFZCUTJKQkxEaENRVUZoTzBWQlEySkJMSGREUVVGMVFqdEZRVU4yUWtFc09FSkJRV0U3UlVGRFlrRXNkME5CUVhWQ08wVkJRM1pDUVN3NFFrRkJZVHRGUVVOaVFTeG5RMEZCWlR0RlFVTm1RU3huUTBGQlpUdEZRVU5tUVN4dlEwRkJiVUk3UlVGRGJrSkJMRFJDUVVGWE8wVkJRMWhCTEc5RFFVRnRRanRGUVVOdVFrRXNPRUpCUVdFN1JVRkRZa0VzT0VKQlFXRTdSVUZEWWtFc2QwTkJRWFZDTzBWQlEzWkNRU3cwUTBGQk1rSTdSVUZETTBKQkxHdERRVUZwUWp0RlFVTnFRa0VzYjBOQlFXMUNPMFZCUTI1Q1FTeDNRMEZCZFVJN1FVRkRla0lzUTBGQlF5eEZRWHBDVjBFc1lVRkJZU3hIUVVGaVF5eHhRa0ZCWVN4TFFVRmlRU3h4UWtGQllUdEJRWGxEZWtJN096czdPenM3T3pzN096dEJRVmxQTEVsQlFVMURMR2xDUVVGcFFpeEhRVUZITEZOQlFYQkNRU3hwUWtGQmFVSXNRMEZETlVKRExFOUJRV2RDTEVWQlEyaENReXhOUVVGakxFVkJSVW83UlVGQlFTeEpRVVJXUXl3NFJVRkJiME1zUlVGQlJUczdSVUZGZEVNc1NVRkJUVU1zVTBGQlV5eEhRVUZITEdGQlFVOHNRMEZCUTBFc1UwRkJVeXh0UTBGQlNTeEZRVUZGTzBWQlJYcERMRTlCUVU5RExFMUJRVTBzUTBGQlEwTXNTVUZCU1N4RFFVRkRTaXhOUVVGTkxFTkJRVU1zUTBGQlEwc3NUVUZCVFN4RFFVRkRMRlZCUVVORExFZEJRVWNzUlVGQlJVTXNUMEZCVHl4RlFVRkpPMGxCUTJwRVJDeEhRVUZITEVOQlFVTkRMRTlCUVU4c1EwRkJReXhIUVVGSExIbENRVUZoTEVWQlFVTkJMRTlCUVU4c1JVRkJSVklzVDBGQlR5eEZRVUZGUXl4TlFVRk5MRVZCUVVWRkxGTkJRVk1zUTBGQlF6dEpRVU5xUlN4UFFVRlBTU3hIUVVGSE8wVkJRMW9zUTBGQlF5eEZRVUZGTEVWQlFWa3NRMEZCUXp0QlFVTnNRaXhEUVVGRE8wRkJXRmxVTEhsQ1FVRnBRanRCUVdFNVFqczdPenM3T3pzN096czdPenM3UVVGalR5eEpRVUZOVnl4aFFVRmhMRWRCUVVjc1UwRkJhRUpCTEdGQlFXRXNRMEZEZUVKRExGVkJRV3RDTEVWQlEyeENWaXhQUVVGblFpeEZRVU5vUWtNc1RVRkJZeXhGUVVOa1JTeFRRVUZ0UWl4RlFVTktPMFZCUTJZc1NVRkJUVkVzVFVGQlRTeEhRVUZIV0N4UFFVRlBMRU5CUVVOWkxFbEJRVWtzUTBGQlF5eFZRVUZEUXl4RFFVRkRPMGxCUVVFc1QwRkJTMEVzUTBGQlF5eERRVUZEUXl4SlFVRkpMRXRCUVV0S0xGVkJRVlU3UlVGQlFTeEZRVUZETzBWQlEzcEVMRWxCUVUxTExFOUJRVThzUjBGQlIwb3NUVUZCVFN4aFFVRk9RU3hOUVVGTkxIVkNRVUZPUVN4TlFVRk5MRU5CUVVWTExFbEJRVWs3UlVGRE5VSXNTVUZCVFVNc1MwRkJTeXhIUVVGSGFFSXNUVUZCVFN4RFFVRkRVeXhWUVVGVkxFTkJRVU03UlVGRmFFTXNTVUZCU1Vzc1QwRkJUeXhKUVVGSkxFTkJRVU5hTEZOQlFWTXNRMEZCUTJVc1VVRkJVU3hEUVVGRFNDeFBRVUZQTEVOQlFVTXNSVUZCUlR0SlFVTXpReXhQUVVGUExIVkNRVUZYTEVWQlFVTkJMRTlCUVU4c1JVRkJSVVVzUzBGQlN5eERRVUZET3p0RlFVZHdReXhQUVVGUFJTeEpRVUZKTEVOQlFVTkdMRXRCUVVzc1EwRkJRenRCUVVOd1FpeERRVUZETzBGQlpsbHVRaXh4UWtGQllUdEJRV2xDTVVJN096czdPenM3T3pzN096czdRVUZoVHl4SlFVRk5jMElzVjBGQlZ5eEhRVUZITEZOQlFXUkJMRmRCUVZjc1EwRkJTVW9zU1VGQldTeEZRVUZGUXl4TFFVRnJRaXhGUVVGcFFqdEZRVU16UlR0RlFVTkJMRWxCUVVsRUxFbEJRVWtzUTBGQlEwc3NUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFZEJRVWNzUlVGQlJUdEpRVU14UWl4SlFVRk5ReXhSUVVGUkxFZEJRVWRPTEVsQlFVa3NRMEZCUTA4c1MwRkJTeXhEUVVGRExFTkJRVU1zUlVGQlJWQXNTVUZCU1N4RFFVRkRVU3hOUVVGTkxFTkJRVU03U1VGRE0wTXNUMEZCVHl4dFFrRkJUeXhGUVVGRFVDeExRVUZMTEVWQlFVVkxMRkZCUVZFc1EwRkJRenM3UlVGSGFrTTdSVUZEUVN4UlFVRlJUaXhKUVVGSk8wbEJRMVlzUzBGQlMyNUNMR0ZCUVdFc1EwRkJRelJDTEVsQlFVazdUVUZEY2tJc1QwRkJUeXh4UWtGQlV5eEZRVUZEVWl4TFFVRkxMRU5CUVVNN1NVRkRla0lzUzBGQlMzQkNMR0ZCUVdFc1EwRkJRelpDTEUxQlFVMDdTVUZEZWtJc1MwRkJTemRDTEdGQlFXRXNRMEZCUXpoQ0xFMUJRVTA3U1VGRGVrSXNTMEZCU3psQ0xHRkJRV0VzUTBGQlF5dENMRWxCUVVrN1NVRkRka0lzUzBGQlN5OUNMR0ZCUVdFc1EwRkJRMmRETEVsQlFVazdTVUZEZGtJc1MwRkJTMmhETEdGQlFXRXNRMEZCUTJsRExFbEJRVWs3U1VGRGRrSXNTMEZCUzJwRExHRkJRV0VzUTBGQlEydERMRTlCUVU4N1NVRkRNVUlzUzBGQlMyeERMR0ZCUVdFc1EwRkJRMjFETEVkQlFVYzdUVUZEY0VJc1QwRkJUeXh2UWtGQlVTeEZRVUZEWml4TFFVRkxMRU5CUVVNN1NVRkRlRUlzUzBGQlMzQkNMR0ZCUVdFc1EwRkJRMjlETEVsQlFVazdTVUZEZGtJc1MwRkJTM0JETEdGQlFXRXNRMEZCUTNGRExFdEJRVXM3VFVGRGRFSXNUMEZCVHl4clFrRkJUU3hGUVVGRGFrSXNTMEZCU3l4RFFVRkRPMGxCUTNSQ0xFdEJRVXR3UWl4aFFVRmhMRU5CUVVOelF5eFRRVUZUTzAxQlF6RkNMRTlCUVU4c05rSkJRV2xDTEVWQlFVTnNRaXhMUVVGTExFTkJRVU03U1VGQlF6dEpRVU5zUXl4TFFVRkxjRUlzWVVGQllTeERRVUZEZFVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRE5VSXNTMEZCUzNaRExHRkJRV0VzUTBGQlEzZERMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRM3BDTEV0QlFVdDRReXhoUVVGaExFTkJRVU41UXl4VFFVRlRPMGxCUXpWQ0xFdEJRVXQ2UXl4aFFVRmhMRU5CUVVNd1F5eFRRVUZUTzBsQlF6VkNMRXRCUVVzeFF5eGhRVUZoTEVOQlFVTXlReXhUUVVGVE8wbEJRelZDTEV0QlFVc3pReXhoUVVGaExFTkJRVU0wUXl4TFFVRkxPMGxCUTNoQ0xFdEJRVXMxUXl4aFFVRmhMRU5CUVVNMlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTTFRaXhMUVVGTE4wTXNZVUZCWVN4RFFVRkRPRU1zU1VGQlNUdEpRVU4yUWl4TFFVRkxPVU1zWVVGQllTeERRVUZESzBNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRGVrSXNTMEZCU3k5RExHRkJRV0VzUTBGQlEyZEVMRmRCUVZjc1EwRkJReXhEUVVGRE8wbEJRMmhETEV0QlFVdG9SQ3hoUVVGaExFTkJRVU5wUkN4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVNelFpeExRVUZMYWtRc1lVRkJZU3hEUVVGRGEwUXNUMEZCVHp0SlFVTXhRaXhMUVVGTGJFUXNZVUZCWVN4RFFVRkRiVVFzVTBGQlV6dE5RVU14UWl4UFFVRlBOMElzU1VGQlNTeERRVUZEUml4TFFVRkxMRU5CUVVNN1NVRkRjRUk3VFVGRFJUdE5RVU5CTEU5QlFVOUZMRWxCUVVrc1EwRkJRMFlzUzBGQlN5eERRVUZETzBWQlFVRTdRVUZGZUVJc1EwRkJRenRCUVRGRFdXNUNMRzFDUVVGWE8wRkJORU40UWl4SlFVRk5jVUlzU1VGQlNTeEhRVUZITEZOQlFWQkJMRWxCUVVrc1EwRkJTVVlzUzBGQmEwSXNSVUZCYVVJN1JVRkRMME1zVDBGQlQwRXNTMEZCU3p0QlFVTmtMRU5CUVVNN1FVRkRUU3hKUVVGTlowTXNVMEZCVXl4SFFVRkhMRk5CUVZwQkxGTkJRVk1zUTBGQlNXaERMRXRCUVd0Q0xFVkJRV2xDTzBWQlF6TkVMRkZCUVZGQkxFdEJRVXM3U1VGRFdDeExRVUZMTEVkQlFVYzdUVUZEVGl4UFFVRlBMRWxCUVVrN1NVRkRZaXhMUVVGTExFZEJRVWM3VFVGRFRpeFBRVUZQTEV0QlFVczdTVUZEWkR0TlFVTkZMRTlCUVU5QkxFdEJRVXM3UlVGQlFUdEJRVVZzUWl4RFFVRkRPMEZCVkZsdVFpeHBRa0ZCVXp0QlFWVm1MRWxCUVUxdlJDeFJRVUZSTEVkQlFVY3NVMEZCV0VFc1VVRkJVU3hEUVVGSmFrTXNTMEZCYTBJc1JVRkJhVUk3UlVGRE1VUXNTVUZCU1N4UFFVRlBRU3hMUVVGTExFdEJRVXNzVVVGQlVTeEZRVUZGTzBsQlF6ZENMRWxCUVUxclF5eFhRVUZYTEVkQlFVZERMRlZCUVZVc1EwRkJRMjVETEV0QlFVc3NRMEZCUXp0SlFVTnlReXhKUVVGSkxFTkJRVU52UXl4TlFVRk5MRU5CUVVORExFdEJRVXNzUTBGQlEwZ3NWMEZCVnl4RFFVRkRMRVZCUVVVN1RVRkRPVUlzVDBGQlQwRXNWMEZCVnpzN08wVkJSM1JDTEU5QlFVOXNReXhMUVVGTE8wRkJRMlFzUTBGQlF6dEJRVkpaYmtJc1owSkJRVkU3UVVGVFpDeEpRVUZOZVVRc1RVRkJUU3hIUVVGSExGTkJRVlJCTEUxQlFVMHNRMEZCU1hSRExFdEJRV3RDTEVWQlFXbENPMFZCUTNoRUxFbEJRVWtzVDBGQlQwRXNTMEZCU3l4TFFVRkxMRkZCUVZFc1JVRkJSVHRKUVVNM1FpeEpRVUZKTzAxQlEwWXNUMEZCVDNWRExFbEJRVWtzUTBGQlEwTXNTMEZCU3l4RFFVRkRlRU1zUzBGQlN5eERRVUZETzB0QlEzcENMRU5CUVVNc1QwRkJUM2xETEV0QlFVc3NSVUZCUlR0TlFVTmtReXhQUVVGUExFTkJRVU5ETEVkQlFVY3NOa0pCUVhOQ1JpeExRVUZMTEVWQlFVYzdUVUZEZWtNc1QwRkJUM3BETEV0QlFVczdPenRGUVVkb1FpeFBRVUZQUVN4TFFVRkxPMEZCUTJRc1EwRkJRenRCUVZaWmJrSXNZMEZCVFR0QlFWbHVRanM3T3pzN096czdPenRCUVZWUExFbEJRVTByUkN4UFFVRlBMRWRCUVVjc1UwRkJWa0VzVDBGQlR5eERRVUZKTlVNc1MwRkJhMElzUlVGQlJVUXNTVUZCV1N4RlFVRnBRanRGUVVOMlJTeEpRVUZKTEU5QlFVOURMRXRCUVVzc1MwRkJTeXhSUVVGUkxFVkJRVVU3U1VGRE4wSXNUMEZCVDBFc1MwRkJTenM3UlVGSFpDeEpRVUZOTmtNc1QwRkJUeXhIUVVGSE4wTXNTMEZCU3l4RFFVRkRUeXhOUVVGTkxFZEJRVWNzUTBGQlF6dEZRVU5vUXl4SlFVRk5kVU1zVlVGQlZTeEhRVUZIT1VNc1MwRkJTeXhEUVVGRE5rTXNUMEZCVHl4RFFVRkRPMFZCUTJwRExFbEJRVTFGTEZOQlFWTXNSMEZCUnk5RExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdSVUZGTVVJN1JVRkRRU3hKUVVGSkswTXNVMEZCVXl4TFFVRkxMRWRCUVVjc1NVRkJTVVFzVlVGQlZTeExRVUZMTEVkQlFVY3NSVUZCUlR0SlFVTXpReXhKUVVGSlJTeEhRVUZITzBsQlExQXNTVUZCVFVNc1QwRkJUeXhIUVVGSGFrUXNTMEZCU3l4RFFVRkRUU3hMUVVGTExFTkJRVU1zUTBGQlF5eEZRVUZGZFVNc1QwRkJUeXhEUVVGRE8wbEJSWFpETzBsQlEwRXNTVUZCU1R0TlFVTkdSeXhIUVVGSExFZEJRVWRVTEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhEUVVGRExFZEJRVWNzUjBGQlIxTXNUMEZCVHl4SFFVRkhMRWRCUVVjc1EwRkJRenRMUVVOMFF5eERRVUZETEU5QlFVOURMRU5CUVVNc1JVRkJSVHROUVVOV08wMUJRMEZHTEVkQlFVY3NSMEZCUjBNc1QwRkJUeXhIUVVGSFFTeFBRVUZQTEVOQlFVTkZMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eEZRVUZGT3p0SlFVZDZReXhQUVVGUFNDeEhRVUZITEVOQlFVTkpMRWRCUVVjc1EwRkJReXhWUVVGRFF5eEhRVUZqTzAxQlFVRXNUMEZCU3l4MVFrRkJWeXhGUVVGRGRFUXNTVUZCU1N4RlFVRkZjMFFzUjBGQlJ5eERRVUZETzBsQlFVRXNSVUZCUXpzN1JVRkhOVVFzVDBGQlQzSkVMRXRCUVVzN1FVRkRaQ3hEUVVGRE8wRkJNVUpaYmtJc1pVRkJUenRCUVRSQ2NFSTdPenM3T3pzN1FVRlBUeXhKUVVGTmVVVXNhVUpCUVdsQ0xFZEJRVWNzVTBGQmNFSkJMR2xDUVVGcFFpeERRVUZKZEVRc1MwRkJhMElzUlVGQmFVSTdSVUZEYmtVc1NVRkJTU3hQUVVGUFFTeExRVUZMTEV0QlFVc3NVVUZCVVN4RlFVRkZPMGxCUXpkQ0xFOUJRVTlCTEV0QlFVc3NRMEZCUTNWRUxFOUJRVThzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRPenRGUVVkb1F5eFBRVUZQZGtRc1MwRkJTenRCUVVOa0xFTkJRVU03UVVGT1dXNUNMSGxDUVVGcFFpSXNJbTVoYldWeklqcGJJbEJ2YzNSbmNtVnpWSGx3WlhNaUxDSmxlSEJ2Y25Seklpd2lZMjl1ZG1WeWRFTm9ZVzVuWlVSaGRHRWlMQ0pqYjJ4MWJXNXpJaXdpY21WamIzSmtJaXdpYjNCMGFXOXVjeUlzSW5OcmFYQlVlWEJsY3lJc0lrOWlhbVZqZENJc0ltdGxlWE1pTENKeVpXUjFZMlVpTENKaFkyTWlMQ0p5WldOZmEyVjVJaXdpWTI5dWRtVnlkRU52YkhWdGJpSXNJbU52YkhWdGJrNWhiV1VpTENKamIyeDFiVzRpTENKbWFXNWtJaXdpZUNJc0ltNWhiV1VpTENKamIyeFVlWEJsSWl3aWRIbHdaU0lzSW5aaGJIVmxJaXdpYVc1amJIVmtaWE1pTENKdWIyOXdJaXdpWTI5dWRtVnlkRU5sYkd3aUxDSmphR0Z5UVhRaUxDSmtZWFJoVkhsd1pTSXNJbk5zYVdObElpd2liR1Z1WjNSb0lpd2lZbTl2YkNJc0ltWnNiMkYwTkNJc0ltWnNiMkYwT0NJc0ltbHVkRElpTENKcGJuUTBJaXdpYVc1ME9DSXNJbTUxYldWeWFXTWlMQ0p2YVdRaUxDSnFjMjl1SWl3aWFuTnZibUlpTENKMGFXMWxjM1JoYlhBaUxDSmhZbk4wYVcxbElpd2laR0YwWlNJc0ltUmhkR1Z5WVc1blpTSXNJbWx1ZERSeVlXNW5aU0lzSW1sdWREaHlZVzVuWlNJc0ltMXZibVY1SWl3aWNtVnNkR2x0WlNJc0luUmxlSFFpTENKMGFXMWxJaXdpZEdsdFpYTjBZVzF3ZEhvaUxDSjBhVzFsZEhvaUxDSjBjM0poYm1kbElpd2lkSE4wZW5KaGJtZGxJaXdpZEc5Q2IyOXNaV0Z1SWl3aWRHOU9kVzFpWlhJaUxDSndZWEp6WldSV1lXeDFaU0lzSW5CaGNuTmxSbXh2WVhRaUxDSk9kVzFpWlhJaUxDSnBjMDVoVGlJc0luUnZTbk52YmlJc0lrcFRUMDRpTENKd1lYSnpaU0lzSW1WeWNtOXlJaXdpWTI5dWMyOXNaU0lzSW14dlp5SXNJblJ2UVhKeVlYa2lMQ0pzWVhOMFNXUjRJaXdpWTJ4dmMyVkNjbUZqWlNJc0ltOXdaVzVDY21GalpTSXNJbUZ5Y2lJc0luWmhiRlJ5YVcwaUxDSmZJaXdpYzNCc2FYUWlMQ0p0WVhBaUxDSjJZV3dpTENKMGIxUnBiV1Z6ZEdGdGNGTjBjbWx1WnlJc0luSmxjR3hoWTJVaVhTd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZjM0pqTDJ4cFlpOTBjbUZ1YzJadmNtMWxjbk11ZEhNaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sdHVkV3hzWFgwPSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gJzIuMS4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3TzBGQlFXRkJMR1ZCUVU4c1IwRkJSeUlzSW01aGJXVnpJanBiSW1WNGNHOXlkSE1pWFN3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dmMzSmpMMnhwWWk5MlpYSnphVzl1TG5SeklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJiblZzYkYxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdm9pZCAwICYmICh2b2lkIDApLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlN0b3JhZ2VDbGllbnQgPSB2b2lkIDA7XG52YXIgU3RvcmFnZUZpbGVBcGlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYWNrYWdlcy9TdG9yYWdlRmlsZUFwaVwiKSk7XG52YXIgU3RvcmFnZUJ1Y2tldEFwaV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhY2thZ2VzL1N0b3JhZ2VCdWNrZXRBcGlcIikpO1xudmFyIFN0b3JhZ2VDbGllbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdG9yYWdlQnVja2V0QXBpXzEkZCkge1xuICBfaW5oZXJpdHMoU3RvcmFnZUNsaWVudCwgX1N0b3JhZ2VCdWNrZXRBcGlfMSRkKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTdG9yYWdlQ2xpZW50KTtcbiAgZnVuY3Rpb24gU3RvcmFnZUNsaWVudCh1cmwpIHtcbiAgICB2YXIgaGVhZGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGZldGNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0b3JhZ2VDbGllbnQpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB1cmwsIGhlYWRlcnMsIGZldGNoKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBmaWxlIG9wZXJhdGlvbiBpbiBhIGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtIGlkIFRoZSBidWNrZXQgaWQgdG8gb3BlcmF0ZSBvbi5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhTdG9yYWdlQ2xpZW50LCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oaWQpIHtcbiAgICAgIHJldHVybiBuZXcgU3RvcmFnZUZpbGVBcGlfMVtcImRlZmF1bHRcIl0odGhpcy51cmwsIHRoaXMuaGVhZGVycywgaWQsIHRoaXMuZmV0Y2gpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RvcmFnZUNsaWVudDtcbn0oU3RvcmFnZUJ1Y2tldEFwaV8xW1wiZGVmYXVsdFwiXSk7XG5leHBvcnRzLlN0b3JhZ2VDbGllbnQgPSBTdG9yYWdlQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPMEZCUVVFN1FVRkRRVHRCUVVFd1JDeEpRVWMzUTBFc1lVRkJZenRGUVVGQk8wVkJRVUU3UlVGRGVrSXNkVUpCUVZsRExFZEJRVmNzUlVGQmQwUTdTVUZCUVN4SlFVRjBSRU1zT0VWQlFYRkRMRVZCUVVVN1NVRkJRU3hKUVVGRlF5eExRVUZoTzBsQlFVRTdTVUZCUVN4NVFrRkRka1ZHTEVkQlFVY3NSVUZCUlVNc1QwRkJUeXhGUVVGRlF5eExRVUZMTzBWQlF6TkNPMFZCUlVFN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJTMEVzWTBGQlMwTXNSVUZCVlR0TlFVTmlMRTlCUVU4c1NVRkJTVU1zTWtKQlFXTXNRMEZCUXl4SlFVRkpMRU5CUVVOS0xFZEJRVWNzUlVGQlJTeEpRVUZKTEVOQlFVTkRMRTlCUVU4c1JVRkJSVVVzUlVGQlJTeEZRVUZGTEVsQlFVa3NRMEZCUTBRc1MwRkJTeXhEUVVGRE8wbEJRMjVGTzBWQlFVTTdSVUZCUVR0QlFVRkJMRVZCV21kRFJ5dzJRa0ZCWjBJN1FVRkJia1JESWl3aWJtRnRaWE1pT2xzaVUzUnZjbUZuWlVOc2FXVnVkQ0lzSW5WeWJDSXNJbWhsWVdSbGNuTWlMQ0ptWlhSamFDSXNJbWxrSWl3aVUzUnZjbUZuWlVacGJHVkJjR2xmTVNJc0lsTjBiM0poWjJWQ2RXTnJaWFJCY0dsZk1TSXNJbVY0Y0c5eWRITWlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDFOMGIzSmhaMlZEYkdsbGJuUXVkSE1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2x0dWRXeHNYWDA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICBkZXNjID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xudmFyIF9fZXhwb3J0U3RhciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2V4cG9ydFN0YXIgfHwgZnVuY3Rpb24gKG0sIGV4cG9ydHMpIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlN0b3JhZ2VDbGllbnQgPSB2b2lkIDA7XG52YXIgU3RvcmFnZUNsaWVudF8xID0gcmVxdWlyZShcIi4vU3RvcmFnZUNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0b3JhZ2VDbGllbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gU3RvcmFnZUNsaWVudF8xLlN0b3JhZ2VDbGllbnQ7XG4gIH1cbn0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi90eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096dEJRVUZCTzBGQlFWTkJPMFZCUVVGRE8wVkJRVUZETzBsQlFVRXNiME5CUVdFN1JVRkJRVHRCUVVGQk8wRkJRM1JDUXp0QlFVTkJRU0lzSW01aGJXVnpJanBiSWs5aWFtVmpkQ0lzSW1WdWRXMWxjbUZpYkdVaUxDSm5aWFFpTENKZlgyVjRjRzl5ZEZOMFlYSWlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJsdVpHVjRMblJ6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYmJuVnNiRjE5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRFRkFVTFRfSEVBREVSUyA9IHZvaWQgMDtcbnZhciB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuZXhwb3J0cy5ERUZBVUxUX0hFQURFUlMgPSB7XG4gICdYLUNsaWVudC1JbmZvJzogXCJzdG9yYWdlLWpzL1wiLmNvbmNhdCh2ZXJzaW9uXzEudmVyc2lvbilcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN08wRkJRVUU3UVVGRFlVRXNkVUpCUVdVc1IwRkJSenRGUVVGRkxHVkJRV1VzZFVKQlFXZENReXhwUWtGQlR6dEJRVUZGTEVOQlFVVWlMQ0p1WVcxbGN5STZXeUpsZUhCdmNuUnpJaXdpZG1WeWMybHZibDh4SWwwc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTlzYVdJdlkyOXVjM1JoYm5SekxuUnpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiYm5Wc2JGMTkiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TdG9yYWdlVW5rbm93bkVycm9yID0gZXhwb3J0cy5TdG9yYWdlQXBpRXJyb3IgPSBleHBvcnRzLmlzU3RvcmFnZUVycm9yID0gZXhwb3J0cy5TdG9yYWdlRXJyb3IgPSB2b2lkIDA7XG52YXIgU3RvcmFnZUVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFN0b3JhZ2VFcnJvciwgX0Vycm9yKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTdG9yYWdlRXJyb3IpO1xuICBmdW5jdGlvbiBTdG9yYWdlRXJyb3IobWVzc2FnZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmFnZUVycm9yKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLl9faXNTdG9yYWdlRXJyb3IgPSB0cnVlO1xuICAgIF90aGlzLm5hbWUgPSAnU3RvcmFnZUVycm9yJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTdG9yYWdlRXJyb3IpO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbmV4cG9ydHMuU3RvcmFnZUVycm9yID0gU3RvcmFnZUVycm9yO1xuZnVuY3Rpb24gaXNTdG9yYWdlRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIF90eXBlb2YoZXJyb3IpID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc1N0b3JhZ2VFcnJvcicgaW4gZXJyb3I7XG59XG5leHBvcnRzLmlzU3RvcmFnZUVycm9yID0gaXNTdG9yYWdlRXJyb3I7XG52YXIgU3RvcmFnZUFwaUVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3RvcmFnZUVycm9yKSB7XG4gIF9pbmhlcml0cyhTdG9yYWdlQXBpRXJyb3IsIF9TdG9yYWdlRXJyb3IpO1xuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihTdG9yYWdlQXBpRXJyb3IpO1xuICBmdW5jdGlvbiBTdG9yYWdlQXBpRXJyb3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgdmFyIF90aGlzMjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmFnZUFwaUVycm9yKTtcbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgX3RoaXMyLm5hbWUgPSAnU3RvcmFnZUFwaUVycm9yJztcbiAgICBfdGhpczIuc3RhdHVzID0gc3RhdHVzO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFN0b3JhZ2VBcGlFcnJvciwgW3tcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RvcmFnZUFwaUVycm9yO1xufShTdG9yYWdlRXJyb3IpO1xuZXhwb3J0cy5TdG9yYWdlQXBpRXJyb3IgPSBTdG9yYWdlQXBpRXJyb3I7XG52YXIgU3RvcmFnZVVua25vd25FcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0b3JhZ2VFcnJvcjIpIHtcbiAgX2luaGVyaXRzKFN0b3JhZ2VVbmtub3duRXJyb3IsIF9TdG9yYWdlRXJyb3IyKTtcbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoU3RvcmFnZVVua25vd25FcnJvcik7XG4gIGZ1bmN0aW9uIFN0b3JhZ2VVbmtub3duRXJyb3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuICAgIHZhciBfdGhpczM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0b3JhZ2VVbmtub3duRXJyb3IpO1xuICAgIF90aGlzMyA9IF9zdXBlcjMuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBfdGhpczMubmFtZSA9ICdTdG9yYWdlVW5rbm93bkVycm9yJztcbiAgICBfdGhpczMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFN0b3JhZ2VVbmtub3duRXJyb3IpO1xufShTdG9yYWdlRXJyb3IpO1xuZXhwb3J0cy5TdG9yYWdlVW5rbm93bkVycm9yID0gU3RvcmFnZVVua25vd25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenRKUVVGaFFTeFpRVUZoTzBWQlFVRTdSVUZCUVR0RlFVZDRRaXh6UWtGQldVTXNUMEZCWlR0SlFVRkJPMGxCUVVFN1NVRkRla0lzTUVKQlFVMUJMRTlCUVU4N1NVRklUQ3h6UWtGQlowSXNSMEZCUnl4SlFVRkpPMGxCU1M5Q0xFMUJRVXRETEVsQlFVa3NSMEZCUnl4alFVRmpPMGxCUVVFN1JVRkROVUk3UlVGQlF6dEJRVUZCTEdsRFFVNHJRa01zUzBGQlN6dEJRVUYyUTBNN1FVRlRRU3hUUVVGblFrTXNZMEZCWXl4RFFVRkRReXhMUVVGak8wVkJRek5ETEU5QlFVOHNVVUZCVDBFc1MwRkJTeXhOUVVGTExGRkJRVkVzU1VGQlNVRXNTMEZCU3l4TFFVRkxMRWxCUVVrc1NVRkJTU3hyUWtGQmEwSXNTVUZCU1VFc1MwRkJTenRCUVVOdVJqdEJRVVpCUmp0QlFVVkRMRWxCUlZsSExHVkJRV2RDTzBWQlFVRTdSVUZCUVR0RlFVY3pRaXg1UWtGQldVNHNUMEZCWlN4RlFVRkZUeXhOUVVGak8wbEJRVUU3U1VGQlFUdEpRVU42UXl3MFFrRkJUVkFzVDBGQlR6dEpRVU5pTEU5QlFVdERMRWxCUVVrc1IwRkJSeXhwUWtGQmFVSTdTVUZETjBJc1QwRkJTMDBzVFVGQlRTeEhRVUZIUVN4TlFVRk5PMGxCUVVFN1JVRkRkRUk3UlVGQlF6dEpRVUZCTzBsQlFVRXNUMEZGUkN4clFrRkJUVHROUVVOS0xFOUJRVTg3VVVGRFRFNHNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJRMEVzU1VGQlNUdFJRVU5tUkN4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFTeFBRVUZQTzFGQlEzSkNUeXhOUVVGTkxFVkJRVVVzU1VGQlNTeERRVUZEUVR0UFFVTmtPMGxCUTBnN1JVRkJRenRGUVVGQk8wRkJRVUVzUlVGbWEwTlNMRmxCUVZrN1FVRkJha1JKTzBGQlowSkRMRWxCUlZsTExHMUNRVUZ2UWp0RlFVRkJPMFZCUVVFN1JVRkhMMElzTmtKQlFWbFNMRTlCUVdVc1JVRkJSVk1zWVVGQmMwSTdTVUZCUVR0SlFVRkJPMGxCUTJwRUxEUkNRVUZOVkN4UFFVRlBPMGxCUTJJc1QwRkJTME1zU1VGQlNTeEhRVUZITEhGQ1FVRnhRanRKUVVOcVF5eFBRVUZMVVN4aFFVRmhMRWRCUVVkQkxHRkJRV0U3U1VGQlFUdEZRVU53UXp0RlFVRkRPMEZCUVVFc1JVRlFjME5XTEZsQlFWazdRVUZCY2tSSklpd2libUZ0WlhNaU9sc2lVM1J2Y21GblpVVnljbTl5SWl3aWJXVnpjMkZuWlNJc0ltNWhiV1VpTENKRmNuSnZjaUlzSW1WNGNHOXlkSE1pTENKcGMxTjBiM0poWjJWRmNuSnZjaUlzSW1WeWNtOXlJaXdpVTNSdmNtRm5aVUZ3YVVWeWNtOXlJaXdpYzNSaGRIVnpJaXdpVTNSdmNtRm5aVlZ1YTI1dmQyNUZjbkp2Y2lJc0ltOXlhV2RwYm1Gc1JYSnliM0lpWFN3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dmMzSmpMMnhwWWk5bGNuSnZjbk11ZEhNaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sdHVkV3hzWFgwPSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxudmFyIF9fYXdhaXRlciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZW1vdmUgPSBleHBvcnRzLnB1dCA9IGV4cG9ydHMucG9zdCA9IGV4cG9ydHMuZ2V0ID0gdm9pZCAwO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG52YXIgX2dldEVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIF9nZXRFcnJvck1lc3NhZ2UoZXJyKSB7XG4gIHJldHVybiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbn07XG52YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgcmVqZWN0KSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgdmFyIFJlcztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICByZXR1cm4gKDAsIGhlbHBlcnNfMS5yZXNvbHZlUmVzcG9uc2UpKCk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBSZXMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJlcykge1xuICAgICAgICAgICAgZXJyb3IuanNvbigpLnRoZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9yc18xLlN0b3JhZ2VBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIGVycm9yLnN0YXR1cyB8fCA1MDApKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IGVycm9yc18xLlN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG59O1xudmFyIF9nZXRSZXF1ZXN0UGFyYW1zID0gZnVuY3Rpb24gX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gIHZhciBwYXJhbXMgPSB7XG4gICAgbWV0aG9kOiBtZXRob2QsXG4gICAgaGVhZGVyczogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSB8fCB7fVxuICB9O1xuICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgcGFyYW1zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmZXRjaGVyKHVybCwgX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0Lm9rKSB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qc29uKCk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycm9yLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGdldChmZXRjaGVyLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnR0VUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzKTtcbiAgfSkpO1xufVxuZXhwb3J0cy5nZXQgPSBnZXQ7XG5mdW5jdGlvbiBwb3N0KGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQT1NUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xufVxuZXhwb3J0cy5wb3N0ID0gcG9zdDtcbmZ1bmN0aW9uIHB1dChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnUFVUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1KTtcbiAgfSkpO1xufVxuZXhwb3J0cy5wdXQgPSBwdXQ7XG5mdW5jdGlvbiByZW1vdmUoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNigpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0RFTEVURScsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNik7XG4gIH0pKTtcbn1cbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3UVVGQlFUdEJRVU5CTzBGQlkwRXNTVUZCVFVFc1owSkJRV2RDTEVkQlFVY3NVMEZCYmtKQkxHZENRVUZuUWl4RFFVRkpReXhIUVVGUk8wVkJRVUVzVDBGRGFFTkJMRWRCUVVjc1EwRkJRME1zUjBGQlJ5eEpRVUZKUkN4SFFVRkhMRU5CUVVORkxFOUJRVThzU1VGQlNVWXNSMEZCUnl4RFFVRkRSeXhwUWtGQmFVSXNTVUZCU1Vnc1IwRkJSeXhEUVVGRFNTeExRVUZMTEVsQlFVbERMRWxCUVVrc1EwRkJRME1zVTBGQlV5eERRVUZEVGl4SFFVRkhMRU5CUVVNN1FVRkJRVHRCUVVWeVJpeEpRVUZOVHl4WFFVRlhMRWRCUVVjc1UwRkJaRUVzVjBGQlZ5eERRVUZWU0N4TFFVRmpMRVZCUVVWSkxFMUJRVGhDTzBWQlFVRXNUMEZCU1VNN1NVRkJRVHRKUVVGQk8wMUJRVUU3VVVGQlFUdFZRVUZCTzFWQlF5OUVMRTlCUVUwc05rSkJRV1VzUjBGQlJUdFJRVUZCTzFWQlFUZENReXhIUVVGSE8xVkJSVlFzU1VGQlNVNHNTMEZCU3l4WlFVRlpUU3hIUVVGSExFVkJRVVU3V1VGRGVFSk9MRXRCUVVzc1EwRkJRMDhzU1VGQlNTeEZRVUZGTEVOQlFVTkRMRWxCUVVrc1EwRkJReXhWUVVGRFdpeEhRVUZITEVWQlFVazdZMEZEZUVKUkxFMUJRVTBzUTBGQlF5eEpRVUZKU3l4M1FrRkJaU3hEUVVGRFpDeG5Ra0ZCWjBJc1EwRkJRME1zUjBGQlJ5eERRVUZETEVWQlFVVkpMRXRCUVVzc1EwRkJRMVVzVFVGQlRTeEpRVUZKTEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUTNwRkxFTkJRVU1zUTBGQlF6dFhRVU5JTEUxQlFVMDdXVUZEVEU0c1RVRkJUU3hEUVVGRExFbEJRVWxMTERSQ1FVRnRRaXhEUVVGRFpDeG5Ra0ZCWjBJc1EwRkJRMHNzUzBGQlN5eERRVUZETEVWQlFVVkJMRXRCUVVzc1EwRkJReXhEUVVGRE96dFJRVU5vUlR0UlFVRkJPMVZCUVVFN1RVRkJRVHRKUVVGQk8wVkJRVUVzUTBGRFJqdEJRVUZCTzBGQlJVUXNTVUZCVFZjc2FVSkJRV2xDTEVkQlFVY3NVMEZCY0VKQkxHbENRVUZwUWl4RFFVTnlRa01zVFVGQmVVSXNSVUZEZWtKRExFOUJRWE5DTEVWQlEzUkNReXhWUVVFMFFpeEZRVU0xUWtNc1NVRkJZU3hGUVVOWU8wVkJRMFlzU1VGQlRVTXNUVUZCVFN4SFFVRjVRanRKUVVGRlNpeE5RVUZOTEVWQlFVNUJMRTFCUVUwN1NVRkJSVXNzVDBGQlR5eEZRVUZGTEZGQlFVOHNZVUZCVUVvc1QwRkJUeXgxUWtGQlVFRXNUMEZCVHl4RFFVRkZTU3hQUVVGUExFdEJRVWs3UlVGQlJTeERRVUZGTzBWQlJXaEdMRWxCUVVsTUxFMUJRVTBzUzBGQlN5eExRVUZMTEVWQlFVVTdTVUZEY0VJc1QwRkJUMGtzVFVGQlRUczdSVUZIWmtFc1RVRkJUU3hEUVVGRFF5eFBRVUZQTzBsQlFVc3NZMEZCWXl4RlFVRkZPMFZCUVd0Q0xFZEJRVXRLTEU5QlFVOHNZVUZCVUVFc1QwRkJUeXgxUWtGQlVFRXNUMEZCVHl4RFFVRkZTU3hQUVVGUExFTkJRVVU3UlVGRE5VVkVMRTFCUVUwc1EwRkJRMFFzU1VGQlNTeEhRVUZIWkN4SlFVRkpMRU5CUVVORExGTkJRVk1zUTBGQlEyRXNTVUZCU1N4RFFVRkRPMFZCUTJ4RExIVkRRVUZaUXl4TlFVRk5MRWRCUVV0R0xGVkJRVlU3UVVGRGJrTXNRMEZCUXp0QlFVVkVMRk5CUVdWSkxHTkJRV01zUTBGRE0wSkRMRTlCUVdNc1JVRkRaRkFzVFVGQmVVSXNSVUZEZWtKUkxFZEJRVmNzUlVGRFdGQXNUMEZCYzBJc1JVRkRkRUpETEZWQlFUUkNMRVZCUXpWQ1F5eEpRVUZoT3pzN096czBRMEZGVGl4SlFVRkpUU3hQUVVGUExFTkJRVU1zVlVGQlEwTXNUMEZCVHl4RlFVRkZiRUlzVFVGQlRTeEZRVUZKTzFsQlEzSkRaU3hQUVVGUExFTkJRVU5ETEVkQlFVY3NSVUZCUlZRc2FVSkJRV2xDTEVOQlFVTkRMRTFCUVUwc1JVRkJSVU1zVDBGQlR5eEZRVUZGUXl4VlFVRlZMRVZCUVVWRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlF5OUVVQ3hKUVVGSkxFTkJRVU1zVlVGQlEyVXNUVUZCVFN4RlFVRkpPMk5CUTJZc1NVRkJTU3hEUVVGRFFTeE5RVUZOTEVOQlFVTkRMRVZCUVVVc1JVRkJSU3hOUVVGTlJDeE5RVUZOTzJOQlF6VkNMRWxCUVVsV0xFOUJRVThzWVVGQlVFRXNUMEZCVHl4MVFrRkJVRUVzVDBGQlR5eERRVUZGV1N4aFFVRmhMRVZCUVVVc1QwRkJUMFlzVFVGQlRUdGpRVU42UXl4UFFVRlBRU3hOUVVGTkxFTkJRVU5vUWl4SlFVRkpMRVZCUVVVN1dVRkRkRUlzUTBGQlF5eERRVUZETEVOQlEwUkRMRWxCUVVrc1EwRkJReXhWUVVGRGEwSXNTVUZCU1R0alFVRkJMRTlCUVV0S0xFOUJRVThzUTBGQlEwa3NTVUZCU1N4RFFVRkRPMWxCUVVFc1JVRkJReXhUUVVONFFpeERRVUZETEZWQlFVTXhRaXhMUVVGTE8yTkJRVUVzVDBGQlMwY3NWMEZCVnl4RFFVRkRTQ3hMUVVGTExFVkJRVVZKTEUxQlFVMHNRMEZCUXp0WlFVRkJMRVZCUVVNN1ZVRkRha1FzUTBGQlF5eERRVUZETzFGQlFVRTdVVUZCUVR0VlFVRkJPMDFCUVVFN1NVRkJRVHRGUVVGQkxFTkJRMGc3TzBGQlJVUXNVMEZCYzBKMVFpeEhRVUZITEVOQlEzWkNVaXhQUVVGakxFVkJRMlJETEVkQlFWY3NSVUZEV0ZBc1QwRkJjMElzUlVGRGRFSkRMRlZCUVRSQ096czdPenMwUTBGRmNrSkpMR05CUVdNc1EwRkJRME1zVDBGQlR5eEZRVUZGTEV0QlFVc3NSVUZCUlVNc1IwRkJSeXhGUVVGRlVDeFBRVUZQTEVWQlFVVkRMRlZCUVZVc1EwRkJRenRSUVVGQk8xRkJRVUU3VlVGQlFUdE5RVUZCTzBsQlFVRTdSVUZCUVN4RFFVTm9SVHM3UVVGUVJHTTdRVUZUUVN4VFFVRnpRa01zU1VGQlNTeERRVU40UWxZc1QwRkJZeXhGUVVOa1F5eEhRVUZYTEVWQlExaE1MRWxCUVZrc1JVRkRXa1lzVDBGQmMwSXNSVUZEZEVKRExGVkJRVFJDT3pzN096czBRMEZGY2tKSkxHTkJRV01zUTBGQlEwTXNUMEZCVHl4RlFVRkZMRTFCUVUwc1JVRkJSVU1zUjBGQlJ5eEZRVUZGVUN4UFFVRlBMRVZCUVVWRExGVkJRVlVzUlVGQlJVTXNTVUZCU1N4RFFVRkRPMUZCUVVFN1VVRkJRVHRWUVVGQk8wMUJRVUU3U1VGQlFUdEZRVUZCTEVOQlEzWkZPenRCUVZKRVlUdEJRVlZCTEZOQlFYTkNSU3hIUVVGSExFTkJRM1pDV0N4UFFVRmpMRVZCUTJSRExFZEJRVmNzUlVGRFdFd3NTVUZCV1N4RlFVTmFSaXhQUVVGelFpeEZRVU4wUWtNc1ZVRkJORUk3T3pzN096UkRRVVZ5UWtrc1kwRkJZeXhEUVVGRFF5eFBRVUZQTEVWQlFVVXNTMEZCU3l4RlFVRkZReXhIUVVGSExFVkJRVVZRTEU5QlFVOHNSVUZCUlVNc1ZVRkJWU3hGUVVGRlF5eEpRVUZKTEVOQlFVTTdVVUZCUVR0UlFVRkJPMVZCUVVFN1RVRkJRVHRKUVVGQk8wVkJRVUVzUTBGRGRFVTdPMEZCVWtSaE8wRkJWVUVzVTBGQmMwSkhMRTFCUVUwc1EwRkRNVUphTEU5QlFXTXNSVUZEWkVNc1IwRkJWeXhGUVVOWVRDeEpRVUZaTEVWQlExcEdMRTlCUVhOQ0xFVkJRM1JDUXl4VlFVRTBRanM3T3pzN05FTkJSWEpDU1N4alFVRmpMRU5CUVVORExFOUJRVThzUlVGQlJTeFJRVUZSTEVWQlFVVkRMRWRCUVVjc1JVRkJSVkFzVDBGQlR5eEZRVUZGUXl4VlFVRlZMRVZCUVVWRExFbEJRVWtzUTBGQlF6dFJRVUZCTzFGQlFVRTdWVUZCUVR0TlFVRkJPMGxCUVVFN1JVRkJRU3hEUVVONlJUczdRVUZTUkdFaUxDSnVZVzFsY3lJNld5SmZaMlYwUlhKeWIzSk5aWE56WVdkbElpd2laWEp5SWl3aWJYTm5JaXdpYldWemMyRm5aU0lzSW1WeWNtOXlYMlJsYzJOeWFYQjBhVzl1SWl3aVpYSnliM0lpTENKS1UwOU9JaXdpYzNSeWFXNW5hV1o1SWl3aWFHRnVaR3hsUlhKeWIzSWlMQ0p5WldwbFkzUWlMQ0pmWDJGM1lXbDBaWElpTENKU1pYTWlMQ0pxYzI5dUlpd2lkR2hsYmlJc0ltVnljbTl5YzE4eElpd2ljM1JoZEhWeklpd2lYMmRsZEZKbGNYVmxjM1JRWVhKaGJYTWlMQ0p0WlhSb2IyUWlMQ0p2Y0hScGIyNXpJaXdpY0dGeVlXMWxkR1Z5Y3lJc0ltSnZaSGtpTENKd1lYSmhiWE1pTENKb1pXRmtaWEp6SWl3aVgyaGhibVJzWlZKbGNYVmxjM1FpTENKbVpYUmphR1Z5SWl3aWRYSnNJaXdpVUhKdmJXbHpaU0lzSW5KbGMyOXNkbVVpTENKeVpYTjFiSFFpTENKdmF5SXNJbTV2VW1WemIyeDJaVXB6YjI0aUxDSmtZWFJoSWl3aVoyVjBJaXdpWlhod2IzSjBjeUlzSW5CdmMzUWlMQ0p3ZFhRaUxDSnlaVzF2ZG1VaVhTd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZjM0pqTDJ4cFlpOW1aWFJqYUM1MGN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXMjUxYkd4ZGZRPT0iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBleHBvcnRzOyB9OyB2YXIgZXhwb3J0cyA9IHt9LCBPcCA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXksIGRlc2MpIHsgb2JqW2tleV0gPSBkZXNjLnZhbHVlOyB9LCAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSwgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSwgb2JqW2tleV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAoZXJyKSB7IGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7IH07IH0gZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkgeyB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvciwgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLCBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyByZXR1cm4gZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KSwgZ2VuZXJhdG9yOyB9IGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07IH0gY2F0Y2ggKGVycikgeyByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07IH0gfSBleHBvcnRzLndyYXAgPSB3cmFwOyB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307IGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pOyB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpOyBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7IHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgeyBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTsgfSk7IH0pOyB9IGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkgeyBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgeyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHsgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsIHZhbHVlID0gcmVzdWx0LnZhbHVlOyByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKHZhbHVlKSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHsgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJlamVjdChyZWNvcmQuYXJnKTsgfSB2YXIgcHJldmlvdXNQcm9taXNlOyBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobWV0aG9kLCBhcmcpIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHsgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiOyByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7IGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7IGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnOyByZXR1cm4gZG9uZVJlc3VsdCgpOyB9IGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHsgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsgaWYgKGRlbGVnYXRlKSB7IHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOyBpZiAoZGVsZWdhdGVSZXN1bHQpIHsgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OyB9IH0gaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHsgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7IGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpOyBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7IHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTsgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7IGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4geyB2YWx1ZTogcmVjb3JkLmFyZywgZG9uZTogY29udGV4dC5kb25lIH07IH0gXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsgdmFyIG1ldGhvZE5hbWUgPSBjb250ZXh0Lm1ldGhvZCwgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07IGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkgcmV0dXJuIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG1ldGhvZE5hbWUgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBtZXRob2ROYW1lICYmIChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBtZXRob2ROYW1lICsgXCInIG1ldGhvZFwiKSksIENvbnRpbnVlU2VudGluZWw7IHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7IHZhciBpbmZvID0gcmVjb3JkLmFyZzsgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTsgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7IH0gZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTsgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDsgfSBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7IHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7IGlmIChpdGVyYWJsZSkgeyB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07IGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7IGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkgeyB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0OyByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OyB9IH0gcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9OyB9IGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7IHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6ICEwIH07IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmVQcm9wZXJ0eShHcCwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgY29uZmlndXJhYmxlOiAhMCB9KSwgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikgeyB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTsgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjsgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7IHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7IHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkgeyB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCksIGtleXMgPSBbXTsgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7IHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IGtleXMubGVuZ3RoOykgeyB2YXIga2V5ID0ga2V5cy5wb3AoKTsgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpOyB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKCkgeyB0aGlzLmRvbmUgPSAhMDsgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZzsgcmV0dXJuIHRoaXMucnZhbDsgfSwgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247IHZhciBjb250ZXh0ID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7IHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7IH0gZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSwgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7IGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChoYXNDYXRjaCkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7IHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTsgYnJlYWs7IH0gfSBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7IHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9OyByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpOyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykgeyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsOyB9LCBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHsgdmFyIHRocm93biA9IHJlY29yZC5hcmc7IHJlc2V0VHJ5RW50cnkoZW50cnkpOyB9IHJldHVybiB0aHJvd247IH0gfSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7IH0sIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLCByZXN1bHROYW1lOiByZXN1bHROYW1lLCBuZXh0TG9jOiBuZXh0TG9jIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIGV4cG9ydHM7IH1cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICBkZXNjID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2XG4gIH0pO1xufSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gdm9pZCAwICYmICh2b2lkIDApLl9fYXdhaXRlciB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIH1cbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlc29sdmVSZXNwb25zZSA9IGV4cG9ydHMucmVzb2x2ZUZldGNoID0gdm9pZCAwO1xudmFyIHJlc29sdmVGZXRjaCA9IGZ1bmN0aW9uIHJlc29sdmVGZXRjaChjdXN0b21GZXRjaCkge1xuICB2YXIgX2ZldGNoO1xuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gZnVuY3Rpb24gX2ZldGNoKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgX3lpZWxkJFByb21pc2UkcmVzb2x2O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnY3Jvc3MtZmV0Y2gnKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIChfeWllbGQkUHJvbWlzZSRyZXNvbHYgPSBfY29udGV4dC5zZW50KS5mZXRjaC5hcHBseShfeWllbGQkUHJvbWlzZSRyZXNvbHYsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICB9KSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZmV0Y2guYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbmV4cG9ydHMucmVzb2x2ZUZldGNoID0gcmVzb2x2ZUZldGNoO1xudmFyIHJlc29sdmVSZXNwb25zZSA9IGZ1bmN0aW9uIHJlc29sdmVSZXNwb25zZSgpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGlmICghKHR5cGVvZiBSZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2ltcG9ydFN0YXIocmVxdWlyZSgnY3Jvc3MtZmV0Y2gnKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudC5SZXNwb25zZSk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBSZXNwb25zZSk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xufTtcbmV4cG9ydHMucmVzb2x2ZVJlc3BvbnNlID0gcmVzb2x2ZVJlc3BvbnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN08wRkJSVThzU1VGQlRVRXNXVUZCV1N4SFFVRkhMRk5CUVdaQkxGbEJRVmtzUTBGQlNVTXNWMEZCYlVJc1JVRkJWenRGUVVONlJDeEpRVUZKUXl4TlFVRmhPMFZCUTJwQ0xFbEJRVWxFTEZkQlFWY3NSVUZCUlR0SlFVTm1ReXhOUVVGTkxFZEJRVWRFTEZkQlFWYzdSMEZEY2tJc1RVRkJUU3hKUVVGSkxFOUJRVTlGTEV0QlFVc3NTMEZCU3l4WFFVRlhMRVZCUVVVN1NVRkRka05FTEUxQlFVMHNSMEZCUnp0TlFVRkJMR3REUVVGVlJTeEpRVUZKTzFGQlFVcEJMRWxCUVVrN1RVRkJRVHROUVVGQkxFOUJRVWxETzFGQlFVRTdVVUZCUVR0VlFVRkJPMWxCUVVFN1kwRkJRVHRqUVVGUk8yZENRVUZCTERSQ1FVRmhMR0ZCUVdFN1kwRkJRU3hGUVVGRE8xbEJRVUU3WTBGQlFUdGpRVUZzUXl3clEwRkJiME5HTEV0QlFVc3NPRUpCUVVsRExFbEJRVWs3V1VGQlF6dGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQk8wbEJRVUU3UjBGREwwVXNUVUZCVFR0SlFVTk1SaXhOUVVGTkxFZEJRVWRETEV0QlFVczdPMFZCUldoQ0xFOUJRVTg3U1VGQlFTeFBRVUZoUkN4TlFVRk5MSGxDUVVGVE8wVkJRVUU3UVVGRGNrTXNRMEZCUXp0QlFWWlpTU3h2UWtGQldUdEJRVmxzUWl4SlFVRk5ReXhsUVVGbExFZEJRVWNzVTBGQmJFSkJMR1ZCUVdVN1JVRkJRU3hQUVVGalJqdEpRVUZCTzAxQlFVRTdVVUZCUVR0VlFVRkJMRTFCUTNCRExFOUJRVTlITEZGQlFWRXNTMEZCU3l4WFFVRlhPMWxCUVVFN1dVRkJRVHRWUVVGQk8xVkJRVUU3VlVGRGVrSTdXVUZCUVN3MFFrRkJZU3hoUVVGaE8xVkJRVUVzUlVGQlF6dFJRVUZCTzFWQlFVRXNhVVJCUVVWQkxGRkJRVkU3VVVGQlFUdFZRVUZCTEd0RFFVZDRRMEVzVVVGQlVUdFJRVUZCTzFGQlFVRTdWVUZCUVR0TlFVRkJPMGxCUVVFN1JVRkJRU3hEUVVOb1FqdEJRVUZCTzBGQlRsbEdMSFZDUVVGbElpd2libUZ0WlhNaU9sc2ljbVZ6YjJ4MlpVWmxkR05vSWl3aVkzVnpkRzl0Um1WMFkyZ2lMQ0pmWm1WMFkyZ2lMQ0ptWlhSamFDSXNJbUZ5WjNNaUxDSmZYMkYzWVdsMFpYSWlMQ0psZUhCdmNuUnpJaXdpY21WemIyeDJaVkpsYzNCdmJuTmxJaXdpVW1WemNHOXVjMlVpWFN3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dmMzSmpMMnhwWWk5b1pXeHdaWEp6TG5SeklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJiblZzYkYxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuLy8gZ2VuZXJhdGVkIGJ5IGdlbnZlcnNpb25cbmV4cG9ydHMudmVyc2lvbiA9ICcyLjEuMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN08wRkJRVUU3UVVGRFlVRXNaVUZCVHl4SFFVRkhMRTlCUVU4aUxDSnVZVzFsY3lJNld5SmxlSEJ2Y25SeklsMHNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5c2FXSXZkbVZ5YzJsdmJpNTBjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2VzI1MWJHeGRmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IFwidXNlIHN0cmljdFwiOyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbnZhciBfX2F3YWl0ZXIgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19hd2FpdGVyIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9saWIvY29uc3RhbnRzXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2xpYi9lcnJvcnNcIik7XG52YXIgZmV0Y2hfMSA9IHJlcXVpcmUoXCIuLi9saWIvZmV0Y2hcIik7XG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4uL2xpYi9oZWxwZXJzXCIpO1xudmFyIFN0b3JhZ2VCdWNrZXRBcGkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdG9yYWdlQnVja2V0QXBpKHVybCkge1xuICAgIHZhciBoZWFkZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgZmV0Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmFnZUJ1Y2tldEFwaSk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25zdGFudHNfMS5ERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcbiAgICB0aGlzLmZldGNoID0gKDAsIGhlbHBlcnNfMS5yZXNvbHZlRmV0Y2gpKGZldGNoKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBTdG9yYWdlIGJ1Y2tldHMgd2l0aGluIGFuIGV4aXN0aW5nIHByb2plY3QuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoU3RvcmFnZUJ1Y2tldEFwaSwgW3tcbiAgICBrZXk6IFwibGlzdEJ1Y2tldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdEJ1Y2tldHMoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLmdldCkodGhpcy5mZXRjaCwgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL2J1Y2tldFwiKSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzU3RvcmFnZUVycm9yKShfY29udGV4dC50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dC50MDtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDddXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBTdG9yYWdlIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRCdWNrZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QnVja2V0KGlkKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5nZXQpKHRoaXMuZmV0Y2gsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9idWNrZXQvXCIpLmNvbmNhdChpZCksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gNztcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzU3RvcmFnZUVycm9yKShfY29udGV4dDIudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQyLnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQyLnQwO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCA3XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2UgYnVja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG4gICAgICogQHJldHVybnMgbmV3bHkgY3JlYXRlZCBidWNrZXQgaWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVCdWNrZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQnVja2V0KGlkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgICBcInB1YmxpY1wiOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLnBvc3QpKHRoaXMuZmV0Y2gsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9idWNrZXRcIiksIHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgICAgICAgXCJwdWJsaWNcIjogb3B0aW9uc1tcInB1YmxpY1wiXVxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBkYXRhID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDc7XG4gICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc1N0b3JhZ2VFcnJvcikoX2NvbnRleHQzLnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0My50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0My50MDtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMCwgN11dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIFN0b3JhZ2UgYnVja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIHVwZGF0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQnVja2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJ1Y2tldChpZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEucHV0KSh0aGlzLmZldGNoLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvYnVja2V0L1wiKS5jb25jYXQoaWQpLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IGlkLFxuICAgICAgICAgICAgICAgIFwicHVibGljXCI6IG9wdGlvbnNbXCJwdWJsaWNcIl1cbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNTdG9yYWdlRXJyb3IpKF9jb250ZXh0NC50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDQudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDQudDA7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzAsIDddXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIG9iamVjdHMgaW5zaWRlIGEgc2luZ2xlIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBlbXB0eS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJlbXB0eUJ1Y2tldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbXB0eUJ1Y2tldChpZCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEucG9zdCkodGhpcy5mZXRjaCwgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL2J1Y2tldC9cIikuY29uY2F0KGlkLCBcIi9lbXB0eVwiKSwge30sIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gNztcbiAgICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzU3RvcmFnZUVycm9yKShfY29udGV4dDUudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQ1LnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ1LnQwO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcywgW1swLCA3XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIGV4aXN0aW5nIGJ1Y2tldC4gQSBidWNrZXQgY2FuJ3QgYmUgZGVsZXRlZCB3aXRoIGV4aXN0aW5nIG9iamVjdHMgaW5zaWRlIGl0LlxuICAgICAqIFlvdSBtdXN0IGZpcnN0IGBlbXB0eSgpYCB0aGUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVCdWNrZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQnVja2V0KGlkKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5yZW1vdmUpKHRoaXMuZmV0Y2gsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9idWNrZXQvXCIpLmNvbmNhdChpZCksIHt9LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBkYXRhID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDc7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NltcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc1N0b3JhZ2VFcnJvcikoX2NvbnRleHQ2LnQwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0Ni50MFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Ni50MDtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMsIFtbMCwgN11dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0b3JhZ2VCdWNrZXRBcGk7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFN0b3JhZ2VCdWNrZXRBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkJOa01zU1VGSGVFSkJMR2RDUVVGblFqdEZRVXR1UXl3d1FrRkJXVU1zUjBGQlZ5eEZRVUYzUkR0SlFVRkJMRWxCUVhSRVF5dzRSVUZCY1VNc1JVRkJSVHRKUVVGQkxFbEJRVVZETEV0QlFXRTdTVUZCUVR0SlFVTTNSU3hKUVVGSkxFTkJRVU5HTEVkQlFVY3NSMEZCUjBFc1IwRkJSenRKUVVOa0xFbEJRVWtzUTBGQlEwTXNUMEZCVHl4dFEwRkJVVVVzTWtKQlFXVXNSMEZCUzBZc1QwRkJUeXhEUVVGRk8wbEJRMnBFTEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhIUVVGSExEQkNRVUZaTEVWQlFVTkJMRXRCUVVzc1EwRkJRenRGUVVOc1F6dEZRVVZCT3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGSFRTeDFRa0ZCVnpzN096czdPenM3WTBGWFFTeFBRVUZOTEdWQlFVY3NSVUZCUXl4SlFVRkpMRU5CUVVOQkxFdEJRVXNzV1VGQlN5eEpRVUZKTEVOQlFVTkdMRWRCUVVjc1kwRkJWenRuUWtGQlJVTXNUMEZCVHl4RlFVRkZMRWxCUVVrc1EwRkJRMEU3WTBGQlR5eERRVUZGTEVOQlFVTTdXVUZCUVR0alFVRTNSVWNzU1VGQlNUdGpRVUZCTEdsRFFVTklPMmRDUVVGRlFTeEpRVUZKTEVWQlFVcEJMRWxCUVVrN1owSkJRVVZETEV0QlFVc3NSVUZCUlR0alFVRkpMRU5CUVVVN1dVRkJRVHRqUVVGQk8yTkJRVUU3WTBGQlFTeExRVVY0UWl3eVFrRkJZeXhqUVVGUE8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3hwUTBGRGFFSTdaMEpCUVVWRUxFbEJRVWtzUlVGQlJTeEpRVUZKTzJkQ1FVRkZReXhMUVVGTE8yTkJRVUVzUTBGQlJUdFpRVUZCTzJOQlFVRTdXVUZCUVR0WlFVRkJPMk5CUVVFN1ZVRkJRVHRSUVVGQk8wMUJRVUVzUTBGTGFrTTdPMGxCUlVRN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJTMDBzYlVKQlEwcERMRVZCUVZVN096czdPenM3TzJOQldVc3NUMEZCVFN4bFFVRkhMRVZCUVVNc1NVRkJTU3hEUVVGRFNpeExRVUZMTEZsQlFVc3NTVUZCU1N4RFFVRkRSaXhIUVVGSExIRkNRVUZYVFN4RlFVRkZMRWRCUVVrN1owSkJRVVZNTEU5QlFVOHNSVUZCUlN4SlFVRkpMRU5CUVVOQk8yTkJRVThzUTBGQlJTeERRVUZETzFsQlFVRTdZMEZCYmtaSExFbEJRVWs3WTBGQlFTeHJRMEZEU0R0blFrRkJSVUVzU1VGQlNTeEZRVUZLUVN4SlFVRkpPMmRDUVVGRlF5eExRVUZMTEVWQlFVVTdZMEZCU1N4RFFVRkZPMWxCUVVFN1kwRkJRVHRqUVVGQk8yTkJRVUVzUzBGRmVFSXNNa0pCUVdNc1pVRkJUenRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc2EwTkJRMmhDTzJkQ1FVRkZSQ3hKUVVGSkxFVkJRVVVzU1VGQlNUdG5Ra0ZCUlVNc1MwRkJTenRqUVVGQkxFTkJRVVU3V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQkxFTkJTMnBET3p0SlFVVkVPenM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlQwMHNjMEpCUTBwRExFVkJRVlVzUlVGRGMwTTdUVUZCUVN4SlFVRm9SRU1zT0VWQlFTdENPMUZCUVVVc1ZVRkJVVHROUVVGTExFTkJRVVU3T3pzN096czdPMk5CV1dwRExFOUJRVTBzWjBKQlFVa3NSVUZEY2tJc1NVRkJTU3hEUVVGRFRDeExRVUZMTEZsQlExQXNTVUZCU1N4RFFVRkRSaXhIUVVGSExHTkJRMWc3WjBKQlFVVk5MRVZCUVVVc1JVRkJSa0VzUlVGQlJUdG5Ra0ZCUlVVc1NVRkJTU3hGUVVGRlJpeEZRVUZGTzJkQ1FVRkZMRlZCUVZGRExFOUJRVTg3WTBGQlR5eERRVUZGTEVWQlEzaERPMmRDUVVGRlRpeFBRVUZQTEVWQlFVVXNTVUZCU1N4RFFVRkRRVHRqUVVGUExFTkJRVVVzUTBGRE1VSTdXVUZCUVR0alFVeExSeXhKUVVGSk8yTkJRVUVzYTBOQlRVZzdaMEpCUVVWQkxFbEJRVWtzUlVGQlNrRXNTVUZCU1R0blFrRkJSVU1zUzBGQlN5eEZRVUZGTzJOQlFVa3NRMEZCUlR0WlFVRkJPMk5CUVVFN1kwRkJRVHRqUVVGQkxFdEJSWGhDTERKQ1FVRmpMR1ZCUVU4N1owSkJRVUU3WjBKQlFVRTdZMEZCUVR0alFVRkJMR3REUVVOb1FqdG5Ra0ZCUlVRc1NVRkJTU3hGUVVGRkxFbEJRVWs3WjBKQlFVVkRMRXRCUVVzN1kwRkJRU3hEUVVGRk8xbEJRVUU3WTBGQlFUdFpRVUZCTzFsQlFVRTdZMEZCUVR0VlFVRkJPMUZCUVVFN1RVRkJRU3hEUVV0cVF6czdTVUZGUkRzN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJUVTBzYzBKQlEwcERMRVZCUVZVc1JVRkRWa01zVDBGQk5FSTdPenM3T3pzN08yTkJXV0lzVDBGQlRTeGxRVUZITEVWQlEzQkNMRWxCUVVrc1EwRkJRMHdzUzBGQlN5eFpRVU5RTEVsQlFVa3NRMEZCUTBZc1IwRkJSeXh4UWtGQlYwMHNSVUZCUlN4SFFVTjRRanRuUWtGQlJVRXNSVUZCUlN4RlFVRkdRU3hGUVVGRk8yZENRVUZGUlN4SlFVRkpMRVZCUVVWR0xFVkJRVVU3WjBKQlFVVXNWVUZCVVVNc1QwRkJUenRqUVVGUExFTkJRVVVzUlVGRGVFTTdaMEpCUVVWT0xFOUJRVThzUlVGQlJTeEpRVUZKTEVOQlFVTkJPMk5CUVU4c1EwRkJSU3hEUVVNeFFqdFpRVUZCTzJOQlRFdEhMRWxCUVVrN1kwRkJRU3hyUTBGTlNEdG5Ra0ZCUlVFc1NVRkJTU3hGUVVGS1FTeEpRVUZKTzJkQ1FVRkZReXhMUVVGTExFVkJRVVU3WTBGQlNTeERRVUZGTzFsQlFVRTdZMEZCUVR0alFVRkJPMk5CUVVFc1MwRkZlRUlzTWtKQlFXTXNaVUZCVHp0blFrRkJRVHRuUWtGQlFUdGpRVUZCTzJOQlFVRXNhME5CUTJoQ08yZENRVUZGUkN4SlFVRkpMRVZCUVVVc1NVRkJTVHRuUWtGQlJVTXNTMEZCU3p0alFVRkJMRU5CUVVVN1dVRkJRVHRqUVVGQk8xbEJRVUU3V1VGQlFUdGpRVUZCTzFWQlFVRTdVVUZCUVR0TlFVRkJMRU5CUzJwRE96dEpRVVZFT3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVdE5MSEZDUVVOS1F5eEZRVUZWT3pzN096czdPenRqUVZsTExFOUJRVTBzWjBKQlFVa3NSVUZEY2tJc1NVRkJTU3hEUVVGRFNpeExRVUZMTEZsQlExQXNTVUZCU1N4RFFVRkRSaXhIUVVGSExIRkNRVUZYVFN4RlFVRkZMR0ZCUTNoQ0xFVkJRVVVzUlVGRFJqdG5Ra0ZCUlV3c1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlEwRTdZMEZCVHl4RFFVRkZMRU5CUXpGQ08xbEJRVUU3WTBGTVMwY3NTVUZCU1R0alFVRkJMR3REUVUxSU8yZENRVUZGUVN4SlFVRkpMRVZCUVVwQkxFbEJRVWs3WjBKQlFVVkRMRXRCUVVzc1JVRkJSVHRqUVVGSkxFTkJRVVU3V1VGQlFUdGpRVUZCTzJOQlFVRTdZMEZCUVN4TFFVVjRRaXd5UWtGQll5eGxRVUZQTzJkQ1FVRkJPMmRDUVVGQk8yTkJRVUU3WTBGQlFTeHJRMEZEYUVJN1owSkJRVVZFTEVsQlFVa3NSVUZCUlN4SlFVRkpPMmRDUVVGRlF5eExRVUZMTzJOQlFVRXNRMEZCUlR0WlFVRkJPMk5CUVVFN1dVRkJRVHRaUVVGQk8yTkJRVUU3VlVGQlFUdFJRVUZCTzAxQlFVRXNRMEZMYWtNN08wbEJSVVE3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVMU5MSE5DUVVOS1F5eEZRVUZWT3pzN096czdPenRqUVZsTExFOUJRVTBzYTBKQlFVMHNSVUZEZGtJc1NVRkJTU3hEUVVGRFNpeExRVUZMTEZsQlExQXNTVUZCU1N4RFFVRkRSaXhIUVVGSExIRkNRVUZYVFN4RlFVRkZMRWRCUTNoQ0xFVkJRVVVzUlVGRFJqdG5Ra0ZCUlV3c1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlEwRTdZMEZCVHl4RFFVRkZMRU5CUXpGQ08xbEJRVUU3WTBGTVMwY3NTVUZCU1R0alFVRkJMR3REUVUxSU8yZENRVUZGUVN4SlFVRkpMRVZCUVVwQkxFbEJRVWs3WjBKQlFVVkRMRXRCUVVzc1JVRkJSVHRqUVVGSkxFTkJRVVU3V1VGQlFUdGpRVUZCTzJOQlFVRTdZMEZCUVN4TFFVVjRRaXd5UWtGQll5eGxRVUZQTzJkQ1FVRkJPMmRDUVVGQk8yTkJRVUU3WTBGQlFTeHJRMEZEYUVJN1owSkJRVVZFTEVsQlFVa3NSVUZCUlN4SlFVRkpPMmRDUVVGRlF5eExRVUZMTzJOQlFVRXNRMEZCUlR0WlFVRkJPMk5CUVVFN1dVRkJRVHRaUVVGQk8yTkJRVUU3VlVGQlFUdFJRVUZCTzAxQlFVRXNRMEZMYWtNN08wVkJRVUU3UlVGQlFUdEJRVUZCTzBGQk4wMUlTU0lzSW01aGJXVnpJanBiSWxOMGIzSmhaMlZDZFdOclpYUkJjR2tpTENKMWNtd2lMQ0pvWldGa1pYSnpJaXdpWm1WMFkyZ2lMQ0pqYjI1emRHRnVkSE5mTVNJc0ltUmhkR0VpTENKbGNuSnZjaUlzSW1sa0lpd2liM0IwYVc5dWN5SXNJbTVoYldVaUxDSmxlSEJ2Y25SeklsMHNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5d1lXTnJZV2RsY3k5VGRHOXlZV2RsUW5WamEyVjBRWEJwTG5SeklsMHNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJiblZzYkYxOSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgX19hd2FpdGVyID0gdm9pZCAwICYmICh2b2lkIDApLl9fYXdhaXRlciB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIH1cbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vbGliL2Vycm9yc1wiKTtcbnZhciBmZXRjaF8xID0gcmVxdWlyZShcIi4uL2xpYi9mZXRjaFwiKTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi4vbGliL2hlbHBlcnNcIik7XG52YXIgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyA9IHtcbiAgbGltaXQ6IDEwMCxcbiAgb2Zmc2V0OiAwLFxuICBzb3J0Qnk6IHtcbiAgICBjb2x1bW46ICduYW1lJyxcbiAgICBvcmRlcjogJ2FzYydcbiAgfVxufTtcbnZhciBERUZBVUxUX0ZJTEVfT1BUSU9OUyA9IHtcbiAgY2FjaGVDb250cm9sOiAnMzYwMCcsXG4gIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JyxcbiAgdXBzZXJ0OiBmYWxzZVxufTtcbnZhciBTdG9yYWdlRmlsZUFwaSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0b3JhZ2VGaWxlQXBpKHVybCkge1xuICAgIHZhciBoZWFkZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgYnVja2V0SWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZmV0Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmFnZUZpbGVBcGkpO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5idWNrZXRJZCA9IGJ1Y2tldElkO1xuICAgIHRoaXMuZmV0Y2ggPSAoMCwgaGVscGVyc18xLnJlc29sdmVGZXRjaCkoZmV0Y2gpO1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQgb3IgcmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFN0b3JhZ2VGaWxlQXBpLCBbe1xuICAgIGtleTogXCJ1cGxvYWRPclVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGxvYWRPclVwZGF0ZShtZXRob2QsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBib2R5LCBvcHRpb25zLCBoZWFkZXJzLCBjbGVhblBhdGgsIF9wYXRoLCByZXMsIGVycm9yO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9GSUxFX09QVElPTlMpLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICAgIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksIG1ldGhvZCA9PT0gJ1BPU1QnICYmIHtcbiAgICAgICAgICAgICAgICAneC11cHNlcnQnOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCcnLCBmaWxlQm9keSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IFwibWF4LWFnZT1cIi5jb25jYXQob3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjbGVhblBhdGggPSB0aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG4gICAgICAgICAgICAgIF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvb2JqZWN0L1wiKS5jb25jYXQoX3BhdGgpLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBwYXRoOiBjbGVhblBhdGhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGVycm9yID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE5O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzU3RvcmFnZUVycm9yKShfY29udGV4dC50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dC50MDtcbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDE5XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBsb2FkKHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy51cGxvYWRPclVwZGF0ZSgnUE9TVCcsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB0aGlzLnVwbG9hZE9yVXBkYXRlKCdQVVQnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSB0b1BhdGggVGhlIG5ldyBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgbmV3IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS1uZXcucG5nYC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoZnJvbVBhdGgsIHRvUGF0aCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEucG9zdCkodGhpcy5mZXRjaCwgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL29iamVjdC9tb3ZlXCIpLCB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHRoaXMuYnVja2V0SWQsXG4gICAgICAgICAgICAgICAgc291cmNlS2V5OiBmcm9tUGF0aCxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbktleTogdG9QYXRoXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gNztcbiAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzU3RvcmFnZUVycm9yKShfY29udGV4dDQudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQ0LnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ0LnQwO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1swLCA3XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAgICogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLWNvcHkucG5nYC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoZnJvbVBhdGgsIHRvUGF0aCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEucG9zdCkodGhpcy5mZXRjaCwgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL29iamVjdC9jb3B5XCIpLCB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHRoaXMuYnVja2V0SWQsXG4gICAgICAgICAgICAgICAgc291cmNlS2V5OiBmcm9tUGF0aCxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbktleTogdG9QYXRoXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHBhdGg6IGRhdGEuS2V5XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNTdG9yYWdlRXJyb3IpKF9jb250ZXh0NS50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDUudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDUudDA7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzAsIDddXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaWduZWQgVVJMLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTCBleHBpcmVzLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgYSBVUkwgd2hpY2ggaXMgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVTaWduZWRVcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU2lnbmVkVXJsKHBhdGgsIGV4cGlyZXNJbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KCkge1xuICAgICAgICB2YXIgX3BhdGgsIGRhdGEsIGRvd25sb2FkUXVlcnlQYXJhbSwgc2lnbmVkVXJsO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAwO1xuICAgICAgICAgICAgICBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEucG9zdCkodGhpcy5mZXRjaCwgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL29iamVjdC9zaWduL1wiKS5jb25jYXQoX3BhdGgpLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBleHBpcmVzSW46IGV4cGlyZXNJblxuICAgICAgICAgICAgICB9LCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgPyB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBvcHRpb25zLnRyYW5zZm9ybVxuICAgICAgICAgICAgICB9IDoge30pLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBkYXRhID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICAgIGRvd25sb2FkUXVlcnlQYXJhbSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG93bmxvYWQpID8gXCImZG93bmxvYWQ9XCIuY29uY2F0KG9wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWQpIDogJyc7XG4gICAgICAgICAgICAgIHNpZ25lZFVybCA9IGVuY29kZVVSSShcIlwiLmNvbmNhdCh0aGlzLnVybCkuY29uY2F0KGRhdGEuc2lnbmVkVVJMKS5jb25jYXQoZG93bmxvYWRRdWVyeVBhcmFtKSk7XG4gICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkVXJsOiBzaWduZWRVcmxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDExO1xuICAgICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNTdG9yYWdlRXJyb3IpKF9jb250ZXh0Ni50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDYudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDYudDA7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzLCBbWzAsIDExXV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG11bHRpcGxlIHNpZ25lZCBVUkxzLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRocyBUaGUgZmlsZSBwYXRocyB0byBiZSBkb3dubG9hZGVkLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lcy4gRm9yIGV4YW1wbGUgYFsnZm9sZGVyL2ltYWdlLnBuZycsICdmb2xkZXIyL2ltYWdlMi5wbmcnXWAuXG4gICAgICogQHBhcmFtIGV4cGlyZXNJbiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdW50aWwgdGhlIHNpZ25lZCBVUkxzIGV4cGlyZS4gRm9yIGV4YW1wbGUsIGA2MGAgZm9yIFVSTHMgd2hpY2ggYXJlIHZhbGlkIGZvciBvbmUgbWludXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIHRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVNpZ25lZFVybHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU2lnbmVkVXJscyhwYXRocywgZXhwaXJlc0luLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhLCBkb3dubG9hZFF1ZXJ5UGFyYW07XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLnBvc3QpKHRoaXMuZmV0Y2gsIFwiXCIuY29uY2F0KHRoaXMudXJsLCBcIi9vYmplY3Qvc2lnbi9cIikuY29uY2F0KHRoaXMuYnVja2V0SWQpLCB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0luOiBleHBpcmVzSW4sXG4gICAgICAgICAgICAgICAgcGF0aHM6IHBhdGhzXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgICAgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBcIiZkb3dubG9hZD1cIi5jb25jYXQob3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZCkgOiAnJztcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEubWFwKGZ1bmN0aW9uIChkYXR1bSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0dW0pLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZFVybDogZGF0dW0uc2lnbmVkVVJMID8gZW5jb2RlVVJJKFwiXCIuY29uY2F0KF90aGlzLnVybCkuY29uY2F0KGRhdHVtLnNpZ25lZFVSTCkuY29uY2F0KGRvd25sb2FkUXVlcnlQYXJhbSkpIDogbnVsbFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gODtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzU3RvcmFnZUVycm9yKShfY29udGV4dDcudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQ3LnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ3LnQwO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcywgW1swLCA4XV0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZ1bGwgcGF0aCBhbmQgZmlsZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGJlIGRvd25sb2FkZWQuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRvd25sb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvd25sb2FkKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgdmFyIHdhbnRzVHJhbnNmb3JtYXRpb24sIHJlbmRlclBhdGgsIHRyYW5zZm9ybWF0aW9uUXVlcnksIHF1ZXJ5U3RyaW5nLCBfcGF0aCwgcmVzLCBkYXRhO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgd2FudHNUcmFuc2Zvcm1hdGlvbiA9IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgICByZW5kZXJQYXRoID0gd2FudHNUcmFuc2Zvcm1hdGlvbiA/ICdyZW5kZXIvaW1hZ2UvYXV0aGVudGljYXRlZCcgOiAnb2JqZWN0JztcbiAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcbiAgICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID8gXCI/XCIuY29uY2F0KHRyYW5zZm9ybWF0aW9uUXVlcnkpIDogJyc7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gNDtcbiAgICAgICAgICAgICAgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBmZXRjaF8xLmdldCkodGhpcy5mZXRjaCwgXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL1wiKS5jb25jYXQocmVuZGVyUGF0aCwgXCIvXCIpLmNvbmNhdChfcGF0aCkuY29uY2F0KHF1ZXJ5U3RyaW5nKSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcy5ibG9iKCk7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBkYXRhID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAxNTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4LnQwID0gX2NvbnRleHQ4W1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzU3RvcmFnZUVycm9yKShfY29udGV4dDgudDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogX2NvbnRleHQ4LnQwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ4LnQwO1xuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOCwgdGhpcywgW1s0LCAxNV1dKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHZlcmlmeSBpZiB0aGUgYnVja2V0IGlzIHB1YmxpYy4gSWYgYSBwdWJsaWMgVVJMIGlzIGNyZWF0ZWQgZm9yIGEgYnVja2V0IHdoaWNoIGlzIG5vdCBwdWJsaWMsIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkIHRoZSBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIGFuZCBuYW1lIG9mIHRoZSBmaWxlIHRvIGdlbmVyYXRlIHRoZSBwdWJsaWMgVVJMIGZvci4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIFRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHVibGljVXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFB1YmxpY1VybChwYXRoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICB2YXIgX3F1ZXJ5U3RyaW5nID0gW107XG4gICAgICB2YXIgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBcImRvd25sb2FkPVwiLmNvbmNhdChvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkKSA6ICcnO1xuICAgICAgaWYgKGRvd25sb2FkUXVlcnlQYXJhbSAhPT0gJycpIHtcbiAgICAgICAgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKTtcbiAgICAgIH1cbiAgICAgIHZhciB3YW50c1RyYW5zZm9ybWF0aW9uID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICB2YXIgcmVuZGVyUGF0aCA9IHdhbnRzVHJhbnNmb3JtYXRpb24gPyAncmVuZGVyL2ltYWdlJyA6ICdvYmplY3QnO1xuICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSB8fCB7fSk7XG4gICAgICBpZiAodHJhbnNmb3JtYXRpb25RdWVyeSAhPT0gJycpIHtcbiAgICAgICAgX3F1ZXJ5U3RyaW5nLnB1c2godHJhbnNmb3JtYXRpb25RdWVyeSk7XG4gICAgICB9XG4gICAgICB2YXIgcXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcuam9pbignJicpO1xuICAgICAgaWYgKHF1ZXJ5U3RyaW5nICE9PSAnJykge1xuICAgICAgICBxdWVyeVN0cmluZyA9IFwiP1wiLmNvbmNhdChxdWVyeVN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcHVibGljVXJsOiBlbmNvZGVVUkkoXCJcIi5jb25jYXQodGhpcy51cmwsIFwiL1wiKS5jb25jYXQocmVuZGVyUGF0aCwgXCIvcHVibGljL1wiKS5jb25jYXQoX3BhdGgpLmNvbmNhdChxdWVyeVN0cmluZykpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgZmlsZXMgd2l0aGluIHRoZSBzYW1lIGJ1Y2tldFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGhzIEFuIGFycmF5IG9mIGZpbGVzIHRvIGRlbGV0ZSwgaW5jbHVkaW5nIHRoZSBwYXRoIGFuZCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIFtgJ2ZvbGRlci9pbWFnZS5wbmcnYF0uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShwYXRocykge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KCkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIGZldGNoXzEucmVtb3ZlKSh0aGlzLmZldGNoLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvb2JqZWN0L1wiKS5jb25jYXQodGhpcy5idWNrZXRJZCksIHtcbiAgICAgICAgICAgICAgICBwcmVmaXhlczogcGF0aHNcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQ5LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dDkudDAgPSBfY29udGV4dDlbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNTdG9yYWdlRXJyb3IpKF9jb250ZXh0OS50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBfY29udGV4dDkudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDkudDA7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU5LCB0aGlzLCBbWzAsIDddXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIGlkIHRoZSBmaWxlIGlkIHRvIHJldHJpZXZlIG1ldGFkYXRhXG4gICAgICovXG4gICAgLy8gYXN5bmMgZ2V0TWV0YWRhdGEoXG4gICAgLy8gICBpZDogc3RyaW5nXG4gICAgLy8gKTogUHJvbWlzZTxcbiAgICAvLyAgIHwge1xuICAgIC8vICAgICAgIGRhdGE6IE1ldGFkYXRhXG4gICAgLy8gICAgICAgZXJyb3I6IG51bGxcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfCB7XG4gICAgLy8gICAgICAgZGF0YTogbnVsbFxuICAgIC8vICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAvLyAgICAgfVxuICAgIC8vID4ge1xuICAgIC8vICAgdHJ5IHtcbiAgICAvLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vbWV0YWRhdGEvJHtpZH1gLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KVxuICAgIC8vICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgLy8gICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHRocm93IGVycm9yXG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBmaWxlIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIGlkIHRoZSBmaWxlIGlkIHRvIHVwZGF0ZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBtZXRhIHRoZSBuZXcgZmlsZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIC8vIGFzeW5jIHVwZGF0ZU1ldGFkYXRhKFxuICAgIC8vICAgaWQ6IHN0cmluZyxcbiAgICAvLyAgIG1ldGE6IE1ldGFkYXRhXG4gICAgLy8gKTogUHJvbWlzZTxcbiAgICAvLyAgIHwge1xuICAgIC8vICAgICAgIGRhdGE6IE1ldGFkYXRhXG4gICAgLy8gICAgICAgZXJyb3I6IG51bGxcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfCB7XG4gICAgLy8gICAgICAgZGF0YTogbnVsbFxuICAgIC8vICAgICAgIGVycm9yOiBTdG9yYWdlRXJyb3JcbiAgICAvLyAgICAgfVxuICAgIC8vID4ge1xuICAgIC8vICAgdHJ5IHtcbiAgICAvLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc3QoXG4gICAgLy8gICAgICAgdGhpcy5mZXRjaCxcbiAgICAvLyAgICAgICBgJHt0aGlzLnVybH0vbWV0YWRhdGEvJHtpZH1gLFxuICAgIC8vICAgICAgIHsgLi4ubWV0YSB9LFxuICAgIC8vICAgICAgIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH1cbiAgICAvLyAgICAgKVxuICAgIC8vICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XG4gICAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgLy8gICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHRocm93IGVycm9yXG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCB0aGUgZmlsZXMgd2l0aGluIGEgYnVja2V0LlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmb2xkZXIgcGF0aC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsaXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3QocGF0aCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMCgpIHtcbiAgICAgICAgdmFyIGJvZHksIGRhdGE7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgYm9keSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFQVJDSF9PUFRJT05TKSwgb3B0aW9ucyksIHtcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHBhdGggfHwgJydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgZmV0Y2hfMS5wb3N0KSh0aGlzLmZldGNoLCBcIlwiLmNvbmNhdCh0aGlzLnVybCwgXCIvb2JqZWN0L2xpc3QvXCIpLmNvbmNhdCh0aGlzLmJ1Y2tldElkKSwgYm9keSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0MTAuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSA4O1xuICAgICAgICAgICAgICBfY29udGV4dDEwLnQwID0gX2NvbnRleHQxMFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBpZiAoISgwLCBlcnJvcnNfMS5pc1N0b3JhZ2VFcnJvcikoX2NvbnRleHQxMC50MCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IF9jb250ZXh0MTAudDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDEwLnQwO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzLCBbWzAsIDhdXSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRGaW5hbFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZpbmFsUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5idWNrZXRJZCwgXCIvXCIpLmNvbmNhdChwYXRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUVtcHR5Rm9sZGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCAnJykucmVwbGFjZSgvXFwvKy9nLCAnLycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyh0cmFuc2Zvcm0pIHtcbiAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgIGlmICh0cmFuc2Zvcm0ud2lkdGgpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJ3aWR0aD1cIi5jb25jYXQodHJhbnNmb3JtLndpZHRoKSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtLmhlaWdodCkge1xuICAgICAgICBwYXJhbXMucHVzaChcImhlaWdodD1cIi5jb25jYXQodHJhbnNmb3JtLmhlaWdodCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5yZXNpemUpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJyZXNpemU9XCIuY29uY2F0KHRyYW5zZm9ybS5yZXNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXMuam9pbignJicpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RvcmFnZUZpbGVBcGk7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFN0b3JhZ2VGaWxlQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN08wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlUwRXNTVUZCVFVFc2MwSkJRWE5DTEVkQlFVYzdSVUZETjBKRExFdEJRVXNzUlVGQlJTeEhRVUZITzBWQlExWkRMRTFCUVUwc1JVRkJSU3hEUVVGRE8wVkJRMVJETEUxQlFVMHNSVUZCUlR0SlFVTk9ReXhOUVVGTkxFVkJRVVVzVFVGQlRUdEpRVU5rUXl4TFFVRkxMRVZCUVVVN08wTkJSVlk3UVVGRlJDeEpRVUZOUXl4dlFrRkJiMElzUjBGQlowSTdSVUZEZUVORExGbEJRVmtzUlVGQlJTeE5RVUZOTzBWQlEzQkNReXhYUVVGWExFVkJRVVVzTUVKQlFUQkNPMFZCUTNaRFF5eE5RVUZOTEVWQlFVVTdRMEZEVkR0QlFVRkJMRWxCUlc5Q1F5eGpRVUZqTzBWQlRXcERMSGRDUVVORlF5eEhRVUZYTEVWQlIwVTdTVUZCUVN4SlFVWmlReXc0UlVGQmNVTXNSVUZCUlR0SlFVRkJMRWxCUTNaRFF5eFJRVUZwUWp0SlFVRkJMRWxCUTJwQ1F5eExRVUZoTzBsQlFVRTdTVUZGWWl4SlFVRkpMRU5CUVVOSUxFZEJRVWNzUjBGQlIwRXNSMEZCUnp0SlFVTmtMRWxCUVVrc1EwRkJRME1zVDBGQlR5eEhRVUZIUVN4UFFVRlBPMGxCUTNSQ0xFbEJRVWtzUTBGQlEwTXNVVUZCVVN4SFFVRkhRU3hSUVVGUk8wbEJRM2hDTEVsQlFVa3NRMEZCUTBNc1MwRkJTeXhIUVVGSExEQkNRVUZaTEVWQlFVTkJMRXRCUVVzc1EwRkJRenRGUVVOc1F6dEZRVVZCT3pzN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJUMk1zZDBKQlExcERMRTFCUVhOQ0xFVkJRM1JDUXl4SlFVRlpMRVZCUTFwRExGRkJWVlVzUlVGRFZrTXNWMEZCZVVJN096czdPenM3WTBGaGFrSkRMRTlCUVU4c2JVTkJRVkZpTEc5Q1FVRnZRaXhIUVVGTFdTeFhRVUZYTEVOQlFVVTdZMEZEY2tST0xFOUJRVThzYlVOQlExSXNTVUZCU1N4RFFVRkRRU3hQUVVGUExFZEJRMWhITEUxQlFVMHNTMEZCU3l4TlFVRk5MRWxCUVVrN1owSkJRVVVzVlVGQlZTeEZRVUZGU3l4TlFVRk5MRU5CUVVORUxFOUJRVThzUTBGQlExWXNUVUZCYVVJN1kwRkJReXhEUVVGRkxFTkJRek5GTzJOQlJVUXNTVUZCU1N4UFFVRlBXU3hKUVVGSkxFdEJRVXNzVjBGQlZ5eEpRVUZKU2l4UlFVRlJMRmxCUVZsSkxFbEJRVWtzUlVGQlJUdG5Ra0ZETTBSRExFbEJRVWtzUjBGQlJ5eEpRVUZKUXl4UlFVRlJMRVZCUVVVN1owSkJRM0pDUkN4SlFVRkpMRU5CUVVORkxFMUJRVTBzUTBGQlF5eGpRVUZqTEVWQlFVVk1MRTlCUVU4c1EwRkJRMW9zV1VGQmMwSXNRMEZCUXp0blFrRkRNMFJsTEVsQlFVa3NRMEZCUTBVc1RVRkJUU3hEUVVGRExFVkJRVVVzUlVGQlJWQXNVVUZCVVN4RFFVRkRPMlZCUXpGQ0xFMUJRVTBzU1VGQlNTeFBRVUZQVFN4UlFVRlJMRXRCUVVzc1YwRkJWeXhKUVVGSlRpeFJRVUZSTEZsQlFWbE5MRkZCUVZFc1JVRkJSVHRuUWtGRE1VVkVMRWxCUVVrc1IwRkJSMHdzVVVGQlVUdG5Ra0ZEWmtzc1NVRkJTU3hEUVVGRFJTeE5RVUZOTEVOQlFVTXNZMEZCWXl4RlFVRkZUQ3hQUVVGUExFTkJRVU5hTEZsQlFYTkNMRU5CUVVNN1pVRkROVVFzVFVGQlRUdG5Ra0ZEVEdVc1NVRkJTU3hIUVVGSFRDeFJRVUZSTzJkQ1FVTm1UQ3hQUVVGUExFTkJRVU1zWlVGQlpTeERRVUZETEhGQ1FVRmpUeXhQUVVGUExFTkJRVU5hTEZsQlFWa3NRMEZCUlR0blFrRkROVVJMTEU5QlFVOHNRMEZCUXl4alFVRmpMRU5CUVVNc1IwRkJSMDhzVDBGQlR5eERRVUZEV0N4WFFVRnhRanM3WTBGSGJrUnBRaXhUUVVGVExFZEJRVWNzU1VGQlNTeERRVUZEUXl4dFFrRkJiVUlzUTBGQlExWXNTVUZCU1N4RFFVRkRPMk5CUXpGRFZ5eExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRReXhoUVVGaExFTkJRVU5JTEZOQlFWTXNRMEZCUXp0alFVRkJPMk5CUXk5Q0xFOUJRVTBzU1VGQlNTeERRVUZEV0N4TFFVRkxMRmRCUVVrc1NVRkJTU3hEUVVGRFNDeEhRVUZITEhGQ1FVRlhaMElzUzBGQlN5eEhRVUZKTzJkQ1FVTXhSRm9zVFVGQlRTeEZRVUZPUVN4TlFVRk5PMmRDUVVOT1R5eEpRVUZKTEVWQlFVVkJMRWxCUVdkQ08yZENRVU4wUWxZc1QwRkJUeXhGUVVGUVFUdGxRVU5FTEVOQlFVTTdXVUZCUVR0alFVcEphVUlzUjBGQlJ6dGpRVUZCTEV0QlRVeEJMRWRCUVVjc1EwRkJRME1zUlVGQlJUdG5Ra0ZCUVR0blFrRkJRVHRqUVVGQk8yTkJRVUVzYVVOQlEwUTdaMEpCUTB4RExFbEJRVWtzUlVGQlJUdHJRa0ZCUldZc1NVRkJTU3hGUVVGRlV6dG5Ra0ZCVXl4RFFVRkZPMmRDUVVONlFrOHNTMEZCU3l4RlFVRkZPMlZCUTFJN1dVRkJRVHRqUVVGQk8yTkJSV0VzVDBGQlRVZ3NSMEZCUnl4RFFVRkRTU3hKUVVGSkxFVkJRVVU3V1VGQlFUdGpRVUY0UWtRc1MwRkJTenRqUVVGQkxHbERRVU5LTzJkQ1FVRkZSQ3hKUVVGSkxFVkJRVVVzU1VGQlNUdG5Ra0ZCUlVNc1MwRkJTeXhGUVVGTVFUdGpRVUZMTEVOQlFVVTdXVUZCUVR0alFVRkJPMk5CUVVFN1dVRkJRVHRqUVVGQk8yTkJRVUU3WTBGQlFTeExRVWN4UWl3eVFrRkJZeXhqUVVGUE8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3hwUTBGRGFFSTdaMEpCUVVWRUxFbEJRVWtzUlVGQlJTeEpRVUZKTzJkQ1FVRkZReXhMUVVGTE8yTkJRVUVzUTBGQlJUdFpRVUZCTzJOQlFVRTdXVUZCUVR0WlFVRkJPMk5CUVVFN1ZVRkJRVHRSUVVGQk8wMUJRVUVzUTBGTGFrTTdPMGxCUlVRN096czdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVTFOTEdkQ1FVTkthRUlzU1VGQldTeEZRVU5hUXl4UlFWVlZMRVZCUTFaRExGZEJRWGxDT3pzN096dG5SRUZYYkVJc1NVRkJTU3hEUVVGRFowSXNZMEZCWXl4RFFVRkRMRTFCUVUwc1JVRkJSV3hDTEVsQlFVa3NSVUZCUlVNc1VVRkJVU3hGUVVGRlF5eFhRVUZYTEVOQlFVTTdXVUZCUVR0WlFVRkJPMk5CUVVFN1ZVRkJRVHRSUVVGQk8wMUJRVUVzUTBGRGFFVTdPMGxCUlVRN096czdPenRGUVVGQk8wbEJRVUU3U1VGQlFTeFBRVTFOTEdkQ1FVTktSaXhKUVVGWkxFVkJRMXBETEZGQlZWVXNSVUZEVmtNc1YwRkJlVUk3T3pzN08yZEVRVmRzUWl4SlFVRkpMRU5CUVVOblFpeGpRVUZqTEVOQlFVTXNTMEZCU3l4RlFVRkZiRUlzU1VGQlNTeEZRVUZGUXl4UlFVRlJMRVZCUVVWRExGZEJRVmNzUTBGQlF6dFpRVUZCTzFsQlFVRTdZMEZCUVR0VlFVRkJPMUZCUVVFN1RVRkJRU3hEUVVNdlJEczdTVUZGUkRzN096czdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFOUJUVTBzWTBGRFNtbENMRkZCUVdkQ0xFVkJRMmhDUXl4TlFVRmpPenM3T3pzN096dGpRVmxETEU5QlFVMHNaMEpCUVVrc1JVRkRja0lzU1VGQlNTeERRVUZEZEVJc1MwRkJTeXhaUVVOUUxFbEJRVWtzUTBGQlEwZ3NSMEZCUnl4dFFrRkRXRHRuUWtGQlJVVXNVVUZCVVN4RlFVRkZMRWxCUVVrc1EwRkJRMEVzVVVGQlVUdG5Ra0ZCUlhkQ0xGTkJRVk1zUlVGQlJVWXNVVUZCVVR0blFrRkJSVWNzWTBGQll5eEZRVUZGUmp0alFVRk5MRU5CUVVVc1JVRkRlRVU3WjBKQlFVVjRRaXhQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZEUVR0alFVRlBMRU5CUVVVc1EwRkRNVUk3V1VGQlFUdGpRVXhMYlVJc1NVRkJTVHRqUVVGQkxHdERRVTFJTzJkQ1FVRkZRU3hKUVVGSkxFVkJRVXBCTEVsQlFVazdaMEpCUVVWRExFdEJRVXNzUlVGQlJUdGpRVUZKTEVOQlFVVTdXVUZCUVR0alFVRkJPMk5CUVVFN1kwRkJRU3hMUVVWNFFpd3lRa0ZCWXl4bFFVRlBPMmRDUVVGQk8yZENRVUZCTzJOQlFVRTdZMEZCUVN4clEwRkRhRUk3WjBKQlFVVkVMRWxCUVVrc1JVRkJSU3hKUVVGSk8yZENRVUZGUXl4TFFVRkxPMk5CUVVFc1EwRkJSVHRaUVVGQk8yTkJRVUU3V1VGQlFUdFpRVUZCTzJOQlFVRTdWVUZCUVR0UlFVRkJPMDFCUVVFc1EwRkxha003TzBsQlJVUTdPenM3T3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVUxTkxHTkJRMHBITEZGQlFXZENMRVZCUTJoQ1F5eE5RVUZqT3pzN096czdPenRqUVZsRExFOUJRVTBzWjBKQlFVa3NSVUZEY2tJc1NVRkJTU3hEUVVGRGRFSXNTMEZCU3l4WlFVTlFMRWxCUVVrc1EwRkJRMGdzUjBGQlJ5eHRRa0ZEV0R0blFrRkJSVVVzVVVGQlVTeEZRVUZGTEVsQlFVa3NRMEZCUTBFc1VVRkJVVHRuUWtGQlJYZENMRk5CUVZNc1JVRkJSVVlzVVVGQlVUdG5Ra0ZCUlVjc1kwRkJZeXhGUVVGRlJqdGpRVUZOTEVOQlFVVXNSVUZEZUVVN1owSkJRVVY0UWl4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRFFUdGpRVUZQTEVOQlFVVXNRMEZETVVJN1dVRkJRVHRqUVV4TGJVSXNTVUZCU1R0alFVRkJMR3REUVUxSU8yZENRVUZGUVN4SlFVRkpMRVZCUVVVN2EwSkJRVVZtTEVsQlFVa3NSVUZCUldVc1NVRkJTU3hEUVVGRFVUdG5Ra0ZCUnl4RFFVRkZPMmRDUVVGRlVDeExRVUZMTEVWQlFVVTdZMEZCU1N4RFFVRkZPMWxCUVVFN1kwRkJRVHRqUVVGQk8yTkJRVUVzUzBGRk5VTXNNa0pCUVdNc1pVRkJUenRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc2EwTkJRMmhDTzJkQ1FVRkZSQ3hKUVVGSkxFVkJRVVVzU1VGQlNUdG5Ra0ZCUlVNc1MwRkJTenRqUVVGQkxFTkJRVVU3V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQkxFTkJTMnBET3p0SlFVVkVPenM3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFWRk5MSGxDUVVOS2FFSXNTVUZCV1N4RlFVTmFkMElzVTBGQmFVSXNSVUZEYWtKeVFpeFBRVUYxUlRzN096czdPenRqUVZscVJWRXNTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkJRME1zWVVGQllTeERRVUZEV2l4SlFVRkpMRU5CUVVNN1kwRkJRVHRqUVVWNlFpeFBRVUZOTEdkQ1FVRkpMRVZCUTI1Q0xFbEJRVWtzUTBGQlEwWXNTMEZCU3l4WlFVTlFMRWxCUVVrc1EwRkJRMGdzUjBGQlJ5d3dRa0ZCWjBKblFpeExRVUZMTEVkQlFVVmpPMmRDUVVOb1EwUXNVMEZCVXl4RlFVRlVRVHRqUVVGVExFZEJRVTBzVVVGQlR5eGhRVUZRY2tJc1QwRkJUeXgxUWtGQlVFRXNUMEZCVHl4RFFVRkZkVUlzVTBGQlV5eEpRVUZITzJkQ1FVRkZRU3hUUVVGVExFVkJRVVYyUWl4UFFVRlBMRU5CUVVOMVFqdGpRVUZUTEVOQlFVVXNSMEZCUnl4RlFVRkZMRU5CUVVNc1JVRkROVVU3WjBKQlFVVTVRaXhQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZEUVR0alFVRlBMRU5CUVVVc1EwRkRNVUk3V1VGQlFUdGpRVXhIYlVJc1NVRkJTVHRqUVUxR1dTeHJRa0ZCYTBJc1IwRkJSeXhSUVVGUExHRkJRVkI0UWl4UFFVRlBMSFZDUVVGUVFTeFBRVUZQTEVOQlFVVjVRaXhSUVVGUkxIZENRVU16UW5wQ0xFOUJRVThzUTBGQlEzbENMRkZCUVZFc1MwRkJTeXhKUVVGSkxFZEJRVWNzUlVGQlJTeEhRVUZIZWtJc1QwRkJUeXhEUVVGRGVVSXNVVUZCVVN4SlFVTTVSQ3hGUVVGRk8yTkJRMEZETEZOQlFWTXNSMEZCUjBNc1UwRkJVeXhYUVVGSkxFbEJRVWtzUTBGQlEyNURMRWRCUVVjc1UwRkJSMjlDTEVsQlFVa3NRMEZCUTJkQ0xGTkJRVk1zVTBGQlIwb3NhMEpCUVd0Q0xFVkJRVWM3WTBGRGFFWmFMRWxCUVVrc1IwRkJSenRuUWtGQlJXTXNVMEZCVXl4RlFVRlVRVHRqUVVGVExFTkJRVVU3WTBGQlFTeHJRMEZEWWp0blFrRkJSV1FzU1VGQlNTeEZRVUZLUVN4SlFVRkpPMmRDUVVGRlF5eExRVUZMTEVWQlFVVTdZMEZCU1N4RFFVRkZPMWxCUVVFN1kwRkJRVHRqUVVGQk8yTkJRVUVzUzBGRmVFSXNNa0pCUVdNc1pVRkJUenRuUWtGQlFUdG5Ra0ZCUVR0alFVRkJPMk5CUVVFc2EwTkJRMmhDTzJkQ1FVRkZSQ3hKUVVGSkxFVkJRVVVzU1VGQlNUdG5Ra0ZCUlVNc1MwRkJTenRqUVVGQkxFTkJRVVU3V1VGQlFUdGpRVUZCTzFsQlFVRTdXVUZCUVR0alFVRkJPMVZCUVVFN1VVRkJRVHROUVVGQkxFTkJTMnBET3p0SlFVVkVPenM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlQwMHNNRUpCUTBwblFpeExRVUZsTEVWQlEyWlNMRk5CUVdsQ0xFVkJRMnBDY2tJc1QwRkJkME03T3pzN096czdPenRqUVZsNlFpeFBRVUZOTEdkQ1FVRkpMRVZCUTNKQ0xFbEJRVWtzUTBGQlEwd3NTMEZCU3l4WlFVTlFMRWxCUVVrc1EwRkJRMGdzUjBGQlJ5d3dRa0ZCWjBJc1NVRkJTU3hEUVVGRFJTeFJRVUZSTEVkQlEzaERPMmRDUVVGRk1rSXNVMEZCVXl4RlFVRlVRU3hUUVVGVE8yZENRVUZGVVN4TFFVRkxMRVZCUVV4Qk8yTkJRVXNzUTBGQlJTeEZRVU53UWp0blFrRkJSWEJETEU5QlFVOHNSVUZCUlN4SlFVRkpMRU5CUVVOQk8yTkJRVThzUTBGQlJTeERRVU14UWp0WlFVRkJPMk5CVEV0dFFpeEpRVUZKTzJOQlQwcFpMR3RDUVVGclFpeEhRVUZITEZGQlFVOHNZVUZCVUhoQ0xFOUJRVThzZFVKQlFWQkJMRTlCUVU4c1EwRkJSWGxDTEZGQlFWRXNkMEpCUXpOQ2VrSXNUMEZCVHl4RFFVRkRlVUlzVVVGQlVTeExRVUZMTEVsQlFVa3NSMEZCUnl4RlFVRkZMRWRCUVVkNlFpeFBRVUZQTEVOQlFVTjVRaXhSUVVGUkxFbEJRemxFTEVWQlFVVTdZMEZCUVN4clEwRkRRenRuUWtGRFRHSXNTVUZCU1N4RlFVRkZRU3hKUVVGSkxFTkJRVU5yUWl4SFFVRkhMRU5CUVVNc1ZVRkJRME1zUzBGQk5FSTdhMEpCUVVFc1QwRkJTMVFzWjBOQlF6VkRVeXhMUVVGTE8yOUNRVU5TVEN4VFFVRlRMRVZCUVVWTExFdEJRVXNzUTBGQlEwZ3NVMEZCVXl4SFFVTjBRa1FzVTBGQlV5eFhRVUZKTEV0QlFVa3NRMEZCUTI1RExFZEJRVWNzVTBGQlIzVkRMRXRCUVVzc1EwRkJRMGdzVTBGQlV5eFRRVUZIU2l4clFrRkJhMElzUlVGQlJ5eEhRVU12UkR0clFrRkJTVHRuUWtGQlFTeERRVU5TTEVOQlFVTTdaMEpCUTBoWUxFdEJRVXNzUlVGQlJUdGxRVU5TTzFsQlFVRTdZMEZCUVR0alFVRkJPMk5CUVVFc1MwRkZSeXd5UWtGQll5eGxRVUZQTzJkQ1FVRkJPMmRDUVVGQk8yTkJRVUU3WTBGQlFTeHJRMEZEYUVJN1owSkJRVVZFTEVsQlFVa3NSVUZCUlN4SlFVRkpPMmRDUVVGRlF5eExRVUZMTzJOQlFVRXNRMEZCUlR0WlFVRkJPMk5CUVVFN1dVRkJRVHRaUVVGQk8yTkJRVUU3VlVGQlFUdFJRVUZCTzAxQlFVRXNRMEZMYWtNN08wbEJSVVE3T3pzN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVMU5MR3RDUVVOS2FFSXNTVUZCV1N4RlFVTmFSeXhQUVVFd1F6czdPenM3TzJOQlYzQkRaME1zYlVKQlFXMUNMRWRCUVVjc1VVRkJUMmhETEU5QlFVOHNZVUZCVUVFc1QwRkJUeXgxUWtGQlVFRXNUMEZCVHl4RFFVRkZkVUlzVTBGQlV5eE5RVUZMTEZkQlFWYzdZMEZETDBSVkxGVkJRVlVzUjBGQlIwUXNiVUpCUVcxQ0xFZEJRVWNzTkVKQlFUUkNMRWRCUVVjc1VVRkJVVHRqUVVNeFJVVXNiVUpCUVcxQ0xFZEJRVWNzU1VGQlNTeERRVUZEUXl3d1FrRkJNRUlzUTBGQlF5eFJRVUZQTEdGQlFWQnVReXhQUVVGUExIVkNRVUZRUVN4UFFVRlBMRU5CUVVWMVFpeFRRVUZUTEV0QlFVa3NSVUZCUlN4RFFVRkRPMk5CUXk5RllTeFhRVUZYTEVkQlFVZEdMRzFDUVVGdFFpeGpRVUZQUVN4dFFrRkJiVUlzU1VGQlN5eEZRVUZGTzJOQlFVRTdZMEZIYUVVeFFpeExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRReXhoUVVGaExFTkJRVU5hTEVsQlFVa3NRMEZCUXp0alFVRkJPMk5CUXpGQ0xFOUJRVTBzWlVGQlJ5eEZRVUZETEVsQlFVa3NRMEZCUTBZc1MwRkJTeXhaUVVGTExFbEJRVWtzUTBGQlEwZ3NSMEZCUnl4alFVRkplVU1zVlVGQlZTeGpRVUZKZWtJc1MwRkJTeXhUUVVGSE5FSXNWMEZCVnl4SFFVRkpPMmRDUVVOd1JqTkRMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU5CTEU5QlFVODdaMEpCUTNKQ05FTXNZVUZCWVN4RlFVRkZPMlZCUTJoQ0xFTkJRVU03V1VGQlFUdGpRVWhKTTBJc1IwRkJSenRqUVVGQk8yTkJTVWtzVDBGQlRVRXNSMEZCUnl4RFFVRkRORUlzU1VGQlNTeEZRVUZGTzFsQlFVRTdZMEZCZGtJeFFpeEpRVUZKTzJOQlFVRXNhME5CUTBnN1owSkJRVVZCTEVsQlFVa3NSVUZCU2tFc1NVRkJTVHRuUWtGQlJVTXNTMEZCU3l4RlFVRkZPMk5CUVVrc1EwRkJSVHRaUVVGQk8yTkJRVUU3WTBGQlFUdGpRVUZCTEV0QlJYaENMREpDUVVGakxHVkJRVTg3WjBKQlFVRTdaMEpCUVVFN1kwRkJRVHRqUVVGQkxHdERRVU5vUWp0blFrRkJSVVFzU1VGQlNTeEZRVUZGTEVsQlFVazdaMEpCUVVWRExFdEJRVXM3WTBGQlFTeERRVUZGTzFsQlFVRTdZMEZCUVR0WlFVRkJPMWxCUVVFN1kwRkJRVHRWUVVGQk8xRkJRVUU3VFVGQlFTeERRVXRxUXpzN1NVRkZSRHM3T3pzN096czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRlJRU3h6UWtGRFJXaENMRWxCUVZrc1JVRkRXa2NzVDBGQmRVVTdUVUZGZGtVc1NVRkJUVkVzUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUTBNc1lVRkJZU3hEUVVGRFdpeEpRVUZKTEVOQlFVTTdUVUZEZEVNc1NVRkJUVEJETEZsQlFWa3NSMEZCUnl4RlFVRkZPMDFCUlhaQ0xFbEJRVTFtTEd0Q1FVRnJRaXhIUVVGSExGRkJRVThzWVVGQlVIaENMRTlCUVU4c2RVSkJRVkJCTEU5QlFVOHNRMEZCUlhsQ0xGRkJRVkVzZFVKQlF6VkNla0lzVDBGQlR5eERRVUZEZVVJc1VVRkJVU3hMUVVGTExFbEJRVWtzUjBGQlJ5eEZRVUZGTEVkQlFVZDZRaXhQUVVGUExFTkJRVU41UWl4UlFVRlJMRWxCUXpkRUxFVkJRVVU3VFVGRlRpeEpRVUZKUkN4clFrRkJhMElzUzBGQlN5eEZRVUZGTEVWQlFVVTdVVUZETjBKbExGbEJRVmtzUTBGQlEwTXNTVUZCU1N4RFFVRkRhRUlzYTBKQlFXdENMRU5CUVVNN08wMUJSM1pETEVsQlFVMVJMRzFDUVVGdFFpeEhRVUZITEZGQlFVOW9ReXhQUVVGUExHRkJRVkJCTEU5QlFVOHNkVUpCUVZCQkxFOUJRVThzUTBGQlJYVkNMRk5CUVZNc1RVRkJTeXhYUVVGWE8wMUJRM0pGTEVsQlFVMVZMRlZCUVZVc1IwRkJSMFFzYlVKQlFXMUNMRWRCUVVjc1kwRkJZeXhIUVVGSExGRkJRVkU3VFVGRGJFVXNTVUZCVFVVc2JVSkJRVzFDTEVkQlFVY3NTVUZCU1N4RFFVRkRReXd3UWtGQk1FSXNRMEZCUXl4UlFVRlBMR0ZCUVZCdVF5eFBRVUZQTEhWQ1FVRlFRU3hQUVVGUExFTkJRVVYxUWl4VFFVRlRMRXRCUVVrc1JVRkJSU3hEUVVGRE8wMUJSWEpHTEVsQlFVbFhMRzFDUVVGdFFpeExRVUZMTEVWQlFVVXNSVUZCUlR0UlFVTTVRa3NzV1VGQldTeERRVUZEUXl4SlFVRkpMRU5CUVVOT0xHMUNRVUZ0UWl4RFFVRkRPenROUVVkNFF5eEpRVUZKUlN4WFFVRlhMRWRCUVVkSExGbEJRVmtzUTBGQlEwVXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJRenROUVVONFF5eEpRVUZKVEN4WFFVRlhMRXRCUVVzc1JVRkJSU3hGUVVGRk8xRkJRM1JDUVN4WFFVRlhMR05CUVU5QkxGZEJRVmNzUTBGQlJUczdUVUZIYWtNc1QwRkJUenRSUVVOTWVFSXNTVUZCU1N4RlFVRkZPMVZCUVVVNFFpeFRRVUZUTEVWQlFVVm1MRk5CUVZNc1YwRkJTU3hKUVVGSkxFTkJRVU51UXl4SFFVRkhMR05CUVVsNVF5eFZRVUZWTEhGQ1FVRlhla0lzUzBGQlN5eFRRVUZITkVJc1YwRkJWenRSUVVGSE8wOUJRM2hHTzBsQlEwZzdTVUZGUVRzN096czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkxUU3huUWtGRFNsQXNTMEZCWlRzN096czdPenM3WTBGWlFTeFBRVUZOTEd0Q1FVRk5MRVZCUTNaQ0xFbEJRVWtzUTBGQlEyeERMRXRCUVVzc1dVRkRVQ3hKUVVGSkxFTkJRVU5JTEVkQlFVY3NjVUpCUVZjc1NVRkJTU3hEUVVGRFJTeFJRVUZSTEVkQlEyNURPMmRDUVVGRmFVUXNVVUZCVVN4RlFVRkZaRHRqUVVGTExFTkJRVVVzUlVGRGJrSTdaMEpCUVVWd1F5eFBRVUZQTEVWQlFVVXNTVUZCU1N4RFFVRkRRVHRqUVVGUExFTkJRVVVzUTBGRE1VSTdXVUZCUVR0alFVeExiVUlzU1VGQlNUdGpRVUZCTEd0RFFVMUlPMmRDUVVGRlFTeEpRVUZKTEVWQlFVcEJMRWxCUVVrN1owSkJRVVZETEV0QlFVc3NSVUZCUlR0alFVRkpMRU5CUVVVN1dVRkJRVHRqUVVGQk8yTkJRVUU3WTBGQlFTeExRVVY0UWl3eVFrRkJZeXhsUVVGUE8yZENRVUZCTzJkQ1FVRkJPMk5CUVVFN1kwRkJRU3hyUTBGRGFFSTdaMEpCUVVWRUxFbEJRVWtzUlVGQlJTeEpRVUZKTzJkQ1FVRkZReXhMUVVGTE8yTkJRVUVzUTBGQlJUdFpRVUZCTzJOQlFVRTdXVUZCUVR0WlFVRkJPMk5CUVVFN1ZVRkJRVHRSUVVGQk8wMUJRVUVzUTBGTGFrTTdPMGxCUlVRN096czdTVUZKUVR0SlFVTkJPMGxCUTBFN1NVRkRRVHRKUVVOQk8wbEJRMEU3U1VGRFFUdEpRVU5CTzBsQlEwRTdTVUZEUVR0SlFVTkJPMGxCUTBFN1NVRkRRVHRKUVVOQk8wbEJRMEU3U1VGRFFUdEpRVU5CTzBsQlEwRTdTVUZEUVR0SlFVVkJPMGxCUTBFN1NVRkRRVHRKUVVWQk96czdPenRKUVV0Qk8wbEJRMEU3U1VGRFFUdEpRVU5CTzBsQlEwRTdTVUZEUVR0SlFVTkJPMGxCUTBFN1NVRkRRVHRKUVVOQk8wbEJRMEU3U1VGRFFUdEpRVU5CTzBsQlEwRTdTVUZEUVR0SlFVTkJPMGxCUTBFN1NVRkRRVHRKUVVOQk8wbEJRMEU3U1VGRFFUdEpRVU5CTzBsQlEwRTdTVUZEUVR0SlFVTkJPMGxCUlVFN1NVRkRRVHRKUVVOQk8wbEJSVUU3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGSlRTeGpRVU5LYUVJc1NVRkJZU3hGUVVOaVJ5eFBRVUYxUWl4RlFVTjJRalJETEZWQlFUUkNPenM3T3pzN08yTkJXWEJDZWtNc1NVRkJTU3hwUkVGQlVYUkNMSE5DUVVGelFpeEhRVUZMYlVJc1QwRkJUenRuUWtGQlJUWkRMRTFCUVUwc1JVRkJSV2hFTEVsQlFVa3NTVUZCU1R0alFVRkZMRVZCUVVVN1kwRkJRVHRqUVVNM1JDeFBRVUZOTEdkQ1FVRkpMRVZCUTNKQ0xFbEJRVWtzUTBGQlEwWXNTMEZCU3l4WlFVTlFMRWxCUVVrc1EwRkJRMGdzUjBGQlJ5d3dRa0ZCWjBJc1NVRkJTU3hEUVVGRFJTeFJRVUZSTEVkQlEzaERVeXhKUVVGSkxFVkJRMG83WjBKQlFVVldMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU5CTzJOQlFVOHNRMEZCUlN4RlFVTjZRbTFFTEZWQlFWVXNRMEZEV0R0WlFVRkJPMk5CVGt0b1F5eEpRVUZKTzJOQlFVRXNiVU5CVDBnN1owSkJRVVZCTEVsQlFVa3NSVUZCU2tFc1NVRkJTVHRuUWtGQlJVTXNTMEZCU3l4RlFVRkZPMk5CUVVrc1EwRkJSVHRaUVVGQk8yTkJRVUU3WTBGQlFUdGpRVUZCTEV0QlJYaENMREpDUVVGakxHZENRVUZQTzJkQ1FVRkJPMmRDUVVGQk8yTkJRVUU3WTBGQlFTeHRRMEZEYUVJN1owSkJRVVZFTEVsQlFVa3NSVUZCUlN4SlFVRkpPMmRDUVVGRlF5eExRVUZMTzJOQlFVRXNRMEZCUlR0WlFVRkJPMk5CUVVFN1dVRkJRVHRaUVVGQk8yTkJRVUU3VlVGQlFUdFJRVUZCTzAxQlFVRXNRMEZMYWtNN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlJVOHNkVUpCUVdOb1FpeEpRVUZaTzAxQlEyaERMR2xDUVVGVkxFbEJRVWtzUTBGQlEwZ3NVVUZCVVN4alFVRkpSeXhKUVVGSk8wbEJRMnBETzBWQlFVTTdTVUZCUVR0SlFVRkJMRTlCUlU4c05rSkJRVzlDUVN4SlFVRlpPMDFCUTNSRExFOUJRVTlCTEVsQlFVa3NRMEZCUTJsRUxFOUJRVThzUTBGQlF5eFZRVUZWTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVOQkxFOUJRVThzUTBGQlF5eE5RVUZOTEVWQlFVVXNSMEZCUnl4RFFVRkRPMGxCUXpGRU8wVkJRVU03U1VGQlFUdEpRVUZCTEU5QlJVOHNiME5CUVRKQ2RrSXNVMEZCTWtJN1RVRkROVVFzU1VGQlRYZENMRTFCUVUwc1IwRkJSeXhGUVVGRk8wMUJRMnBDTEVsQlFVbDRRaXhUUVVGVExFTkJRVU41UWl4TFFVRkxMRVZCUVVVN1VVRkRia0pFTEUxQlFVMHNRMEZCUTFBc1NVRkJTU3hwUWtGQlZXcENMRk5CUVZNc1EwRkJRM2xDTEV0QlFVc3NSVUZCUnpzN1RVRkhla01zU1VGQlNYcENMRk5CUVZNc1EwRkJRekJDTEUxQlFVMHNSVUZCUlR0UlFVTndRa1lzVFVGQlRTeERRVUZEVUN4SlFVRkpMR3RDUVVGWGFrSXNVMEZCVXl4RFFVRkRNRUlzVFVGQlRTeEZRVUZIT3p0TlFVY3pReXhKUVVGSk1VSXNVMEZCVXl4RFFVRkRNa0lzVFVGQlRTeEZRVUZGTzFGQlEzQkNTQ3hOUVVGTkxFTkJRVU5RTEVsQlFVa3NhMEpCUVZkcVFpeFRRVUZUTEVOQlFVTXlRaXhOUVVGTkxFVkJRVWM3TzAxQlJ6TkRMRTlCUVU5SUxFMUJRVTBzUTBGQlEwNHNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJRenRKUVVONlFqdEZRVUZETzBWQlFVRTdRVUZCUVR0QlFURnFRa2hWSWl3aWJtRnRaWE1pT2xzaVJFVkdRVlZNVkY5VFJVRlNRMGhmVDFCVVNVOU9VeUlzSW14cGJXbDBJaXdpYjJabWMyVjBJaXdpYzI5eWRFSjVJaXdpWTI5c2RXMXVJaXdpYjNKa1pYSWlMQ0pFUlVaQlZVeFVYMFpKVEVWZlQxQlVTVTlPVXlJc0ltTmhZMmhsUTI5dWRISnZiQ0lzSW1OdmJuUmxiblJVZVhCbElpd2lkWEJ6WlhKMElpd2lVM1J2Y21GblpVWnBiR1ZCY0draUxDSjFjbXdpTENKb1pXRmtaWEp6SWl3aVluVmphMlYwU1dRaUxDSm1aWFJqYUNJc0ltMWxkR2h2WkNJc0luQmhkR2dpTENKbWFXeGxRbTlrZVNJc0ltWnBiR1ZQY0hScGIyNXpJaXdpYjNCMGFXOXVjeUlzSWxOMGNtbHVaeUlzSWtKc2IySWlMQ0ppYjJSNUlpd2lSbTl5YlVSaGRHRWlMQ0poY0hCbGJtUWlMQ0pqYkdWaGJsQmhkR2dpTENKZmNtVnRiM1psUlcxd2RIbEdiMnhrWlhKeklpd2lYM0JoZEdnaUxDSmZaMlYwUm1sdVlXeFFZWFJvSWl3aWNtVnpJaXdpYjJzaUxDSmtZWFJoSWl3aVpYSnliM0lpTENKcWMyOXVJaXdpZFhCc2IyRmtUM0pWY0dSaGRHVWlMQ0ptY205dFVHRjBhQ0lzSW5SdlVHRjBhQ0lzSW5OdmRYSmpaVXRsZVNJc0ltUmxjM1JwYm1GMGFXOXVTMlY1SWl3aVMyVjVJaXdpWlhod2FYSmxjMGx1SWl3aVQySnFaV04wSWl3aWRISmhibk5tYjNKdElpd2laRzkzYm14dllXUlJkV1Z5ZVZCaGNtRnRJaXdpWkc5M2JteHZZV1FpTENKemFXZHVaV1JWY213aUxDSmxibU52WkdWVlVra2lMQ0p6YVdkdVpXUlZVa3dpTENKd1lYUm9jeUlzSW0xaGNDSXNJbVJoZEhWdElpd2lkMkZ1ZEhOVWNtRnVjMlp2Y20xaGRHbHZiaUlzSW5KbGJtUmxjbEJoZEdnaUxDSjBjbUZ1YzJadmNtMWhkR2x2YmxGMVpYSjVJaXdpZEhKaGJuTm1iM0p0VDNCMGMxUnZVWFZsY25sVGRISnBibWNpTENKeGRXVnllVk4wY21sdVp5SXNJbTV2VW1WemIyeDJaVXB6YjI0aUxDSmliRzlpSWl3aVgzRjFaWEo1VTNSeWFXNW5JaXdpY0hWemFDSXNJbXB2YVc0aUxDSndkV0pzYVdOVmNtd2lMQ0p3Y21WbWFYaGxjeUlzSW5CaGNtRnRaWFJsY25NaUxDSndjbVZtYVhnaUxDSnlaWEJzWVdObElpd2ljR0Z5WVcxeklpd2lkMmxrZEdnaUxDSm9aV2xuYUhRaUxDSnlaWE5wZW1VaUxDSmxlSEJ2Y25SeklsMHNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5d1lXTnJZV2RsY3k5VGRHOXlZV2RsUm1sc1pVRndhUzUwY3lKZExDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNlcyNTFiR3hkZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgX19hd2FpdGVyID0gdm9pZCAwICYmICh2b2lkIDApLl9fYXdhaXRlciB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIH1cbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgZnVuY3Rpb25zX2pzXzEgPSByZXF1aXJlKFwiQHN1cGFiYXNlL2Z1bmN0aW9ucy1qc1wiKTtcbnZhciBwb3N0Z3Jlc3RfanNfMSA9IHJlcXVpcmUoXCJAc3VwYWJhc2UvcG9zdGdyZXN0LWpzXCIpO1xudmFyIHJlYWx0aW1lX2pzXzEgPSByZXF1aXJlKFwiQHN1cGFiYXNlL3JlYWx0aW1lLWpzXCIpO1xudmFyIHN0b3JhZ2VfanNfMSA9IHJlcXVpcmUoXCJAc3VwYWJhc2Uvc3RvcmFnZS1qc1wiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2xpYi9jb25zdGFudHNcIik7XG52YXIgZmV0Y2hfMSA9IHJlcXVpcmUoXCIuL2xpYi9mZXRjaFwiKTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9saWIvaGVscGVyc1wiKTtcbnZhciBTdXBhYmFzZUF1dGhDbGllbnRfMSA9IHJlcXVpcmUoXCIuL2xpYi9TdXBhYmFzZUF1dGhDbGllbnRcIik7XG52YXIgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyA9IHtcbiAgaGVhZGVyczogY29uc3RhbnRzXzEuREVGQVVMVF9IRUFERVJTXG59O1xudmFyIERFRkFVTFRfREJfT1BUSU9OUyA9IHtcbiAgc2NoZW1hOiAncHVibGljJ1xufTtcbnZhciBERUZBVUxUX0FVVEhfT1BUSU9OUyA9IHtcbiAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gIGRldGVjdFNlc3Npb25JblVybDogdHJ1ZVxufTtcbnZhciBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMgPSB7fTtcbi8qKlxuICogU3VwYWJhc2UgQ2xpZW50LlxuICpcbiAqIEFuIGlzb21vcnBoaWMgSmF2YXNjcmlwdCBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggUG9zdGdyZXMuXG4gKi9cbnZhciBTdXBhYmFzZUNsaWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gICAqIEBwYXJhbSBzdXBhYmFzZVVybCBUaGUgdW5pcXVlIFN1cGFiYXNlIFVSTCB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgKiBAcGFyYW0gc3VwYWJhc2VLZXkgVGhlIHVuaXF1ZSBTdXBhYmFzZSBLZXkgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZGIuc2NoZW1hIFlvdSBjYW4gc3dpdGNoIGluIGJldHdlZW4gc2NoZW1hcy4gVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmF1dG9SZWZyZXNoVG9rZW4gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCB0aGUgdG9rZW4gYmVmb3JlIGV4cGlyaW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLnBlcnNpc3RTZXNzaW9uIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHNhdmUgdGhlIHVzZXIgc2Vzc2lvbiBpbnRvIGxvY2FsIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSBvcHRpb25zLmF1dGguZGV0ZWN0U2Vzc2lvbkluVXJsIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdHMgT0F1dGggZ3JhbnRzIGluIHRoZSBVUkwgYW5kIHNpZ25zIGluIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWFsdGltZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byByZWFsdGltZS1qcyBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmZldGNoIEEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuaGVhZGVycyBBbnkgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHNlbmQgd2l0aCBlYWNoIG5ldHdvcmsgcmVxdWVzdC5cbiAgICovXG4gIGZ1bmN0aW9uIFN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdXBhYmFzZUNsaWVudCk7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICB0aGlzLnN1cGFiYXNlVXJsID0gc3VwYWJhc2VVcmw7XG4gICAgdGhpcy5zdXBhYmFzZUtleSA9IHN1cGFiYXNlS2V5O1xuICAgIGlmICghc3VwYWJhc2VVcmwpIHRocm93IG5ldyBFcnJvcignc3VwYWJhc2VVcmwgaXMgcmVxdWlyZWQuJyk7XG4gICAgaWYgKCFzdXBhYmFzZUtleSkgdGhyb3cgbmV3IEVycm9yKCdzdXBhYmFzZUtleSBpcyByZXF1aXJlZC4nKTtcbiAgICB2YXIgX3N1cGFiYXNlVXJsID0gKDAsIGhlbHBlcnNfMS5zdHJpcFRyYWlsaW5nU2xhc2gpKHN1cGFiYXNlVXJsKTtcbiAgICB0aGlzLnJlYWx0aW1lVXJsID0gXCJcIi5jb25jYXQoX3N1cGFiYXNlVXJsLCBcIi9yZWFsdGltZS92MVwiKS5yZXBsYWNlKC9eaHR0cC9pLCAnd3MnKTtcbiAgICB0aGlzLmF1dGhVcmwgPSBcIlwiLmNvbmNhdChfc3VwYWJhc2VVcmwsIFwiL2F1dGgvdjFcIik7XG4gICAgdGhpcy5zdG9yYWdlVXJsID0gXCJcIi5jb25jYXQoX3N1cGFiYXNlVXJsLCBcIi9zdG9yYWdlL3YxXCIpO1xuICAgIHZhciBpc1BsYXRmb3JtID0gX3N1cGFiYXNlVXJsLm1hdGNoKC8oc3VwYWJhc2VcXC5jbyl8KHN1cGFiYXNlXFwuaW4pLyk7XG4gICAgaWYgKGlzUGxhdGZvcm0pIHtcbiAgICAgIHZhciB1cmxQYXJ0cyA9IF9zdXBhYmFzZVVybC5zcGxpdCgnLicpO1xuICAgICAgdGhpcy5mdW5jdGlvbnNVcmwgPSBcIlwiLmNvbmNhdCh1cmxQYXJ0c1swXSwgXCIuZnVuY3Rpb25zLlwiKS5jb25jYXQodXJsUGFydHNbMV0sIFwiLlwiKS5jb25jYXQodXJsUGFydHNbMl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZ1bmN0aW9uc1VybCA9IFwiXCIuY29uY2F0KF9zdXBhYmFzZVVybCwgXCIvZnVuY3Rpb25zL3YxXCIpO1xuICAgIH1cbiAgICAvLyBkZWZhdWx0IHN0b3JhZ2Uga2V5IHVzZXMgdGhlIHN1cGFiYXNlIHByb2plY3QgcmVmIGFzIGEgbmFtZXNwYWNlXG4gICAgdmFyIGRlZmF1bHRTdG9yYWdlS2V5ID0gXCJzYi1cIi5jb25jYXQobmV3IFVSTCh0aGlzLmF1dGhVcmwpLmhvc3RuYW1lLnNwbGl0KCcuJylbMF0sIFwiLWF1dGgtdG9rZW5cIik7XG4gICAgdmFyIERFRkFVTFRTID0ge1xuICAgICAgZGI6IERFRkFVTFRfREJfT1BUSU9OUyxcbiAgICAgIHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG4gICAgICBhdXRoOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQVVUSF9PUFRJT05TKSwge1xuICAgICAgICBzdG9yYWdlS2V5OiBkZWZhdWx0U3RvcmFnZUtleVxuICAgICAgfSksXG4gICAgICBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlNcbiAgICB9O1xuICAgIHZhciBzZXR0aW5ncyA9ICgwLCBoZWxwZXJzXzEuYXBwbHlTZXR0aW5nRGVmYXVsdHMpKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBERUZBVUxUUyk7XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gKF9iID0gKF9hID0gc2V0dGluZ3MuYXV0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3JhZ2VLZXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgIHRoaXMuaGVhZGVycyA9IChfZCA9IChfYyA9IHNldHRpbmdzLmdsb2JhbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmhlYWRlcnMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9O1xuICAgIHRoaXMuYXV0aCA9IHRoaXMuX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoKF9lID0gc2V0dGluZ3MuYXV0aCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDoge30sIHRoaXMuaGVhZGVycywgKF9mID0gc2V0dGluZ3MuZ2xvYmFsKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZmV0Y2gpO1xuICAgIHRoaXMuZmV0Y2ggPSAoMCwgZmV0Y2hfMS5mZXRjaFdpdGhBdXRoKShzdXBhYmFzZUtleSwgdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSwgKF9nID0gc2V0dGluZ3MuZ2xvYmFsKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuZmV0Y2gpO1xuICAgIHRoaXMucmVhbHRpbWUgPSB0aGlzLl9pbml0UmVhbHRpbWVDbGllbnQoT2JqZWN0LmFzc2lnbih7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9LCBzZXR0aW5ncy5yZWFsdGltZSkpO1xuICAgIHRoaXMucmVzdCA9IG5ldyBwb3N0Z3Jlc3RfanNfMS5Qb3N0Z3Jlc3RDbGllbnQoXCJcIi5jb25jYXQoX3N1cGFiYXNlVXJsLCBcIi9yZXN0L3YxXCIpLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBzY2hlbWE6IChfaCA9IHNldHRpbmdzLmRiKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guc2NoZW1hLFxuICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2hcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5Gb3JBdXRoRXZlbnRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN1cGFiYXNlIEZ1bmN0aW9ucyBhbGxvd3MgeW91IHRvIGRlcGxveSBhbmQgaW52b2tlIGVkZ2UgZnVuY3Rpb25zLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFN1cGFiYXNlQ2xpZW50LCBbe1xuICAgIGtleTogXCJmdW5jdGlvbnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBuZXcgZnVuY3Rpb25zX2pzXzEuRnVuY3Rpb25zQ2xpZW50KHRoaXMuZnVuY3Rpb25zVXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgY3VzdG9tRmV0Y2g6IHRoaXMuZmV0Y2hcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBhYmFzZSBTdG9yYWdlIGFsbG93cyB5b3UgdG8gbWFuYWdlIHVzZXItZ2VuZXJhdGVkIGNvbnRlbnQsIHN1Y2ggYXMgcGhvdG9zIG9yIHZpZGVvcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzdG9yYWdlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbmV3IHN0b3JhZ2VfanNfMS5TdG9yYWdlQ2xpZW50KHRoaXMuc3RvcmFnZVVybCwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKHJlbGF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXN0LmZyb20ocmVsYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAgVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0gYXJncyAgVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkICAgV2hlbiBzZXQgdG8gdHJ1ZSwgbm8gZGF0YSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50ICBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgaW4gYSB0YWJsZS5cbiAgICAgKlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJwY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBycGMoZm4pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcy5yZXN0LnJwYyhmbiwgYXJncywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBSZWFsdGltZSBjaGFubmVsIHdpdGggQnJvYWRjYXN0LCBQcmVzZW5jZSwgYW5kIFBvc3RncmVzIENoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbm5lbChuYW1lKSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgICBjb25maWc6IHt9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMucmVhbHRpbWUuY2hhbm5lbChuYW1lLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2hhbm5lbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhbm5lbHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5nZXRDaGFubmVscygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgUmVhbHRpbWUgY2hhbm5lbCBmcm9tIFJlYWx0aW1lIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhbHRpbWVDaGFubmVsfSBjaGFubmVsIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVDaGFubmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQ2hhbm5lbChjaGFubmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGFsbCBSZWFsdGltZSBjaGFubmVscyBmcm9tIFJlYWx0aW1lIGNsaWVudC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVBbGxDaGFubmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBbGxDaGFubmVscygpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUFsbENoYW5uZWxzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBY2Nlc3NUb2tlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBfeWllbGQkdGhpcyRhdXRoJGdldFMsIGRhdGE7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoLmdldFNlc3Npb24oKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkYXV0aCRnZXRTID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgZGF0YSA9IF95aWVsZCR0aGlzJGF1dGgkZ2V0Uy5kYXRhO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIChfYiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCk7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRTdXBhYmFzZUF1dGhDbGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoX3JlZiwgaGVhZGVycywgZmV0Y2gpIHtcbiAgICAgIHZhciBhdXRvUmVmcmVzaFRva2VuID0gX3JlZi5hdXRvUmVmcmVzaFRva2VuLFxuICAgICAgICBwZXJzaXN0U2Vzc2lvbiA9IF9yZWYucGVyc2lzdFNlc3Npb24sXG4gICAgICAgIGRldGVjdFNlc3Npb25JblVybCA9IF9yZWYuZGV0ZWN0U2Vzc2lvbkluVXJsLFxuICAgICAgICBzdG9yYWdlID0gX3JlZi5zdG9yYWdlLFxuICAgICAgICBzdG9yYWdlS2V5ID0gX3JlZi5zdG9yYWdlS2V5O1xuICAgICAgdmFyIGF1dGhIZWFkZXJzID0ge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIi5jb25jYXQodGhpcy5zdXBhYmFzZUtleSksXG4gICAgICAgIGFwaWtleTogXCJcIi5jb25jYXQodGhpcy5zdXBhYmFzZUtleSlcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3IFN1cGFiYXNlQXV0aENsaWVudF8xLlN1cGFiYXNlQXV0aENsaWVudCh7XG4gICAgICAgIHVybDogdGhpcy5hdXRoVXJsLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF1dGhIZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgIHN0b3JhZ2VLZXk6IHN0b3JhZ2VLZXksXG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGF1dG9SZWZyZXNoVG9rZW4sXG4gICAgICAgIHBlcnNpc3RTZXNzaW9uOiBwZXJzaXN0U2Vzc2lvbixcbiAgICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiBkZXRlY3RTZXNzaW9uSW5VcmwsXG4gICAgICAgIHN0b3JhZ2U6IHN0b3JhZ2UsXG4gICAgICAgIGZldGNoOiBmZXRjaFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0UmVhbHRpbWVDbGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRSZWFsdGltZUNsaWVudChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHJlYWx0aW1lX2pzXzEuUmVhbHRpbWVDbGllbnQodGhpcy5yZWFsdGltZVVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGFwaWtleTogdGhpcy5zdXBhYmFzZUtleVxuICAgICAgICB9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbGlzdGVuRm9yQXV0aEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGlzdGVuRm9yQXV0aEV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZShmdW5jdGlvbiAoZXZlbnQsIHNlc3Npb24pIHtcbiAgICAgICAgX3RoaXMuX2hhbmRsZVRva2VuQ2hhbmdlZChldmVudCwgc2Vzc2lvbiA9PT0gbnVsbCB8fCBzZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uLmFjY2Vzc190b2tlbiwgJ0NMSUVOVCcpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVRva2VuQ2hhbmdlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCB0b2tlbiwgc291cmNlKSB7XG4gICAgICBpZiAoKGV2ZW50ID09PSAnVE9LRU5fUkVGUkVTSEVEJyB8fCBldmVudCA9PT0gJ1NJR05FRF9JTicpICYmIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlbikge1xuICAgICAgICAvLyBUb2tlbiBoYXMgY2hhbmdlZFxuICAgICAgICB0aGlzLnJlYWx0aW1lLnNldEF1dGgodG9rZW4gIT09IG51bGwgJiYgdG9rZW4gIT09IHZvaWQgMCA/IHRva2VuIDogbnVsbCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnU0lHTkVEX09VVCcgfHwgZXZlbnQgPT09ICdVU0VSX0RFTEVURUQnKSB7XG4gICAgICAgIC8vIFRva2VuIGlzIHJlbW92ZWRcbiAgICAgICAgdGhpcy5yZWFsdGltZS5zZXRBdXRoKHRoaXMuc3VwYWJhc2VLZXkpO1xuICAgICAgICBpZiAoc291cmNlID09ICdTVE9SQUdFJykgdGhpcy5hdXRoLnNpZ25PdXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN1cGFiYXNlQ2xpZW50O1xufSgpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTdXBhYmFzZUNsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPMEZCUVVFN1FVRkZRVHRCUVV0Qk8wRkJUVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVZEJMRWxCUVUxQkxITkNRVUZ6UWl4SFFVRkhPMFZCUXpkQ1F5eFBRVUZQTEVWQlFVVkRPME5CUTFZN1FVRkZSQ3hKUVVGTlF5eHJRa0ZCYTBJc1IwRkJSenRGUVVONlFrTXNUVUZCVFN4RlFVRkZPME5CUTFRN1FVRkZSQ3hKUVVGTlF5eHZRa0ZCYjBJc1IwRkJPRUk3UlVGRGRFUkRMR2RDUVVGblFpeEZRVUZGTEVsQlFVazdSVUZEZEVKRExHTkJRV01zUlVGQlJTeEpRVUZKTzBWQlEzQkNReXhyUWtGQmEwSXNSVUZCUlR0RFFVTnlRanRCUVVWRUxFbEJRVTFETEhkQ1FVRjNRaXhIUVVFd1FpeEZRVUZGTzBGQlJURkVPenM3T3p0QlFVRkJMRWxCUzNGQ1F5eGpRVUZqTzBWQk5FSnFRenM3T3pzN096czdPenM3TzBWQldVRXNkMEpCUTFsRExGZEJRVzFDTEVWQlEyNUNReXhYUVVGdFFpeEZRVU0zUWtNc1QwRkJNa003U1VGQlFUczdTVUZHYWtNc1owSkJRVmNzUjBGQldFWXNWMEZCVnp0SlFVTllMR2RDUVVGWExFZEJRVmhETEZkQlFWYzdTVUZIY2tJc1NVRkJTU3hEUVVGRFJDeFhRVUZYTEVWQlFVVXNUVUZCVFN4SlFVRkpSeXhMUVVGTExFTkJRVU1zTUVKQlFUQkNMRU5CUVVNN1NVRkROMFFzU1VGQlNTeERRVUZEUml4WFFVRlhMRVZCUVVVc1RVRkJUU3hKUVVGSlJTeExRVUZMTEVOQlFVTXNNRUpCUVRCQ0xFTkJRVU03U1VGRk4wUXNTVUZCVFVNc1dVRkJXU3hIUVVGSExHZERRVUZyUWl4RlFVRkRTaXhYUVVGWExFTkJRVU03U1VGRmNFUXNTVUZCU1N4RFFVRkRTeXhYUVVGWExFZEJRVWNzVlVGQlIwUXNXVUZCV1N4clFrRkJaVVVzVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4SlFVRkpMRU5CUVVNN1NVRkRlRVVzU1VGQlNTeERRVUZEUXl4UFFVRlBMR0ZCUVUxSUxGbEJRVmtzWVVGQlZUdEpRVU40UXl4SlFVRkpMRU5CUVVOSkxGVkJRVlVzWVVGQlRVb3NXVUZCV1N4blFrRkJZVHRKUVVVNVF5eEpRVUZOU3l4VlFVRlZMRWRCUVVkTUxGbEJRVmtzUTBGQlEwMHNTMEZCU3l4RFFVRkRMQ3RDUVVFclFpeERRVUZETzBsQlEzUkZMRWxCUVVsRUxGVkJRVlVzUlVGQlJUdE5RVU5rTEVsQlFVMUZMRkZCUVZFc1IwRkJSMUFzV1VGQldTeERRVUZEVVN4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRE8wMUJRM2hETEVsQlFVa3NRMEZCUTBNc1dVRkJXU3hoUVVGTlJpeFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMSGRDUVVGalFTeFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMR05CUVVsQkxGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUlR0TFFVTTNSU3hOUVVGTk8wMUJRMHdzU1VGQlNTeERRVUZEUlN4WlFVRlpMR0ZCUVUxVUxGbEJRVmtzYTBKQlFXVTdPMGxCUlhCRU8wbEJRMEVzU1VGQlRWVXNhVUpCUVdsQ0xHZENRVUZUTEVsQlFVbERMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU5TTEU5QlFVOHNRMEZCUXl4RFFVRkRVeXhSUVVGUkxFTkJRVU5LTEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zWjBKQlFXRTdTVUZEZWtZc1NVRkJUVXNzVVVGQlVTeEhRVUZITzAxQlEyWkRMRVZCUVVVc1JVRkJSVEZDTEd0Q1FVRnJRanROUVVOMFFqSkNMRkZCUVZFc1JVRkJSWEpDTEhkQ1FVRjNRanROUVVOc1EzTkNMRWxCUVVrc2EwTkJRVTh4UWl4dlFrRkJiMEk3VVVGQlJUSkNMRlZCUVZVc1JVRkJSVkE3VFVGQmFVSXNSVUZCUlR0TlFVTm9SVkVzVFVGQlRTeEZRVUZGYWtNN1MwRkRWRHRKUVVWRUxFbEJRVTFyUXl4UlFVRlJMRWRCUVVjc2EwTkJRVzlDTEVWQlFVTnlRaXhQUVVGUExHRkJRVkJCTEU5QlFVOHNZMEZCVUVFc1QwRkJUeXhIUVVGSkxFVkJRVVVzUlVGQlJXVXNVVUZCVVN4RFFVRkRPMGxCUlRsRUxFbEJRVWtzUTBGQlEwa3NWVUZCVlN4SFFVRkhMRzlDUVVGUkxFTkJRVU5FTEVsQlFVa3NNRU5CUVVWRExGVkJRVlVzYlVOQlFVa3NSVUZCUlR0SlFVTnFSQ3hKUVVGSkxFTkJRVU12UWl4UFFVRlBMRWRCUVVjc2IwSkJRVkVzUTBGQlEyZERMRTFCUVUwc01FTkJRVVZvUXl4UFFVRlBMRzFEUVVGSkxFVkJRVVU3U1VGRk4wTXNTVUZCU1N4RFFVRkRPRUlzU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUTBrc2RVSkJRWFZDTEVOQlEzUkRMR05CUVZFc1EwRkJRMG9zU1VGQlNTeHRRMEZCU1N4RlFVRkZMRVZCUTI1Q0xFbEJRVWtzUTBGQlF6bENMRTlCUVU4c1JVRkRXaXhqUVVGUkxFTkJRVU5uUXl4TlFVRk5MREJEUVVGRlJ5eExRVUZMTEVOQlEzWkNPMGxCUTBRc1NVRkJTU3hEUVVGRFFTeExRVUZMTEVkQlFVY3NlVUpCUVdFc1JVRkJRM2hDTEZkQlFWY3NSVUZCUlN4SlFVRkpMRU5CUVVONVFpeGxRVUZsTEVOQlFVTkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeGpRVUZSTEVOQlFVTk1MRTFCUVUwc01FTkJRVVZITEV0QlFVc3NRMEZCUXp0SlFVVm9SeXhKUVVGSkxFTkJRVU5PTEZGQlFWRXNSMEZCUnl4SlFVRkpMRU5CUVVOVExHMUNRVUZ0UWp0TlFVRkhkRU1zVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTBFN1NVRkJUeXhIUVVGTGFVTXNVVUZCVVN4RFFVRkRTaXhSUVVGUkxFVkJRVWM3U1VGRGVrWXNTVUZCU1N4RFFVRkRWU3hKUVVGSkxFZEJRVWNzU1VGQlNVTXNPRUpCUVdVc1YwRkJTVEZDTEZsQlFWa3NaVUZCV1R0TlFVTjZSR1FzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUTBFc1QwRkJUenROUVVOeVFrY3NUVUZCVFN4RlFVRkZMR05CUVZFc1EwRkJRM2xDTEVWQlFVVXNNRU5CUVVWNlFpeE5RVUZOTzAxQlF6TkNaME1zUzBGQlN5eEZRVUZGTEVsQlFVa3NRMEZCUTBFN1MwRkRZaXhEUVVGRE8wbEJSVVlzU1VGQlNTeERRVUZEVFN4dlFrRkJiMElzUlVGQlJUdEZRVU0zUWp0RlFVVkJPenM3UlVGQlFUdEpRVUZCTzBsQlFVRXNTMEZIUVN4bFFVRmhPMDFCUTFnc1QwRkJUeXhKUVVGSlF5dzRRa0ZCWlN4RFFVRkRMRWxCUVVrc1EwRkJRMjVDTEZsQlFWa3NSVUZCUlR0UlFVTTFRM1pDTEU5QlFVOHNSVUZCUlN4SlFVRkpMRU5CUVVOQkxFOUJRVTg3VVVGRGNrSXlReXhYUVVGWExFVkJRVVVzU1VGQlNTeERRVUZEVWp0UFFVTnVRaXhEUVVGRE8wbEJRMG83U1VGRlFUczdPMFZCUVVFN1NVRkJRVHRKUVVGQkxFdEJSMEVzWlVGQlZ6dE5RVU5VTEU5QlFVOHNTVUZCU1ZNc01FSkJRWEZDTEVOQlFVTXNTVUZCU1N4RFFVRkRNVUlzVlVGQlZTeEZRVUZGTEVsQlFVa3NRMEZCUTJ4Q0xFOUJRVThzUlVGQlJTeEpRVUZKTEVOQlFVTnRReXhMUVVGTExFTkJRVU03U1VGRE4wVTdSVUZCUXp0SlFVRkJPMGxCUVVFc1QwRmxSQ3hqUVVGTFZTeFJRVUZuUWp0TlFVTnVRaXhQUVVGUExFbEJRVWtzUTBGQlEwNHNTVUZCU1N4RFFVRkRUeXhKUVVGSkxFTkJRVU5FTEZGQlFWRXNRMEZCUXp0SlFVTnFRenRKUVVWQk96czdPenM3T3pzN1JVRkJRVHRKUVVGQk8wbEJRVUVzVDBGVFFTeGhRVWxGUlN4RlFVRm5RaXhGUVV0bU8wMUJRVUVzU1VGS1JFTXNNa1ZCUVRCQ0xFVkJRVVU3VFVGQlFTeEpRVU0xUW5CRExFOUJSME03VFVGVlJDeFBRVUZQTEVsQlFVa3NRMEZCUXpKQ0xFbEJRVWtzUTBGQlExVXNSMEZCUnl4RFFVRkRSaXhGUVVGRkxFVkJRVVZETEVsQlFVa3NSVUZCUlhCRExFOUJRVThzUTBGQlF6dEpRVU42UXp0SlFVVkJPenM3T3pzN08wVkJRVUU3U1VGQlFUdEpRVUZCTEU5QlQwRXNhVUpCUVZGelF5eEpRVUZaTEVWQlFTdERPMDFCUVVFc1NVRkJOME5ETERKRlFVRXJRanRSUVVGRlF5eE5RVUZOTEVWQlFVVTdUVUZCUlN4RFFVRkZPMDFCUTJwRkxFOUJRVThzU1VGQlNTeERRVUZEZGtJc1VVRkJVU3hEUVVGRGQwSXNUMEZCVHl4RFFVRkRTQ3hKUVVGSkxFVkJRVVZETEVsQlFVa3NRMEZCUXp0SlFVTXhRenRKUVVWQk96czdSVUZCUVR0SlFVRkJPMGxCUVVFc1QwRkhRU3gxUWtGQlZ6dE5RVU5VTEU5QlFVOHNTVUZCU1N4RFFVRkRkRUlzVVVGQlVTeERRVUZEZVVJc1YwRkJWeXhGUVVGRk8wbEJRM0JETzBsQlJVRTdPenM3T3p0RlFVRkJPMGxCUVVFN1NVRkJRU3hQUVUxQkxIVkNRVUZqUkN4UFFVRjNRanROUVVOd1F5eFBRVUZQTEVsQlFVa3NRMEZCUTNoQ0xGRkJRVkVzUTBGQlF6QkNMR0ZCUVdFc1EwRkJRMFlzVDBGQlR5eERRVUZETzBsQlF6ZERPMGxCUlVFN096dEZRVUZCTzBsQlFVRTdTVUZCUVN4UFFVZEJMRFpDUVVGcFFqdE5RVU5tTEU5QlFVOHNTVUZCU1N4RFFVRkRlRUlzVVVGQlVTeERRVUZETWtJc2FVSkJRV2xDTEVWQlFVVTdTVUZETVVNN1JVRkJRenRKUVVGQk8wbEJRVUVzVDBGRllTd3lRa0ZCWlRzN096czdPenM3WTBGRFZpeFBRVUZOTEVsQlFVa3NRMEZCUXpGQ0xFbEJRVWtzUTBGQlF6SkNMRlZCUVZVc1JVRkJSVHRaUVVGQk8yTkJRVUU3WTBGQmNrTkRMRWxCUVVrc2VVSkJRVXBCTEVsQlFVazdZMEZCUVN4cFEwRkZUQ3huUWtGQlNTeERRVUZEUXl4UFFVRlBMREJEUVVGRlF5eFpRVUZaTEcxRFFVRkpMRWxCUVVrN1dVRkJRVHRaUVVGQk8yTkJRVUU3VlVGQlFUdFJRVUZCTzAxQlFVRTdPMFZCUXpGRE8wbEJRVUU3U1VGQlFTeFBRVVZQTEhWRFFWRk9OVVFzVDBGQlowTXNSVUZEYUVOdFF5eExRVUZoTzAxQlFVRXNTVUZRV0RsQ0xHZENRVUZuUWl4UlFVRm9Ra0VzWjBKQlFXZENPMUZCUTJoQ1F5eGpRVUZqTEZGQlFXUkJMR05CUVdNN1VVRkRaRU1zYTBKQlFXdENMRkZCUVd4Q1FTeHJRa0ZCYTBJN1VVRkRiRUp6UkN4UFFVRlBMRkZCUVZCQkxFOUJRVTg3VVVGRFVEbENMRlZCUVZVc1VVRkJWa0VzVlVGQlZUdE5RVXRhTEVsQlFVMHJRaXhYUVVGWExFZEJRVWM3VVVGRGJFSkRMR0ZCUVdFc2JVSkJRVmtzU1VGQlNTeERRVUZEY0VRc1YwRkJWeXhEUVVGRk8xRkJRek5EY1VRc1RVRkJUU3haUVVGTExFbEJRVWtzUTBGQlEzSkVMRmRCUVZjN1QwRkROVUk3VFVGRFJDeFBRVUZQTEVsQlFVbHpSQ3gxUTBGQmEwSXNRMEZCUXp0UlFVTTFRa01zUjBGQlJ5eEZRVUZGTEVsQlFVa3NRMEZCUTJwRUxFOUJRVTg3VVVGRGFrSnFRaXhQUVVGUExHdERRVUZQT0VRc1YwRkJWeXhIUVVGTE9VUXNUMEZCVHl4RFFVRkZPMUZCUTNaREswSXNWVUZCVlN4RlFVRkZRU3hWUVVGVk8xRkJRM1JDTVVJc1owSkJRV2RDTEVWQlFXaENRU3huUWtGQlowSTdVVUZEYUVKRExHTkJRV01zUlVGQlpFRXNZMEZCWXp0UlFVTmtReXhyUWtGQmEwSXNSVUZCYkVKQkxHdENRVUZyUWp0UlFVTnNRbk5FTEU5QlFVOHNSVUZCVUVFc1QwRkJUenRSUVVOUU1VSXNTMEZCU3l4RlFVRk1RVHRQUVVORUxFTkJRVU03U1VGRFNqdEZRVUZETzBsQlFVRTdTVUZCUVN4UFFVVlBMRFpDUVVGdlFuWkNMRTlCUVRoQ08wMUJRM2hFTEU5QlFVOHNTVUZCU1hWRUxEUkNRVUZqTEVOQlFVTXNTVUZCU1N4RFFVRkRjRVFzVjBGQlZ5eHJRMEZEY2tOSUxFOUJRVTg3VVVGRFZuZEVMRTFCUVUwc1owSkJRVTg3VlVGQlJVb3NUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJRM0pFTzFGQlFWY3NRMEZCUlN4RlFVRkxReXhQUVVGUExHRkJRVkJCTEU5QlFVOHNkVUpCUVZCQkxFOUJRVThzUTBGQlJYZEVMRTFCUVUwN1RVRkJRU3hIUVVNM1JEdEpRVU5LTzBWQlFVTTdTVUZCUVR0SlFVRkJMRTlCUlU4c1owTkJRVzlDTzAxQlFVRTdUVUZETVVJc1NVRkJTVllzU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXpWQ0xFbEJRVWtzUTBGQlEzVkRMR2xDUVVGcFFpeERRVUZETEZWQlFVTkRMRXRCUVVzc1JVRkJSVmdzVDBGQlR5eEZRVUZKTzFGQlEzaEVMRXRCUVVrc1EwRkJRMWtzYlVKQlFXMUNMRU5CUVVORUxFdEJRVXNzUlVGQlJWZ3NUMEZCVHl4aFFVRlFRU3hQUVVGUExIVkNRVUZRUVN4UFFVRlBMRU5CUVVWRExGbEJRVmtzUlVGQlJTeFJRVUZSTEVOQlFVTTdUVUZEYkVVc1EwRkJReXhEUVVGRE8wMUJRMFlzVDBGQlQwWXNTVUZCU1R0SlFVTmlPMFZCUVVNN1NVRkJRVHRKUVVGQkxFOUJSVThzTmtKQlEwNVpMRXRCUVhOQ0xFVkJRM1JDUlN4TFFVRjVRaXhGUVVONlFrTXNUVUZCTkVJN1RVRkZOVUlzU1VGRFJTeERRVUZEU0N4TFFVRkxMRXRCUVVzc2FVSkJRV2xDTEVsQlFVbEJMRXRCUVVzc1MwRkJTeXhYUVVGWExFdEJRM0pFTEVsQlFVa3NRMEZCUTBrc2EwSkJRV3RDTEV0QlFVdEdMRXRCUVVzc1JVRkRha003VVVGRFFUdFJRVU5CTEVsQlFVa3NRMEZCUXpORExGRkJRVkVzUTBGQlF6aERMRTlCUVU4c1EwRkJRMGdzUzBGQlN5eGhRVUZNUVN4TFFVRkxMR05CUVV4QkxFdEJRVXNzUjBGQlNTeEpRVUZKTEVOQlFVTTdVVUZGY0VNc1NVRkJTU3hEUVVGRFJTeHJRa0ZCYTBJc1IwRkJSMFlzUzBGQlN6dFBRVU5vUXl4TlFVRk5MRWxCUVVsR0xFdEJRVXNzUzBGQlN5eFpRVUZaTEVsQlFVbEJMRXRCUVVzc1MwRkJTeXhqUVVGakxFVkJRVVU3VVVGRE4wUTdVVUZEUVN4SlFVRkpMRU5CUVVONlF5eFJRVUZSTEVOQlFVTTRReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZEYUVVc1YwRkJWeXhEUVVGRE8xRkJRM1pETEVsQlFVazRSQ3hOUVVGTkxFbEJRVWtzVTBGQlV5eEZRVUZGTEVsQlFVa3NRMEZCUXpORExFbEJRVWtzUTBGQlF6aERMRTlCUVU4c1JVRkJSVHM3U1VGRmFFUTdSVUZCUXp0RlFVRkJPMEZCUVVFN1FVRnFVVWhESWl3aWJtRnRaWE1pT2xzaVJFVkdRVlZNVkY5SFRFOUNRVXhmVDFCVVNVOU9VeUlzSW1obFlXUmxjbk1pTENKamIyNXpkR0Z1ZEhOZk1TSXNJa1JGUmtGVlRGUmZSRUpmVDFCVVNVOU9VeUlzSW5OamFHVnRZU0lzSWtSRlJrRlZURlJmUVZWVVNGOVBVRlJKVDA1VElpd2lZWFYwYjFKbFpuSmxjMmhVYjJ0bGJpSXNJbkJsY25OcGMzUlRaWE56YVc5dUlpd2laR1YwWldOMFUyVnpjMmx2YmtsdVZYSnNJaXdpUkVWR1FWVk1WRjlTUlVGTVZFbE5SVjlQVUZSSlQwNVRJaXdpVTNWd1lXSmhjMlZEYkdsbGJuUWlMQ0p6ZFhCaFltRnpaVlZ5YkNJc0luTjFjR0ZpWVhObFMyVjVJaXdpYjNCMGFXOXVjeUlzSWtWeWNtOXlJaXdpWDNOMWNHRmlZWE5sVlhKc0lpd2ljbVZoYkhScGJXVlZjbXdpTENKeVpYQnNZV05sSWl3aVlYVjBhRlZ5YkNJc0luTjBiM0poWjJWVmNtd2lMQ0pwYzFCc1lYUm1iM0p0SWl3aWJXRjBZMmdpTENKMWNteFFZWEowY3lJc0luTndiR2wwSWl3aVpuVnVZM1JwYjI1elZYSnNJaXdpWkdWbVlYVnNkRk4wYjNKaFoyVkxaWGtpTENKVlVrd2lMQ0pvYjNOMGJtRnRaU0lzSWtSRlJrRlZURlJUSWl3aVpHSWlMQ0p5WldGc2RHbHRaU0lzSW1GMWRHZ2lMQ0p6ZEc5eVlXZGxTMlY1SWl3aVoyeHZZbUZzSWl3aWMyVjBkR2x1WjNNaUxDSmZhVzVwZEZOMWNHRmlZWE5sUVhWMGFFTnNhV1Z1ZENJc0ltWmxkR05vSWl3aVgyZGxkRUZqWTJWemMxUnZhMlZ1SWl3aVltbHVaQ0lzSWw5cGJtbDBVbVZoYkhScGJXVkRiR2xsYm5RaUxDSnlaWE4wSWl3aWNHOXpkR2R5WlhOMFgycHpYekVpTENKZmJHbHpkR1Z1Um05eVFYVjBhRVYyWlc1MGN5SXNJbVoxYm1OMGFXOXVjMTlxYzE4eElpd2lZM1Z6ZEc5dFJtVjBZMmdpTENKemRHOXlZV2RsWDJwelh6RWlMQ0p5Wld4aGRHbHZiaUlzSW1aeWIyMGlMQ0ptYmlJc0ltRnlaM01pTENKeWNHTWlMQ0p1WVcxbElpd2liM0IwY3lJc0ltTnZibVpwWnlJc0ltTm9ZVzV1Wld3aUxDSm5aWFJEYUdGdWJtVnNjeUlzSW5KbGJXOTJaVU5vWVc1dVpXd2lMQ0p5WlcxdmRtVkJiR3hEYUdGdWJtVnNjeUlzSW1kbGRGTmxjM05wYjI0aUxDSmtZWFJoSWl3aWMyVnpjMmx2YmlJc0ltRmpZMlZ6YzE5MGIydGxiaUlzSW5OMGIzSmhaMlVpTENKaGRYUm9TR1ZoWkdWeWN5SXNJa0YxZEdodmNtbDZZWFJwYjI0aUxDSmhjR2xyWlhraUxDSlRkWEJoWW1GelpVRjFkR2hEYkdsbGJuUmZNU0lzSW5WeWJDSXNJbkpsWVd4MGFXMWxYMnB6WHpFaUxDSndZWEpoYlhNaUxDSnZia0YxZEdoVGRHRjBaVU5vWVc1blpTSXNJbVYyWlc1MElpd2lYMmhoYm1Sc1pWUnZhMlZ1UTJoaGJtZGxaQ0lzSW5SdmEyVnVJaXdpYzI5MWNtTmxJaXdpWTJoaGJtZGxaRUZqWTJWemMxUnZhMlZ1SWl3aWMyVjBRWFYwYUNJc0luTnBaMjVQZFhRaUxDSmxlSEJ2Y25SeklsMHNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlUZFhCaFltRnpaVU5zYVdWdWRDNTBjeUpkTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2VzI1MWJHeGRmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICBkZXNjID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xudmFyIF9fZXhwb3J0U3RhciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2V4cG9ydFN0YXIgfHwgZnVuY3Rpb24gKG0sIGV4cG9ydHMpIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlQ2xpZW50ID0gZXhwb3J0cy5TdXBhYmFzZUNsaWVudCA9IGV4cG9ydHMuRnVuY3Rpb25zRXJyb3IgPSBleHBvcnRzLkZ1bmN0aW9uc1JlbGF5RXJyb3IgPSBleHBvcnRzLkZ1bmN0aW9uc0ZldGNoRXJyb3IgPSBleHBvcnRzLkZ1bmN0aW9uc0h0dHBFcnJvciA9IHZvaWQgMDtcbnZhciBTdXBhYmFzZUNsaWVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1N1cGFiYXNlQ2xpZW50XCIpKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiQHN1cGFiYXNlL2dvdHJ1ZS1qc1wiKSwgZXhwb3J0cyk7XG52YXIgZnVuY3Rpb25zX2pzXzEgPSByZXF1aXJlKFwiQHN1cGFiYXNlL2Z1bmN0aW9ucy1qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZ1bmN0aW9uc0h0dHBFcnJvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBmdW5jdGlvbnNfanNfMS5GdW5jdGlvbnNIdHRwRXJyb3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25zRmV0Y2hFcnJvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBmdW5jdGlvbnNfanNfMS5GdW5jdGlvbnNGZXRjaEVycm9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZ1bmN0aW9uc1JlbGF5RXJyb3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25zX2pzXzEuRnVuY3Rpb25zUmVsYXlFcnJvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbnNFcnJvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBmdW5jdGlvbnNfanNfMS5GdW5jdGlvbnNFcnJvcjtcbiAgfVxufSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIkBzdXBhYmFzZS9yZWFsdGltZS1qc1wiKSwgZXhwb3J0cyk7XG52YXIgU3VwYWJhc2VDbGllbnRfMiA9IHJlcXVpcmUoXCIuL1N1cGFiYXNlQ2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3VwYWJhc2VDbGllbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX19pbXBvcnREZWZhdWx0KFN1cGFiYXNlQ2xpZW50XzIpW1wiZGVmYXVsdFwiXTtcbiAgfVxufSk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU3VwYWJhc2UgQ2xpZW50LlxuICovXG52YXIgY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50XzFbXCJkZWZhdWx0XCJdKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucyk7XG59O1xuZXhwb3J0cy5jcmVhdGVDbGllbnQgPSBjcmVhdGVDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzBGQlFVRTdRVUZIUVVFN1FVRlJRVHRCUVVORlF6dEZRVUZCUXp0RlFVRkJRenRKUVVGQkxIZERRVUZyUWp0RlFVRkJPMEZCUVVFN1FVRkRiRUpHTzBWQlFVRkRPMFZCUVVGRE8wbEJRVUVzZVVOQlFXMUNPMFZCUVVFN1FVRkJRVHRCUVVOdVFrWTdSVUZCUVVNN1JVRkJRVU03U1VGQlFTeDVRMEZCYlVJN1JVRkJRVHRCUVVGQk8wRkJRMjVDUmp0RlFVRkJRenRGUVVGQlF6dEpRVUZCTEc5RFFVRmpPMFZCUVVFN1FVRkJRVHRCUVVWb1FrZzdRVUZEUVR0QlFVRlRRenRGUVVGQlF6dEZRVUZCUXp0SlFVRkJMRzFFUVVGUE8wVkJRVUU3UVVGQlFUdEJRVWRvUWpzN08wRkJSMDhzU1VGQlRVTXNXVUZCV1N4SFFVRkhMRk5CUVdaQkxGbEJRVmtzUTBGVGRrSkRMRmRCUVcxQ0xFVkJRMjVDUXl4WFFVRnRRaXhGUVVOdVFrTXNUMEZCTWtNc1JVRkRTenRGUVVOb1JDeFBRVUZQTEVsQlFVbERMREpDUVVGakxFTkJRVU5JTEZkQlFWY3NSVUZCUlVNc1YwRkJWeXhGUVVGRlF5eFBRVUZQTEVOQlFVTTdRVUZET1VRc1EwRkJRenRCUVdSWlJTeHZRa0ZCV1NJc0ltNWhiV1Z6SWpwYklsOWZaWGh3YjNKMFUzUmhjaUlzSWs5aWFtVmpkQ0lzSW1WdWRXMWxjbUZpYkdVaUxDSm5aWFFpTENKamNtVmhkR1ZEYkdsbGJuUWlMQ0p6ZFhCaFltRnpaVlZ5YkNJc0luTjFjR0ZpWVhObFMyVjVJaXdpYjNCMGFXOXVjeUlzSWxOMWNHRmlZWE5sUTJ4cFpXNTBYekVpTENKbGVIQnZjblJ6SWwwc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXBibVJsZUM1MGN5SmRMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXMjUxYkd4ZGZRPT0iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU3VwYWJhc2VBdXRoQ2xpZW50ID0gdm9pZCAwO1xudmFyIGdvdHJ1ZV9qc18xID0gcmVxdWlyZShcIkBzdXBhYmFzZS9nb3RydWUtanNcIik7XG52YXIgU3VwYWJhc2VBdXRoQ2xpZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfZ290cnVlX2pzXzEkR29UcnVlQ2wpIHtcbiAgX2luaGVyaXRzKFN1cGFiYXNlQXV0aENsaWVudCwgX2dvdHJ1ZV9qc18xJEdvVHJ1ZUNsKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTdXBhYmFzZUF1dGhDbGllbnQpO1xuICBmdW5jdGlvbiBTdXBhYmFzZUF1dGhDbGllbnQob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdXBhYmFzZUF1dGhDbGllbnQpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFN1cGFiYXNlQXV0aENsaWVudCk7XG59KGdvdHJ1ZV9qc18xLkdvVHJ1ZUNsaWVudCk7XG5leHBvcnRzLlN1cGFiYXNlQXV0aENsaWVudCA9IFN1cGFiYXNlQXV0aENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096dEJRVUZCTzBGQlFXdEVMRWxCUjNKRFFTeHJRa0ZCYlVJN1JVRkJRVHRGUVVGQk8wVkJRemxDTERSQ1FVRlpReXhQUVVGclF6dEpRVUZCTzBsQlFVRXNlVUpCUTNSRFFTeFBRVUZQTzBWQlEyWTdSVUZCUXp0QlFVRkJMRVZCU0hGRFF5eDNRa0ZCV1R0QlFVRndSRU1pTENKdVlXMWxjeUk2V3lKVGRYQmhZbUZ6WlVGMWRHaERiR2xsYm5RaUxDSnZjSFJwYjI1eklpd2laMjkwY25WbFgycHpYekVpTENKbGVIQnZjblJ6SWwwc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTlzYVdJdlUzVndZV0poYzJWQmRYUm9RMnhwWlc1MExuUnpJbDBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiYm5Wc2JGMTkiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuREVGQVVMVF9IRUFERVJTID0gdm9pZCAwO1xuLy8gY29uc3RhbnRzLnRzXG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMuREVGQVVMVF9IRUFERVJTID0ge1xuICAnWC1DbGllbnQtSW5mbyc6IFwic3VwYWJhc2UtanMvXCIuY29uY2F0KHZlcnNpb25fMS52ZXJzaW9uKVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3TzBGQlFVRTdRVUZEUVR0QlFVTmhRU3gxUWtGQlpTeEhRVUZITzBWQlFVVXNaVUZCWlN4M1FrRkJhVUpETEdsQ1FVRlBPMEZCUVVVc1EwRkJSU0lzSW01aGJXVnpJanBiSW1WNGNHOXlkSE1pTENKMlpYSnphVzl1WHpFaVhTd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZjM0pqTDJ4cFlpOWpiMjV6ZEdGdWRITXVkSE1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2x0dWRXeHNYWDA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IFwidXNlIHN0cmljdFwiOyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG52YXIgX19jcmVhdGVCaW5kaW5nID0gdm9pZCAwICYmICh2b2lkIDApLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgZGVzYyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdlxuICB9KTtcbn0gOiBmdW5jdGlvbiAobywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9IHZvaWQgMCAmJiAodm9pZCAwKS5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mZXRjaFdpdGhBdXRoID0gZXhwb3J0cy5yZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yID0gZXhwb3J0cy5yZXNvbHZlRmV0Y2ggPSB2b2lkIDA7XG52YXIgY3Jvc3NfZmV0Y2hfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiY3Jvc3MtZmV0Y2hcIikpO1xudmFyIHJlc29sdmVGZXRjaCA9IGZ1bmN0aW9uIHJlc29sdmVGZXRjaChjdXN0b21GZXRjaCkge1xuICB2YXIgX2ZldGNoO1xuICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2ZldGNoID0gY3Jvc3NfZmV0Y2hfMVtcImRlZmF1bHRcIl07XG4gIH0gZWxzZSB7XG4gICAgX2ZldGNoID0gZmV0Y2g7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2ZldGNoLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5leHBvcnRzLnJlc29sdmVGZXRjaCA9IHJlc29sdmVGZXRjaDtcbnZhciByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcigpIHtcbiAgaWYgKHR5cGVvZiBIZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBjcm9zc19mZXRjaF8xLkhlYWRlcnM7XG4gIH1cbiAgcmV0dXJuIEhlYWRlcnM7XG59O1xuZXhwb3J0cy5yZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yID0gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcjtcbnZhciBmZXRjaFdpdGhBdXRoID0gZnVuY3Rpb24gZmV0Y2hXaXRoQXV0aChzdXBhYmFzZUtleSwgZ2V0QWNjZXNzVG9rZW4sIGN1c3RvbUZldGNoKSB7XG4gIHZhciBmZXRjaCA9ICgwLCBleHBvcnRzLnJlc29sdmVGZXRjaCkoY3VzdG9tRmV0Y2gpO1xuICB2YXIgSGVhZGVyc0NvbnN0cnVjdG9yID0gKDAsIGV4cG9ydHMucmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcikoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgX2EsIGFjY2Vzc1Rva2VuLCBoZWFkZXJzO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfY29udGV4dC50MSA9IF9hID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHQudDEgIT09IG51bGw7XG4gICAgICAgICAgICBpZiAoIV9jb250ZXh0LnQwKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2EgIT09IHZvaWQgMDtcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBpZiAoIV9jb250ZXh0LnQwKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY29udGV4dC50MiA9IF9hO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnQyID0gc3VwYWJhc2VLZXk7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gX2NvbnRleHQudDI7XG4gICAgICAgICAgICBoZWFkZXJzID0gbmV3IEhlYWRlcnNDb25zdHJ1Y3Rvcihpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKCdhcGlrZXknKSkge1xuICAgICAgICAgICAgICBoZWFkZXJzLnNldCgnYXBpa2V5Jywgc3VwYWJhc2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoZWFkZXJzLmhhcygnQXV0aG9yaXphdGlvbicpKSB7XG4gICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgXCJCZWFyZXIgXCIuY29uY2F0KGFjY2Vzc1Rva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGZldGNoKGlucHV0LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXQpLCB7XG4gICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlKTtcbiAgICB9KSk7XG4gIH07XG59O1xuZXhwb3J0cy5mZXRjaFdpdGhBdXRoID0gZmV0Y2hXaXRoQXV0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPMEZCUVVFN1FVRkpUeXhKUVVGTlFTeFpRVUZaTEVkQlFVY3NVMEZCWmtFc1dVRkJXU3hEUVVGSlF5eFhRVUZ0UWl4RlFVRlhPMFZCUTNwRUxFbEJRVWxETEUxQlFXRTdSVUZEYWtJc1NVRkJTVVFzVjBGQlZ5eEZRVUZGTzBsQlEyWkRMRTFCUVUwc1IwRkJSMFFzVjBGQlZ6dEhRVU55UWl4TlFVRk5MRWxCUVVrc1QwRkJUMFVzUzBGQlN5eExRVUZMTEZkQlFWY3NSVUZCUlR0SlFVTjJRMFFzVFVGQlRTeEhRVUZIUlN4M1FrRkJPRUk3UjBGRGVFTXNUVUZCVFR0SlFVTk1SaXhOUVVGTkxFZEJRVWRETEV0QlFVczdPMFZCUldoQ0xFOUJRVTg3U1VGQlFTeFBRVUZoUkN4TlFVRk5MSGxDUVVGVE8wVkJRVUU3UVVGRGNrTXNRMEZCUXp0QlFWWlpSeXh2UWtGQldUdEJRVmxzUWl4SlFVRk5ReXg1UWtGQmVVSXNSMEZCUnl4VFFVRTFRa0VzZVVKQlFYbENMRWRCUVZFN1JVRkROVU1zU1VGQlNTeFBRVUZQUXl4UFFVRlBMRXRCUVVzc1YwRkJWeXhGUVVGRk8wbEJRMnhETEU5QlFVOUlMSEZDUVVGcFFqczdSVUZITVVJc1QwRkJUMGNzVDBGQlR6dEJRVU5vUWl4RFFVRkRPMEZCVGxsR0xHbERRVUY1UWp0QlFWRXZRaXhKUVVGTlJ5eGhRVUZoTEVkQlFVY3NVMEZCYUVKQkxHRkJRV0VzUTBGRGVFSkRMRmRCUVcxQ0xFVkJRMjVDUXl4alFVRTBReXhGUVVNMVExUXNWMEZCYlVJc1JVRkRWanRGUVVOVUxFbEJRVTFGTEV0QlFVc3NSMEZCUnl4M1FrRkJXU3hGUVVGRFJpeFhRVUZYTEVOQlFVTTdSVUZEZGtNc1NVRkJUVlVzYTBKQlFXdENMRWRCUVVjc2NVTkJRWGxDTEVkQlFVVTdSVUZGZEVRc1QwRkJUeXhWUVVGUFF5eExRVUZMTEVWQlFVVkRMRWxCUVVrN1NVRkJRU3hQUVVGSlF6dE5RVUZCTzAxQlFVRTdVVUZCUVR0VlFVRkJPMWxCUVVFN1dVRkRUaXhQUVVGTlNpeGpRVUZqTEVWQlFVVTdWVUZCUVR0WlFVRkJMR05CUVhaQ1N6dFpRVUZCTERoQ1FVRjNRanRaUVVGQk8yTkJRVUU3WTBGQlFUdFpRVUZCTzFsQlFVRTdWVUZCUVR0WlFVRkJPMk5CUVVFN1kwRkJRVHRaUVVGQk8xbEJRVUU3V1VGQlFUdFpRVUZCTzFWQlFVRTdXVUZCUVN4alFVRkpUaXhYUVVGWE8xVkJRVUU3V1VGQmNrUlBMRmRCUVZjN1dVRkRZa01zVDBGQlR5eEhRVUZITEVsQlFVbE9MR3RDUVVGclFpeERRVUZEUlN4SlFVRkpMR0ZCUVVwQkxFbEJRVWtzZFVKQlFVcEJMRWxCUVVrc1EwRkJSVWtzVDBGQlR5eERRVUZETzFsQlJXNUVMRWxCUVVrc1EwRkJRMEVzVDBGQlR5eERRVUZEUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hEUVVGRExFVkJRVVU3WTBGRE1VSkVMRTlCUVU4c1EwRkJRMFVzUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlZZc1YwRkJWeXhEUVVGRE96dFpRVWR3UXl4SlFVRkpMRU5CUVVOUkxFOUJRVThzUTBGQlEwTXNSMEZCUnl4RFFVRkRMR1ZCUVdVc1EwRkJReXhGUVVGRk8yTkJRMnBEUkN4UFFVRlBMRU5CUVVORkxFZEJRVWNzUTBGQlF5eGxRVUZsTEcxQ1FVRlpTQ3hYUVVGWExFVkJRVWM3TzFsQlEzUkVMR2xEUVVWTllpeExRVUZMTEVOQlFVTlRMRXRCUVVzc2EwTkJRVTlETEVsQlFVazdZMEZCUlVrc1QwRkJUeXhGUVVGUVFUdFpRVUZQTEVkQlFVYzdWVUZCUVR0VlFVRkJPMWxCUVVFN1VVRkJRVHROUVVGQk8wbEJRVUVzUTBGRE1VTTdSVUZCUVR0QlFVTklMRU5CUVVNN1FVRjBRbGxhTEhGQ1FVRmhJaXdpYm1GdFpYTWlPbHNpY21WemIyeDJaVVpsZEdOb0lpd2lZM1Z6ZEc5dFJtVjBZMmdpTENKZlptVjBZMmdpTENKbVpYUmphQ0lzSW1OeWIzTnpYMlpsZEdOb1h6RWlMQ0psZUhCdmNuUnpJaXdpY21WemIyeDJaVWhsWVdSbGNuTkRiMjV6ZEhKMVkzUnZjaUlzSWtobFlXUmxjbk1pTENKbVpYUmphRmRwZEdoQmRYUm9JaXdpYzNWd1lXSmhjMlZMWlhraUxDSm5aWFJCWTJObGMzTlViMnRsYmlJc0lraGxZV1JsY25ORGIyNXpkSEoxWTNSdmNpSXNJbWx1Y0hWMElpd2lhVzVwZENJc0lsOWZZWGRoYVhSbGNpSXNJbDloSWl3aVlXTmpaWE56Vkc5clpXNGlMQ0pvWldGa1pYSnpJaXdpYUdGeklpd2ljMlYwSWwwc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTlzYVdJdlptVjBZMmd1ZEhNaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sdHVkV3hzWFgwPSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hcHBseVNldHRpbmdEZWZhdWx0cyA9IGV4cG9ydHMuaXNCcm93c2VyID0gZXhwb3J0cy5zdHJpcFRyYWlsaW5nU2xhc2ggPSBleHBvcnRzLnV1aWQgPSB2b2lkIDA7XG5mdW5jdGlvbiB1dWlkKCkge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgIHYgPSBjID09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4O1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59XG5leHBvcnRzLnV1aWQgPSB1dWlkO1xuZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHVybCkge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG59XG5leHBvcnRzLnN0cmlwVHJhaWxpbmdTbGFzaCA9IHN0cmlwVHJhaWxpbmdTbGFzaDtcbnZhciBpc0Jyb3dzZXIgPSBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn07XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmZ1bmN0aW9uIGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIHZhciBkYk9wdGlvbnMgPSBvcHRpb25zLmRiLFxuICAgIGF1dGhPcHRpb25zID0gb3B0aW9ucy5hdXRoLFxuICAgIHJlYWx0aW1lT3B0aW9ucyA9IG9wdGlvbnMucmVhbHRpbWUsXG4gICAgZ2xvYmFsT3B0aW9ucyA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgREVGQVVMVF9EQl9PUFRJT05TID0gZGVmYXVsdHMuZGIsXG4gICAgREVGQVVMVF9BVVRIX09QVElPTlMgPSBkZWZhdWx0cy5hdXRoLFxuICAgIERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyA9IGRlZmF1bHRzLnJlYWx0aW1lLFxuICAgIERFRkFVTFRfR0xPQkFMX09QVElPTlMgPSBkZWZhdWx0cy5nbG9iYWw7XG4gIHJldHVybiB7XG4gICAgZGI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9EQl9PUFRJT05TKSwgZGJPcHRpb25zKSxcbiAgICBhdXRoOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQVVUSF9PUFRJT05TKSwgYXV0aE9wdGlvbnMpLFxuICAgIHJlYWx0aW1lOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyksIHJlYWx0aW1lT3B0aW9ucyksXG4gICAgZ2xvYmFsOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfR0xPQkFMX09QVElPTlMpLCBnbG9iYWxPcHRpb25zKVxuICB9O1xufVxuZXhwb3J0cy5hcHBseVNldHRpbmdEZWZhdWx0cyA9IGFwcGx5U2V0dGluZ0RlZmF1bHRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPMEZCUjBFc1UwRkJaMEpCTEVsQlFVazdSVUZEYkVJc1QwRkJUeXh6UTBGQmMwTXNRMEZCUTBNc1QwRkJUeXhEUVVGRExFOUJRVThzUlVGQlJTeFZRVUZWUXl4RFFVRkRPMGxCUTNoRkxFbEJRVWxETEVOQlFVTXNSMEZCU1VNc1NVRkJTU3hEUVVGRFF5eE5RVUZOTEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVrc1EwRkJRenROUVVNNVFrTXNRMEZCUXl4SFFVRkhTaXhEUVVGRExFbEJRVWtzUjBGQlJ5eEhRVUZIUXl4RFFVRkRMRWRCUVVsQkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVa3NSMEZCUnp0SlFVTndReXhQUVVGUFJ5eERRVUZETEVOQlFVTkRMRkZCUVZFc1EwRkJReXhGUVVGRkxFTkJRVU03UlVGRGRrSXNRMEZCUXl4RFFVRkRPMEZCUTBvN1FVRk9RVU03UVVGUlFTeFRRVUZuUWtNc2EwSkJRV3RDTEVOQlFVTkRMRWRCUVZjN1JVRkROVU1zVDBGQlQwRXNSMEZCUnl4RFFVRkRWQ3hQUVVGUExFTkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVVXNRMEZCUXp0QlFVTXZRanRCUVVaQlR6dEJRVWxQTEVsQlFVMUhMRk5CUVZNc1IwRkJSeXhUUVVGYVFTeFRRVUZUTzBWQlFVRXNUMEZCVXl4UFFVRlBReXhOUVVGTkxFdEJRVXNzVjBGQlZ6dEJRVUZCTzBGQlFTOURTaXhwUWtGQlV6dEJRVVYwUWl4VFFVRm5Ra3NzYjBKQlFXOUNMRU5CVFd4RFF5eFBRVUV3UXl4RlFVTXhRME1zVVVGQmIwTTdSVUZGY0VNc1NVRkRUVU1zVTBGQlV5eEhRVWxZUml4UFFVRlBMRU5CU2xSSExFVkJRVVU3U1VGRFNVTXNWMEZCVnl4SFFVZG1TaXhQUVVGUExFTkJTRlJMTEVsQlFVazdTVUZEVFVNc1pVRkJaU3hIUVVWMlFrNHNUMEZCVHl4RFFVWlVUeXhSUVVGUk8wbEJRMEZETEdGQlFXRXNSMEZEYmtKU0xFOUJRVThzUTBGRVZGTXNUVUZCVFR0RlFVVlNMRWxCUTAxRExHdENRVUZyUWl4SFFVbHdRbFFzVVVGQlVTeERRVXBXUlN4RlFVRkZPMGxCUTBsUkxHOUNRVUZ2UWl4SFFVZDRRbFlzVVVGQlVTeERRVWhXU1N4SlFVRkpPMGxCUTAxUExIZENRVUYzUWl4SFFVVm9RMWdzVVVGQlVTeERRVVpXVFN4UlFVRlJPMGxCUTBGTkxITkNRVUZ6UWl4SFFVTTFRbG9zVVVGQlVTeERRVVJXVVN4TlFVRk5PMFZCUjFJc1QwRkJUenRKUVVOTVRpeEZRVUZGTEd0RFFVTkhUeXhyUWtGQmEwSXNSMEZEYkVKU0xGTkJRVk1zUTBGRFlqdEpRVU5FUnl4SlFVRkpMR3REUVVORFRTeHZRa0ZCYjBJc1IwRkRjRUpRTEZkQlFWY3NRMEZEWmp0SlFVTkVSeXhSUVVGUkxHdERRVU5JU3l4M1FrRkJkMElzUjBGRGVFSk9MR1ZCUVdVc1EwRkRia0k3U1VGRFJFY3NUVUZCVFN4clEwRkRSRWtzYzBKQlFYTkNMRWRCUTNSQ1RDeGhRVUZoTzBkQlJXNUNPMEZCUTBnN1FVRjRRMEZrSWl3aWJtRnRaWE1pT2xzaWRYVnBaQ0lzSW5KbGNHeGhZMlVpTENKaklpd2ljaUlzSWsxaGRHZ2lMQ0p5WVc1a2IyMGlMQ0oySWl3aWRHOVRkSEpwYm1jaUxDSmxlSEJ2Y25Seklpd2ljM1J5YVhCVWNtRnBiR2x1WjFOc1lYTm9JaXdpZFhKc0lpd2lhWE5DY205M2MyVnlJaXdpZDJsdVpHOTNJaXdpWVhCd2JIbFRaWFIwYVc1blJHVm1ZWFZzZEhNaUxDSnZjSFJwYjI1eklpd2laR1ZtWVhWc2RITWlMQ0prWWs5d2RHbHZibk1pTENKa1lpSXNJbUYxZEdoUGNIUnBiMjV6SWl3aVlYVjBhQ0lzSW5KbFlXeDBhVzFsVDNCMGFXOXVjeUlzSW5KbFlXeDBhVzFsSWl3aVoyeHZZbUZzVDNCMGFXOXVjeUlzSW1kc2IySmhiQ0lzSWtSRlJrRlZURlJmUkVKZlQxQlVTVTlPVXlJc0lrUkZSa0ZWVEZSZlFWVlVTRjlQVUZSSlQwNVRJaXdpUkVWR1FWVk1WRjlTUlVGTVZFbE5SVjlQVUZSSlQwNVRJaXdpUkVWR1FWVk1WRjlIVEU5Q1FVeGZUMUJVU1U5T1V5SmRMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTl6Y21NdmJHbGlMMmhsYkhCbGNuTXVkSE1pWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2x0dWRXeHNYWDA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSAnMi4yLjInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPMEZCUVdGQkxHVkJRVThzUjBGQlJ5SXNJbTVoYldWeklqcGJJbVY0Y0c5eWRITWlYU3dpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2YzNKakwyeHBZaTkyWlhKemFXOXVMblJ6SWwwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYmJuVnNiRjE5IiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgTFJVID0gcmVxdWlyZSgnbmFub2xydScpXG5cbm1vZHVsZS5leHBvcnRzID0gQ2hvb0NvbXBvbmVudENhY2hlXG5cbmZ1bmN0aW9uIENob29Db21wb25lbnRDYWNoZSAoc3RhdGUsIGVtaXQsIGxydSkge1xuICBhc3NlcnQub2sodGhpcyBpbnN0YW5jZW9mIENob29Db21wb25lbnRDYWNoZSwgJ0Nob29Db21wb25lbnRDYWNoZSBzaG91bGQgYmUgY3JlYXRlZCB3aXRoIGBuZXdgJylcblxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHN0YXRlLCAnb2JqZWN0JywgJ0Nob29Db21wb25lbnRDYWNoZTogc3RhdGUgc2hvdWxkIGJlIHR5cGUgb2JqZWN0JylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBlbWl0LCAnZnVuY3Rpb24nLCAnQ2hvb0NvbXBvbmVudENhY2hlOiBlbWl0IHNob3VsZCBiZSB0eXBlIGZ1bmN0aW9uJylcblxuICBpZiAodHlwZW9mIGxydSA9PT0gJ251bWJlcicpIHRoaXMuY2FjaGUgPSBuZXcgTFJVKGxydSlcbiAgZWxzZSB0aGlzLmNhY2hlID0gbHJ1IHx8IG5ldyBMUlUoMTAwKVxuICB0aGlzLnN0YXRlID0gc3RhdGVcbiAgdGhpcy5lbWl0ID0gZW1pdFxufVxuXG4vLyBHZXQgJiBjcmVhdGUgY29tcG9uZW50IGluc3RhbmNlcy5cbkNob29Db21wb25lbnRDYWNoZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKENvbXBvbmVudCwgaWQpIHtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBDb21wb25lbnQsICdmdW5jdGlvbicsICdDaG9vQ29tcG9uZW50Q2FjaGUucmVuZGVyOiBDb21wb25lbnQgc2hvdWxkIGJlIHR5cGUgZnVuY3Rpb24nKVxuICBhc3NlcnQub2sodHlwZW9mIGlkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaWQgPT09ICdudW1iZXInLCAnQ2hvb0NvbXBvbmVudENhY2hlLnJlbmRlcjogaWQgc2hvdWxkIGJlIHR5cGUgc3RyaW5nIG9yIHR5cGUgbnVtYmVyJylcblxuICB2YXIgZWwgPSB0aGlzLmNhY2hlLmdldChpZClcbiAgaWYgKCFlbCkge1xuICAgIHZhciBhcmdzID0gW11cbiAgICBmb3IgKHZhciBpID0gMiwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgICBhcmdzLnVuc2hpZnQoQ29tcG9uZW50LCBpZCwgdGhpcy5zdGF0ZSwgdGhpcy5lbWl0KVxuICAgIGVsID0gbmV3Q2FsbC5hcHBseShuZXdDYWxsLCBhcmdzKVxuICAgIHRoaXMuY2FjaGUuc2V0KGlkLCBlbClcbiAgfVxuXG4gIHJldHVybiBlbFxufVxuXG4vLyBCZWNhdXNlIHlvdSBjYW4ndCBjYWxsIGBuZXdgIGFuZCBgLmFwcGx5KClgIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBtYWRcbi8vIGhhY2ssIGJ1dCBoZXkgaXQgd29ya3Mgc28gd2UgZ29ubmEgZ28gZm9yIGl0LiBXaG9vcC5cbmZ1bmN0aW9uIG5ld0NhbGwgKENscykge1xuICByZXR1cm4gbmV3IChDbHMuYmluZC5hcHBseShDbHMsIGFyZ3VtZW50cykpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbmFub2h0bWwnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCduYW5vaHRtbC9yYXcnKVxuIiwidmFyIHNjcm9sbFRvQW5jaG9yID0gcmVxdWlyZSgnc2Nyb2xsLXRvLWFuY2hvcicpXG52YXIgZG9jdW1lbnRSZWFkeSA9IHJlcXVpcmUoJ2RvY3VtZW50LXJlYWR5JylcbnZhciBuYW5vdGltaW5nID0gcmVxdWlyZSgnbmFub3RpbWluZycpXG52YXIgbmFub3JvdXRlciA9IHJlcXVpcmUoJ25hbm9yb3V0ZXInKVxudmFyIG5hbm9tb3JwaCA9IHJlcXVpcmUoJ25hbm9tb3JwaCcpXG52YXIgbmFub3F1ZXJ5ID0gcmVxdWlyZSgnbmFub3F1ZXJ5JylcbnZhciBuYW5vaHJlZiA9IHJlcXVpcmUoJ25hbm9ocmVmJylcbnZhciBuYW5vcmFmID0gcmVxdWlyZSgnbmFub3JhZicpXG52YXIgbmFub2J1cyA9IHJlcXVpcmUoJ25hbm9idXMnKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbnZhciBDYWNoZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50L2NhY2hlJylcblxubW9kdWxlLmV4cG9ydHMgPSBDaG9vXG5cbnZhciBISVNUT1JZX09CSkVDVCA9IHt9XG5cbmZ1bmN0aW9uIENob28gKG9wdHMpIHtcbiAgdmFyIHRpbWluZyA9IG5hbm90aW1pbmcoJ2Nob28uY29uc3RydWN0b3InKVxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2hvbykpIHJldHVybiBuZXcgQ2hvbyhvcHRzKVxuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3B0cywgJ29iamVjdCcsICdjaG9vOiBvcHRzIHNob3VsZCBiZSB0eXBlIG9iamVjdCcpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgLy8gZGVmaW5lIGV2ZW50cyB1c2VkIGJ5IGNob29cbiAgdGhpcy5fZXZlbnRzID0ge1xuICAgIERPTUNPTlRFTlRMT0FERUQ6ICdET01Db250ZW50TG9hZGVkJyxcbiAgICBET01USVRMRUNIQU5HRTogJ0RPTVRpdGxlQ2hhbmdlJyxcbiAgICBSRVBMQUNFU1RBVEU6ICdyZXBsYWNlU3RhdGUnLFxuICAgIFBVU0hTVEFURTogJ3B1c2hTdGF0ZScsXG4gICAgTkFWSUdBVEU6ICduYXZpZ2F0ZScsXG4gICAgUE9QU1RBVEU6ICdwb3BTdGF0ZScsXG4gICAgUkVOREVSOiAncmVuZGVyJ1xuICB9XG5cbiAgLy8gcHJvcGVydGllcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgdGhpcy5faGlzdG9yeUVuYWJsZWQgPSBvcHRzLmhpc3RvcnkgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLmhpc3RvcnlcbiAgdGhpcy5faHJlZkVuYWJsZWQgPSBvcHRzLmhyZWYgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLmhyZWZcbiAgdGhpcy5faGFzaEVuYWJsZWQgPSBvcHRzLmhhc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0cy5oYXNoXG4gIHRoaXMuX2hhc1dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gIHRoaXMuX2NhY2hlID0gb3B0cy5jYWNoZVxuICB0aGlzLl9sb2FkZWQgPSBmYWxzZVxuICB0aGlzLl9zdG9yZXMgPSBbb25kb210aXRsZWNoYW5nZV1cbiAgdGhpcy5fdHJlZSA9IG51bGxcblxuICAvLyBzdGF0ZVxuICB2YXIgX3N0YXRlID0ge1xuICAgIGV2ZW50czogdGhpcy5fZXZlbnRzLFxuICAgIGNvbXBvbmVudHM6IHt9XG4gIH1cbiAgaWYgKHRoaXMuX2hhc1dpbmRvdykge1xuICAgIHRoaXMuc3RhdGUgPSB3aW5kb3cuaW5pdGlhbFN0YXRlXG4gICAgICA/IE9iamVjdC5hc3NpZ24oe30sIHdpbmRvdy5pbml0aWFsU3RhdGUsIF9zdGF0ZSlcbiAgICAgIDogX3N0YXRlXG4gICAgZGVsZXRlIHdpbmRvdy5pbml0aWFsU3RhdGVcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXRlID0gX3N0YXRlXG4gIH1cblxuICAvLyBwcm9wZXJ0aWVzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIEFQSVxuICB0aGlzLnJvdXRlciA9IG5hbm9yb3V0ZXIoeyBjdXJyeTogdHJ1ZSB9KVxuICB0aGlzLmVtaXR0ZXIgPSBuYW5vYnVzKCdjaG9vLmVtaXQnKVxuICB0aGlzLmVtaXQgPSB0aGlzLmVtaXR0ZXIuZW1pdC5iaW5kKHRoaXMuZW1pdHRlcilcblxuICAvLyBsaXN0ZW4gZm9yIHRpdGxlIGNoYW5nZXM7IGF2YWlsYWJsZSBldmVuIHdoZW4gY2FsbGluZyAudG9TdHJpbmcoKVxuICBpZiAodGhpcy5faGFzV2luZG93KSB0aGlzLnN0YXRlLnRpdGxlID0gZG9jdW1lbnQudGl0bGVcbiAgZnVuY3Rpb24gb25kb210aXRsZWNoYW5nZSAoc3RhdGUpIHtcbiAgICBzZWxmLmVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKHNlbGYuX2V2ZW50cy5ET01USVRMRUNIQU5HRSwgZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHRpdGxlLCAnc3RyaW5nJywgJ2V2ZW50cy5ET01UaXRsZUNoYW5nZTogdGl0bGUgc2hvdWxkIGJlIHR5cGUgc3RyaW5nJylcbiAgICAgIHN0YXRlLnRpdGxlID0gdGl0bGVcbiAgICAgIGlmIChzZWxmLl9oYXNXaW5kb3cpIGRvY3VtZW50LnRpdGxlID0gdGl0bGVcbiAgICB9KVxuICB9XG4gIHRpbWluZygpXG59XG5cbkNob28ucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24gKHJvdXRlLCBoYW5kbGVyKSB7XG4gIHZhciByb3V0ZVRpbWluZyA9IG5hbm90aW1pbmcoXCJjaG9vLnJvdXRlKCdcIiArIHJvdXRlICsgXCInKVwiKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHJvdXRlLCAnc3RyaW5nJywgJ2Nob28ucm91dGU6IHJvdXRlIHNob3VsZCBiZSB0eXBlIHN0cmluZycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgaGFuZGxlciwgJ2Z1bmN0aW9uJywgJ2Nob28uaGFuZGxlcjogcm91dGUgc2hvdWxkIGJlIHR5cGUgZnVuY3Rpb24nKVxuICB0aGlzLnJvdXRlci5vbihyb3V0ZSwgaGFuZGxlcilcbiAgcm91dGVUaW1pbmcoKVxufVxuXG5DaG9vLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBjYiwgJ2Z1bmN0aW9uJywgJ2Nob28udXNlOiBjYiBzaG91bGQgYmUgdHlwZSBmdW5jdGlvbicpXG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9zdG9yZXMucHVzaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgbXNnID0gJ2Nob28udXNlJ1xuICAgIG1zZyA9IGNiLnN0b3JlTmFtZSA/IG1zZyArICcoJyArIGNiLnN0b3JlTmFtZSArICcpJyA6IG1zZ1xuICAgIHZhciBlbmRUaW1pbmcgPSBuYW5vdGltaW5nKG1zZylcbiAgICBjYihzdGF0ZSwgc2VsZi5lbWl0dGVyLCBzZWxmKVxuICAgIGVuZFRpbWluZygpXG4gIH0pXG59XG5cbkNob28ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICBhc3NlcnQuZXF1YWwodHlwZW9mIHdpbmRvdywgJ29iamVjdCcsICdjaG9vLnN0YXJ0OiB3aW5kb3cgd2FzIG5vdCBmb3VuZC4gLnN0YXJ0KCkgbXVzdCBiZSBjYWxsZWQgaW4gYSBicm93c2VyLCB1c2UgLnRvU3RyaW5nKCkgaWYgcnVubmluZyBpbiBOb2RlJylcbiAgdmFyIHN0YXJ0VGltaW5nID0gbmFub3RpbWluZygnY2hvby5zdGFydCcpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICh0aGlzLl9oaXN0b3J5RW5hYmxlZCkge1xuICAgIHRoaXMuZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIodGhpcy5fZXZlbnRzLk5BVklHQVRFLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9tYXRjaFJvdXRlKHNlbGYuc3RhdGUpXG4gICAgICBpZiAoc2VsZi5fbG9hZGVkKSB7XG4gICAgICAgIHNlbGYuZW1pdHRlci5lbWl0KHNlbGYuX2V2ZW50cy5SRU5ERVIpXG4gICAgICAgIHNldFRpbWVvdXQoc2Nyb2xsVG9BbmNob3IuYmluZChudWxsLCB3aW5kb3cubG9jYXRpb24uaGFzaCksIDApXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIodGhpcy5fZXZlbnRzLlBPUFNUQVRFLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXR0ZXIuZW1pdChzZWxmLl9ldmVudHMuTkFWSUdBVEUpXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIodGhpcy5fZXZlbnRzLlBVU0hTVEFURSwgZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgaHJlZiwgJ3N0cmluZycsICdldmVudHMucHVzaFN0YXRlOiBocmVmIHNob3VsZCBiZSB0eXBlIHN0cmluZycpXG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoSElTVE9SWV9PQkpFQ1QsIG51bGwsIGhyZWYpXG4gICAgICBzZWxmLmVtaXR0ZXIuZW1pdChzZWxmLl9ldmVudHMuTkFWSUdBVEUpXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIodGhpcy5fZXZlbnRzLlJFUExBQ0VTVEFURSwgZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgaHJlZiwgJ3N0cmluZycsICdldmVudHMucmVwbGFjZVN0YXRlOiBocmVmIHNob3VsZCBiZSB0eXBlIHN0cmluZycpXG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoSElTVE9SWV9PQkpFQ1QsIG51bGwsIGhyZWYpXG4gICAgICBzZWxmLmVtaXR0ZXIuZW1pdChzZWxmLl9ldmVudHMuTkFWSUdBVEUpXG4gICAgfSlcblxuICAgIHdpbmRvdy5vbnBvcHN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0dGVyLmVtaXQoc2VsZi5fZXZlbnRzLlBPUFNUQVRFKVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9ocmVmRW5hYmxlZCkge1xuICAgICAgbmFub2hyZWYoZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBocmVmID0gbG9jYXRpb24uaHJlZlxuICAgICAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2hcbiAgICAgICAgaWYgKGhyZWYgPT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLl9oYXNoRW5hYmxlZCAmJiBoYXNoKSBzY3JvbGxUb0FuY2hvcihoYXNoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW1pdHRlci5lbWl0KHNlbGYuX2V2ZW50cy5QVVNIU1RBVEUsIGhyZWYpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3NldENhY2hlKHRoaXMuc3RhdGUpXG4gIHRoaXMuX21hdGNoUm91dGUodGhpcy5zdGF0ZSlcbiAgdGhpcy5fc3RvcmVzLmZvckVhY2goZnVuY3Rpb24gKGluaXRTdG9yZSkge1xuICAgIGluaXRTdG9yZShzZWxmLnN0YXRlKVxuICB9KVxuXG4gIHRoaXMuX3RyZWUgPSB0aGlzLl9wcmVyZW5kZXIodGhpcy5zdGF0ZSlcbiAgYXNzZXJ0Lm9rKHRoaXMuX3RyZWUsICdjaG9vLnN0YXJ0OiBubyB2YWxpZCBET00gbm9kZSByZXR1cm5lZCBmb3IgbG9jYXRpb24gJyArIHRoaXMuc3RhdGUuaHJlZilcblxuICB0aGlzLmVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKHNlbGYuX2V2ZW50cy5SRU5ERVIsIG5hbm9yYWYoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJUaW1pbmcgPSBuYW5vdGltaW5nKCdjaG9vLnJlbmRlcicpXG4gICAgdmFyIG5ld1RyZWUgPSBzZWxmLl9wcmVyZW5kZXIoc2VsZi5zdGF0ZSlcbiAgICBhc3NlcnQub2sobmV3VHJlZSwgJ2Nob28ucmVuZGVyOiBubyB2YWxpZCBET00gbm9kZSByZXR1cm5lZCBmb3IgbG9jYXRpb24gJyArIHNlbGYuc3RhdGUuaHJlZilcblxuICAgIGFzc2VydC5lcXVhbChzZWxmLl90cmVlLm5vZGVOYW1lLCBuZXdUcmVlLm5vZGVOYW1lLCAnY2hvby5yZW5kZXI6IFRoZSB0YXJnZXQgbm9kZSA8JyArXG4gICAgICBzZWxmLl90cmVlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPiBpcyBub3QgdGhlIHNhbWUgdHlwZSBhcyB0aGUgbmV3IG5vZGUgPCcgK1xuICAgICAgbmV3VHJlZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4uJylcblxuICAgIHZhciBtb3JwaFRpbWluZyA9IG5hbm90aW1pbmcoJ2Nob28ubW9ycGgnKVxuICAgIG5hbm9tb3JwaChzZWxmLl90cmVlLCBuZXdUcmVlKVxuICAgIG1vcnBoVGltaW5nKClcblxuICAgIHJlbmRlclRpbWluZygpXG4gIH0pKVxuXG4gIGRvY3VtZW50UmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdHRlci5lbWl0KHNlbGYuX2V2ZW50cy5ET01DT05URU5UTE9BREVEKVxuICAgIHNlbGYuX2xvYWRlZCA9IHRydWVcbiAgfSlcblxuICBzdGFydFRpbWluZygpXG4gIHJldHVybiB0aGlzLl90cmVlXG59XG5cbkNob28ucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gbW91bnQgKHNlbGVjdG9yKSB7XG4gIHZhciBtb3VudFRpbWluZyA9IG5hbm90aW1pbmcoXCJjaG9vLm1vdW50KCdcIiArIHNlbGVjdG9yICsgXCInKVwiKVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJywgJ2Nob28ubW91bnQ6IHNlbGVjdG9yIHNob3VsZCBiZSB0eXBlIFN0cmluZycpXG4gICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yXG4gICAgbW91bnRUaW1pbmcoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhc3NlcnQub2sodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09ICdvYmplY3QnLCAnY2hvby5tb3VudDogc2VsZWN0b3Igc2hvdWxkIGJlIHR5cGUgU3RyaW5nIG9yIEhUTUxFbGVtZW50JylcblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICBkb2N1bWVudFJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVuZGVyVGltaW5nID0gbmFub3RpbWluZygnY2hvby5yZW5kZXInKVxuICAgIHZhciBuZXdUcmVlID0gc2VsZi5zdGFydCgpXG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlbGYuX3RyZWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl90cmVlID0gc2VsZWN0b3JcbiAgICB9XG5cbiAgICBhc3NlcnQub2soc2VsZi5fdHJlZSwgJ2Nob28ubW91bnQ6IGNvdWxkIG5vdCBxdWVyeSBzZWxlY3RvcjogJyArIHNlbGVjdG9yKVxuICAgIGFzc2VydC5lcXVhbChzZWxmLl90cmVlLm5vZGVOYW1lLCBuZXdUcmVlLm5vZGVOYW1lLCAnY2hvby5tb3VudDogVGhlIHRhcmdldCBub2RlIDwnICtcbiAgICAgIHNlbGYuX3RyZWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSArICc+IGlzIG5vdCB0aGUgc2FtZSB0eXBlIGFzIHRoZSBuZXcgbm9kZSA8JyArXG4gICAgICBuZXdUcmVlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPi4nKVxuXG4gICAgdmFyIG1vcnBoVGltaW5nID0gbmFub3RpbWluZygnY2hvby5tb3JwaCcpXG4gICAgbmFub21vcnBoKHNlbGYuX3RyZWUsIG5ld1RyZWUpXG4gICAgbW9ycGhUaW1pbmcoKVxuXG4gICAgcmVuZGVyVGltaW5nKClcbiAgfSlcbiAgbW91bnRUaW1pbmcoKVxufVxuXG5DaG9vLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgc3RhdGUpIHtcbiAgc3RhdGUgPSBzdGF0ZSB8fCB7fVxuICBzdGF0ZS5jb21wb25lbnRzID0gc3RhdGUuY29tcG9uZW50cyB8fCB7fVxuICBzdGF0ZS5ldmVudHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5ldmVudHMsIHRoaXMuX2V2ZW50cylcblxuICBhc3NlcnQubm90RXF1YWwodHlwZW9mIHdpbmRvdywgJ29iamVjdCcsICdjaG9vLm1vdW50OiB3aW5kb3cgd2FzIGZvdW5kLiAudG9TdHJpbmcoKSBtdXN0IGJlIGNhbGxlZCBpbiBOb2RlLCB1c2UgLnN0YXJ0KCkgb3IgLm1vdW50KCkgaWYgcnVubmluZyBpbiB0aGUgYnJvd3NlcicpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgbG9jYXRpb24sICdzdHJpbmcnLCAnY2hvby50b1N0cmluZzogbG9jYXRpb24gc2hvdWxkIGJlIHR5cGUgc3RyaW5nJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBzdGF0ZSwgJ29iamVjdCcsICdjaG9vLnRvU3RyaW5nOiBzdGF0ZSBzaG91bGQgYmUgdHlwZSBvYmplY3QnKVxuXG4gIHRoaXMuX3NldENhY2hlKHN0YXRlKVxuICB0aGlzLl9tYXRjaFJvdXRlKHN0YXRlLCBsb2NhdGlvbilcbiAgdGhpcy5lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpXG4gIHRoaXMuX3N0b3Jlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbml0U3RvcmUpIHtcbiAgICBpbml0U3RvcmUoc3RhdGUpXG4gIH0pXG5cbiAgdmFyIGh0bWwgPSB0aGlzLl9wcmVyZW5kZXIoc3RhdGUpXG4gIGFzc2VydC5vayhodG1sLCAnY2hvby50b1N0cmluZzogbm8gdmFsaWQgdmFsdWUgcmV0dXJuZWQgZm9yIHRoZSByb3V0ZSAnICsgbG9jYXRpb24pXG4gIGFzc2VydCghQXJyYXkuaXNBcnJheShodG1sKSwgJ2Nob28udG9TdHJpbmc6IHJldHVybiB2YWx1ZSB3YXMgYW4gYXJyYXkgZm9yIHRoZSByb3V0ZSAnICsgbG9jYXRpb24pXG4gIHJldHVybiB0eXBlb2YgaHRtbC5vdXRlckhUTUwgPT09ICdzdHJpbmcnID8gaHRtbC5vdXRlckhUTUwgOiBodG1sLnRvU3RyaW5nKClcbn1cblxuQ2hvby5wcm90b3R5cGUuX21hdGNoUm91dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGxvY2F0aW9uT3ZlcnJpZGUpIHtcbiAgdmFyIGxvY2F0aW9uLCBxdWVyeVN0cmluZ1xuICBpZiAobG9jYXRpb25PdmVycmlkZSkge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb25PdmVycmlkZS5yZXBsYWNlKC9cXD8uKyQvLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKVxuICAgIGlmICghdGhpcy5faGFzaEVuYWJsZWQpIGxvY2F0aW9uID0gbG9jYXRpb24ucmVwbGFjZSgvIy4rJC8sICcnKVxuICAgIHF1ZXJ5U3RyaW5nID0gbG9jYXRpb25PdmVycmlkZVxuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCAnJylcbiAgICBpZiAodGhpcy5faGFzaEVuYWJsZWQpIGxvY2F0aW9uICs9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoL14jLywgJy8nKVxuICAgIHF1ZXJ5U3RyaW5nID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaFxuICB9XG4gIHZhciBtYXRjaGVkID0gdGhpcy5yb3V0ZXIubWF0Y2gobG9jYXRpb24pXG4gIHRoaXMuX2hhbmRsZXIgPSBtYXRjaGVkLmNiXG4gIHN0YXRlLmhyZWYgPSBsb2NhdGlvblxuICBzdGF0ZS5xdWVyeSA9IG5hbm9xdWVyeShxdWVyeVN0cmluZylcbiAgc3RhdGUucm91dGUgPSBtYXRjaGVkLnJvdXRlXG4gIHN0YXRlLnBhcmFtcyA9IG1hdGNoZWQucGFyYW1zXG59XG5cbkNob28ucHJvdG90eXBlLl9wcmVyZW5kZXIgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIHJvdXRlVGltaW5nID0gbmFub3RpbWluZyhcImNob28ucHJlcmVuZGVyKCdcIiArIHN0YXRlLnJvdXRlICsgXCInKVwiKVxuICB2YXIgcmVzID0gdGhpcy5faGFuZGxlcihzdGF0ZSwgdGhpcy5lbWl0KVxuICByb3V0ZVRpbWluZygpXG4gIHJldHVybiByZXNcbn1cblxuQ2hvby5wcm90b3R5cGUuX3NldENhY2hlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBjYWNoZSA9IG5ldyBDYWNoZShzdGF0ZSwgdGhpcy5lbWl0dGVyLmVtaXQuYmluZCh0aGlzLmVtaXR0ZXIpLCB0aGlzLl9jYWNoZSlcbiAgc3RhdGUuY2FjaGUgPSByZW5kZXJDb21wb25lbnRcblxuICBmdW5jdGlvbiByZW5kZXJDb21wb25lbnQgKENvbXBvbmVudCwgaWQpIHtcbiAgICBhc3NlcnQuZXF1YWwodHlwZW9mIENvbXBvbmVudCwgJ2Z1bmN0aW9uJywgJ2Nob28uc3RhdGUuY2FjaGU6IENvbXBvbmVudCBzaG91bGQgYmUgdHlwZSBmdW5jdGlvbicpXG4gICAgdmFyIGFyZ3MgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pXG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5yZW5kZXIuYXBwbHkoY2FjaGUsIGFyZ3MpXG4gIH1cblxuICAvLyBXaGVuIHRoZSBzdGF0ZSBnZXRzIHN0cmluZ2lmaWVkLCBtYWtlIHN1cmUgYHN0YXRlLmNhY2hlYCBpc24ndFxuICAvLyBzdHJpbmdpZmllZCB0b28uXG4gIHJlbmRlckNvbXBvbmVudC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwidmFyIGdsb2JhbCA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzO1xudmFyIF9fc2VsZl9fID0gKGZ1bmN0aW9uICgpIHtcbmZ1bmN0aW9uIEYoKSB7XG50aGlzLmZldGNoID0gZmFsc2U7XG50aGlzLkRPTUV4Y2VwdGlvbiA9IGdsb2JhbC5ET01FeGNlcHRpb25cbn1cbkYucHJvdG90eXBlID0gZ2xvYmFsO1xucmV0dXJuIG5ldyBGKCk7XG59KSgpO1xuKGZ1bmN0aW9uKHNlbGYpIHtcblxudmFyIGlycmVsZXZhbnQgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjpcbiAgICAgICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmXG4gICAgICAnQmxvYicgaW4gc2VsZiAmJlxuICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF07XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV07XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpO1xuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKTtcbiAgICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5O1xuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybDtcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFscztcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2Q7XG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlO1xuICAgICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWw7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nO1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpO1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbDtcbiAgICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG4gIH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGJvZHlcbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdCgnJicpXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpO1xuICAgIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXM7XG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSyc7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTtcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH07XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJztcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfTtcblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfTtcblxuICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IHNlbGYuRE9NRXhjZXB0aW9uO1xuICB0cnkge1xuICAgIG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgfTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXhwb3J0cy5ET01FeGNlcHRpb247XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpO1xuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKTtcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcblxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9XG5cbiAgZmV0Y2gucG9seWZpbGwgPSB0cnVlO1xuXG4gIGlmICghc2VsZi5mZXRjaCkge1xuICAgIHNlbGYuZmV0Y2ggPSBmZXRjaDtcbiAgICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzO1xuICAgIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICB9XG5cbiAgZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbiAgZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICBleHBvcnRzLmZldGNoID0gZmV0Y2g7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZXhwb3J0cztcblxufSkoe30pO1xufSkoX19zZWxmX18pO1xuX19zZWxmX18uZmV0Y2gucG9ueWZpbGwgPSB0cnVlO1xuLy8gUmVtb3ZlIFwicG9seWZpbGxcIiBwcm9wZXJ0eSBhZGRlZCBieSB3aGF0d2ctZmV0Y2hcbmRlbGV0ZSBfX3NlbGZfXy5mZXRjaC5wb2x5ZmlsbDtcbi8vIENob29zZSBiZXR3ZWVuIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiAoZ2xvYmFsKSBvciBjdXN0b20gaW1wbGVtZW50YXRpb24gKF9fc2VsZl9fKVxuLy8gdmFyIGN0eCA9IGdsb2JhbC5mZXRjaCA/IGdsb2JhbCA6IF9fc2VsZl9fO1xudmFyIGN0eCA9IF9fc2VsZl9fOyAvLyB0aGlzIGxpbmUgZGlzYWJsZSBzZXJ2aWNlIHdvcmtlciBzdXBwb3J0IHRlbXBvcmFyaWx5XG5leHBvcnRzID0gY3R4LmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IGZldGNoIGZyb20gJ2Nyb3NzLWZldGNoJ1xuZXhwb3J0cy5kZWZhdWx0ID0gY3R4LmZldGNoIC8vIEZvciBUeXBlU2NyaXB0IGNvbnN1bWVycyB3aXRob3V0IGVzTW9kdWxlSW50ZXJvcC5cbmV4cG9ydHMuZmV0Y2ggPSBjdHguZmV0Y2ggLy8gVG8gZW5hYmxlOiBpbXBvcnQge2ZldGNofSBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuSGVhZGVycyA9IGN0eC5IZWFkZXJzXG5leHBvcnRzLlJlcXVlc3QgPSBjdHguUmVxdWVzdFxuZXhwb3J0cy5SZXNwb25zZSA9IGN0eC5SZXNwb25zZVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSByZWFkeVxuXG5mdW5jdGlvbiByZWFkeSAoY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvY3VtZW50LXJlYWR5IG9ubHkgcnVucyBpbiB0aGUgYnJvd3NlcicpXG4gIH1cbiAgdmFyIHN0YXRlID0gZG9jdW1lbnQucmVhZHlTdGF0ZVxuICBpZiAoc3RhdGUgPT09ICdjb21wbGV0ZScgfHwgc3RhdGUgPT09ICdpbnRlcmFjdGl2ZScpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgMClcbiAgfVxuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiBvbkxvYWQgKCkge1xuICAgIGNhbGxiYWNrKClcbiAgfSlcbn1cbiIsInZhciBuYWl2ZUZhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZikgcmV0dXJuIHNlbGY7XG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdykgcmV0dXJuIHdpbmRvdztcblx0dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIGB0aGlzYFwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMpIHJldHVybiB0aGlzO1xuXG5cdC8vIFVuZXhwZWN0ZWQgc3RyaWN0IG1vZGUgKG1heSBoYXBwZW4gaWYgZS5nLiBidW5kbGVkIGludG8gRVNNIG1vZHVsZSlcblxuXHQvLyBGYWxsYmFjayB0byBzdGFuZGFyZCBnbG9iYWxUaGlzIGlmIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsVGhpcykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cblx0Ly8gVGhhbmtzIEBtYXRoaWFzYnluZW5zIC0+IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9nbG9iYWx0aGlzXG5cdC8vIEluIGFsbCBFUzUrIGVuZ2luZXMgZ2xvYmFsIG9iamVjdCBpbmhlcml0cyBmcm9tIE9iamVjdC5wcm90b3R5cGVcblx0Ly8gKGlmIHlvdSBhcHByb2FjaGVkIG9uZSB0aGF0IGRvZXNuJ3QgcGxlYXNlIHJlcG9ydClcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgXCJfX2dsb2JhbF9fXCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFVuZm9ydHVuYXRlIGNhc2Ugb2YgdXBkYXRlcyB0byBPYmplY3QucHJvdG90eXBlIGJlaW5nIHJlc3RyaWN0ZWRcblx0XHQvLyB2aWEgcHJldmVudEV4dGVuc2lvbnMsIHNlYWwgb3IgZnJlZXplXG5cdFx0cmV0dXJuIG5haXZlRmFsbGJhY2soKTtcblx0fVxuXHR0cnkge1xuXHRcdC8vIFNhZmFyaSBjYXNlICh3aW5kb3cuX19nbG9iYWxfXyB3b3JrcywgYnV0IF9fZ2xvYmFsX18gZG9lcyBub3QpXG5cdFx0aWYgKCFfX2dsb2JhbF9fKSByZXR1cm4gbmFpdmVGYWxsYmFjaygpO1xuXHRcdHJldHVybiBfX2dsb2JhbF9fO1xuXHR9IGZpbmFsbHkge1xuXHRcdGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fZ2xvYmFsX187XG5cdH1cbn0pKCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGF0dHJpYnV0ZVRvUHJvcGVydHlcblxudmFyIHRyYW5zZm9ybSA9IHtcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICdmb3InOiAnaHRtbEZvcicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdidcbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlVG9Qcm9wZXJ0eSAoaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhZ05hbWUsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgIGlmIChhdHRyIGluIHRyYW5zZm9ybSkge1xuICAgICAgICBhdHRyc1t0cmFuc2Zvcm1bYXR0cl1dID0gYXR0cnNbYXR0cl1cbiAgICAgICAgZGVsZXRlIGF0dHJzW2F0dHJdXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoKHRhZ05hbWUsIGF0dHJzLCBjaGlsZHJlbilcbiAgfVxufVxuIiwidmFyIGF0dHJUb1Byb3AgPSByZXF1aXJlKCdoeXBlcnNjcmlwdC1hdHRyaWJ1dGUtdG8tcHJvcGVydHknKVxuXG52YXIgVkFSID0gMCwgVEVYVCA9IDEsIE9QRU4gPSAyLCBDTE9TRSA9IDMsIEFUVFIgPSA0XG52YXIgQVRUUl9LRVkgPSA1LCBBVFRSX0tFWV9XID0gNlxudmFyIEFUVFJfVkFMVUVfVyA9IDcsIEFUVFJfVkFMVUUgPSA4XG52YXIgQVRUUl9WQUxVRV9TUSA9IDksIEFUVFJfVkFMVUVfRFEgPSAxMFxudmFyIEFUVFJfRVEgPSAxMSwgQVRUUl9CUkVBSyA9IDEyXG52YXIgQ09NTUVOVCA9IDEzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGgsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgdmFyIGNvbmNhdCA9IG9wdHMuY29uY2F0IHx8IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSArIFN0cmluZyhiKVxuICB9XG4gIGlmIChvcHRzLmF0dHJUb1Byb3AgIT09IGZhbHNlKSB7XG4gICAgaCA9IGF0dHJUb1Byb3AoaClcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5ncykge1xuICAgIHZhciBzdGF0ZSA9IFRFWFQsIHJlZyA9ICcnXG4gICAgdmFyIGFyZ2xlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICB2YXIgcGFydHMgPSBbXVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA8IGFyZ2xlbiAtIDEpIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpKzFdXG4gICAgICAgIHZhciBwID0gcGFyc2Uoc3RyaW5nc1tpXSlcbiAgICAgICAgdmFyIHhzdGF0ZSA9IHN0YXRlXG4gICAgICAgIGlmICh4c3RhdGUgPT09IEFUVFJfVkFMVUVfRFEpIHhzdGF0ZSA9IEFUVFJfVkFMVUVcbiAgICAgICAgaWYgKHhzdGF0ZSA9PT0gQVRUUl9WQUxVRV9TUSkgeHN0YXRlID0gQVRUUl9WQUxVRVxuICAgICAgICBpZiAoeHN0YXRlID09PSBBVFRSX1ZBTFVFX1cpIHhzdGF0ZSA9IEFUVFJfVkFMVUVcbiAgICAgICAgaWYgKHhzdGF0ZSA9PT0gQVRUUikgeHN0YXRlID0gQVRUUl9LRVlcbiAgICAgICAgaWYgKHhzdGF0ZSA9PT0gT1BFTikge1xuICAgICAgICAgIGlmIChyZWcgPT09ICcvJykge1xuICAgICAgICAgICAgcC5wdXNoKFsgT1BFTiwgJy8nLCBhcmcgXSlcbiAgICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAucHVzaChbIE9QRU4sIGFyZyBdKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh4c3RhdGUgPT09IENPTU1FTlQgJiYgb3B0cy5jb21tZW50cykge1xuICAgICAgICAgIHJlZyArPSBTdHJpbmcoYXJnKVxuICAgICAgICB9IGVsc2UgaWYgKHhzdGF0ZSAhPT0gQ09NTUVOVCkge1xuICAgICAgICAgIHAucHVzaChbIFZBUiwgeHN0YXRlLCBhcmcgXSlcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoLmFwcGx5KHBhcnRzLCBwKVxuICAgICAgfSBlbHNlIHBhcnRzLnB1c2guYXBwbHkocGFydHMsIHBhcnNlKHN0cmluZ3NbaV0pKVxuICAgIH1cblxuICAgIHZhciB0cmVlID0gW251bGwse30sW11dXG4gICAgdmFyIHN0YWNrID0gW1t0cmVlLC0xXV1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdWzBdXG4gICAgICB2YXIgcCA9IHBhcnRzW2ldLCBzID0gcFswXVxuICAgICAgaWYgKHMgPT09IE9QRU4gJiYgL15cXC8vLnRlc3QocFsxXSkpIHtcbiAgICAgICAgdmFyIGl4ID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdWzFdXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGgtMV1bMF1bMl1baXhdID0gaChcbiAgICAgICAgICAgIGN1clswXSwgY3VyWzFdLCBjdXJbMl0ubGVuZ3RoID8gY3VyWzJdIDogdW5kZWZpbmVkXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHMgPT09IE9QRU4pIHtcbiAgICAgICAgdmFyIGMgPSBbcFsxXSx7fSxbXV1cbiAgICAgICAgY3VyWzJdLnB1c2goYylcbiAgICAgICAgc3RhY2sucHVzaChbYyxjdXJbMl0ubGVuZ3RoLTFdKVxuICAgICAgfSBlbHNlIGlmIChzID09PSBBVFRSX0tFWSB8fCAocyA9PT0gVkFSICYmIHBbMV0gPT09IEFUVFJfS0VZKSkge1xuICAgICAgICB2YXIga2V5ID0gJydcbiAgICAgICAgdmFyIGNvcHlLZXlcbiAgICAgICAgZm9yICg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICAgIGtleSA9IGNvbmNhdChrZXksIHBhcnRzW2ldWzFdKVxuICAgICAgICAgIH0gZWxzZSBpZiAocGFydHNbaV1bMF0gPT09IFZBUiAmJiBwYXJ0c1tpXVsxXSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydHNbaV1bMl0gPT09ICdvYmplY3QnICYmICFrZXkpIHtcbiAgICAgICAgICAgICAgZm9yIChjb3B5S2V5IGluIHBhcnRzW2ldWzJdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzW2ldWzJdLmhhc093blByb3BlcnR5KGNvcHlLZXkpICYmICFjdXJbMV1bY29weUtleV0pIHtcbiAgICAgICAgICAgICAgICAgIGN1clsxXVtjb3B5S2V5XSA9IHBhcnRzW2ldWzJdW2NvcHlLZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBrZXkgPSBjb25jYXQoa2V5LCBwYXJ0c1tpXVsyXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydHNbaV1bMF0gPT09IEFUVFJfRVEpIGkrK1xuICAgICAgICB2YXIgaiA9IGlcbiAgICAgICAgZm9yICg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gQVRUUl9WQUxVRSB8fCBwYXJ0c1tpXVswXSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICAgIGlmICghY3VyWzFdW2tleV0pIGN1clsxXVtrZXldID0gc3RyZm4ocGFydHNbaV1bMV0pXG4gICAgICAgICAgICBlbHNlIHBhcnRzW2ldWzFdPT09XCJcIiB8fCAoY3VyWzFdW2tleV0gPSBjb25jYXQoY3VyWzFdW2tleV0sIHBhcnRzW2ldWzFdKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXVswXSA9PT0gVkFSXG4gICAgICAgICAgJiYgKHBhcnRzW2ldWzFdID09PSBBVFRSX1ZBTFVFIHx8IHBhcnRzW2ldWzFdID09PSBBVFRSX0tFWSkpIHtcbiAgICAgICAgICAgIGlmICghY3VyWzFdW2tleV0pIGN1clsxXVtrZXldID0gc3RyZm4ocGFydHNbaV1bMl0pXG4gICAgICAgICAgICBlbHNlIHBhcnRzW2ldWzJdPT09XCJcIiB8fCAoY3VyWzFdW2tleV0gPSBjb25jYXQoY3VyWzFdW2tleV0sIHBhcnRzW2ldWzJdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrZXkubGVuZ3RoICYmICFjdXJbMV1ba2V5XSAmJiBpID09PSBqXG4gICAgICAgICAgICAmJiAocGFydHNbaV1bMF0gPT09IENMT1NFIHx8IHBhcnRzW2ldWzBdID09PSBBVFRSX0JSRUFLKSkge1xuICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI2Jvb2xlYW4tYXR0cmlidXRlc1xuICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgZmFsc3ksIG5vdCB3ZWxsIGJlaGF2ZWQgdmFsdWUgaW4gYnJvd3NlclxuICAgICAgICAgICAgICBjdXJbMV1ba2V5XSA9IGtleS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydHNbaV1bMF0gPT09IENMT1NFKSB7XG4gICAgICAgICAgICAgIGktLVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgY3VyWzFdW3BbMV1dID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzID09PSBWQVIgJiYgcFsxXSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgY3VyWzFdW3BbMl1dID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzID09PSBDTE9TRSkge1xuICAgICAgICBpZiAoc2VsZkNsb3NpbmcoY3VyWzBdKSAmJiBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgaXggPSBzdGFja1tzdGFjay5sZW5ndGgtMV1bMV1cbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aC0xXVswXVsyXVtpeF0gPSBoKFxuICAgICAgICAgICAgY3VyWzBdLCBjdXJbMV0sIGN1clsyXS5sZW5ndGggPyBjdXJbMl0gOiB1bmRlZmluZWRcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gVkFSICYmIHBbMV0gPT09IFRFWFQpIHtcbiAgICAgICAgaWYgKHBbMl0gPT09IHVuZGVmaW5lZCB8fCBwWzJdID09PSBudWxsKSBwWzJdID0gJydcbiAgICAgICAgZWxzZSBpZiAoIXBbMl0pIHBbMl0gPSBjb25jYXQoJycsIHBbMl0pXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBbMl1bMF0pKSB7XG4gICAgICAgICAgY3VyWzJdLnB1c2guYXBwbHkoY3VyWzJdLCBwWzJdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1clsyXS5wdXNoKHBbMl0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gVEVYVCkge1xuICAgICAgICBjdXJbMl0ucHVzaChwWzFdKVxuICAgICAgfSBlbHNlIGlmIChzID09PSBBVFRSX0VRIHx8IHMgPT09IEFUVFJfQlJFQUspIHtcbiAgICAgICAgLy8gbm8tb3BcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5kbGVkOiAnICsgcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJlZVsyXS5sZW5ndGggPiAxICYmIC9eXFxzKiQvLnRlc3QodHJlZVsyXVswXSkpIHtcbiAgICAgIHRyZWVbMl0uc2hpZnQoKVxuICAgIH1cblxuICAgIGlmICh0cmVlWzJdLmxlbmd0aCA+IDJcbiAgICB8fCAodHJlZVsyXS5sZW5ndGggPT09IDIgJiYgL1xcUy8udGVzdCh0cmVlWzJdWzFdKSkpIHtcbiAgICAgIGlmIChvcHRzLmNyZWF0ZUZyYWdtZW50KSByZXR1cm4gb3B0cy5jcmVhdGVGcmFnbWVudCh0cmVlWzJdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbXVsdGlwbGUgcm9vdCBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gYW4gZW5jbG9zaW5nIHRhZydcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZVsyXVswXSkgJiYgdHlwZW9mIHRyZWVbMl1bMF1bMF0gPT09ICdzdHJpbmcnXG4gICAgJiYgQXJyYXkuaXNBcnJheSh0cmVlWzJdWzBdWzJdKSkge1xuICAgICAgdHJlZVsyXVswXSA9IGgodHJlZVsyXVswXVswXSwgdHJlZVsyXVswXVsxXSwgdHJlZVsyXVswXVsyXSlcbiAgICB9XG4gICAgcmV0dXJuIHRyZWVbMl1bMF1cblxuICAgIGZ1bmN0aW9uIHBhcnNlIChzdHIpIHtcbiAgICAgIHZhciByZXMgPSBbXVxuICAgICAgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1cpIHN0YXRlID0gQVRUUlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gVEVYVCAmJiBjID09PSAnPCcpIHtcbiAgICAgICAgICBpZiAocmVnLmxlbmd0aCkgcmVzLnB1c2goW1RFWFQsIHJlZ10pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IE9QRU5cbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicgJiYgIXF1b3Qoc3RhdGUpICYmIHN0YXRlICE9PSBDT01NRU5UKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBPUEVOICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtPUEVOLHJlZ10pXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddKVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUUgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2goW0NMT1NFXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gVEVYVFxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBDT01NRU5UICYmIC8tJC8udGVzdChyZWcpICYmIGMgPT09ICctJykge1xuICAgICAgICAgIGlmIChvcHRzLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWcuc3Vic3RyKDAsIHJlZy5sZW5ndGggLSAxKV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBURVhUXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IE9QRU4gJiYgL14hLS0kLy50ZXN0KHJlZykpIHtcbiAgICAgICAgICBpZiAob3B0cy5jb21tZW50cykge1xuICAgICAgICAgICAgcmVzLnB1c2goW09QRU4sIHJlZ10sW0FUVFJfS0VZLCdjb21tZW50J10sW0FUVFJfRVFdKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZWcgPSBjXG4gICAgICAgICAgc3RhdGUgPSBDT01NRU5UXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFRFWFQgfHwgc3RhdGUgPT09IENPTU1FTlQpIHtcbiAgICAgICAgICByZWcgKz0gY1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBPUEVOICYmIGMgPT09ICcvJyAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gbm8tb3AsIHNlbGYgY2xvc2luZyB0YWcgd2l0aG91dCBhIHNwYWNlIDxici8+XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IE9QRU4gJiYgL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIGlmIChyZWcubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMucHVzaChbT1BFTiwgcmVnXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gT1BFTikge1xuICAgICAgICAgIHJlZyArPSBjXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFIgJiYgL1teXFxzXCInPS9dLy50ZXN0KGMpKSB7XG4gICAgICAgICAgc3RhdGUgPSBBVFRSX0tFWVxuICAgICAgICAgIHJlZyA9IGNcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUiAmJiAvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgaWYgKHJlZy5sZW5ndGgpIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddKVxuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0JSRUFLXSlcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkgJiYgL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSX0tFWV9XXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfS0VZICYmIGMgPT09ICc9Jykge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddLFtBVFRSX0VRXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRV9XXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfS0VZKSB7XG4gICAgICAgICAgcmVnICs9IGNcbiAgICAgICAgfSBlbHNlIGlmICgoc3RhdGUgPT09IEFUVFJfS0VZX1cgfHwgc3RhdGUgPT09IEFUVFIpICYmIGMgPT09ICc9Jykge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0VRXSlcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfVkFMVUVfV1xuICAgICAgICB9IGVsc2UgaWYgKChzdGF0ZSA9PT0gQVRUUl9LRVlfVyB8fCBzdGF0ZSA9PT0gQVRUUikgJiYgIS9cXHMvLnRlc3QoYykpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9CUkVBS10pXG4gICAgICAgICAgaWYgKC9bXFx3LV0vLnRlc3QoYykpIHtcbiAgICAgICAgICAgIHJlZyArPSBjXG4gICAgICAgICAgICBzdGF0ZSA9IEFUVFJfS0VZXG4gICAgICAgICAgfSBlbHNlIHN0YXRlID0gQVRUUlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1cgJiYgYyA9PT0gJ1wiJykge1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRV9EUVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1cgJiYgYyA9PT0gXCInXCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfVkFMVUVfU1FcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9EUSAmJiBjID09PSAnXCInKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSxbQVRUUl9CUkVBS10pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9TUSAmJiBjID09PSBcIidcIikge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10sW0FUVFJfQlJFQUtdKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfVyAmJiAhL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRVxuICAgICAgICAgIGktLVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFICYmIC9cXHMvLnRlc3QoYykpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddLFtBVFRSX0JSRUFLXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFIHx8IHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRXG4gICAgICAgIHx8IHN0YXRlID09PSBBVFRSX1ZBTFVFX0RRKSB7XG4gICAgICAgICAgcmVnICs9IGNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSBURVhUICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgcmVzLnB1c2goW1RFWFQscmVnXSlcbiAgICAgICAgcmVnID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUUgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddKVxuICAgICAgICByZWcgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9EUSAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10pXG4gICAgICAgIHJlZyA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSlcbiAgICAgICAgcmVnID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfS0VZKSB7XG4gICAgICAgIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddKVxuICAgICAgICByZWcgPSAnJ1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmZuICh4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSByZXR1cm4geFxuICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykgcmV0dXJuIHhcbiAgICBlbHNlIGlmICh4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JykgcmV0dXJuIHhcbiAgICBlbHNlIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkgcmV0dXJuIHhcbiAgICBlbHNlIHJldHVybiBjb25jYXQoJycsIHgpXG4gIH1cbn1cblxuZnVuY3Rpb24gcXVvdCAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRIHx8IHN0YXRlID09PSBBVFRSX1ZBTFVFX0RRXG59XG5cbnZhciBjbG9zZVJFID0gUmVnRXhwKCdeKCcgKyBbXG4gICdhcmVhJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdicicsICdjb2wnLCAnY29tbWFuZCcsICdlbWJlZCcsXG4gICdmcmFtZScsICdocicsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdrZXlnZW4nLCAnbGluaycsICdtZXRhJywgJ3BhcmFtJyxcbiAgJ3NvdXJjZScsICd0cmFjaycsICd3YnInLCAnIS0tJyxcbiAgLy8gU1ZHIFRBR1NcbiAgJ2FuaW1hdGUnLCAnYW5pbWF0ZVRyYW5zZm9ybScsICdjaXJjbGUnLCAnY3Vyc29yJywgJ2Rlc2MnLCAnZWxsaXBzZScsXG4gICdmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLCAnZmVDb21wb3NpdGUnLFxuICAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsXG4gICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLFxuICAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLFxuICAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLFxuICAnZmVUdXJidWxlbmNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXVyaScsXG4gICdnbHlwaCcsICdnbHlwaFJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ21pc3NpbmctZ2x5cGgnLCAnbXBhdGgnLFxuICAncGF0aCcsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JlY3QnLCAnc2V0JywgJ3N0b3AnLCAndHJlZicsICd1c2UnLCAndmlldycsXG4gICd2a2Vybidcbl0uam9pbignfCcpICsgJykoPzpbXFwuI11bYS16QS1aMC05XFx1MDA3Ri1cXHVGRkZGXzotXSspKiQnKVxuZnVuY3Rpb24gc2VsZkNsb3NpbmcgKHRhZykgeyByZXR1cm4gY2xvc2VSRS50ZXN0KHRhZykgfVxuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImFzc2VydC5ub3RFcXVhbCA9IG5vdEVxdWFsXG5hc3NlcnQubm90T2sgPSBub3RPa1xuYXNzZXJ0LmVxdWFsID0gZXF1YWxcbmFzc2VydC5vayA9IGFzc2VydFxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydFxuXG5mdW5jdGlvbiBlcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSA9PSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RFcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSAhPSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RPayAodCwgbSkge1xuICBhc3NlcnQoIXQsIG0pXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodCwgbSkge1xuICBpZiAoIXQpIHRocm93IG5ldyBFcnJvcihtIHx8ICdBc3NlcnRpb25FcnJvcicpXG59XG4iLCJ2YXIgc3BsaWNlID0gcmVxdWlyZSgncmVtb3ZlLWFycmF5LWl0ZW1zJylcbnZhciBuYW5vdGltaW5nID0gcmVxdWlyZSgnbmFub3RpbWluZycpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxubW9kdWxlLmV4cG9ydHMgPSBOYW5vYnVzXG5cbmZ1bmN0aW9uIE5hbm9idXMgKG5hbWUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5hbm9idXMpKSByZXR1cm4gbmV3IE5hbm9idXMobmFtZSlcblxuICB0aGlzLl9uYW1lID0gbmFtZSB8fCAnbmFub2J1cydcbiAgdGhpcy5fc3Rhckxpc3RlbmVycyA9IFtdXG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9XG59XG5cbk5hbm9idXMucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgZXZlbnROYW1lID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZXZlbnROYW1lID09PSAnc3ltYm9sJywgJ25hbm9idXMuZW1pdDogZXZlbnROYW1lIHNob3VsZCBiZSB0eXBlIHN0cmluZyBvciBzeW1ib2wnKVxuXG4gIHZhciBkYXRhID0gW11cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGRhdGEucHVzaChhcmd1bWVudHNbaV0pXG4gIH1cblxuICB2YXIgZW1pdFRpbWluZyA9IG5hbm90aW1pbmcodGhpcy5fbmFtZSArIFwiKCdcIiArIGV2ZW50TmFtZS50b1N0cmluZygpICsgXCInKVwiKVxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV1cbiAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuX2VtaXQodGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV0sIGRhdGEpXG4gIH1cblxuICBpZiAodGhpcy5fc3Rhckxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5fZW1pdCh0aGlzLl9zdGFyTGlzdGVuZXJzLCBldmVudE5hbWUsIGRhdGEsIGVtaXRUaW1pbmcudXVpZClcbiAgfVxuICBlbWl0VGltaW5nKClcblxuICByZXR1cm4gdGhpc1xufVxuXG5OYW5vYnVzLnByb3RvdHlwZS5vbiA9IE5hbm9idXMucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiBldmVudE5hbWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBldmVudE5hbWUgPT09ICdzeW1ib2wnLCAnbmFub2J1cy5vbjogZXZlbnROYW1lIHNob3VsZCBiZSB0eXBlIHN0cmluZyBvciBzeW1ib2wnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGxpc3RlbmVyLCAnZnVuY3Rpb24nLCAnbmFub2J1cy5vbjogbGlzdGVuZXIgc2hvdWxkIGJlIHR5cGUgZnVuY3Rpb24nKVxuXG4gIGlmIChldmVudE5hbWUgPT09ICcqJykge1xuICAgIHRoaXMuX3N0YXJMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcilcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdKSB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdXG4gICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5OYW5vYnVzLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICBhc3NlcnQub2sodHlwZW9mIGV2ZW50TmFtZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGV2ZW50TmFtZSA9PT0gJ3N5bWJvbCcsICduYW5vYnVzLnByZXBlbmRMaXN0ZW5lcjogZXZlbnROYW1lIHNob3VsZCBiZSB0eXBlIHN0cmluZyBvciBzeW1ib2wnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGxpc3RlbmVyLCAnZnVuY3Rpb24nLCAnbmFub2J1cy5wcmVwZW5kTGlzdGVuZXI6IGxpc3RlbmVyIHNob3VsZCBiZSB0eXBlIGZ1bmN0aW9uJylcblxuICBpZiAoZXZlbnROYW1lID09PSAnKicpIHtcbiAgICB0aGlzLl9zdGFyTGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpXG4gIH0gZWxzZSB7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXSkgdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXVxuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdLnVuc2hpZnQobGlzdGVuZXIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuTmFub2J1cy5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgZXZlbnROYW1lID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZXZlbnROYW1lID09PSAnc3ltYm9sJywgJ25hbm9idXMub25jZTogZXZlbnROYW1lIHNob3VsZCBiZSB0eXBlIHN0cmluZyBvciBzeW1ib2wnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGxpc3RlbmVyLCAnZnVuY3Rpb24nLCAnbmFub2J1cy5vbmNlOiBsaXN0ZW5lciBzaG91bGQgYmUgdHlwZSBmdW5jdGlvbicpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMub24oZXZlbnROYW1lLCBvbmNlKVxuICBmdW5jdGlvbiBvbmNlICgpIHtcbiAgICBsaXN0ZW5lci5hcHBseShzZWxmLCBhcmd1bWVudHMpXG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIG9uY2UpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuTmFub2J1cy5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgZXZlbnROYW1lID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZXZlbnROYW1lID09PSAnc3ltYm9sJywgJ25hbm9idXMucHJlcGVuZE9uY2VMaXN0ZW5lcjogZXZlbnROYW1lIHNob3VsZCBiZSB0eXBlIHN0cmluZyBvciBzeW1ib2wnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGxpc3RlbmVyLCAnZnVuY3Rpb24nLCAnbmFub2J1cy5wcmVwZW5kT25jZUxpc3RlbmVyOiBsaXN0ZW5lciBzaG91bGQgYmUgdHlwZSBmdW5jdGlvbicpXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMucHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgb25jZSlcbiAgZnVuY3Rpb24gb25jZSAoKSB7XG4gICAgbGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKVxuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBvbmNlKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbk5hbm9idXMucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiBldmVudE5hbWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBldmVudE5hbWUgPT09ICdzeW1ib2wnLCAnbmFub2J1cy5yZW1vdmVMaXN0ZW5lcjogZXZlbnROYW1lIHNob3VsZCBiZSB0eXBlIHN0cmluZyBvciBzeW1ib2wnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGxpc3RlbmVyLCAnZnVuY3Rpb24nLCAnbmFub2J1cy5yZW1vdmVMaXN0ZW5lcjogbGlzdGVuZXIgc2hvdWxkIGJlIHR5cGUgZnVuY3Rpb24nKVxuXG4gIGlmIChldmVudE5hbWUgPT09ICcqJykge1xuICAgIHRoaXMuX3N0YXJMaXN0ZW5lcnMgPSB0aGlzLl9zdGFyTGlzdGVuZXJzLnNsaWNlKClcbiAgICByZXR1cm4gcmVtb3ZlKHRoaXMuX3N0YXJMaXN0ZW5lcnMsIGxpc3RlbmVyKVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXSA9IHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdLnNsaWNlKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtb3ZlKHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdLCBsaXN0ZW5lcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBsaXN0ZW5lcikge1xuICAgIGlmICghYXJyKSByZXR1cm5cbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihsaXN0ZW5lcilcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzcGxpY2UoYXJyLCBpbmRleCwgMSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbk5hbm9idXMucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgaWYgKGV2ZW50TmFtZSkge1xuICAgIGlmIChldmVudE5hbWUgPT09ICcqJykge1xuICAgICAgdGhpcy5fc3Rhckxpc3RlbmVycyA9IFtdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdID0gW11cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc3Rhckxpc3RlbmVycyA9IFtdXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge31cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5OYW5vYnVzLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBldmVudE5hbWUgIT09ICcqJ1xuICAgID8gdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV1cbiAgICA6IHRoaXMuX3N0YXJMaXN0ZW5lcnNcblxuICB2YXIgcmV0ID0gW11cbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBpbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWxlbmd0aDsgaSsrKSByZXQucHVzaChsaXN0ZW5lcnNbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5OYW5vYnVzLnByb3RvdHlwZS5fZW1pdCA9IGZ1bmN0aW9uIChhcnIsIGV2ZW50TmFtZSwgZGF0YSwgdXVpZCkge1xuICBpZiAodHlwZW9mIGFyciA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBkYXRhID0gZXZlbnROYW1lXG4gICAgZXZlbnROYW1lID0gbnVsbFxuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSkge1xuICAgIGlmICh1dWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRhdGEgPSBbZXZlbnROYW1lXS5jb25jYXQoZGF0YSwgdXVpZClcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IFtldmVudE5hbWVdLmNvbmNhdChkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBhcnJbaV1cbiAgICBsaXN0ZW5lci5hcHBseShsaXN0ZW5lciwgZGF0YSlcbiAgfVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbnZhciBzYWZlRXh0ZXJuYWxMaW5rID0gLyhub29wZW5lcnxub3JlZmVycmVyKSAobm9vcGVuZXJ8bm9yZWZlcnJlcikvXG52YXIgcHJvdG9jb2xMaW5rID0gL15bXFx3LV9dKzovXG5cbm1vZHVsZS5leHBvcnRzID0gaHJlZlxuXG5mdW5jdGlvbiBocmVmIChjYiwgcm9vdCkge1xuICBhc3NlcnQubm90RXF1YWwodHlwZW9mIHdpbmRvdywgJ3VuZGVmaW5lZCcsICduYW5vaHJlZjogZXhwZWN0ZWQgd2luZG93IHRvIGV4aXN0JylcblxuICByb290ID0gcm9vdCB8fCB3aW5kb3cuZG9jdW1lbnRcblxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAnbmFub2hyZWY6IGNiIHNob3VsZCBiZSB0eXBlIGZ1bmN0aW9uJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiByb290LCAnb2JqZWN0JywgJ25hbm9ocmVmOiByb290IHNob3VsZCBiZSB0eXBlIG9iamVjdCcpXG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoKGUuYnV0dG9uICYmIGUuYnV0dG9uICE9PSAwKSB8fFxuICAgICAgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLnNoaWZ0S2V5IHx8XG4gICAgICBlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVyblxuXG4gICAgdmFyIGFuY2hvciA9IChmdW5jdGlvbiB0cmF2ZXJzZSAobm9kZSkge1xuICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IHJvb3QpIHJldHVyblxuICAgICAgaWYgKG5vZGUubG9jYWxOYW1lICE9PSAnYScgfHwgbm9kZS5ocmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlKG5vZGUucGFyZW50Tm9kZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlXG4gICAgfSkoZS50YXJnZXQpXG5cbiAgICBpZiAoIWFuY2hvcikgcmV0dXJuXG5cbiAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSBhbmNob3IucHJvdG9jb2wgfHxcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICE9PSBhbmNob3IuaG9zdG5hbWUgfHxcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnBvcnQgIT09IGFuY2hvci5wb3J0IHx8XG4gICAgICBhbmNob3IuaGFzQXR0cmlidXRlKCdkYXRhLW5hbm9ocmVmLWlnbm9yZScpIHx8XG4gICAgICBhbmNob3IuaGFzQXR0cmlidXRlKCdkb3dubG9hZCcpIHx8XG4gICAgICAoYW5jaG9yLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykgPT09ICdfYmxhbmsnICYmXG4gICAgICAgIHNhZmVFeHRlcm5hbExpbmsudGVzdChhbmNob3IuZ2V0QXR0cmlidXRlKCdyZWwnKSkpIHx8XG4gICAgICBwcm90b2NvbExpbmsudGVzdChhbmNob3IuZ2V0QXR0cmlidXRlKCdocmVmJykpKSByZXR1cm5cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGNiKGFuY2hvcilcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgdHJhaWxpbmdOZXdsaW5lUmVnZXggPSAvXFxuW1xcc10rJC9cbnZhciBsZWFkaW5nTmV3bGluZVJlZ2V4ID0gL15cXG5bXFxzXSsvXG52YXIgdHJhaWxpbmdTcGFjZVJlZ2V4ID0gL1tcXHNdKyQvXG52YXIgbGVhZGluZ1NwYWNlUmVnZXggPSAvXltcXHNdKy9cbnZhciBtdWx0aVNwYWNlUmVnZXggPSAvW1xcblxcc10rL2dcblxudmFyIFRFWFRfVEFHUyA9IFtcbiAgJ2EnLCAnYWJicicsICdiJywgJ2JkaScsICdiZG8nLCAnYnInLCAnY2l0ZScsICdkYXRhJywgJ2RmbicsICdlbScsICdpJyxcbiAgJ2tiZCcsICdtYXJrJywgJ3EnLCAncnAnLCAncnQnLCAncnRjJywgJ3J1YnknLCAncycsICdhbXAnLCAnc21hbGwnLCAnc3BhbicsXG4gICdzdHJvbmcnLCAnc3ViJywgJ3N1cCcsICd0aW1lJywgJ3UnLCAndmFyJywgJ3dicidcbl1cblxudmFyIFZFUkJBVElNX1RBR1MgPSBbXG4gICdjb2RlJywgJ3ByZScsICd0ZXh0YXJlYSdcbl1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZCAoZWwsIGNoaWxkcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRzKSkgcmV0dXJuXG5cbiAgdmFyIG5vZGVOYW1lID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gIHZhciBoYWRUZXh0ID0gZmFsc2VcbiAgdmFyIHZhbHVlLCBsZWFkZXJcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBjaGlsZHNbaV1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgYXBwZW5kQ2hpbGQoZWwsIG5vZGUpXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicgfHxcbiAgICAgIHR5cGVvZiBub2RlID09PSAnYm9vbGVhbicgfHxcbiAgICAgIHR5cGVvZiBub2RlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICBub2RlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgbm9kZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgbm9kZSA9IG5vZGUudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIHZhciBsYXN0Q2hpbGQgPSBlbC5jaGlsZE5vZGVzW2VsLmNoaWxkTm9kZXMubGVuZ3RoIC0gMV1cblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0ZXh0IG5vZGVzXG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgaGFkVGV4dCA9IHRydWVcblxuICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYWQgdGV4dCwgYXBwZW5kIHRvIHRoZSBleGlzdGluZyB0ZXh0XG4gICAgICBpZiAobGFzdENoaWxkICYmIGxhc3RDaGlsZC5ub2RlTmFtZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgICBsYXN0Q2hpbGQubm9kZVZhbHVlICs9IG5vZGVcblxuICAgICAgLy8gV2UgZGlkbid0IGhhdmUgYSB0ZXh0IG5vZGUgeWV0LCBjcmVhdGUgb25lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gZWwub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlKVxuICAgICAgICBlbC5hcHBlbmRDaGlsZChub2RlKVxuICAgICAgICBsYXN0Q2hpbGQgPSBub2RlXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3Qgb2YgdGhlIGNoaWxkIG5vZGVzLCBtYWtlIHN1cmUgd2UgY2xvc2UgaXQgb3V0XG4gICAgICAvLyByaWdodFxuICAgICAgaWYgKGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgaGFkVGV4dCA9IGZhbHNlXG4gICAgICAgIC8vIFRyaW0gdGhlIGNoaWxkIHRleHQgbm9kZXMgaWYgdGhlIGN1cnJlbnQgbm9kZSBpc24ndCBhXG4gICAgICAgIC8vIG5vZGUgd2hlcmUgd2hpdGVzcGFjZSBtYXR0ZXJzLlxuICAgICAgICBpZiAoVEVYVF9UQUdTLmluZGV4T2Yobm9kZU5hbWUpID09PSAtMSAmJlxuICAgICAgICAgIFZFUkJBVElNX1RBR1MuaW5kZXhPZihub2RlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgdmFsdWUgPSBsYXN0Q2hpbGQubm9kZVZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nTmV3bGluZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyYWlsaW5nU3BhY2VSZWdleCwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSh0cmFpbGluZ05ld2xpbmVSZWdleCwgJycpXG4gICAgICAgICAgICAucmVwbGFjZShtdWx0aVNwYWNlUmVnZXgsICcgJylcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChsYXN0Q2hpbGQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChWRVJCQVRJTV9UQUdTLmluZGV4T2Yobm9kZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgIC8vIFRoZSB2ZXJ5IGZpcnN0IG5vZGUgaW4gdGhlIGxpc3Qgc2hvdWxkIG5vdCBoYXZlIGxlYWRpbmdcbiAgICAgICAgICAvLyB3aGl0ZXNwYWNlLiBTaWJsaW5nIHRleHQgbm9kZXMgc2hvdWxkIGhhdmUgd2hpdGVzcGFjZSBpZiB0aGVyZVxuICAgICAgICAgIC8vIHdhcyBhbnkuXG4gICAgICAgICAgbGVhZGVyID0gaSA9PT0gMCA/ICcnIDogJyAnXG4gICAgICAgICAgdmFsdWUgPSBsYXN0Q2hpbGQubm9kZVZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nTmV3bGluZVJlZ2V4LCBsZWFkZXIpXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nU3BhY2VSZWdleCwgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UodHJhaWxpbmdTcGFjZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyYWlsaW5nTmV3bGluZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKG11bHRpU3BhY2VSZWdleCwgJyAnKVxuICAgICAgICAgIGxhc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgRE9NIG5vZGVzXG4gICAgfSBlbHNlIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IG5vZGUgd2FzIGEgdGV4dCBub2RlLCBtYWtlIHN1cmUgaXQgaXMgcHJvcGVybHkgY2xvc2VkIG91dFxuICAgICAgaWYgKGhhZFRleHQpIHtcbiAgICAgICAgaGFkVGV4dCA9IGZhbHNlXG5cbiAgICAgICAgLy8gVHJpbSB0aGUgY2hpbGQgdGV4dCBub2RlcyBpZiB0aGUgY3VycmVudCBub2RlIGlzbid0IGFcbiAgICAgICAgLy8gdGV4dCBub2RlIG9yIGEgY29kZSBub2RlXG4gICAgICAgIGlmIChURVhUX1RBR1MuaW5kZXhPZihub2RlTmFtZSkgPT09IC0xICYmXG4gICAgICAgICAgVkVSQkFUSU1fVEFHUy5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB2YWx1ZSA9IGxhc3RDaGlsZC5ub2RlVmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKGxlYWRpbmdOZXdsaW5lUmVnZXgsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UodHJhaWxpbmdOZXdsaW5lUmVnZXgsICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKG11bHRpU3BhY2VSZWdleCwgJyAnKVxuXG4gICAgICAgICAgLy8gUmVtb3ZlIGVtcHR5IHRleHQgbm9kZXMsIGFwcGVuZCBvdGhlcndpc2VcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChsYXN0Q2hpbGQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gVHJpbSB0aGUgY2hpbGQgbm9kZXMgYnV0IHByZXNlcnZlIHRoZSBhcHByb3ByaWF0ZSB3aGl0ZXNwYWNlXG4gICAgICAgIH0gZWxzZSBpZiAoVkVSQkFUSU1fVEFHUy5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB2YWx1ZSA9IGxhc3RDaGlsZC5ub2RlVmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKGxlYWRpbmdTcGFjZVJlZ2V4LCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nTmV3bGluZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyYWlsaW5nTmV3bGluZVJlZ2V4LCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZShtdWx0aVNwYWNlUmVnZXgsICcgJylcbiAgICAgICAgICBsYXN0Q2hpbGQubm9kZVZhbHVlID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSB0aGUgbGFzdCBub2RlbmFtZVxuICAgICAgdmFyIF9ub2RlTmFtZSA9IG5vZGUubm9kZU5hbWVcbiAgICAgIGlmIChfbm9kZU5hbWUpIG5vZGVOYW1lID0gX25vZGVOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgICAgLy8gQXBwZW5kIHRoZSBub2RlIHRvIHRoZSBET01cbiAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhc3luYycsICdhdXRvZm9jdXMnLCAnYXV0b3BsYXknLCAnY2hlY2tlZCcsICdjb250cm9scycsICdkZWZhdWx0JyxcbiAgJ2RlZmF1bHRjaGVja2VkJywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Zvcm1ub3ZhbGlkYXRlJywgJ2hpZGRlbicsXG4gICdpc21hcCcsICdsb29wJywgJ211bHRpcGxlJywgJ211dGVkJywgJ25vdmFsaWRhdGUnLCAnb3BlbicsICdwbGF5c2lubGluZScsXG4gICdyZWFkb25seScsICdyZXF1aXJlZCcsICdyZXZlcnNlZCcsICdzZWxlY3RlZCdcbl1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kb20nKShkb2N1bWVudClcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2luZGV0ZXJtaW5hdGUnXG5dXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGh5cGVyeCA9IHJlcXVpcmUoJ2h5cGVyeCcpXG52YXIgYXBwZW5kQ2hpbGQgPSByZXF1aXJlKCcuL2FwcGVuZC1jaGlsZCcpXG52YXIgU1ZHX1RBR1MgPSByZXF1aXJlKCcuL3N2Zy10YWdzJylcbnZhciBCT09MX1BST1BTID0gcmVxdWlyZSgnLi9ib29sLXByb3BzJylcbi8vIFByb3BzIHRoYXQgbmVlZCB0byBiZSBzZXQgZGlyZWN0bHkgcmF0aGVyIHRoYW4gd2l0aCBlbC5zZXRBdHRyaWJ1dGUoKVxudmFyIERJUkVDVF9QUk9QUyA9IHJlcXVpcmUoJy4vZGlyZWN0LXByb3BzJylcblxudmFyIFNWR05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xudmFyIFhMSU5LTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcblxudmFyIENPTU1FTlRfVEFHID0gJyEtLSdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgZnVuY3Rpb24gbmFub0h0bWxDcmVhdGVFbGVtZW50ICh0YWcsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBlbFxuXG4gICAgLy8gSWYgYW4gc3ZnIHRhZywgaXQgbmVlZHMgYSBuYW1lc3BhY2VcbiAgICBpZiAoU1ZHX1RBR1MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgcHJvcHMubmFtZXNwYWNlID0gU1ZHTlNcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBhcmUgdXNpbmcgYSBuYW1lc3BhY2VcbiAgICB2YXIgbnMgPSBmYWxzZVxuICAgIGlmIChwcm9wcy5uYW1lc3BhY2UpIHtcbiAgICAgIG5zID0gcHJvcHMubmFtZXNwYWNlXG4gICAgICBkZWxldGUgcHJvcHMubmFtZXNwYWNlXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIGV4dGVuZGluZyBhIGJ1aWx0aW4gZWxlbWVudFxuICAgIHZhciBpc0N1c3RvbUVsZW1lbnQgPSBmYWxzZVxuICAgIGlmIChwcm9wcy5pcykge1xuICAgICAgaXNDdXN0b21FbGVtZW50ID0gcHJvcHMuaXNcbiAgICAgIGRlbGV0ZSBwcm9wcy5pc1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgZWxlbWVudFxuICAgIGlmIChucykge1xuICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCkge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7IGlzOiBpc0N1c3RvbUVsZW1lbnQgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0YWcgPT09IENPTU1FTlRfVEFHKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChwcm9wcy5jb21tZW50KVxuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnLCB7IGlzOiBpc0N1c3RvbUVsZW1lbnQgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZylcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIHByb3BlcnRpZXNcbiAgICBmb3IgKHZhciBwIGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgdmFyIGtleSA9IHAudG9Mb3dlckNhc2UoKVxuICAgICAgICB2YXIgdmFsID0gcHJvcHNbcF1cbiAgICAgICAgLy8gTm9ybWFsaXplIGNsYXNzTmFtZVxuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3NuYW1lJykge1xuICAgICAgICAgIGtleSA9ICdjbGFzcydcbiAgICAgICAgICBwID0gJ2NsYXNzJ1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBmb3IgYXR0cmlidXRlIGdldHMgdHJhbnNmb3JtZWQgdG8gaHRtbEZvciwgYnV0IHdlIGp1c3Qgc2V0IGFzIGZvclxuICAgICAgICBpZiAocCA9PT0gJ2h0bWxGb3InKSB7XG4gICAgICAgICAgcCA9ICdmb3InXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBwcm9wZXJ0eSBpcyBib29sZWFuLCBzZXQgaXRzZWxmIHRvIHRoZSBrZXlcbiAgICAgICAgaWYgKEJPT0xfUFJPUFMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgIGlmIChTdHJpbmcodmFsKSA9PT0gJ3RydWUnKSB2YWwgPSBrZXlcbiAgICAgICAgICBlbHNlIGlmIChTdHJpbmcodmFsKSA9PT0gJ2ZhbHNlJykgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIHByb3BlcnR5IHByZWZlcnMgYmVpbmcgc2V0IGRpcmVjdGx5IHZzIHNldEF0dHJpYnV0ZVxuICAgICAgICBpZiAoa2V5LnNsaWNlKDAsIDIpID09PSAnb24nIHx8IERJUkVDVF9QUk9QUy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgICAgZWxbcF0gPSB2YWxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIGlmIChwID09PSAneGxpbms6aHJlZicpIHtcbiAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoWExJTktOUywgcCwgdmFsKVxuICAgICAgICAgICAgfSBlbHNlIGlmICgvXnhtbG5zKCR8OikvaS50ZXN0KHApKSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgeG1sbnMgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsIHAsIHZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKHAsIHZhbClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBlbmRDaGlsZChlbCwgY2hpbGRyZW4pXG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudCAobm9kZXMpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobm9kZXNbaV0gPT0gbnVsbCkgY29udGludWVcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzW2ldKSkge1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjcmVhdGVGcmFnbWVudChub2Rlc1tpXSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIG5vZGVzW2ldID09PSAnc3RyaW5nJykgbm9kZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2Rlc1tpXSlcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZXNbaV0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudFxuICB9XG5cbiAgdmFyIGV4cG9ydHMgPSBoeXBlcngobmFub0h0bWxDcmVhdGVFbGVtZW50LCB7XG4gICAgY29tbWVudHM6IHRydWUsXG4gICAgY3JlYXRlRnJhZ21lbnQ6IGNyZWF0ZUZyYWdtZW50XG4gIH0pXG4gIGV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHNcbiAgZXhwb3J0cy5jcmVhdGVDb21tZW50ID0gbmFub0h0bWxDcmVhdGVFbGVtZW50XG4gIHJldHVybiBleHBvcnRzXG59XG4iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gbmFub2h0bWxSYXdCcm93c2VyICh0YWcpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgZWwuaW5uZXJIVE1MID0gdGFnXG4gIHJldHVybiB0b0FycmF5KGVsLmNoaWxkTm9kZXMpXG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKGFycikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpID8gYXJyIDogW10uc2xpY2UuY2FsbChhcnIpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmFub2h0bWxSYXdCcm93c2VyXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdzdmcnLCAnYWx0R2x5cGgnLCAnYWx0R2x5cGhEZWYnLCAnYWx0R2x5cGhJdGVtJywgJ2FuaW1hdGUnLCAnYW5pbWF0ZUNvbG9yJyxcbiAgJ2FuaW1hdGVNb3Rpb24nLCAnYW5pbWF0ZVRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcFBhdGgnLCAnY29sb3ItcHJvZmlsZScsXG4gICdjdXJzb3InLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JyxcbiAgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsXG4gICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJyxcbiAgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsXG4gICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJywgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLFxuICAnZmVTcGVjdWxhckxpZ2h0aW5nJywgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsICdmZVR1cmJ1bGVuY2UnLCAnZmlsdGVyJyxcbiAgJ2ZvbnQnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXNyYycsXG4gICdmb250LWZhY2UtdXJpJywgJ2ZvcmVpZ25PYmplY3QnLCAnZycsICdnbHlwaCcsICdnbHlwaFJlZicsICdoa2VybicsICdpbWFnZScsXG4gICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21pc3NpbmctZ2x5cGgnLFxuICAnbXBhdGgnLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsXG4gICdzZXQnLCAnc3RvcCcsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dFBhdGgnLCAndGl0bGUnLCAndHJlZicsXG4gICd0c3BhbicsICd1c2UnLCAndmlldycsICd2a2Vybidcbl1cbiIsIm1vZHVsZS5leHBvcnRzID0gTFJVXG5cbmZ1bmN0aW9uIExSVSAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTFJVKSkgcmV0dXJuIG5ldyBMUlUob3B0cylcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnbnVtYmVyJykgb3B0cyA9IHttYXg6IG9wdHN9XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIHRoaXMuY2FjaGUgPSB7fVxuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDBcbiAgdGhpcy5tYXhBZ2UgPSBvcHRzLm1heEFnZSB8fCAwXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlUucHJvdG90eXBlLCAna2V5cycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNhY2hlKSB9XG59KVxuXG5MUlUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNhY2hlID0ge31cbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbFxuICB0aGlzLmxlbmd0aCA9IDBcbn1cblxuTFJVLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykga2V5ID0gJycgKyBrZXlcbiAgaWYgKCF0aGlzLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHJldHVyblxuXG4gIHZhciBlbGVtZW50ID0gdGhpcy5jYWNoZVtrZXldXG4gIGRlbGV0ZSB0aGlzLmNhY2hlW2tleV1cbiAgdGhpcy5fdW5saW5rKGtleSwgZWxlbWVudC5wcmV2LCBlbGVtZW50Lm5leHQpXG4gIHJldHVybiBlbGVtZW50LnZhbHVlXG59XG5cbkxSVS5wcm90b3R5cGUuX3VubGluayA9IGZ1bmN0aW9uIChrZXksIHByZXYsIG5leHQpIHtcbiAgdGhpcy5sZW5ndGgtLVxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5oZWFkID09PSBrZXkpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHByZXZcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5oZWFkXS5uZXh0ID0gbnVsbFxuICAgIH0gZWxzZSBpZiAodGhpcy50YWlsID09PSBrZXkpIHtcbiAgICAgIHRoaXMudGFpbCA9IG5leHRcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy50YWlsXS5wcmV2ID0gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhY2hlW3ByZXZdLm5leHQgPSBuZXh0XG4gICAgICB0aGlzLmNhY2hlW25leHRdLnByZXYgPSBwcmV2XG4gICAgfVxuICB9XG59XG5cbkxSVS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKCF0aGlzLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHJldHVyblxuXG4gIHZhciBlbGVtZW50ID0gdGhpcy5jYWNoZVtrZXldXG5cbiAgaWYgKCF0aGlzLl9jaGVja0FnZShrZXksIGVsZW1lbnQpKSByZXR1cm5cbiAgcmV0dXJuIGVsZW1lbnQudmFsdWVcbn1cblxuTFJVLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIGtleSA9ICcnICsga2V5XG5cbiAgdmFyIGVsZW1lbnRcblxuICBpZiAodGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuICAgIGVsZW1lbnQudmFsdWUgPSB2YWx1ZVxuICAgIGlmICh0aGlzLm1heEFnZSkgZWxlbWVudC5tb2RpZmllZCA9IERhdGUubm93KClcblxuICAgIC8vIElmIGl0J3MgYWxyZWFkeSB0aGUgaGVhZCwgdGhlcmUncyBub3RoaW5nIG1vcmUgdG8gZG86XG4gICAgaWYgKGtleSA9PT0gdGhpcy5oZWFkKSByZXR1cm4gdmFsdWVcbiAgICB0aGlzLl91bmxpbmsoa2V5LCBlbGVtZW50LnByZXYsIGVsZW1lbnQubmV4dClcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50ID0ge3ZhbHVlOiB2YWx1ZSwgbW9kaWZpZWQ6IDAsIG5leHQ6IG51bGwsIHByZXY6IG51bGx9XG4gICAgaWYgKHRoaXMubWF4QWdlKSBlbGVtZW50Lm1vZGlmaWVkID0gRGF0ZS5ub3coKVxuICAgIHRoaXMuY2FjaGVba2V5XSA9IGVsZW1lbnRcblxuICAgIC8vIEV2aWN0aW9uIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIGtleSBkaWRuJ3QgYWxyZWFkeSBleGlzdDpcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IHRoaXMubWF4KSB0aGlzLmV2aWN0KClcbiAgfVxuXG4gIHRoaXMubGVuZ3RoKytcbiAgZWxlbWVudC5uZXh0ID0gbnVsbFxuICBlbGVtZW50LnByZXYgPSB0aGlzLmhlYWRcblxuICBpZiAodGhpcy5oZWFkKSB0aGlzLmNhY2hlW3RoaXMuaGVhZF0ubmV4dCA9IGtleVxuICB0aGlzLmhlYWQgPSBrZXlcblxuICBpZiAoIXRoaXMudGFpbCkgdGhpcy50YWlsID0ga2V5XG4gIHJldHVybiB2YWx1ZVxufVxuXG5MUlUucHJvdG90eXBlLl9jaGVja0FnZSA9IGZ1bmN0aW9uIChrZXksIGVsZW1lbnQpIHtcbiAgaWYgKHRoaXMubWF4QWdlICYmIChEYXRlLm5vdygpIC0gZWxlbWVudC5tb2RpZmllZCkgPiB0aGlzLm1heEFnZSkge1xuICAgIHRoaXMucmVtb3ZlKGtleSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSBrZXkgPSAnJyArIGtleVxuICBpZiAoIXRoaXMuY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuXG5cbiAgdmFyIGVsZW1lbnQgPSB0aGlzLmNhY2hlW2tleV1cblxuICBpZiAoIXRoaXMuX2NoZWNrQWdlKGtleSwgZWxlbWVudCkpIHJldHVyblxuXG4gIGlmICh0aGlzLmhlYWQgIT09IGtleSkge1xuICAgIGlmIChrZXkgPT09IHRoaXMudGFpbCkge1xuICAgICAgdGhpcy50YWlsID0gZWxlbWVudC5uZXh0XG4gICAgICB0aGlzLmNhY2hlW3RoaXMudGFpbF0ucHJldiA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0IHByZXYubmV4dCAtPiBlbGVtZW50Lm5leHQ6XG4gICAgICB0aGlzLmNhY2hlW2VsZW1lbnQucHJldl0ubmV4dCA9IGVsZW1lbnQubmV4dFxuICAgIH1cblxuICAgIC8vIFNldCBlbGVtZW50Lm5leHQucHJldiAtPiBlbGVtZW50LnByZXY6XG4gICAgdGhpcy5jYWNoZVtlbGVtZW50Lm5leHRdLnByZXYgPSBlbGVtZW50LnByZXZcblxuICAgIC8vIEVsZW1lbnQgaXMgdGhlIG5ldyBoZWFkXG4gICAgdGhpcy5jYWNoZVt0aGlzLmhlYWRdLm5leHQgPSBrZXlcbiAgICBlbGVtZW50LnByZXYgPSB0aGlzLmhlYWRcbiAgICBlbGVtZW50Lm5leHQgPSBudWxsXG4gICAgdGhpcy5oZWFkID0ga2V5XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC52YWx1ZVxufVxuXG5MUlUucHJvdG90eXBlLmV2aWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkgcmV0dXJuXG4gIHRoaXMucmVtb3ZlKHRoaXMudGFpbClcbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCduYW5vYXNzZXJ0JylcbnZhciBtb3JwaCA9IHJlcXVpcmUoJy4vbGliL21vcnBoJylcblxudmFyIFRFWFRfTk9ERSA9IDNcbi8vIHZhciBERUJVRyA9IGZhbHNlXG5cbm1vZHVsZS5leHBvcnRzID0gbmFub21vcnBoXG5cbi8vIE1vcnBoIG9uZSB0cmVlIGludG8gYW5vdGhlciB0cmVlXG4vL1xuLy8gbm8gcGFyZW50XG4vLyAgIC0+IHNhbWU6IGRpZmYgYW5kIHdhbGsgY2hpbGRyZW5cbi8vICAgLT4gbm90IHNhbWU6IHJlcGxhY2UgYW5kIHJldHVyblxuLy8gb2xkIG5vZGUgZG9lc24ndCBleGlzdFxuLy8gICAtPiBpbnNlcnQgbmV3IG5vZGVcbi8vIG5ldyBub2RlIGRvZXNuJ3QgZXhpc3Rcbi8vICAgLT4gZGVsZXRlIG9sZCBub2RlXG4vLyBub2RlcyBhcmUgbm90IHRoZSBzYW1lXG4vLyAgIC0+IGRpZmYgbm9kZXMgYW5kIGFwcGx5IHBhdGNoIHRvIG9sZCBub2RlXG4vLyBub2RlcyBhcmUgdGhlIHNhbWVcbi8vICAgLT4gd2FsayBhbGwgY2hpbGQgbm9kZXMgYW5kIGFwcGVuZCB0byBvbGQgbm9kZVxuZnVuY3Rpb24gbmFub21vcnBoIChvbGRUcmVlLCBuZXdUcmVlLCBvcHRpb25zKSB7XG4gIC8vIGlmIChERUJVRykge1xuICAvLyAgIGNvbnNvbGUubG9nKFxuICAvLyAgICduYW5vbW9ycGhcXG5vbGRcXG4gICVzXFxubmV3XFxuICAlcycsXG4gIC8vICAgb2xkVHJlZSAmJiBvbGRUcmVlLm91dGVySFRNTCxcbiAgLy8gICBuZXdUcmVlICYmIG5ld1RyZWUub3V0ZXJIVE1MXG4gIC8vIClcbiAgLy8gfVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIG9sZFRyZWUsICdvYmplY3QnLCAnbmFub21vcnBoOiBvbGRUcmVlIHNob3VsZCBiZSBhbiBvYmplY3QnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIG5ld1RyZWUsICdvYmplY3QnLCAnbmFub21vcnBoOiBuZXdUcmVlIHNob3VsZCBiZSBhbiBvYmplY3QnKVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2hpbGRyZW5Pbmx5KSB7XG4gICAgdXBkYXRlQ2hpbGRyZW4obmV3VHJlZSwgb2xkVHJlZSlcbiAgICByZXR1cm4gb2xkVHJlZVxuICB9XG5cbiAgYXNzZXJ0Lm5vdEVxdWFsKFxuICAgIG5ld1RyZWUubm9kZVR5cGUsXG4gICAgMTEsXG4gICAgJ25hbm9tb3JwaDogbmV3VHJlZSBzaG91bGQgaGF2ZSBvbmUgcm9vdCBub2RlICh3aGljaCBpcyBub3QgYSBEb2N1bWVudEZyYWdtZW50KSdcbiAgKVxuXG4gIHJldHVybiB3YWxrKG5ld1RyZWUsIG9sZFRyZWUpXG59XG5cbi8vIFdhbGsgYW5kIG1vcnBoIGEgZG9tIHRyZWVcbmZ1bmN0aW9uIHdhbGsgKG5ld05vZGUsIG9sZE5vZGUpIHtcbiAgLy8gaWYgKERFQlVHKSB7XG4gIC8vICAgY29uc29sZS5sb2coXG4gIC8vICAgJ3dhbGtcXG5vbGRcXG4gICVzXFxubmV3XFxuICAlcycsXG4gIC8vICAgb2xkTm9kZSAmJiBvbGROb2RlLm91dGVySFRNTCxcbiAgLy8gICBuZXdOb2RlICYmIG5ld05vZGUub3V0ZXJIVE1MXG4gIC8vIClcbiAgLy8gfVxuICBpZiAoIW9sZE5vZGUpIHtcbiAgICByZXR1cm4gbmV3Tm9kZVxuICB9IGVsc2UgaWYgKCFuZXdOb2RlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIGlmIChuZXdOb2RlLmlzU2FtZU5vZGUgJiYgbmV3Tm9kZS5pc1NhbWVOb2RlKG9sZE5vZGUpKSB7XG4gICAgcmV0dXJuIG9sZE5vZGVcbiAgfSBlbHNlIGlmIChuZXdOb2RlLnRhZ05hbWUgIT09IG9sZE5vZGUudGFnTmFtZSB8fCBnZXRDb21wb25lbnRJZChuZXdOb2RlKSAhPT0gZ2V0Q29tcG9uZW50SWQob2xkTm9kZSkpIHtcbiAgICByZXR1cm4gbmV3Tm9kZVxuICB9IGVsc2Uge1xuICAgIG1vcnBoKG5ld05vZGUsIG9sZE5vZGUpXG4gICAgdXBkYXRlQ2hpbGRyZW4obmV3Tm9kZSwgb2xkTm9kZSlcbiAgICByZXR1cm4gb2xkTm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudElkIChub2RlKSB7XG4gIHJldHVybiBub2RlLmRhdGFzZXQgPyBub2RlLmRhdGFzZXQubmFub21vcnBoQ29tcG9uZW50SWQgOiB1bmRlZmluZWRcbn1cblxuLy8gVXBkYXRlIHRoZSBjaGlsZHJlbiBvZiBlbGVtZW50c1xuLy8gKG9iaiwgb2JqKSAtPiBudWxsXG5mdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAobmV3Tm9kZSwgb2xkTm9kZSkge1xuICAvLyBpZiAoREVCVUcpIHtcbiAgLy8gICBjb25zb2xlLmxvZyhcbiAgLy8gICAndXBkYXRlQ2hpbGRyZW5cXG5vbGRcXG4gICVzXFxubmV3XFxuICAlcycsXG4gIC8vICAgb2xkTm9kZSAmJiBvbGROb2RlLm91dGVySFRNTCxcbiAgLy8gICBuZXdOb2RlICYmIG5ld05vZGUub3V0ZXJIVE1MXG4gIC8vIClcbiAgLy8gfVxuICB2YXIgb2xkQ2hpbGQsIG5ld0NoaWxkLCBtb3JwaGVkLCBvbGRNYXRjaFxuXG4gIC8vIFRoZSBvZmZzZXQgaXMgb25seSBldmVyIGluY3JlYXNlZCwgYW5kIHVzZWQgZm9yIFtpIC0gb2Zmc2V0XSBpbiB0aGUgbG9vcFxuICB2YXIgb2Zmc2V0ID0gMFxuXG4gIGZvciAodmFyIGkgPSAwOyA7IGkrKykge1xuICAgIG9sZENoaWxkID0gb2xkTm9kZS5jaGlsZE5vZGVzW2ldXG4gICAgbmV3Q2hpbGQgPSBuZXdOb2RlLmNoaWxkTm9kZXNbaSAtIG9mZnNldF1cbiAgICAvLyBpZiAoREVCVUcpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKFxuICAgIC8vICAgJz09PVxcbi0gb2xkXFxuICAlc1xcbi0gbmV3XFxuICAlcycsXG4gICAgLy8gICBvbGRDaGlsZCAmJiBvbGRDaGlsZC5vdXRlckhUTUwsXG4gICAgLy8gICBuZXdDaGlsZCAmJiBuZXdDaGlsZC5vdXRlckhUTUxcbiAgICAvLyApXG4gICAgLy8gfVxuICAgIC8vIEJvdGggbm9kZXMgYXJlIGVtcHR5LCBkbyBub3RoaW5nXG4gICAgaWYgKCFvbGRDaGlsZCAmJiAhbmV3Q2hpbGQpIHtcbiAgICAgIGJyZWFrXG5cbiAgICAvLyBUaGVyZSBpcyBubyBuZXcgY2hpbGQsIHJlbW92ZSBvbGRcbiAgICB9IGVsc2UgaWYgKCFuZXdDaGlsZCkge1xuICAgICAgb2xkTm9kZS5yZW1vdmVDaGlsZChvbGRDaGlsZClcbiAgICAgIGktLVxuXG4gICAgLy8gVGhlcmUgaXMgbm8gb2xkIGNoaWxkLCBhZGQgbmV3XG4gICAgfSBlbHNlIGlmICghb2xkQ2hpbGQpIHtcbiAgICAgIG9sZE5vZGUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpXG4gICAgICBvZmZzZXQrK1xuXG4gICAgLy8gQm90aCBub2RlcyBhcmUgdGhlIHNhbWUsIG1vcnBoXG4gICAgfSBlbHNlIGlmIChzYW1lKG5ld0NoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIG1vcnBoZWQgPSB3YWxrKG5ld0NoaWxkLCBvbGRDaGlsZClcbiAgICAgIGlmIChtb3JwaGVkICE9PSBvbGRDaGlsZCkge1xuICAgICAgICBvbGROb2RlLnJlcGxhY2VDaGlsZChtb3JwaGVkLCBvbGRDaGlsZClcbiAgICAgICAgb2Zmc2V0KytcbiAgICAgIH1cblxuICAgIC8vIEJvdGggbm9kZXMgZG8gbm90IHNoYXJlIGFuIElEIG9yIGEgcGxhY2Vob2xkZXIsIHRyeSByZW9yZGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZE1hdGNoID0gbnVsbFxuXG4gICAgICAvLyBUcnkgYW5kIGZpbmQgYSBzaW1pbGFyIG5vZGUgc29tZXdoZXJlIGluIHRoZSB0cmVlXG4gICAgICBmb3IgKHZhciBqID0gaTsgaiA8IG9sZE5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoc2FtZShvbGROb2RlLmNoaWxkTm9kZXNbal0sIG5ld0NoaWxkKSkge1xuICAgICAgICAgIG9sZE1hdGNoID0gb2xkTm9kZS5jaGlsZE5vZGVzW2pdXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSB3YXMgYSBub2RlIHdpdGggdGhlIHNhbWUgSUQgb3IgcGxhY2Vob2xkZXIgaW4gdGhlIG9sZCBsaXN0XG4gICAgICBpZiAob2xkTWF0Y2gpIHtcbiAgICAgICAgbW9ycGhlZCA9IHdhbGsobmV3Q2hpbGQsIG9sZE1hdGNoKVxuICAgICAgICBpZiAobW9ycGhlZCAhPT0gb2xkTWF0Y2gpIG9mZnNldCsrXG4gICAgICAgIG9sZE5vZGUuaW5zZXJ0QmVmb3JlKG1vcnBoZWQsIG9sZENoaWxkKVxuXG4gICAgICAvLyBJdCdzIHNhZmUgdG8gbW9ycGggdHdvIG5vZGVzIGluLXBsYWNlIGlmIG5laXRoZXIgaGFzIGFuIElEXG4gICAgICB9IGVsc2UgaWYgKCFuZXdDaGlsZC5pZCAmJiAhb2xkQ2hpbGQuaWQpIHtcbiAgICAgICAgbW9ycGhlZCA9IHdhbGsobmV3Q2hpbGQsIG9sZENoaWxkKVxuICAgICAgICBpZiAobW9ycGhlZCAhPT0gb2xkQ2hpbGQpIHtcbiAgICAgICAgICBvbGROb2RlLnJlcGxhY2VDaGlsZChtb3JwaGVkLCBvbGRDaGlsZClcbiAgICAgICAgICBvZmZzZXQrK1xuICAgICAgICB9XG5cbiAgICAgIC8vIEluc2VydCB0aGUgbm9kZSBhdCB0aGUgaW5kZXggaWYgd2UgY291bGRuJ3QgbW9ycGggb3IgZmluZCBhIG1hdGNoaW5nIG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZE5vZGUuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCBvbGRDaGlsZClcbiAgICAgICAgb2Zmc2V0KytcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FtZSAoYSwgYikge1xuICBpZiAoYS5pZCkgcmV0dXJuIGEuaWQgPT09IGIuaWRcbiAgaWYgKGEuaXNTYW1lTm9kZSkgcmV0dXJuIGEuaXNTYW1lTm9kZShiKVxuICBpZiAoYS50YWdOYW1lICE9PSBiLnRhZ05hbWUpIHJldHVybiBmYWxzZVxuICBpZiAoYS50eXBlID09PSBURVhUX05PREUpIHJldHVybiBhLm5vZGVWYWx1ZSA9PT0gYi5ub2RlVmFsdWVcbiAgcmV0dXJuIGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gYXR0cmlidXRlIGV2ZW50cyAoY2FuIGJlIHNldCB3aXRoIGF0dHJpYnV0ZXMpXG4gICdvbmNsaWNrJyxcbiAgJ29uZGJsY2xpY2snLFxuICAnb25tb3VzZWRvd24nLFxuICAnb25tb3VzZXVwJyxcbiAgJ29ubW91c2VvdmVyJyxcbiAgJ29ubW91c2Vtb3ZlJyxcbiAgJ29ubW91c2VvdXQnLFxuICAnb25tb3VzZWVudGVyJyxcbiAgJ29ubW91c2VsZWF2ZScsXG4gICdvbnRvdWNoY2FuY2VsJyxcbiAgJ29udG91Y2hlbmQnLFxuICAnb250b3VjaG1vdmUnLFxuICAnb250b3VjaHN0YXJ0JyxcbiAgJ29uZHJhZ3N0YXJ0JyxcbiAgJ29uZHJhZycsXG4gICdvbmRyYWdlbnRlcicsXG4gICdvbmRyYWdsZWF2ZScsXG4gICdvbmRyYWdvdmVyJyxcbiAgJ29uZHJvcCcsXG4gICdvbmRyYWdlbmQnLFxuICAnb25rZXlkb3duJyxcbiAgJ29ua2V5cHJlc3MnLFxuICAnb25rZXl1cCcsXG4gICdvbnVubG9hZCcsXG4gICdvbmFib3J0JyxcbiAgJ29uZXJyb3InLFxuICAnb25yZXNpemUnLFxuICAnb25zY3JvbGwnLFxuICAnb25zZWxlY3QnLFxuICAnb25jaGFuZ2UnLFxuICAnb25zdWJtaXQnLFxuICAnb25yZXNldCcsXG4gICdvbmZvY3VzJyxcbiAgJ29uYmx1cicsXG4gICdvbmlucHV0JyxcbiAgJ29uYW5pbWF0aW9uZW5kJyxcbiAgJ29uYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgJ29uYW5pbWF0aW9uc3RhcnQnLFxuICAvLyBvdGhlciBjb21tb24gZXZlbnRzXG4gICdvbmNvbnRleHRtZW51JyxcbiAgJ29uZm9jdXNpbicsXG4gICdvbmZvY3Vzb3V0J1xuXVxuIiwidmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJylcbnZhciBldmVudHNMZW5ndGggPSBldmVudHMubGVuZ3RoXG5cbnZhciBFTEVNRU5UX05PREUgPSAxXG52YXIgVEVYVF9OT0RFID0gM1xudmFyIENPTU1FTlRfTk9ERSA9IDhcblxubW9kdWxlLmV4cG9ydHMgPSBtb3JwaFxuXG4vLyBkaWZmIGVsZW1lbnRzIGFuZCBhcHBseSB0aGUgcmVzdWx0aW5nIHBhdGNoIHRvIHRoZSBvbGQgbm9kZVxuLy8gKG9iaiwgb2JqKSAtPiBudWxsXG5mdW5jdGlvbiBtb3JwaCAobmV3Tm9kZSwgb2xkTm9kZSkge1xuICB2YXIgbm9kZVR5cGUgPSBuZXdOb2RlLm5vZGVUeXBlXG4gIHZhciBub2RlTmFtZSA9IG5ld05vZGUubm9kZU5hbWVcblxuICBpZiAobm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgIGNvcHlBdHRycyhuZXdOb2RlLCBvbGROb2RlKVxuICB9XG5cbiAgaWYgKG5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGlmIChvbGROb2RlLm5vZGVWYWx1ZSAhPT0gbmV3Tm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgIG9sZE5vZGUubm9kZVZhbHVlID0gbmV3Tm9kZS5ub2RlVmFsdWVcbiAgICB9XG4gIH1cblxuICAvLyBTb21lIERPTSBub2RlcyBhcmUgd2VpcmRcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BhdHJpY2stc3RlZWxlLWlkZW0vbW9ycGhkb20vYmxvYi9tYXN0ZXIvc3JjL3NwZWNpYWxFbEhhbmRsZXJzLmpzXG4gIGlmIChub2RlTmFtZSA9PT0gJ0lOUFVUJykgdXBkYXRlSW5wdXQobmV3Tm9kZSwgb2xkTm9kZSlcbiAgZWxzZSBpZiAobm9kZU5hbWUgPT09ICdPUFRJT04nKSB1cGRhdGVPcHRpb24obmV3Tm9kZSwgb2xkTm9kZSlcbiAgZWxzZSBpZiAobm9kZU5hbWUgPT09ICdURVhUQVJFQScpIHVwZGF0ZVRleHRhcmVhKG5ld05vZGUsIG9sZE5vZGUpXG5cbiAgY29weUV2ZW50cyhuZXdOb2RlLCBvbGROb2RlKVxufVxuXG5mdW5jdGlvbiBjb3B5QXR0cnMgKG5ld05vZGUsIG9sZE5vZGUpIHtcbiAgdmFyIG9sZEF0dHJzID0gb2xkTm9kZS5hdHRyaWJ1dGVzXG4gIHZhciBuZXdBdHRycyA9IG5ld05vZGUuYXR0cmlidXRlc1xuICB2YXIgYXR0ck5hbWVzcGFjZVVSSSA9IG51bGxcbiAgdmFyIGF0dHJWYWx1ZSA9IG51bGxcbiAgdmFyIGZyb21WYWx1ZSA9IG51bGxcbiAgdmFyIGF0dHJOYW1lID0gbnVsbFxuICB2YXIgYXR0ciA9IG51bGxcblxuICBmb3IgKHZhciBpID0gbmV3QXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBhdHRyID0gbmV3QXR0cnNbaV1cbiAgICBhdHRyTmFtZSA9IGF0dHIubmFtZVxuICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSVxuICAgIGF0dHJWYWx1ZSA9IGF0dHIudmFsdWVcbiAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZVxuICAgICAgZnJvbVZhbHVlID0gb2xkTm9kZS5nZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSlcbiAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICBvbGROb2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lLCBhdHRyVmFsdWUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghb2xkTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgIG9sZE5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tVmFsdWUgPSBvbGROb2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSlcbiAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgLy8gYXBwYXJlbnRseSB2YWx1ZXMgYXJlIGFsd2F5cyBjYXN0IHRvIHN0cmluZ3MsIGFoIHdlbGxcbiAgICAgICAgICBpZiAoYXR0clZhbHVlID09PSAnbnVsbCcgfHwgYXR0clZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb2xkTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9sZE5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGFueSBleHRyYSBhdHRyaWJ1dGVzIGZvdW5kIG9uIHRoZSBvcmlnaW5hbCBET00gZWxlbWVudCB0aGF0XG4gIC8vIHdlcmVuJ3QgZm91bmQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICBmb3IgKHZhciBqID0gb2xkQXR0cnMubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICBhdHRyID0gb2xkQXR0cnNbal1cbiAgICBpZiAoYXR0ci5zcGVjaWZpZWQgIT09IGZhbHNlKSB7XG4gICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZVxuICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJXG5cbiAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWVcbiAgICAgICAgaWYgKCFuZXdOb2RlLmhhc0F0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKSkge1xuICAgICAgICAgIG9sZE5vZGUucmVtb3ZlQXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghbmV3Tm9kZS5oYXNBdHRyaWJ1dGVOUyhudWxsLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICBvbGROb2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5RXZlbnRzIChuZXdOb2RlLCBvbGROb2RlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXYgPSBldmVudHNbaV1cbiAgICBpZiAobmV3Tm9kZVtldl0pIHsgICAgICAgICAgIC8vIGlmIG5ldyBlbGVtZW50IGhhcyBhIHdoaXRlbGlzdGVkIGF0dHJpYnV0ZVxuICAgICAgb2xkTm9kZVtldl0gPSBuZXdOb2RlW2V2XSAgLy8gdXBkYXRlIGV4aXN0aW5nIGVsZW1lbnRcbiAgICB9IGVsc2UgaWYgKG9sZE5vZGVbZXZdKSB7ICAgIC8vIGlmIGV4aXN0aW5nIGVsZW1lbnQgaGFzIGl0IGFuZCBuZXcgb25lIGRvZXNudFxuICAgICAgb2xkTm9kZVtldl0gPSB1bmRlZmluZWQgICAgLy8gcmVtb3ZlIGl0IGZyb20gZXhpc3RpbmcgZWxlbWVudFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb24gKG5ld05vZGUsIG9sZE5vZGUpIHtcbiAgdXBkYXRlQXR0cmlidXRlKG5ld05vZGUsIG9sZE5vZGUsICdzZWxlY3RlZCcpXG59XG5cbi8vIFRoZSBcInZhbHVlXCIgYXR0cmlidXRlIGlzIHNwZWNpYWwgZm9yIHRoZSA8aW5wdXQ+IGVsZW1lbnQgc2luY2UgaXQgc2V0cyB0aGVcbi8vIGluaXRpYWwgdmFsdWUuIENoYW5naW5nIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlIFwidmFsdWVcIlxuLy8gcHJvcGVydHkgd2lsbCBoYXZlIG5vIGVmZmVjdCBzaW5jZSBpdCBpcyBvbmx5IHVzZWQgdG8gdGhlIHNldCB0aGUgaW5pdGlhbFxuLy8gdmFsdWUuIFNpbWlsYXIgZm9yIHRoZSBcImNoZWNrZWRcIiBhdHRyaWJ1dGUsIGFuZCBcImRpc2FibGVkXCIuXG5mdW5jdGlvbiB1cGRhdGVJbnB1dCAobmV3Tm9kZSwgb2xkTm9kZSkge1xuICB2YXIgbmV3VmFsdWUgPSBuZXdOb2RlLnZhbHVlXG4gIHZhciBvbGRWYWx1ZSA9IG9sZE5vZGUudmFsdWVcblxuICB1cGRhdGVBdHRyaWJ1dGUobmV3Tm9kZSwgb2xkTm9kZSwgJ2NoZWNrZWQnKVxuICB1cGRhdGVBdHRyaWJ1dGUobmV3Tm9kZSwgb2xkTm9kZSwgJ2Rpc2FibGVkJylcblxuICAvLyBUaGUgXCJpbmRldGVybWluYXRlXCIgcHJvcGVydHkgY2FuIG5vdCBiZSBzZXQgdXNpbmcgYW4gSFRNTCBhdHRyaWJ1dGUuXG4gIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQvY2hlY2tib3hcbiAgaWYgKG5ld05vZGUuaW5kZXRlcm1pbmF0ZSAhPT0gb2xkTm9kZS5pbmRldGVybWluYXRlKSB7XG4gICAgb2xkTm9kZS5pbmRldGVybWluYXRlID0gbmV3Tm9kZS5pbmRldGVybWluYXRlXG4gIH1cblxuICAvLyBQZXJzaXN0IGZpbGUgdmFsdWUgc2luY2UgZmlsZSBpbnB1dHMgY2FuJ3QgYmUgY2hhbmdlZCBwcm9ncmFtYXRpY2FsbHlcbiAgaWYgKG9sZE5vZGUudHlwZSA9PT0gJ2ZpbGUnKSByZXR1cm5cblxuICBpZiAobmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgb2xkTm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgbmV3VmFsdWUpXG4gICAgb2xkTm9kZS52YWx1ZSA9IG5ld1ZhbHVlXG4gIH1cblxuICBpZiAobmV3VmFsdWUgPT09ICdudWxsJykge1xuICAgIG9sZE5vZGUudmFsdWUgPSAnJ1xuICAgIG9sZE5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpXG4gIH1cblxuICBpZiAoIW5ld05vZGUuaGFzQXR0cmlidXRlTlMobnVsbCwgJ3ZhbHVlJykpIHtcbiAgICBvbGROb2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKVxuICB9IGVsc2UgaWYgKG9sZE5vZGUudHlwZSA9PT0gJ3JhbmdlJykge1xuICAgIC8vIHRoaXMgaXMgc28gZWxlbWVudHMgbGlrZSBzbGlkZXIgbW92ZSB0aGVpciBVSSB0aGluZ3lcbiAgICBvbGROb2RlLnZhbHVlID0gbmV3VmFsdWVcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVUZXh0YXJlYSAobmV3Tm9kZSwgb2xkTm9kZSkge1xuICB2YXIgbmV3VmFsdWUgPSBuZXdOb2RlLnZhbHVlXG4gIGlmIChuZXdWYWx1ZSAhPT0gb2xkTm9kZS52YWx1ZSkge1xuICAgIG9sZE5vZGUudmFsdWUgPSBuZXdWYWx1ZVxuICB9XG5cbiAgaWYgKG9sZE5vZGUuZmlyc3RDaGlsZCAmJiBvbGROb2RlLmZpcnN0Q2hpbGQubm9kZVZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgIC8vIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgc2V0cyB0aGUgcGxhY2Vob2xkZXIgYXMgdGhlXG4gICAgLy8gbm9kZSB2YWx1ZSBhbmQgdmlzZSB2ZXJzYS4gVGhpcyBpZ25vcmVzIGFuIGVtcHR5IHVwZGF0ZS5cbiAgICBpZiAobmV3VmFsdWUgPT09ICcnICYmIG9sZE5vZGUuZmlyc3RDaGlsZC5ub2RlVmFsdWUgPT09IG9sZE5vZGUucGxhY2Vob2xkZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIG9sZE5vZGUuZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZSAobmV3Tm9kZSwgb2xkTm9kZSwgbmFtZSkge1xuICBpZiAobmV3Tm9kZVtuYW1lXSAhPT0gb2xkTm9kZVtuYW1lXSkge1xuICAgIG9sZE5vZGVbbmFtZV0gPSBuZXdOb2RlW25hbWVdXG4gICAgaWYgKG5ld05vZGVbbmFtZV0pIHtcbiAgICAgIG9sZE5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnKVxuICAgIH0gZWxzZSB7XG4gICAgICBvbGROb2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIHJlZyA9IC8oW14/PSZdKykoPShbXiZdKikpPy9nXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxubW9kdWxlLmV4cG9ydHMgPSBxc1xuXG5mdW5jdGlvbiBxcyAodXJsKSB7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgdXJsLCAnc3RyaW5nJywgJ25hbm9xdWVyeTogdXJsIHNob3VsZCBiZSB0eXBlIHN0cmluZycpXG5cbiAgdmFyIG9iaiA9IHt9XG4gIHVybC5yZXBsYWNlKC9eLipcXD8vLCAnJykucmVwbGFjZShyZWcsIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMykge1xuICAgIHZhciB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChhMylcbiAgICB2YXIga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGExKVxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSBvYmpba2V5XS5wdXNoKHZhbHVlKVxuICAgICAgZWxzZSBvYmpba2V5XSA9IFtvYmpba2V5XSwgdmFsdWVdXG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWVcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG9ialxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hbm9yYWZcblxuLy8gT25seSBjYWxsIFJBRiB3aGVuIG5lZWRlZFxuLy8gKGZuLCBmbj8pIC0+IGZuXG5mdW5jdGlvbiBuYW5vcmFmIChyZW5kZXIsIHJhZikge1xuICBhc3NlcnQuZXF1YWwodHlwZW9mIHJlbmRlciwgJ2Z1bmN0aW9uJywgJ25hbm9yYWY6IHJlbmRlciBzaG91bGQgYmUgYSBmdW5jdGlvbicpXG4gIGFzc2VydC5vayh0eXBlb2YgcmFmID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByYWYgPT09ICd1bmRlZmluZWQnLCAnbmFub3JhZjogcmFmIHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZCcpXG5cbiAgaWYgKCFyYWYpIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgdmFyIHJlZHJhd1NjaGVkdWxlZCA9IGZhbHNlXG4gIHZhciBhcmdzID0gbnVsbFxuXG4gIHJldHVybiBmdW5jdGlvbiBmcmFtZSAoKSB7XG4gICAgaWYgKGFyZ3MgPT09IG51bGwgJiYgIXJlZHJhd1NjaGVkdWxlZCkge1xuICAgICAgcmVkcmF3U2NoZWR1bGVkID0gdHJ1ZVxuXG4gICAgICByYWYoZnVuY3Rpb24gcmVkcmF3ICgpIHtcbiAgICAgICAgcmVkcmF3U2NoZWR1bGVkID0gZmFsc2VcblxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGhcbiAgICAgICAgdmFyIF9hcmdzID0gbmV3IEFycmF5KGxlbmd0aClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgX2FyZ3NbaV0gPSBhcmdzW2ldXG5cbiAgICAgICAgcmVuZGVyLmFwcGx5KHJlbmRlciwgX2FyZ3MpXG4gICAgICAgIGFyZ3MgPSBudWxsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGFyZ3MgPSBhcmd1bWVudHNcbiAgfVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgd2F5ZmFyZXIgPSByZXF1aXJlKCd3YXlmYXJlcicpXG5cbi8vIGVsZWN0cm9uIHN1cHBvcnRcbnZhciBpc0xvY2FsRmlsZSA9ICgvZmlsZTpcXC9cXC8vLnRlc3QoXG4gIHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXG4gIHdpbmRvdy5sb2NhdGlvbiAmJlxuICB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4pKVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11c2VsZXNzLWVzY2FwZSAqL1xudmFyIGVsZWN0cm9uID0gJ14oZmlsZTpcXC9cXC98XFwvKSguKlxcLmh0bWw/XFwvPyk/J1xudmFyIHByb3RvY29sID0gJ14oaHR0cChzKT8oOlxcL1xcLykpPyh3d3dcXC4pPydcbnZhciBkb21haW4gPSAnW2EtekEtWjAtOS1fXFwuXSsoOlswLTldezEsNX0pPyhcXC97MX0pPydcbnZhciBxcyA9ICdbXFw/XS4qJCdcbi8qIGVzbGludC1lbmFibGUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cblxudmFyIHN0cmlwRWxlY3Ryb24gPSBuZXcgUmVnRXhwKGVsZWN0cm9uKVxudmFyIHByZWZpeCA9IG5ldyBSZWdFeHAocHJvdG9jb2wgKyBkb21haW4pXG52YXIgbm9ybWFsaXplID0gbmV3IFJlZ0V4cCgnIycpXG52YXIgc3VmZml4ID0gbmV3IFJlZ0V4cChxcylcblxubW9kdWxlLmV4cG9ydHMgPSBOYW5vcm91dGVyXG5cbmZ1bmN0aW9uIE5hbm9yb3V0ZXIgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5hbm9yb3V0ZXIpKSByZXR1cm4gbmV3IE5hbm9yb3V0ZXIob3B0cylcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgdGhpcy5yb3V0ZXIgPSB3YXlmYXJlcihvcHRzLmRlZmF1bHQgfHwgJy80MDQnKVxufVxuXG5OYW5vcm91dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChyb3V0ZW5hbWUsIGxpc3RlbmVyKSB7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygcm91dGVuYW1lLCAnc3RyaW5nJylcbiAgcm91dGVuYW1lID0gcm91dGVuYW1lLnJlcGxhY2UoL15bIy9dLywgJycpXG4gIHRoaXMucm91dGVyLm9uKHJvdXRlbmFtZSwgbGlzdGVuZXIpXG59XG5cbk5hbm9yb3V0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAocm91dGVuYW1lKSB7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygcm91dGVuYW1lLCAnc3RyaW5nJylcbiAgcm91dGVuYW1lID0gcGF0aG5hbWUocm91dGVuYW1lLCBpc0xvY2FsRmlsZSlcbiAgcmV0dXJuIHRoaXMucm91dGVyLmVtaXQocm91dGVuYW1lKVxufVxuXG5OYW5vcm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChyb3V0ZW5hbWUpIHtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiByb3V0ZW5hbWUsICdzdHJpbmcnKVxuICByb3V0ZW5hbWUgPSBwYXRobmFtZShyb3V0ZW5hbWUsIGlzTG9jYWxGaWxlKVxuICByZXR1cm4gdGhpcy5yb3V0ZXIubWF0Y2gocm91dGVuYW1lKVxufVxuXG4vLyByZXBsYWNlIGV2ZXJ5dGhpbmcgaW4gYSByb3V0ZSBidXQgdGhlIHBhdGhuYW1lIGFuZCBoYXNoXG5mdW5jdGlvbiBwYXRobmFtZSAocm91dGVuYW1lLCBpc0VsZWN0cm9uKSB7XG4gIGlmIChpc0VsZWN0cm9uKSByb3V0ZW5hbWUgPSByb3V0ZW5hbWUucmVwbGFjZShzdHJpcEVsZWN0cm9uLCAnJylcbiAgZWxzZSByb3V0ZW5hbWUgPSByb3V0ZW5hbWUucmVwbGFjZShwcmVmaXgsICcnKVxuICByZXR1cm4gZGVjb2RlVVJJKHJvdXRlbmFtZS5yZXBsYWNlKHN1ZmZpeCwgJycpLnJlcGxhY2Uobm9ybWFsaXplLCAnLycpKVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbnZhciBoYXNXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXG5mdW5jdGlvbiBjcmVhdGVTY2hlZHVsZXIgKCkge1xuICB2YXIgc2NoZWR1bGVyXG4gIGlmIChoYXNXaW5kb3cpIHtcbiAgICBpZiAoIXdpbmRvdy5fbmFub1NjaGVkdWxlcikgd2luZG93Ll9uYW5vU2NoZWR1bGVyID0gbmV3IE5hbm9TY2hlZHVsZXIodHJ1ZSlcbiAgICBzY2hlZHVsZXIgPSB3aW5kb3cuX25hbm9TY2hlZHVsZXJcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZXIgPSBuZXcgTmFub1NjaGVkdWxlcigpXG4gIH1cbiAgcmV0dXJuIHNjaGVkdWxlclxufVxuXG5mdW5jdGlvbiBOYW5vU2NoZWR1bGVyIChoYXNXaW5kb3cpIHtcbiAgdGhpcy5oYXNXaW5kb3cgPSBoYXNXaW5kb3dcbiAgdGhpcy5oYXNJZGxlID0gdGhpcy5oYXNXaW5kb3cgJiYgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2tcbiAgdGhpcy5tZXRob2QgPSB0aGlzLmhhc0lkbGUgPyB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjay5iaW5kKHdpbmRvdykgOiB0aGlzLnNldFRpbWVvdXRcbiAgdGhpcy5zY2hlZHVsZWQgPSBmYWxzZVxuICB0aGlzLnF1ZXVlID0gW11cbn1cblxuTmFub1NjaGVkdWxlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjYikge1xuICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAnbmFub3NjaGVkdWxlci5wdXNoOiBjYiBzaG91bGQgYmUgdHlwZSBmdW5jdGlvbicpXG5cbiAgdGhpcy5xdWV1ZS5wdXNoKGNiKVxuICB0aGlzLnNjaGVkdWxlKClcbn1cblxuTmFub1NjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjaGVkdWxlZCkgcmV0dXJuXG5cbiAgdGhpcy5zY2hlZHVsZWQgPSB0cnVlXG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLm1ldGhvZChmdW5jdGlvbiAoaWRsZURlYWRsaW5lKSB7XG4gICAgdmFyIGNiXG4gICAgd2hpbGUgKHNlbGYucXVldWUubGVuZ3RoICYmIGlkbGVEZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiAwKSB7XG4gICAgICBjYiA9IHNlbGYucXVldWUuc2hpZnQoKVxuICAgICAgY2IoaWRsZURlYWRsaW5lKVxuICAgIH1cbiAgICBzZWxmLnNjaGVkdWxlZCA9IGZhbHNlXG4gICAgaWYgKHNlbGYucXVldWUubGVuZ3RoKSBzZWxmLnNjaGVkdWxlKClcbiAgfSlcbn1cblxuTmFub1NjaGVkdWxlci5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChjYikge1xuICBzZXRUaW1lb3V0KGNiLCAwLCB7XG4gICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2NoZWR1bGVyXG4iLCJ2YXIgc2NoZWR1bGVyID0gcmVxdWlyZSgnbmFub3NjaGVkdWxlcicpKClcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG52YXIgcGVyZlxubmFub3RpbWluZy5kaXNhYmxlZCA9IHRydWVcbnRyeSB7XG4gIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2VcbiAgbmFub3RpbWluZy5kaXNhYmxlZCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuRElTQUJMRV9OQU5PVElNSU5HID09PSAndHJ1ZScgfHwgIXBlcmYubWFya1xufSBjYXRjaCAoZSkgeyB9XG5cbm1vZHVsZS5leHBvcnRzID0gbmFub3RpbWluZ1xuXG5mdW5jdGlvbiBuYW5vdGltaW5nIChuYW1lKSB7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgbmFtZSwgJ3N0cmluZycsICduYW5vdGltaW5nOiBuYW1lIHNob3VsZCBiZSB0eXBlIHN0cmluZycpXG5cbiAgaWYgKG5hbm90aW1pbmcuZGlzYWJsZWQpIHJldHVybiBub29wXG5cbiAgdmFyIHV1aWQgPSAocGVyZi5ub3coKSAqIDEwMDAwKS50b0ZpeGVkKCkgJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB2YXIgc3RhcnROYW1lID0gJ3N0YXJ0LScgKyB1dWlkICsgJy0nICsgbmFtZVxuICBwZXJmLm1hcmsoc3RhcnROYW1lKVxuXG4gIGZ1bmN0aW9uIGVuZCAoY2IpIHtcbiAgICB2YXIgZW5kTmFtZSA9ICdlbmQtJyArIHV1aWQgKyAnLScgKyBuYW1lXG4gICAgcGVyZi5tYXJrKGVuZE5hbWUpXG5cbiAgICBzY2hlZHVsZXIucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXJyID0gbnVsbFxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG1lYXN1cmVOYW1lID0gbmFtZSArICcgWycgKyB1dWlkICsgJ10nXG4gICAgICAgIHBlcmYubWVhc3VyZShtZWFzdXJlTmFtZSwgc3RhcnROYW1lLCBlbmROYW1lKVxuICAgICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnROYW1lKVxuICAgICAgICBwZXJmLmNsZWFyTWFya3MoZW5kTmFtZSlcbiAgICAgIH0gY2F0Y2ggKGUpIHsgZXJyID0gZSB9XG4gICAgICBpZiAoY2IpIGNiKGVyciwgbmFtZSlcbiAgICB9KVxuICB9XG5cbiAgZW5kLnV1aWQgPSB1dWlkXG4gIHJldHVybiBlbmRcbn1cblxuZnVuY3Rpb24gbm9vcCAoY2IpIHtcbiAgaWYgKGNiKSB7XG4gICAgc2NoZWR1bGVyLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgY2IobmV3IEVycm9yKCduYW5vdGltaW5nOiBwZXJmb3JtYW5jZSBBUEkgdW5hdmFpbGFibGUnKSlcbiAgICB9KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBSZW1vdmUgYSByYW5nZSBvZiBpdGVtcyBmcm9tIGFuIGFycmF5XG4gKlxuICogQGZ1bmN0aW9uIHJlbW92ZUl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIHRhcmdldCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SWR4IFRoZSBpbmRleCB0byBiZWdpbiByZW1vdmluZyBmcm9tIChpbmNsdXNpdmUpXG4gKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlQ291bnQgSG93IG1hbnkgaXRlbXMgdG8gcmVtb3ZlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVtb3ZlSXRlbXMgKGFyciwgc3RhcnRJZHgsIHJlbW92ZUNvdW50KSB7XG4gIHZhciBpLCBsZW5ndGggPSBhcnIubGVuZ3RoXG5cbiAgaWYgKHN0YXJ0SWR4ID49IGxlbmd0aCB8fCByZW1vdmVDb3VudCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgcmVtb3ZlQ291bnQgPSAoc3RhcnRJZHggKyByZW1vdmVDb3VudCA+IGxlbmd0aCA/IGxlbmd0aCAtIHN0YXJ0SWR4IDogcmVtb3ZlQ291bnQpXG5cbiAgdmFyIGxlbiA9IGxlbmd0aCAtIHJlbW92ZUNvdW50XG5cbiAgZm9yIChpID0gc3RhcnRJZHg7IGkgPCBsZW47ICsraSkge1xuICAgIGFycltpXSA9IGFycltpICsgcmVtb3ZlQ291bnRdXG4gIH1cblxuICBhcnIubGVuZ3RoID0gbGVuXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjcm9sbFRvQW5jaG9yXG5cbmZ1bmN0aW9uIHNjcm9sbFRvQW5jaG9yIChhbmNob3IsIG9wdGlvbnMpIHtcbiAgaWYgKGFuY2hvcikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGFuY2hvcilcbiAgICAgIGlmIChlbCkgZWwuc2Nyb2xsSW50b1ZpZXcob3B0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciB0cmllID0gcmVxdWlyZSgnLi90cmllJylcblxubW9kdWxlLmV4cG9ydHMgPSBXYXlmYXJlclxuXG4vLyBjcmVhdGUgYSByb3V0ZXJcbi8vIHN0ciAtPiBvYmpcbmZ1bmN0aW9uIFdheWZhcmVyIChkZnQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdheWZhcmVyKSkgcmV0dXJuIG5ldyBXYXlmYXJlcihkZnQpXG5cbiAgdmFyIF9kZWZhdWx0ID0gKGRmdCB8fCAnJykucmVwbGFjZSgvXlxcLy8sICcnKVxuICB2YXIgX3RyaWUgPSB0cmllKClcblxuICBlbWl0Ll90cmllID0gX3RyaWVcbiAgZW1pdC5vbiA9IG9uXG4gIGVtaXQuZW1pdCA9IGVtaXRcbiAgZW1pdC5tYXRjaCA9IG1hdGNoXG4gIGVtaXQuX3dheWZhcmVyID0gdHJ1ZVxuXG4gIHJldHVybiBlbWl0XG5cbiAgLy8gZGVmaW5lIGEgcm91dGVcbiAgLy8gKHN0ciwgZm4pIC0+IG9ialxuICBmdW5jdGlvbiBvbiAocm91dGUsIGNiKSB7XG4gICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiByb3V0ZSwgJ3N0cmluZycpXG4gICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBjYiwgJ2Z1bmN0aW9uJylcblxuICAgIHJvdXRlID0gcm91dGUgfHwgJy8nXG5cbiAgICBpZiAoY2IuX3dheWZhcmVyICYmIGNiLl90cmllKSB7XG4gICAgICBfdHJpZS5tb3VudChyb3V0ZSwgY2IuX3RyaWUudHJpZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGUgPSBfdHJpZS5jcmVhdGUocm91dGUpXG4gICAgICBub2RlLmNiID0gY2JcbiAgICAgIG5vZGUucm91dGUgPSByb3V0ZVxuICAgIH1cblxuICAgIHJldHVybiBlbWl0XG4gIH1cblxuICAvLyBtYXRjaCBhbmQgY2FsbCBhIHJvdXRlXG4gIC8vIChzdHIsIG9iaj8pIC0+IG51bGxcbiAgZnVuY3Rpb24gZW1pdCAocm91dGUpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IG1hdGNoKHJvdXRlKVxuXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBhcmdzWzBdID0gbWF0Y2hlZC5wYXJhbXNcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZC5jYi5hcHBseShtYXRjaGVkLmNiLCBhcmdzKVxuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2ggKHJvdXRlKSB7XG4gICAgYXNzZXJ0Lm5vdEVxdWFsKHJvdXRlLCB1bmRlZmluZWQsIFwiJ3JvdXRlJyBtdXN0IGJlIGRlZmluZWRcIilcblxuICAgIHZhciBtYXRjaGVkID0gX3RyaWUubWF0Y2gocm91dGUpXG4gICAgaWYgKG1hdGNoZWQgJiYgbWF0Y2hlZC5jYikgcmV0dXJuIG5ldyBSb3V0ZShtYXRjaGVkKVxuXG4gICAgdmFyIGRmdCA9IF90cmllLm1hdGNoKF9kZWZhdWx0KVxuICAgIGlmIChkZnQgJiYgZGZ0LmNiKSByZXR1cm4gbmV3IFJvdXRlKGRmdClcblxuICAgIHRocm93IG5ldyBFcnJvcihcInJvdXRlICdcIiArIHJvdXRlICsgXCInIGRpZCBub3QgbWF0Y2hcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIFJvdXRlIChtYXRjaGVkKSB7XG4gICAgdGhpcy5jYiA9IG1hdGNoZWQuY2JcbiAgICB0aGlzLnJvdXRlID0gbWF0Y2hlZC5yb3V0ZVxuICAgIHRoaXMucGFyYW1zID0gbWF0Y2hlZC5wYXJhbXNcbiAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbm1vZHVsZS5leHBvcnRzID0gVHJpZVxuXG4vLyBjcmVhdGUgYSBuZXcgdHJpZVxuLy8gbnVsbCAtPiBvYmpcbmZ1bmN0aW9uIFRyaWUgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJpZSkpIHJldHVybiBuZXcgVHJpZSgpXG4gIHRoaXMudHJpZSA9IHsgbm9kZXM6IHt9IH1cbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBvbiB0aGUgdHJpZSBhdCByb3V0ZVxuLy8gYW5kIHJldHVybiBhIG5vZGVcbi8vIHN0ciAtPiBvYmpcblRyaWUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChyb3V0ZSkge1xuICBhc3NlcnQuZXF1YWwodHlwZW9mIHJvdXRlLCAnc3RyaW5nJywgJ3JvdXRlIHNob3VsZCBiZSBhIHN0cmluZycpXG4gIC8vIHN0cmlwIGxlYWRpbmcgJy8nIGFuZCBzcGxpdCByb3V0ZXNcbiAgdmFyIHJvdXRlcyA9IHJvdXRlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGUgKGluZGV4LCB0cmllKSB7XG4gICAgdmFyIHRoaXNSb3V0ZSA9IChoYXMocm91dGVzLCBpbmRleCkgJiYgcm91dGVzW2luZGV4XSlcbiAgICBpZiAodGhpc1JvdXRlID09PSBmYWxzZSkgcmV0dXJuIHRyaWVcblxuICAgIHZhciBub2RlID0gbnVsbFxuICAgIGlmICgvXjp8XlxcKi8udGVzdCh0aGlzUm91dGUpKSB7XG4gICAgICAvLyBpZiBub2RlIGlzIGEgbmFtZSBtYXRjaCwgc2V0IG5hbWUgYW5kIGFwcGVuZCB0byAnOicgbm9kZVxuICAgICAgaWYgKCFoYXModHJpZS5ub2RlcywgJyQkJykpIHtcbiAgICAgICAgbm9kZSA9IHsgbm9kZXM6IHt9IH1cbiAgICAgICAgdHJpZS5ub2Rlcy4kJCA9IG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSB0cmllLm5vZGVzLiQkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzUm91dGVbMF0gPT09ICcqJykge1xuICAgICAgICB0cmllLndpbGRjYXJkID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICB0cmllLm5hbWUgPSB0aGlzUm91dGUucmVwbGFjZSgvXjp8XlxcKi8sICcnKVxuICAgIH0gZWxzZSBpZiAoIWhhcyh0cmllLm5vZGVzLCB0aGlzUm91dGUpKSB7XG4gICAgICBub2RlID0geyBub2Rlczoge30gfVxuICAgICAgdHJpZS5ub2Rlc1t0aGlzUm91dGVdID0gbm9kZVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gdHJpZS5ub2Rlc1t0aGlzUm91dGVdXG4gICAgfVxuXG4gICAgLy8gd2UgbXVzdCByZWN1cnNlIGRlZXBlclxuICAgIHJldHVybiBjcmVhdGVOb2RlKGluZGV4ICsgMSwgbm9kZSlcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVOb2RlKDAsIHRoaXMudHJpZSlcbn1cblxuLy8gbWF0Y2ggYSByb3V0ZSBvbiB0aGUgdHJpZVxuLy8gYW5kIHJldHVybiB0aGUgbm9kZVxuLy8gc3RyIC0+IG9ialxuVHJpZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocm91dGUpIHtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiByb3V0ZSwgJ3N0cmluZycsICdyb3V0ZSBzaG91bGQgYmUgYSBzdHJpbmcnKVxuXG4gIHZhciByb3V0ZXMgPSByb3V0ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJylcbiAgdmFyIHBhcmFtcyA9IHt9XG5cbiAgZnVuY3Rpb24gc2VhcmNoIChpbmRleCwgdHJpZSkge1xuICAgIC8vIGVpdGhlciB0aGVyZSdzIG5vIG1hdGNoLCBvciB3ZSdyZSBkb25lIHNlYXJjaGluZ1xuICAgIGlmICh0cmllID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWRcbiAgICB2YXIgdGhpc1JvdXRlID0gcm91dGVzW2luZGV4XVxuICAgIGlmICh0aGlzUm91dGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRyaWVcblxuICAgIGlmIChoYXModHJpZS5ub2RlcywgdGhpc1JvdXRlKSkge1xuICAgICAgLy8gbWF0Y2ggcmVndWxhciByb3V0ZXMgZmlyc3RcbiAgICAgIHJldHVybiBzZWFyY2goaW5kZXggKyAxLCB0cmllLm5vZGVzW3RoaXNSb3V0ZV0pXG4gICAgfSBlbHNlIGlmICh0cmllLm5hbWUpIHtcbiAgICAgIC8vIG1hdGNoIG5hbWVkIHJvdXRlc1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyYW1zW3RyaWUubmFtZV0gPSBkZWNvZGVVUklDb21wb25lbnQodGhpc1JvdXRlKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2VhcmNoKGluZGV4LCB1bmRlZmluZWQpXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VhcmNoKGluZGV4ICsgMSwgdHJpZS5ub2Rlcy4kJClcbiAgICB9IGVsc2UgaWYgKHRyaWUud2lsZGNhcmQpIHtcbiAgICAgIC8vIG1hdGNoIHdpbGRjYXJkc1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyYW1zLndpbGRjYXJkID0gZGVjb2RlVVJJQ29tcG9uZW50KHJvdXRlcy5zbGljZShpbmRleCkuam9pbignLycpKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2VhcmNoKGluZGV4LCB1bmRlZmluZWQpXG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gZWFybHksIG9yIGVsc2Ugc2VhcmNoIG1heSBrZWVwIHJlY3Vyc2luZyB0aHJvdWdoIHRoZSB3aWxkY2FyZFxuICAgICAgcmV0dXJuIHRyaWUubm9kZXMuJCRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gbWF0Y2hlcyBmb3VuZFxuICAgICAgcmV0dXJuIHNlYXJjaChpbmRleCArIDEpXG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGUgPSBzZWFyY2goMCwgdGhpcy50cmllKVxuXG4gIGlmICghbm9kZSkgcmV0dXJuIHVuZGVmaW5lZFxuICBub2RlID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSlcbiAgbm9kZS5wYXJhbXMgPSBwYXJhbXNcbiAgcmV0dXJuIG5vZGVcbn1cblxuLy8gbW91bnQgYSB0cmllIG9udG8gYSBub2RlIGF0IHJvdXRlXG4vLyAoc3RyLCBvYmopIC0+IG51bGxcblRyaWUucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gKHJvdXRlLCB0cmllKSB7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygcm91dGUsICdzdHJpbmcnLCAncm91dGUgc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiB0cmllLCAnb2JqZWN0JywgJ3RyaWUgc2hvdWxkIGJlIGEgb2JqZWN0JylcblxuICB2YXIgc3BsaXQgPSByb3V0ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJylcbiAgdmFyIG5vZGUgPSBudWxsXG4gIHZhciBrZXkgPSBudWxsXG5cbiAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgIGtleSA9IHNwbGl0WzBdXG4gICAgbm9kZSA9IHRoaXMuY3JlYXRlKGtleSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgaGVhZCA9IHNwbGl0LmpvaW4oJy8nKVxuICAgIGtleSA9IHNwbGl0WzBdXG4gICAgbm9kZSA9IHRoaXMuY3JlYXRlKGhlYWQpXG4gIH1cblxuICBPYmplY3QuYXNzaWduKG5vZGUubm9kZXMsIHRyaWUubm9kZXMpXG4gIGlmICh0cmllLm5hbWUpIG5vZGUubmFtZSA9IHRyaWUubmFtZVxuXG4gIC8vIGRlbGVnYXRlIHByb3BlcnRpZXMgZnJvbSAnLycgdG8gdGhlIG5ldyBub2RlXG4gIC8vICcvJyBjYW5ub3QgYmUgcmVhY2hlZCBvbmNlIG1vdW50ZWRcbiAgaWYgKG5vZGUubm9kZXNbJyddKSB7XG4gICAgT2JqZWN0LmtleXMobm9kZS5ub2Rlc1snJ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ25vZGVzJykgcmV0dXJuXG4gICAgICBub2RlW2tleV0gPSBub2RlLm5vZGVzWycnXVtrZXldXG4gICAgfSlcbiAgICBPYmplY3QuYXNzaWduKG5vZGUubm9kZXMsIG5vZGUubm9kZXNbJyddLm5vZGVzKVxuICAgIGRlbGV0ZSBub2RlLm5vZGVzWycnXS5ub2Rlc1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhcyAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpXG59XG4iLCJ2YXIgX2dsb2JhbFRoaXM7XG5pZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSB7XG5cdF9nbG9iYWxUaGlzID0gZ2xvYmFsVGhpcztcbn0gZWxzZSB7XG5cdHRyeSB7XG5cdFx0X2dsb2JhbFRoaXMgPSByZXF1aXJlKCdlczUtZXh0L2dsb2JhbCcpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHR9IGZpbmFsbHkge1xuXHRcdGlmICghX2dsb2JhbFRoaXMgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgX2dsb2JhbFRoaXMgPSB3aW5kb3c7IH1cblx0XHRpZiAoIV9nbG9iYWxUaGlzKSB7IHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBnbG9iYWwgdGhpcycpOyB9XG5cdH1cbn1cblxudmFyIE5hdGl2ZVdlYlNvY2tldCA9IF9nbG9iYWxUaGlzLldlYlNvY2tldCB8fCBfZ2xvYmFsVGhpcy5Nb3pXZWJTb2NrZXQ7XG52YXIgd2Vic29ja2V0X3ZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxuXG4vKipcbiAqIEV4cG9zZSBhIFczQyBXZWJTb2NrZXQgY2xhc3Mgd2l0aCBqdXN0IG9uZSBvciB0d28gYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBXM0NXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpIHtcblx0dmFyIG5hdGl2ZV9pbnN0YW5jZTtcblxuXHRpZiAocHJvdG9jb2xzKSB7XG5cdFx0bmF0aXZlX2luc3RhbmNlID0gbmV3IE5hdGl2ZVdlYlNvY2tldCh1cmksIHByb3RvY29scyk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0bmF0aXZlX2luc3RhbmNlID0gbmV3IE5hdGl2ZVdlYlNvY2tldCh1cmkpO1xuXHR9XG5cblx0LyoqXG5cdCAqICduYXRpdmVfaW5zdGFuY2UnIGlzIGFuIGluc3RhbmNlIG9mIG5hdGl2ZVdlYlNvY2tldCAodGhlIGJyb3dzZXIncyBXZWJTb2NrZXRcblx0ICogY2xhc3MpLiBTaW5jZSBpdCBpcyBhbiBPYmplY3QgaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBpdCBpcyB3aGVuIGNyZWF0aW5nIGFuXG5cdCAqIGluc3RhbmNlIG9mIFczQ1dlYlNvY2tldCB2aWEgJ25ldyBXM0NXZWJTb2NrZXQoKScuXG5cdCAqXG5cdCAqIEVDTUFTY3JpcHQgNTogaHR0cDovL2JjbGFyeS5jb20vMjAwNC8xMS8wNy8jYS0xMy4yLjJcblx0ICovXG5cdHJldHVybiBuYXRpdmVfaW5zdGFuY2U7XG59XG5pZiAoTmF0aXZlV2ViU29ja2V0KSB7XG5cdFsnQ09OTkVDVElORycsICdPUEVOJywgJ0NMT1NJTkcnLCAnQ0xPU0VEJ10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFczQ1dlYlNvY2tldCwgcHJvcCwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIE5hdGl2ZVdlYlNvY2tldFtwcm9wXTsgfVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ3czY3dlYnNvY2tldCcgOiBOYXRpdmVXZWJTb2NrZXQgPyBXM0NXZWJTb2NrZXQgOiBudWxsLFxuICAgICd2ZXJzaW9uJyAgICAgIDogd2Vic29ja2V0X3ZlcnNpb25cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIndlYnNvY2tldFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiV2Vic29ja2V0IENsaWVudCAmIFNlcnZlciBMaWJyYXJ5IGltcGxlbWVudGluZyB0aGUgV2ViU29ja2V0IHByb3RvY29sIGFzIHNwZWNpZmllZCBpbiBSRkMgNjQ1NS5cIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJ3ZWJzb2NrZXRcIixcbiAgICBcIndlYnNvY2tldHNcIixcbiAgICBcInNvY2tldFwiLFxuICAgIFwibmV0d29ya2luZ1wiLFxuICAgIFwiY29tZXRcIixcbiAgICBcInB1c2hcIixcbiAgICBcIlJGQy02NDU1XCIsXG4gICAgXCJyZWFsdGltZVwiLFxuICAgIFwic2VydmVyXCIsXG4gICAgXCJjbGllbnRcIlxuICBdLFxuICBcImF1dGhvclwiOiBcIkJyaWFuIE1jS2VsdmV5IDx0aGV0dXJ0bGUzMkBnbWFpbC5jb20+IChodHRwczovL2dpdGh1Yi5jb20vdGhldHVydGxlMzIpXCIsXG4gIFwiY29udHJpYnV0b3JzXCI6IFtcbiAgICBcIknDsWFraSBCYXogQ2FzdGlsbG8gPGliY0BhbGlheC5uZXQ+IChodHRwOi8vZGV2LnNpcGRvYy5uZXQpXCJcbiAgXSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4wLjM0XCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdGhldHVydGxlMzIvV2ViU29ja2V0LU5vZGUuZ2l0XCJcbiAgfSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90aGV0dXJ0bGUzMi9XZWJTb2NrZXQtTm9kZVwiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49NC4wLjBcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJidWZmZXJ1dGlsXCI6IFwiXjQuMC4xXCIsXG4gICAgXCJkZWJ1Z1wiOiBcIl4yLjIuMFwiLFxuICAgIFwiZXM1LWV4dFwiOiBcIl4wLjEwLjUwXCIsXG4gICAgXCJ0eXBlZGFycmF5LXRvLWJ1ZmZlclwiOiBcIl4zLjEuNVwiLFxuICAgIFwidXRmLTgtdmFsaWRhdGVcIjogXCJeNS4wLjJcIixcbiAgICBcInlhZXRpXCI6IFwiXjAuMC42XCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnVmZmVyLWVxdWFsXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJndWxwXCI6IFwiXjQuMC4yXCIsXG4gICAgXCJndWxwLWpzaGludFwiOiBcIl4yLjAuNFwiLFxuICAgIFwianNoaW50LXN0eWxpc2hcIjogXCJeMi4yLjFcIixcbiAgICBcImpzaGludFwiOiBcIl4yLjAuMFwiLFxuICAgIFwidGFwZVwiOiBcIl40LjkuMVwiXG4gIH0sXG4gIFwiY29uZmlnXCI6IHtcbiAgICBcInZlcmJvc2VcIjogZmFsc2VcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJ0YXBlIHRlc3QvdW5pdC8qLmpzXCIsXG4gICAgXCJndWxwXCI6IFwiZ3VscFwiXG4gIH0sXG4gIFwibWFpblwiOiBcImluZGV4XCIsXG4gIFwiZGlyZWN0b3JpZXNcIjoge1xuICAgIFwibGliXCI6IFwiLi9saWJcIlxuICB9LFxuICBcImJyb3dzZXJcIjogXCJsaWIvYnJvd3Nlci5qc1wiLFxuICBcImxpY2Vuc2VcIjogXCJBcGFjaGUtMi4wXCJcbn1cbiIsIiIsImV4cG9ydCBkZWZhdWx0IChzdGF0ZSwgZW1pdHRlcikgPT4ge1xuXG59IiwiZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU291cmNlKHNvdXJjZSkge1xuICBpZiAoIXNvdXJjZS5pbmNsdWRlcyhcImh0dHBzXCIpKSB7XG4gICAgc291cmNlID0gXCJodHRwczovL1wiICsgc291cmNlXG4gIH1cbiAgbGV0IGZiY2xpZCA9IG5ldyBVUkwoc291cmNlKS5zZWFyY2hQYXJhbXMuZ2V0KFwiZmJjbGlkXCIpXG4gIGlmIChmYmNsaWQpIHtcbiAgICByZXR1cm4gXCJGQiBcIiArIGZiY2xpZFxuICB9XG5cbiAgcmV0dXJuXG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFR3aXRSZWZzKHJlZikge1xuICBpZiAoIXJlZikgcmV0dXJuIGZhbHNlXG4gIGlmKHJlZi5pbmNsdWRlcygndC5jbycpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQWN0aW9uVHlwZSAoYXQpIHtcbiAgLy8gbmF2aWdhdGUgaXMgbGVnYWN5XG4gIGlmIChhdCA9PT0gXCJuYXZpZ2F0ZVwiKSByZXR1cm4gXCJjbGlja1wiXG4gIHJldHVybiBhdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQWN0aW9uRGV0YWlsKGFkKSB7XG4gIC8vIHJlbW92ZSBjbGljayBhbmQgbGlua1xuICAvLyBhZCA9ICc8ZGl2IGNsYXNzPVwibXI0XCI+LTwvZGl2PicgKyBhZFxuICByZXR1cm4gYWQucmVwbGFjZShcImNsaWNrXCIsIFwiXCIpLnJlcGxhY2UoXCJsaW5rXCIsIFwiXCIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGlja1Rocm91Z2hzKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmFjdGlvbikgcmV0dXJuIGZhbHNlXG4gIGlmKGRhdGEuYWN0aW9uLmluY2x1ZGVzKFwidGltZS5jbGFpbXNcIikpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59IiwiaW1wb3J0IGh0bWwgZnJvbSBcImNob28vaHRtbFwiXG5pbXBvcnQgcmF3IGZyb20gXCJjaG9vL2h0bWwvcmF3XCJcbmltcG9ydCB7XG4gIHJlbmRlckFjdGlvblR5cGUsXG4gIHJlbmRlckFjdGlvbkRldGFpbFxufSBmcm9tIFwiLi4vdXRpbHNcIlxuZXhwb3J0IGRlZmF1bHQgKHN0YXRlLCBlbWl0KSA9PiB7XG5cbiAgZnVuY3Rpb24gcmVuZGVyRW50cnkoZGF5QXJyKSB7XG4gICAgbGV0IGVudHJpZXMgPSBcIlwiXG4gICAgZGF5QXJyLnJldmVyc2UoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF5QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQge1xuICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgYWN0aW9uX3R5cGUsXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgYWN0aW9uX2RldGFpbCxcbiAgICAgICAgcmVmZXJyZXJcbiAgICAgIH0gPSBkYXlBcnJbaV0uZGF0YTtcblxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcClcblxuICAgICAgZW50cmllcyArPSBgXG4gICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkZiBmZHIgZnd3XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1yNCBmd2JcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke2RhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlc3Npb24gbXI0ICR7c2Vzc2lvbklkID8gJycgOiAnZG4nfVwiPlxuICAgICAgICAgICAgICAgICAgJHtzZXNzaW9uSWQgPyBzZXNzaW9uSWQuc2xpY2UoMCwyNCkgOiAnJ31cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXBwZXJjYXNlIG1yNFwiPlxuICAgICAgICAgICAgICAgICAgICAke3JlbmRlckFjdGlvblR5cGUoYWN0aW9uX3R5cGUpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtcjQgJHthY3Rpb25fdHlwZSA9PT0gXCJ2aXNpdFwiID8gJ2RuJyA6ICcnfVwiPi08L2Rpdj5cblxuICAgICAgICAgICAgICAgICR7YWN0aW9uX2RldGFpbCA/IHJlbmRlckFjdGlvbkRldGFpbChhY3Rpb25fZGV0YWlsKSA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7YWN0aW9uID8gJ2RmICcgOiAnZG4nfVwiPlxuICAgICAgICAgICAgICAgICAgICAoJHthY3Rpb24gPyByZW5kZXJBY3Rpb24oYWN0aW9uKSA6IFwiXCJ9KVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke3JlZmVycmVyID8gJ2RmIGZkcicgOiAnZG4nfVwiPlxuICAgICAgICAgICAgICAgICAgICBSZWZlcnJlcjogJHtyZWZlcnJlcn1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2xpPlxuICAgICAgYFxuICAgIH1cblxuICAgIHJldHVybiBlbnRyaWVzXG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckRheSgpIHtcbiAgICBpZiAoIXN0YXRlLmRhdGEpIHJldHVyblxuICAgIGxldCBkYXlzID0gXCJcIlxuXG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHN0YXRlLmRhdGEpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXlzICs9IGBcbiAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVudHJ5LWRhdGUgZGYgZmRyIGpjc2JcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibXI0XCI+JHtlbnRyaWVzW2ldWzBdfTwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkZiBmZHJcIiBzdHlsZT1cIm9wYWNpdHk6IDAuNVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1yNFwiPlZpc2l0czogJHtlbnRyaWVzW2ldWzFdLm1ldGEudmlzaXRzfSwgQ1QlICR7TWF0aC5yb3VuZChlbnRyaWVzW2ldWzFdLm1ldGEuY2xpY2tUaHJvdWdocy9lbnRyaWVzW2ldWzFdLm1ldGEudmlzaXRzKiAxMDApfSgke2VudHJpZXNbaV1bMV0ubWV0YS5jbGlja1Rocm91Z2hzfSk8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDxkaXY+KEZyb20gRkI6ICR7ZW50cmllc1tpXVsxXS5tZXRhLmZifSwgRnJvbSBUOiAke2VudHJpZXNbaV1bMV0ubWV0YS50d2l0fSk8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgJHtyZW5kZXJFbnRyeShlbnRyaWVzW2ldWzFdLmRhdGEpfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICBgXG4gICAgfVxuXG4gICAgcmV0dXJuIHJhdyhkYXlzKVxuICB9XG5cbiAgcmV0dXJuIGh0bWwgYFxuICAgICAgPGRpdj5cbiAgICAgICAgPHVsPlxuICAgICAgICAgICR7cmVuZGVyRGF5KCl9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L2Rpdj5cbiAgYFxufVxuXG5mdW5jdGlvbiByZW5kZXJBY3Rpb24oYWN0aW9uKSB7XG4gIGlmKGFjdGlvbi5pbmNsdWRlcyhcInRpbWUuY2xhaW1zXCIpKSB7XG4gICAgcmV0dXJuIGDihpIgPGRpdiBjbGFzcz0nYWN0aW9uIGRmJz4gJHthY3Rpb259PC9kaXY+YFxuICAgIFxuICB9XG5cbiAgcmV0dXJuIFwi4oaSIFwiICsgYWN0aW9uXG4gIFxufSIsImltcG9ydCBodG1sIGZyb20gXCJjaG9vL2h0bWxcIlxuXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChzdGF0ZSwgZW1pdCkgPT4ge1xuXG4gIHJldHVybiBodG1sIGBcbiAgICA8Ym9keT5cbiAgICAgIDxtYWluPlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAke2VudHJpZXMoc3RhdGUsZW1pdCl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICA8L21haW4+XG4gICAgPC9ib2R5PlxuICBgXG59Il19
